function __vite__mapDeps(indexes) {
  if (!__vite__mapDeps.viteFileDeps) {
    __vite__mapDeps.viteFileDeps = []
  }
  return indexes.map((i) => __vite__mapDeps.viteFileDeps[i])
}

function ise(e, t) {
  for (var n = 0; n < t.length; n++) {
    const r = t[n];
    if (typeof r != "string" && !Array.isArray(r)) {
      for (const i in r)
        if (i !== "default" && !(i in e)) {
          const s = Object.getOwnPropertyDescriptor(r, i);
          s && Object.defineProperty(e, i, s.get ? s : {
            enumerable: !0,
            get: () => r[i]
          })
        }
    }
  }
  return Object.freeze(Object.defineProperty(e, Symbol.toStringTag, {
    value: "Module"
  }))
}(function () {
  const t = document.createElement("link").relList;
  if (t && t.supports && t.supports("modulepreload")) return;
  for (const i of document.querySelectorAll('link[rel="modulepreload"]')) r(i);
  new MutationObserver(i => {
    for (const s of i)
      if (s.type === "childList")
        for (const o of s.addedNodes) o.tagName === "LINK" && o.rel === "modulepreload" && r(o)
  }).observe(document, {
    childList: !0,
    subtree: !0
  });

  function n(i) {
    const s = {};
    return i.integrity && (s.integrity = i.integrity), i.referrerPolicy && (s.referrerPolicy = i.referrerPolicy), i.crossOrigin === "use-credentials" ? s.credentials = "include" : i.crossOrigin === "anonymous" ? s.credentials = "omit" : s.credentials = "same-origin", s
  }

  function r(i) {
    if (i.ep) return;
    i.ep = !0;
    const s = n(i);
    fetch(i.href, s)
  }
})();
var rn = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};

function Vo(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e
}

function Ds(e) {
  if (e.__esModule) return e;
  var t = e.default;
  if (typeof t == "function") {
    var n = function r() {
      return this instanceof r ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments)
    };
    n.prototype = t.prototype
  } else n = {};
  return Object.defineProperty(n, "__esModule", {
    value: !0
  }), Object.keys(e).forEach(function (r) {
    var i = Object.getOwnPropertyDescriptor(e, r);
    Object.defineProperty(n, r, i.get ? i : {
      enumerable: !0,
      get: function () {
        return e[r]
      }
    })
  }), n
}
var hF = {
    exports: {}
  },
  Ax = {},
  pF = {
    exports: {}
  },
  bn = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var k2 = Symbol.for("react.element"),
  sse = Symbol.for("react.portal"),
  ose = Symbol.for("react.fragment"),
  ase = Symbol.for("react.strict_mode"),
  cse = Symbol.for("react.profiler"),
  lse = Symbol.for("react.provider"),
  use = Symbol.for("react.context"),
  dse = Symbol.for("react.forward_ref"),
  fse = Symbol.for("react.suspense"),
  hse = Symbol.for("react.memo"),
  pse = Symbol.for("react.lazy"),
  NR = Symbol.iterator;

function mse(e) {
  return e === null || typeof e != "object" ? null : (e = NR && e[NR] || e["@@iterator"], typeof e == "function" ? e : null)
}
var mF = {
    isMounted: function () {
      return !1
    },
    enqueueForceUpdate: function () {},
    enqueueReplaceState: function () {},
    enqueueSetState: function () {}
  },
  gF = Object.assign,
  yF = {};

function am(e, t, n) {
  this.props = e, this.context = t, this.refs = yF, this.updater = n || mF
}
am.prototype.isReactComponent = {};
am.prototype.setState = function (e, t) {
  if (typeof e != "object" && typeof e != "function" && e != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
  this.updater.enqueueSetState(this, e, t, "setState")
};
am.prototype.forceUpdate = function (e) {
  this.updater.enqueueForceUpdate(this, e, "forceUpdate")
};

function vF() {}
vF.prototype = am.prototype;

function g9(e, t, n) {
  this.props = e, this.context = t, this.refs = yF, this.updater = n || mF
}
var y9 = g9.prototype = new vF;
y9.constructor = g9;
gF(y9, am.prototype);
y9.isPureReactComponent = !0;
var MR = Array.isArray,
  bF = Object.prototype.hasOwnProperty,
  v9 = {
    current: null
  },
  wF = {
    key: !0,
    ref: !0,
    __self: !0,
    __source: !0
  };

function xF(e, t, n) {
  var r, i = {},
    s = null,
    o = null;
  if (t != null)
    for (r in t.ref !== void 0 && (o = t.ref), t.key !== void 0 && (s = "" + t.key), t) bF.call(t, r) && !wF.hasOwnProperty(r) && (i[r] = t[r]);
  var a = arguments.length - 2;
  if (a === 1) i.children = n;
  else if (1 < a) {
    for (var c = Array(a), l = 0; l < a; l++) c[l] = arguments[l + 2];
    i.children = c
  }
  if (e && e.defaultProps)
    for (r in a = e.defaultProps, a) i[r] === void 0 && (i[r] = a[r]);
  return {
    $$typeof: k2,
    type: e,
    key: s,
    ref: o,
    props: i,
    _owner: v9.current
  }
}

function gse(e, t) {
  return {
    $$typeof: k2,
    type: e.type,
    key: t,
    ref: e.ref,
    props: e.props,
    _owner: e._owner
  }
}

function b9(e) {
  return typeof e == "object" && e !== null && e.$$typeof === k2
}

function yse(e) {
  var t = {
    "=": "=0",
    ":": "=2"
  };
  return "$" + e.replace(/[=:]/g, function (n) {
    return t[n]
  })
}
var $R = /\/+/g;

function P4(e, t) {
  return typeof e == "object" && e !== null && e.key != null ? yse("" + e.key) : t.toString(36)
}

function Qb(e, t, n, r, i) {
  var s = typeof e;
  (s === "undefined" || s === "boolean") && (e = null);
  var o = !1;
  if (e === null) o = !0;
  else switch (s) {
    case "string":
    case "number":
      o = !0;
      break;
    case "object":
      switch (e.$$typeof) {
        case k2:
        case sse:
          o = !0
      }
  }
  if (o) return o = e, i = i(o), e = r === "" ? "." + P4(o, 0) : r, MR(i) ? (n = "", e != null && (n = e.replace($R, "$&/") + "/"), Qb(i, t, n, "", function (l) {
    return l
  })) : i != null && (b9(i) && (i = gse(i, n + (!i.key || o && o.key === i.key ? "" : ("" + i.key).replace($R, "$&/") + "/") + e)), t.push(i)), 1;
  if (o = 0, r = r === "" ? "." : r + ":", MR(e))
    for (var a = 0; a < e.length; a++) {
      s = e[a];
      var c = r + P4(s, a);
      o += Qb(s, t, n, c, i)
    } else if (c = mse(e), typeof c == "function")
      for (e = c.call(e), a = 0; !(s = e.next()).done;) s = s.value, c = r + P4(s, a++), o += Qb(s, t, n, c, i);
    else if (s === "object") throw t = String(e), Error("Objects are not valid as a React child (found: " + (t === "[object Object]" ? "object with keys {" + Object.keys(e).join(", ") + "}" : t) + "). If you meant to render a collection of children, use an array instead.");
  return o
}

function Fv(e, t, n) {
  if (e == null) return e;
  var r = [],
    i = 0;
  return Qb(e, r, "", "", function (s) {
    return t.call(n, s, i++)
  }), r
}

function vse(e) {
  if (e._status === -1) {
    var t = e._result;
    t = t(), t.then(function (n) {
      (e._status === 0 || e._status === -1) && (e._status = 1, e._result = n)
    }, function (n) {
      (e._status === 0 || e._status === -1) && (e._status = 2, e._result = n)
    }), e._status === -1 && (e._status = 0, e._result = t)
  }
  if (e._status === 1) return e._result.default;
  throw e._result
}
var Ns = {
    current: null
  },
  Yb = {
    transition: null
  },
  bse = {
    ReactCurrentDispatcher: Ns,
    ReactCurrentBatchConfig: Yb,
    ReactCurrentOwner: v9
  };
bn.Children = {
  map: Fv,
  forEach: function (e, t, n) {
    Fv(e, function () {
      t.apply(this, arguments)
    }, n)
  },
  count: function (e) {
    var t = 0;
    return Fv(e, function () {
      t++
    }), t
  },
  toArray: function (e) {
    return Fv(e, function (t) {
      return t
    }) || []
  },
  only: function (e) {
    if (!b9(e)) throw Error("React.Children.only expected to receive a single React element child.");
    return e
  }
};
bn.Component = am;
bn.Fragment = ose;
bn.Profiler = cse;
bn.PureComponent = g9;
bn.StrictMode = ase;
bn.Suspense = fse;
bn.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = bse;
bn.cloneElement = function (e, t, n) {
  if (e == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + e + ".");
  var r = gF({}, e.props),
    i = e.key,
    s = e.ref,
    o = e._owner;
  if (t != null) {
    if (t.ref !== void 0 && (s = t.ref, o = v9.current), t.key !== void 0 && (i = "" + t.key), e.type && e.type.defaultProps) var a = e.type.defaultProps;
    for (c in t) bF.call(t, c) && !wF.hasOwnProperty(c) && (r[c] = t[c] === void 0 && a !== void 0 ? a[c] : t[c])
  }
  var c = arguments.length - 2;
  if (c === 1) r.children = n;
  else if (1 < c) {
    a = Array(c);
    for (var l = 0; l < c; l++) a[l] = arguments[l + 2];
    r.children = a
  }
  return {
    $$typeof: k2,
    type: e.type,
    key: i,
    ref: s,
    props: r,
    _owner: o
  }
};
bn.createContext = function (e) {
  return e = {
    $$typeof: use,
    _currentValue: e,
    _currentValue2: e,
    _threadCount: 0,
    Provider: null,
    Consumer: null,
    _defaultValue: null,
    _globalName: null
  }, e.Provider = {
    $$typeof: lse,
    _context: e
  }, e.Consumer = e
};
bn.createElement = xF;
bn.createFactory = function (e) {
  var t = xF.bind(null, e);
  return t.type = e, t
};
bn.createRef = function () {
  return {
    current: null
  }
};
bn.forwardRef = function (e) {
  return {
    $$typeof: dse,
    render: e
  }
};
bn.isValidElement = b9;
bn.lazy = function (e) {
  return {
    $$typeof: pse,
    _payload: {
      _status: -1,
      _result: e
    },
    _init: vse
  }
};
bn.memo = function (e, t) {
  return {
    $$typeof: hse,
    type: e,
    compare: t === void 0 ? null : t
  }
};
bn.startTransition = function (e) {
  var t = Yb.transition;
  Yb.transition = {};
  try {
    e()
  } finally {
    Yb.transition = t
  }
};
bn.unstable_act = function () {
  throw Error("act(...) is not supported in production builds of React.")
};
bn.useCallback = function (e, t) {
  return Ns.current.useCallback(e, t)
};
bn.useContext = function (e) {
  return Ns.current.useContext(e)
};
bn.useDebugValue = function () {};
bn.useDeferredValue = function (e) {
  return Ns.current.useDeferredValue(e)
};
bn.useEffect = function (e, t) {
  return Ns.current.useEffect(e, t)
};
bn.useId = function () {
  return Ns.current.useId()
};
bn.useImperativeHandle = function (e, t, n) {
  return Ns.current.useImperativeHandle(e, t, n)
};
bn.useInsertionEffect = function (e, t) {
  return Ns.current.useInsertionEffect(e, t)
};
bn.useLayoutEffect = function (e, t) {
  return Ns.current.useLayoutEffect(e, t)
};
bn.useMemo = function (e, t) {
  return Ns.current.useMemo(e, t)
};
bn.useReducer = function (e, t, n) {
  return Ns.current.useReducer(e, t, n)
};
bn.useRef = function (e) {
  return Ns.current.useRef(e)
};
bn.useState = function (e) {
  return Ns.current.useState(e)
};
bn.useSyncExternalStore = function (e, t, n) {
  return Ns.current.useSyncExternalStore(e, t, n)
};
bn.useTransition = function () {
  return Ns.current.useTransition()
};
bn.version = "18.2.0";
pF.exports = bn;
var j = pF.exports;
const Jt = Vo(j),
  Rw = ise({
    __proto__: null,
    default: Jt
  }, [j]);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var wse = j,
  xse = Symbol.for("react.element"),
  Ese = Symbol.for("react.fragment"),
  Sse = Object.prototype.hasOwnProperty,
  Cse = wse.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,
  Ase = {
    key: !0,
    ref: !0,
    __self: !0,
    __source: !0
  };

function EF(e, t, n) {
  var r, i = {},
    s = null,
    o = null;
  n !== void 0 && (s = "" + n), t.key !== void 0 && (s = "" + t.key), t.ref !== void 0 && (o = t.ref);
  for (r in t) Sse.call(t, r) && !Ase.hasOwnProperty(r) && (i[r] = t[r]);
  if (e && e.defaultProps)
    for (r in t = e.defaultProps, t) i[r] === void 0 && (i[r] = t[r]);
  return {
    $$typeof: xse,
    type: e,
    key: s,
    ref: o,
    props: i,
    _owner: Cse.current
  }
}
Ax.Fragment = Ese;
Ax.jsx = EF;
Ax.jsxs = EF;
hF.exports = Ax;
var C = hF.exports,
  V8 = {},
  SF = {
    exports: {}
  },
  Wo = {},
  CF = {
    exports: {}
  },
  AF = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function (e) {
  function t(O, U) {
    var q = O.length;
    O.push(U);
    e: for (; 0 < q;) {
      var W = q - 1 >>> 1,
        M = O[W];
      if (0 < i(M, U)) O[W] = U, O[q] = M, q = W;
      else break e
    }
  }

  function n(O) {
    return O.length === 0 ? null : O[0]
  }

  function r(O) {
    if (O.length === 0) return null;
    var U = O[0],
      q = O.pop();
    if (q !== U) {
      O[0] = q;
      e: for (var W = 0, M = O.length, Q = M >>> 1; W < Q;) {
        var he = 2 * (W + 1) - 1,
          H = O[he],
          ne = he + 1,
          X = O[ne];
        if (0 > i(H, q)) ne < M && 0 > i(X, H) ? (O[W] = X, O[ne] = q, W = ne) : (O[W] = H, O[he] = q, W = he);
        else if (ne < M && 0 > i(X, q)) O[W] = X, O[ne] = q, W = ne;
        else break e
      }
    }
    return U
  }

  function i(O, U) {
    var q = O.sortIndex - U.sortIndex;
    return q !== 0 ? q : O.id - U.id
  }
  if (typeof performance == "object" && typeof performance.now == "function") {
    var s = performance;
    e.unstable_now = function () {
      return s.now()
    }
  } else {
    var o = Date,
      a = o.now();
    e.unstable_now = function () {
      return o.now() - a
    }
  }
  var c = [],
    l = [],
    u = 1,
    f = null,
    h = 3,
    g = !1,
    y = !1,
    x = !1,
    k = typeof setTimeout == "function" ? setTimeout : null,
    _ = typeof clearTimeout == "function" ? clearTimeout : null,
    p = typeof setImmediate < "u" ? setImmediate : null;
  typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);

  function v(O) {
    for (var U = n(l); U !== null;) {
      if (U.callback === null) r(l);
      else if (U.startTime <= O) r(l), U.sortIndex = U.expirationTime, t(c, U);
      else break;
      U = n(l)
    }
  }

  function S(O) {
    if (x = !1, v(O), !y)
      if (n(c) !== null) y = !0, R(I);
      else {
        var U = n(l);
        U !== null && N(S, U.startTime - O)
      }
  }

  function I(O, U) {
    y = !1, x && (x = !1, _(E), E = -1), g = !0;
    var q = h;
    try {
      for (v(U), f = n(c); f !== null && (!(f.expirationTime > U) || O && !V());) {
        var W = f.callback;
        if (typeof W == "function") {
          f.callback = null, h = f.priorityLevel;
          var M = W(f.expirationTime <= U);
          U = e.unstable_now(), typeof M == "function" ? f.callback = M : f === n(c) && r(c), v(U)
        } else r(c);
        f = n(c)
      }
      if (f !== null) var Q = !0;
      else {
        var he = n(l);
        he !== null && N(S, he.startTime - U), Q = !1
      }
      return Q
    } finally {
      f = null, h = q, g = !1
    }
  }
  var A = !1,
    w = null,
    E = -1,
    D = 5,
    $ = -1;

  function V() {
    return !(e.unstable_now() - $ < D)
  }

  function G() {
    if (w !== null) {
      var O = e.unstable_now();
      $ = O;
      var U = !0;
      try {
        U = w(!0, O)
      } finally {
        U ? L() : (A = !1, w = null)
      }
    } else A = !1
  }
  var L;
  if (typeof p == "function") L = function () {
    p(G)
  };
  else if (typeof MessageChannel < "u") {
    var b = new MessageChannel,
      T = b.port2;
    b.port1.onmessage = G, L = function () {
      T.postMessage(null)
    }
  } else L = function () {
    k(G, 0)
  };

  function R(O) {
    w = O, A || (A = !0, L())
  }

  function N(O, U) {
    E = k(function () {
      O(e.unstable_now())
    }, U)
  }
  e.unstable_IdlePriority = 5, e.unstable_ImmediatePriority = 1, e.unstable_LowPriority = 4, e.unstable_NormalPriority = 3, e.unstable_Profiling = null, e.unstable_UserBlockingPriority = 2, e.unstable_cancelCallback = function (O) {
    O.callback = null
  }, e.unstable_continueExecution = function () {
    y || g || (y = !0, R(I))
  }, e.unstable_forceFrameRate = function (O) {
    0 > O || 125 < O ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : D = 0 < O ? Math.floor(1e3 / O) : 5
  }, e.unstable_getCurrentPriorityLevel = function () {
    return h
  }, e.unstable_getFirstCallbackNode = function () {
    return n(c)
  }, e.unstable_next = function (O) {
    switch (h) {
      case 1:
      case 2:
      case 3:
        var U = 3;
        break;
      default:
        U = h
    }
    var q = h;
    h = U;
    try {
      return O()
    } finally {
      h = q
    }
  }, e.unstable_pauseExecution = function () {}, e.unstable_requestPaint = function () {}, e.unstable_runWithPriority = function (O, U) {
    switch (O) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        O = 3
    }
    var q = h;
    h = O;
    try {
      return U()
    } finally {
      h = q
    }
  }, e.unstable_scheduleCallback = function (O, U, q) {
    var W = e.unstable_now();
    switch (typeof q == "object" && q !== null ? (q = q.delay, q = typeof q == "number" && 0 < q ? W + q : W) : q = W, O) {
      case 1:
        var M = -1;
        break;
      case 2:
        M = 250;
        break;
      case 5:
        M = 1073741823;
        break;
      case 4:
        M = 1e4;
        break;
      default:
        M = 5e3
    }
    return M = q + M, O = {
      id: u++,
      callback: U,
      priorityLevel: O,
      startTime: q,
      expirationTime: M,
      sortIndex: -1
    }, q > W ? (O.sortIndex = q, t(l, O), n(c) === null && O === n(l) && (x ? (_(E), E = -1) : x = !0, N(S, q - W))) : (O.sortIndex = M, t(c, O), y || g || (y = !0, R(I))), O
  }, e.unstable_shouldYield = V, e.unstable_wrapCallback = function (O) {
    var U = h;
    return function () {
      var q = h;
      h = U;
      try {
        return O.apply(this, arguments)
      } finally {
        h = q
      }
    }
  }
})(AF);
CF.exports = AF;
var Tse = CF.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var TF = j,
  Uo = Tse;

function Ke(e) {
  for (var t = "https://reactjs.org/docs/error-decoder.html?invariant=" + e, n = 1; n < arguments.length; n++) t += "&args[]=" + encodeURIComponent(arguments[n]);
  return "Minified React error #" + e + "; visit " + t + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
}
var kF = new Set,
  R1 = {};

function xh(e, t) {
  bp(e, t), bp(e + "Capture", t)
}

function bp(e, t) {
  for (R1[e] = t, e = 0; e < t.length; e++) kF.add(t[e])
}
var iu = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"),
  W8 = Object.prototype.hasOwnProperty,
  kse = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
  LR = {},
  BR = {};

function _se(e) {
  return W8.call(BR, e) ? !0 : W8.call(LR, e) ? !1 : kse.test(e) ? BR[e] = !0 : (LR[e] = !0, !1)
}

function Ise(e, t, n, r) {
  if (n !== null && n.type === 0) return !1;
  switch (typeof t) {
    case "function":
    case "symbol":
      return !0;
    case "boolean":
      return r ? !1 : n !== null ? !n.acceptsBooleans : (e = e.toLowerCase().slice(0, 5), e !== "data-" && e !== "aria-");
    default:
      return !1
  }
}

function Pse(e, t, n, r) {
  if (t === null || typeof t > "u" || Ise(e, t, n, r)) return !0;
  if (r) return !1;
  if (n !== null) switch (n.type) {
    case 3:
      return !t;
    case 4:
      return t === !1;
    case 5:
      return isNaN(t);
    case 6:
      return isNaN(t) || 1 > t
  }
  return !1
}

function Ms(e, t, n, r, i, s, o) {
  this.acceptsBooleans = t === 2 || t === 3 || t === 4, this.attributeName = r, this.attributeNamespace = i, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = s, this.removeEmptyString = o
}
var zi = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function (e) {
  zi[e] = new Ms(e, 0, !1, e, null, !1, !1)
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(function (e) {
  var t = e[0];
  zi[t] = new Ms(t, 1, !1, e[1], null, !1, !1)
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function (e) {
  zi[e] = new Ms(e, 2, !1, e.toLowerCase(), null, !1, !1)
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function (e) {
  zi[e] = new Ms(e, 2, !1, e, null, !1, !1)
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function (e) {
  zi[e] = new Ms(e, 3, !1, e.toLowerCase(), null, !1, !1)
});
["checked", "multiple", "muted", "selected"].forEach(function (e) {
  zi[e] = new Ms(e, 3, !0, e, null, !1, !1)
});
["capture", "download"].forEach(function (e) {
  zi[e] = new Ms(e, 4, !1, e, null, !1, !1)
});
["cols", "rows", "size", "span"].forEach(function (e) {
  zi[e] = new Ms(e, 6, !1, e, null, !1, !1)
});
["rowSpan", "start"].forEach(function (e) {
  zi[e] = new Ms(e, 5, !1, e.toLowerCase(), null, !1, !1)
});
var w9 = /[\-:]([a-z])/g;

function x9(e) {
  return e[1].toUpperCase()
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function (e) {
  var t = e.replace(w9, x9);
  zi[t] = new Ms(t, 1, !1, e, null, !1, !1)
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function (e) {
  var t = e.replace(w9, x9);
  zi[t] = new Ms(t, 1, !1, e, "http://www.w3.org/1999/xlink", !1, !1)
});
["xml:base", "xml:lang", "xml:space"].forEach(function (e) {
  var t = e.replace(w9, x9);
  zi[t] = new Ms(t, 1, !1, e, "http://www.w3.org/XML/1998/namespace", !1, !1)
});
["tabIndex", "crossOrigin"].forEach(function (e) {
  zi[e] = new Ms(e, 1, !1, e.toLowerCase(), null, !1, !1)
});
zi.xlinkHref = new Ms("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1);
["src", "href", "action", "formAction"].forEach(function (e) {
  zi[e] = new Ms(e, 1, !1, e.toLowerCase(), null, !0, !0)
});

function E9(e, t, n, r) {
  var i = zi.hasOwnProperty(t) ? zi[t] : null;
  (i !== null ? i.type !== 0 : r || !(2 < t.length) || t[0] !== "o" && t[0] !== "O" || t[1] !== "n" && t[1] !== "N") && (Pse(t, n, i, r) && (n = null), r || i === null ? _se(t) && (n === null ? e.removeAttribute(t) : e.setAttribute(t, "" + n)) : i.mustUseProperty ? e[i.propertyName] = n === null ? i.type === 3 ? !1 : "" : n : (t = i.attributeName, r = i.attributeNamespace, n === null ? e.removeAttribute(t) : (i = i.type, n = i === 3 || i === 4 && n === !0 ? "" : "" + n, r ? e.setAttributeNS(r, t, n) : e.setAttribute(t, n))))
}
var pu = TF.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
  jv = Symbol.for("react.element"),
  P0 = Symbol.for("react.portal"),
  R0 = Symbol.for("react.fragment"),
  S9 = Symbol.for("react.strict_mode"),
  q8 = Symbol.for("react.profiler"),
  _F = Symbol.for("react.provider"),
  IF = Symbol.for("react.context"),
  C9 = Symbol.for("react.forward_ref"),
  G8 = Symbol.for("react.suspense"),
  K8 = Symbol.for("react.suspense_list"),
  A9 = Symbol.for("react.memo"),
  Ju = Symbol.for("react.lazy"),
  PF = Symbol.for("react.offscreen"),
  FR = Symbol.iterator;

function hg(e) {
  return e === null || typeof e != "object" ? null : (e = FR && e[FR] || e["@@iterator"], typeof e == "function" ? e : null)
}
var Dr = Object.assign,
  R4;

function Xg(e) {
  if (R4 === void 0) try {
    throw Error()
  } catch (n) {
    var t = n.stack.trim().match(/\n( *(at )?)/);
    R4 = t && t[1] || ""
  }
  return `
` + R4 + e
}
var O4 = !1;

function D4(e, t) {
  if (!e || O4) return "";
  O4 = !0;
  var n = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (t)
      if (t = function () {
          throw Error()
        }, Object.defineProperty(t.prototype, "props", {
          set: function () {
            throw Error()
          }
        }), typeof Reflect == "object" && Reflect.construct) {
        try {
          Reflect.construct(t, [])
        } catch (l) {
          var r = l
        }
        Reflect.construct(e, [], t)
      } else {
        try {
          t.call()
        } catch (l) {
          r = l
        }
        e.call(t.prototype)
      }
    else {
      try {
        throw Error()
      } catch (l) {
        r = l
      }
      e()
    }
  } catch (l) {
    if (l && r && typeof l.stack == "string") {
      for (var i = l.stack.split(`
`), s = r.stack.split(`
`), o = i.length - 1, a = s.length - 1; 1 <= o && 0 <= a && i[o] !== s[a];) a--;
      for (; 1 <= o && 0 <= a; o--, a--)
        if (i[o] !== s[a]) {
          if (o !== 1 || a !== 1)
            do
              if (o--, a--, 0 > a || i[o] !== s[a]) {
                var c = `
` + i[o].replace(" at new ", " at ");
                return e.displayName && c.includes("<anonymous>") && (c = c.replace("<anonymous>", e.displayName)), c
              } while (1 <= o && 0 <= a);
          break
        }
    }
  } finally {
    O4 = !1, Error.prepareStackTrace = n
  }
  return (e = e ? e.displayName || e.name : "") ? Xg(e) : ""
}

function Rse(e) {
  switch (e.tag) {
    case 5:
      return Xg(e.type);
    case 16:
      return Xg("Lazy");
    case 13:
      return Xg("Suspense");
    case 19:
      return Xg("SuspenseList");
    case 0:
    case 2:
    case 15:
      return e = D4(e.type, !1), e;
    case 11:
      return e = D4(e.type.render, !1), e;
    case 1:
      return e = D4(e.type, !0), e;
    default:
      return ""
  }
}

function Q8(e) {
  if (e == null) return null;
  if (typeof e == "function") return e.displayName || e.name || null;
  if (typeof e == "string") return e;
  switch (e) {
    case R0:
      return "Fragment";
    case P0:
      return "Portal";
    case q8:
      return "Profiler";
    case S9:
      return "StrictMode";
    case G8:
      return "Suspense";
    case K8:
      return "SuspenseList"
  }
  if (typeof e == "object") switch (e.$$typeof) {
    case IF:
      return (e.displayName || "Context") + ".Consumer";
    case _F:
      return (e._context.displayName || "Context") + ".Provider";
    case C9:
      var t = e.render;
      return e = e.displayName, e || (e = t.displayName || t.name || "", e = e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef"), e;
    case A9:
      return t = e.displayName || null, t !== null ? t : Q8(e.type) || "Memo";
    case Ju:
      t = e._payload, e = e._init;
      try {
        return Q8(e(t))
      } catch {}
  }
  return null
}

function Ose(e) {
  var t = e.type;
  switch (e.tag) {
    case 24:
      return "Cache";
    case 9:
      return (t.displayName || "Context") + ".Consumer";
    case 10:
      return (t._context.displayName || "Context") + ".Provider";
    case 18:
      return "DehydratedFragment";
    case 11:
      return e = t.render, e = e.displayName || e.name || "", t.displayName || (e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef");
    case 7:
      return "Fragment";
    case 5:
      return t;
    case 4:
      return "Portal";
    case 3:
      return "Root";
    case 6:
      return "Text";
    case 16:
      return Q8(t);
    case 8:
      return t === S9 ? "StrictMode" : "Mode";
    case 22:
      return "Offscreen";
    case 12:
      return "Profiler";
    case 21:
      return "Scope";
    case 13:
      return "Suspense";
    case 19:
      return "SuspenseList";
    case 25:
      return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if (typeof t == "function") return t.displayName || t.name || null;
      if (typeof t == "string") return t
  }
  return null
}

function bd(e) {
  switch (typeof e) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return e;
    case "object":
      return e;
    default:
      return ""
  }
}

function RF(e) {
  var t = e.type;
  return (e = e.nodeName) && e.toLowerCase() === "input" && (t === "checkbox" || t === "radio")
}

function Dse(e) {
  var t = RF(e) ? "checked" : "value",
    n = Object.getOwnPropertyDescriptor(e.constructor.prototype, t),
    r = "" + e[t];
  if (!e.hasOwnProperty(t) && typeof n < "u" && typeof n.get == "function" && typeof n.set == "function") {
    var i = n.get,
      s = n.set;
    return Object.defineProperty(e, t, {
      configurable: !0,
      get: function () {
        return i.call(this)
      },
      set: function (o) {
        r = "" + o, s.call(this, o)
      }
    }), Object.defineProperty(e, t, {
      enumerable: n.enumerable
    }), {
      getValue: function () {
        return r
      },
      setValue: function (o) {
        r = "" + o
      },
      stopTracking: function () {
        e._valueTracker = null, delete e[t]
      }
    }
  }
}

function Uv(e) {
  e._valueTracker || (e._valueTracker = Dse(e))
}

function OF(e) {
  if (!e) return !1;
  var t = e._valueTracker;
  if (!t) return !0;
  var n = t.getValue(),
    r = "";
  return e && (r = RF(e) ? e.checked ? "true" : "false" : e.value), e = r, e !== n ? (t.setValue(e), !0) : !1
}

function Ow(e) {
  if (e = e || (typeof document < "u" ? document : void 0), typeof e > "u") return null;
  try {
    return e.activeElement || e.body
  } catch {
    return e.body
  }
}

function Y8(e, t) {
  var n = t.checked;
  return Dr({}, t, {
    defaultChecked: void 0,
    defaultValue: void 0,
    value: void 0,
    checked: n ?? e._wrapperState.initialChecked
  })
}

function jR(e, t) {
  var n = t.defaultValue == null ? "" : t.defaultValue,
    r = t.checked != null ? t.checked : t.defaultChecked;
  n = bd(t.value != null ? t.value : n), e._wrapperState = {
    initialChecked: r,
    initialValue: n,
    controlled: t.type === "checkbox" || t.type === "radio" ? t.checked != null : t.value != null
  }
}

function DF(e, t) {
  t = t.checked, t != null && E9(e, "checked", t, !1)
}

function J8(e, t) {
  DF(e, t);
  var n = bd(t.value),
    r = t.type;
  if (n != null) r === "number" ? (n === 0 && e.value === "" || e.value != n) && (e.value = "" + n) : e.value !== "" + n && (e.value = "" + n);
  else if (r === "submit" || r === "reset") {
    e.removeAttribute("value");
    return
  }
  t.hasOwnProperty("value") ? X8(e, t.type, n) : t.hasOwnProperty("defaultValue") && X8(e, t.type, bd(t.defaultValue)), t.checked == null && t.defaultChecked != null && (e.defaultChecked = !!t.defaultChecked)
}

function UR(e, t, n) {
  if (t.hasOwnProperty("value") || t.hasOwnProperty("defaultValue")) {
    var r = t.type;
    if (!(r !== "submit" && r !== "reset" || t.value !== void 0 && t.value !== null)) return;
    t = "" + e._wrapperState.initialValue, n || t === e.value || (e.value = t), e.defaultValue = t
  }
  n = e.name, n !== "" && (e.name = ""), e.defaultChecked = !!e._wrapperState.initialChecked, n !== "" && (e.name = n)
}

function X8(e, t, n) {
  (t !== "number" || Ow(e.ownerDocument) !== e) && (n == null ? e.defaultValue = "" + e._wrapperState.initialValue : e.defaultValue !== "" + n && (e.defaultValue = "" + n))
}
var Zg = Array.isArray;

function np(e, t, n, r) {
  if (e = e.options, t) {
    t = {};
    for (var i = 0; i < n.length; i++) t["$" + n[i]] = !0;
    for (n = 0; n < e.length; n++) i = t.hasOwnProperty("$" + e[n].value), e[n].selected !== i && (e[n].selected = i), i && r && (e[n].defaultSelected = !0)
  } else {
    for (n = "" + bd(n), t = null, i = 0; i < e.length; i++) {
      if (e[i].value === n) {
        e[i].selected = !0, r && (e[i].defaultSelected = !0);
        return
      }
      t !== null || e[i].disabled || (t = e[i])
    }
    t !== null && (t.selected = !0)
  }
}

function Z8(e, t) {
  if (t.dangerouslySetInnerHTML != null) throw Error(Ke(91));
  return Dr({}, t, {
    value: void 0,
    defaultValue: void 0,
    children: "" + e._wrapperState.initialValue
  })
}

function zR(e, t) {
  var n = t.value;
  if (n == null) {
    if (n = t.children, t = t.defaultValue, n != null) {
      if (t != null) throw Error(Ke(92));
      if (Zg(n)) {
        if (1 < n.length) throw Error(Ke(93));
        n = n[0]
      }
      t = n
    }
    t == null && (t = ""), n = t
  }
  e._wrapperState = {
    initialValue: bd(n)
  }
}

function NF(e, t) {
  var n = bd(t.value),
    r = bd(t.defaultValue);
  n != null && (n = "" + n, n !== e.value && (e.value = n), t.defaultValue == null && e.defaultValue !== n && (e.defaultValue = n)), r != null && (e.defaultValue = "" + r)
}

function HR(e) {
  var t = e.textContent;
  t === e._wrapperState.initialValue && t !== "" && t !== null && (e.value = t)
}

function MF(e) {
  switch (e) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml"
  }
}

function eC(e, t) {
  return e == null || e === "http://www.w3.org/1999/xhtml" ? MF(t) : e === "http://www.w3.org/2000/svg" && t === "foreignObject" ? "http://www.w3.org/1999/xhtml" : e
}
var zv, $F = function (e) {
  return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function (t, n, r, i) {
    MSApp.execUnsafeLocalFunction(function () {
      return e(t, n, r, i)
    })
  } : e
}(function (e, t) {
  if (e.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in e) e.innerHTML = t;
  else {
    for (zv = zv || document.createElement("div"), zv.innerHTML = "<svg>" + t.valueOf().toString() + "</svg>", t = zv.firstChild; e.firstChild;) e.removeChild(e.firstChild);
    for (; t.firstChild;) e.appendChild(t.firstChild)
  }
});

function O1(e, t) {
  if (t) {
    var n = e.firstChild;
    if (n && n === e.lastChild && n.nodeType === 3) {
      n.nodeValue = t;
      return
    }
  }
  e.textContent = t
}
var a1 = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
  },
  Nse = ["Webkit", "ms", "Moz", "O"];
Object.keys(a1).forEach(function (e) {
  Nse.forEach(function (t) {
    t = t + e.charAt(0).toUpperCase() + e.substring(1), a1[t] = a1[e]
  })
});

function LF(e, t, n) {
  return t == null || typeof t == "boolean" || t === "" ? "" : n || typeof t != "number" || t === 0 || a1.hasOwnProperty(e) && a1[e] ? ("" + t).trim() : t + "px"
}

function BF(e, t) {
  e = e.style;
  for (var n in t)
    if (t.hasOwnProperty(n)) {
      var r = n.indexOf("--") === 0,
        i = LF(n, t[n], r);
      n === "float" && (n = "cssFloat"), r ? e.setProperty(n, i) : e[n] = i
    }
}
var Mse = Dr({
  menuitem: !0
}, {
  area: !0,
  base: !0,
  br: !0,
  col: !0,
  embed: !0,
  hr: !0,
  img: !0,
  input: !0,
  keygen: !0,
  link: !0,
  meta: !0,
  param: !0,
  source: !0,
  track: !0,
  wbr: !0
});

function tC(e, t) {
  if (t) {
    if (Mse[e] && (t.children != null || t.dangerouslySetInnerHTML != null)) throw Error(Ke(137, e));
    if (t.dangerouslySetInnerHTML != null) {
      if (t.children != null) throw Error(Ke(60));
      if (typeof t.dangerouslySetInnerHTML != "object" || !("__html" in t.dangerouslySetInnerHTML)) throw Error(Ke(61))
    }
    if (t.style != null && typeof t.style != "object") throw Error(Ke(62))
  }
}

function nC(e, t) {
  if (e.indexOf("-") === -1) return typeof t.is == "string";
  switch (e) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return !1;
    default:
      return !0
  }
}
var rC = null;

function T9(e) {
  return e = e.target || e.srcElement || window, e.correspondingUseElement && (e = e.correspondingUseElement), e.nodeType === 3 ? e.parentNode : e
}
var iC = null,
  rp = null,
  ip = null;

function VR(e) {
  if (e = P2(e)) {
    if (typeof iC != "function") throw Error(Ke(280));
    var t = e.stateNode;
    t && (t = Px(t), iC(e.stateNode, e.type, t))
  }
}

function FF(e) {
  rp ? ip ? ip.push(e) : ip = [e] : rp = e
}

function jF() {
  if (rp) {
    var e = rp,
      t = ip;
    if (ip = rp = null, VR(e), t)
      for (e = 0; e < t.length; e++) VR(t[e])
  }
}

function UF(e, t) {
  return e(t)
}

function zF() {}
var N4 = !1;

function HF(e, t, n) {
  if (N4) return e(t, n);
  N4 = !0;
  try {
    return UF(e, t, n)
  } finally {
    N4 = !1, (rp !== null || ip !== null) && (zF(), jF())
  }
}

function D1(e, t) {
  var n = e.stateNode;
  if (n === null) return null;
  var r = Px(n);
  if (r === null) return null;
  n = r[t];
  e: switch (t) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
      (r = !r.disabled) || (e = e.type, r = !(e === "button" || e === "input" || e === "select" || e === "textarea")), e = !r;
      break e;
    default:
      e = !1
  }
  if (e) return null;
  if (n && typeof n != "function") throw Error(Ke(231, t, typeof n));
  return n
}
var sC = !1;
if (iu) try {
  var pg = {};
  Object.defineProperty(pg, "passive", {
    get: function () {
      sC = !0
    }
  }), window.addEventListener("test", pg, pg), window.removeEventListener("test", pg, pg)
} catch {
  sC = !1
}

function $se(e, t, n, r, i, s, o, a, c) {
  var l = Array.prototype.slice.call(arguments, 3);
  try {
    t.apply(n, l)
  } catch (u) {
    this.onError(u)
  }
}
var c1 = !1,
  Dw = null,
  Nw = !1,
  oC = null,
  Lse = {
    onError: function (e) {
      c1 = !0, Dw = e
    }
  };

function Bse(e, t, n, r, i, s, o, a, c) {
  c1 = !1, Dw = null, $se.apply(Lse, arguments)
}

function Fse(e, t, n, r, i, s, o, a, c) {
  if (Bse.apply(this, arguments), c1) {
    if (c1) {
      var l = Dw;
      c1 = !1, Dw = null
    } else throw Error(Ke(198));
    Nw || (Nw = !0, oC = l)
  }
}

function Eh(e) {
  var t = e,
    n = e;
  if (e.alternate)
    for (; t.return;) t = t.return;
  else {
    e = t;
    do t = e, t.flags & 4098 && (n = t.return), e = t.return; while (e)
  }
  return t.tag === 3 ? n : null
}

function VF(e) {
  if (e.tag === 13) {
    var t = e.memoizedState;
    if (t === null && (e = e.alternate, e !== null && (t = e.memoizedState)), t !== null) return t.dehydrated
  }
  return null
}

function WR(e) {
  if (Eh(e) !== e) throw Error(Ke(188))
}

function jse(e) {
  var t = e.alternate;
  if (!t) {
    if (t = Eh(e), t === null) throw Error(Ke(188));
    return t !== e ? null : e
  }
  for (var n = e, r = t;;) {
    var i = n.return;
    if (i === null) break;
    var s = i.alternate;
    if (s === null) {
      if (r = i.return, r !== null) {
        n = r;
        continue
      }
      break
    }
    if (i.child === s.child) {
      for (s = i.child; s;) {
        if (s === n) return WR(i), e;
        if (s === r) return WR(i), t;
        s = s.sibling
      }
      throw Error(Ke(188))
    }
    if (n.return !== r.return) n = i, r = s;
    else {
      for (var o = !1, a = i.child; a;) {
        if (a === n) {
          o = !0, n = i, r = s;
          break
        }
        if (a === r) {
          o = !0, r = i, n = s;
          break
        }
        a = a.sibling
      }
      if (!o) {
        for (a = s.child; a;) {
          if (a === n) {
            o = !0, n = s, r = i;
            break
          }
          if (a === r) {
            o = !0, r = s, n = i;
            break
          }
          a = a.sibling
        }
        if (!o) throw Error(Ke(189))
      }
    }
    if (n.alternate !== r) throw Error(Ke(190))
  }
  if (n.tag !== 3) throw Error(Ke(188));
  return n.stateNode.current === n ? e : t
}

function WF(e) {
  return e = jse(e), e !== null ? qF(e) : null
}

function qF(e) {
  if (e.tag === 5 || e.tag === 6) return e;
  for (e = e.child; e !== null;) {
    var t = qF(e);
    if (t !== null) return t;
    e = e.sibling
  }
  return null
}
var GF = Uo.unstable_scheduleCallback,
  qR = Uo.unstable_cancelCallback,
  Use = Uo.unstable_shouldYield,
  zse = Uo.unstable_requestPaint,
  Gr = Uo.unstable_now,
  Hse = Uo.unstable_getCurrentPriorityLevel,
  k9 = Uo.unstable_ImmediatePriority,
  KF = Uo.unstable_UserBlockingPriority,
  Mw = Uo.unstable_NormalPriority,
  Vse = Uo.unstable_LowPriority,
  QF = Uo.unstable_IdlePriority,
  Tx = null,
  nl = null;

function Wse(e) {
  if (nl && typeof nl.onCommitFiberRoot == "function") try {
    nl.onCommitFiberRoot(Tx, e, void 0, (e.current.flags & 128) === 128)
  } catch {}
}
var gc = Math.clz32 ? Math.clz32 : Kse,
  qse = Math.log,
  Gse = Math.LN2;

function Kse(e) {
  return e >>>= 0, e === 0 ? 32 : 31 - (qse(e) / Gse | 0) | 0
}
var Hv = 64,
  Vv = 4194304;

function e1(e) {
  switch (e & -e) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return e & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return e & 130023424;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 1073741824;
    default:
      return e
  }
}

function $w(e, t) {
  var n = e.pendingLanes;
  if (n === 0) return 0;
  var r = 0,
    i = e.suspendedLanes,
    s = e.pingedLanes,
    o = n & 268435455;
  if (o !== 0) {
    var a = o & ~i;
    a !== 0 ? r = e1(a) : (s &= o, s !== 0 && (r = e1(s)))
  } else o = n & ~i, o !== 0 ? r = e1(o) : s !== 0 && (r = e1(s));
  if (r === 0) return 0;
  if (t !== 0 && t !== r && !(t & i) && (i = r & -r, s = t & -t, i >= s || i === 16 && (s & 4194240) !== 0)) return t;
  if (r & 4 && (r |= n & 16), t = e.entangledLanes, t !== 0)
    for (e = e.entanglements, t &= r; 0 < t;) n = 31 - gc(t), i = 1 << n, r |= e[n], t &= ~i;
  return r
}

function Qse(e, t) {
  switch (e) {
    case 1:
    case 2:
    case 4:
      return t + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return t + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1
  }
}

function Yse(e, t) {
  for (var n = e.suspendedLanes, r = e.pingedLanes, i = e.expirationTimes, s = e.pendingLanes; 0 < s;) {
    var o = 31 - gc(s),
      a = 1 << o,
      c = i[o];
    c === -1 ? (!(a & n) || a & r) && (i[o] = Qse(a, t)) : c <= t && (e.expiredLanes |= a), s &= ~a
  }
}

function aC(e) {
  return e = e.pendingLanes & -1073741825, e !== 0 ? e : e & 1073741824 ? 1073741824 : 0
}

function YF() {
  var e = Hv;
  return Hv <<= 1, !(Hv & 4194240) && (Hv = 64), e
}

function M4(e) {
  for (var t = [], n = 0; 31 > n; n++) t.push(e);
  return t
}

function _2(e, t, n) {
  e.pendingLanes |= t, t !== 536870912 && (e.suspendedLanes = 0, e.pingedLanes = 0), e = e.eventTimes, t = 31 - gc(t), e[t] = n
}

function Jse(e, t) {
  var n = e.pendingLanes & ~t;
  e.pendingLanes = t, e.suspendedLanes = 0, e.pingedLanes = 0, e.expiredLanes &= t, e.mutableReadLanes &= t, e.entangledLanes &= t, t = e.entanglements;
  var r = e.eventTimes;
  for (e = e.expirationTimes; 0 < n;) {
    var i = 31 - gc(n),
      s = 1 << i;
    t[i] = 0, r[i] = -1, e[i] = -1, n &= ~s
  }
}

function _9(e, t) {
  var n = e.entangledLanes |= t;
  for (e = e.entanglements; n;) {
    var r = 31 - gc(n),
      i = 1 << r;
    i & t | e[r] & t && (e[r] |= t), n &= ~i
  }
}
var qn = 0;

function JF(e) {
  return e &= -e, 1 < e ? 4 < e ? e & 268435455 ? 16 : 536870912 : 4 : 1
}
var XF, I9, ZF, ej, tj, cC = !1,
  Wv = [],
  ud = null,
  dd = null,
  fd = null,
  N1 = new Map,
  M1 = new Map,
  nd = [],
  Xse = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");

function GR(e, t) {
  switch (e) {
    case "focusin":
    case "focusout":
      ud = null;
      break;
    case "dragenter":
    case "dragleave":
      dd = null;
      break;
    case "mouseover":
    case "mouseout":
      fd = null;
      break;
    case "pointerover":
    case "pointerout":
      N1.delete(t.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      M1.delete(t.pointerId)
  }
}

function mg(e, t, n, r, i, s) {
  return e === null || e.nativeEvent !== s ? (e = {
    blockedOn: t,
    domEventName: n,
    eventSystemFlags: r,
    nativeEvent: s,
    targetContainers: [i]
  }, t !== null && (t = P2(t), t !== null && I9(t)), e) : (e.eventSystemFlags |= r, t = e.targetContainers, i !== null && t.indexOf(i) === -1 && t.push(i), e)
}

function Zse(e, t, n, r, i) {
  switch (t) {
    case "focusin":
      return ud = mg(ud, e, t, n, r, i), !0;
    case "dragenter":
      return dd = mg(dd, e, t, n, r, i), !0;
    case "mouseover":
      return fd = mg(fd, e, t, n, r, i), !0;
    case "pointerover":
      var s = i.pointerId;
      return N1.set(s, mg(N1.get(s) || null, e, t, n, r, i)), !0;
    case "gotpointercapture":
      return s = i.pointerId, M1.set(s, mg(M1.get(s) || null, e, t, n, r, i)), !0
  }
  return !1
}

function nj(e) {
  var t = kf(e.target);
  if (t !== null) {
    var n = Eh(t);
    if (n !== null) {
      if (t = n.tag, t === 13) {
        if (t = VF(n), t !== null) {
          e.blockedOn = t, tj(e.priority, function () {
            ZF(n)
          });
          return
        }
      } else if (t === 3 && n.stateNode.current.memoizedState.isDehydrated) {
        e.blockedOn = n.tag === 3 ? n.stateNode.containerInfo : null;
        return
      }
    }
  }
  e.blockedOn = null
}

function Jb(e) {
  if (e.blockedOn !== null) return !1;
  for (var t = e.targetContainers; 0 < t.length;) {
    var n = lC(e.domEventName, e.eventSystemFlags, t[0], e.nativeEvent);
    if (n === null) {
      n = e.nativeEvent;
      var r = new n.constructor(n.type, n);
      rC = r, n.target.dispatchEvent(r), rC = null
    } else return t = P2(n), t !== null && I9(t), e.blockedOn = n, !1;
    t.shift()
  }
  return !0
}

function KR(e, t, n) {
  Jb(e) && n.delete(t)
}

function eoe() {
  cC = !1, ud !== null && Jb(ud) && (ud = null), dd !== null && Jb(dd) && (dd = null), fd !== null && Jb(fd) && (fd = null), N1.forEach(KR), M1.forEach(KR)
}

function gg(e, t) {
  e.blockedOn === t && (e.blockedOn = null, cC || (cC = !0, Uo.unstable_scheduleCallback(Uo.unstable_NormalPriority, eoe)))
}

function $1(e) {
  function t(i) {
    return gg(i, e)
  }
  if (0 < Wv.length) {
    gg(Wv[0], e);
    for (var n = 1; n < Wv.length; n++) {
      var r = Wv[n];
      r.blockedOn === e && (r.blockedOn = null)
    }
  }
  for (ud !== null && gg(ud, e), dd !== null && gg(dd, e), fd !== null && gg(fd, e), N1.forEach(t), M1.forEach(t), n = 0; n < nd.length; n++) r = nd[n], r.blockedOn === e && (r.blockedOn = null);
  for (; 0 < nd.length && (n = nd[0], n.blockedOn === null);) nj(n), n.blockedOn === null && nd.shift()
}
var sp = pu.ReactCurrentBatchConfig,
  Lw = !0;

function toe(e, t, n, r) {
  var i = qn,
    s = sp.transition;
  sp.transition = null;
  try {
    qn = 1, P9(e, t, n, r)
  } finally {
    qn = i, sp.transition = s
  }
}

function noe(e, t, n, r) {
  var i = qn,
    s = sp.transition;
  sp.transition = null;
  try {
    qn = 4, P9(e, t, n, r)
  } finally {
    qn = i, sp.transition = s
  }
}

function P9(e, t, n, r) {
  if (Lw) {
    var i = lC(e, t, n, r);
    if (i === null) W4(e, t, r, Bw, n), GR(e, r);
    else if (Zse(i, e, t, n, r)) r.stopPropagation();
    else if (GR(e, r), t & 4 && -1 < Xse.indexOf(e)) {
      for (; i !== null;) {
        var s = P2(i);
        if (s !== null && XF(s), s = lC(e, t, n, r), s === null && W4(e, t, r, Bw, n), s === i) break;
        i = s
      }
      i !== null && r.stopPropagation()
    } else W4(e, t, r, null, n)
  }
}
var Bw = null;

function lC(e, t, n, r) {
  if (Bw = null, e = T9(r), e = kf(e), e !== null)
    if (t = Eh(e), t === null) e = null;
    else if (n = t.tag, n === 13) {
    if (e = VF(t), e !== null) return e;
    e = null
  } else if (n === 3) {
    if (t.stateNode.current.memoizedState.isDehydrated) return t.tag === 3 ? t.stateNode.containerInfo : null;
    e = null
  } else t !== e && (e = null);
  return Bw = e, null
}

function rj(e) {
  switch (e) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 4;
    case "message":
      switch (Hse()) {
        case k9:
          return 1;
        case KF:
          return 4;
        case Mw:
        case Vse:
          return 16;
        case QF:
          return 536870912;
        default:
          return 16
      }
      default:
        return 16
  }
}
var sd = null,
  R9 = null,
  Xb = null;

function ij() {
  if (Xb) return Xb;
  var e, t = R9,
    n = t.length,
    r, i = "value" in sd ? sd.value : sd.textContent,
    s = i.length;
  for (e = 0; e < n && t[e] === i[e]; e++);
  var o = n - e;
  for (r = 1; r <= o && t[n - r] === i[s - r]; r++);
  return Xb = i.slice(e, 1 < r ? 1 - r : void 0)
}

function Zb(e) {
  var t = e.keyCode;
  return "charCode" in e ? (e = e.charCode, e === 0 && t === 13 && (e = 13)) : e = t, e === 10 && (e = 13), 32 <= e || e === 13 ? e : 0
}

function qv() {
  return !0
}

function QR() {
  return !1
}

function qo(e) {
  function t(n, r, i, s, o) {
    this._reactName = n, this._targetInst = i, this.type = r, this.nativeEvent = s, this.target = o, this.currentTarget = null;
    for (var a in e) e.hasOwnProperty(a) && (n = e[a], this[a] = n ? n(s) : s[a]);
    return this.isDefaultPrevented = (s.defaultPrevented != null ? s.defaultPrevented : s.returnValue === !1) ? qv : QR, this.isPropagationStopped = QR, this
  }
  return Dr(t.prototype, {
    preventDefault: function () {
      this.defaultPrevented = !0;
      var n = this.nativeEvent;
      n && (n.preventDefault ? n.preventDefault() : typeof n.returnValue != "unknown" && (n.returnValue = !1), this.isDefaultPrevented = qv)
    },
    stopPropagation: function () {
      var n = this.nativeEvent;
      n && (n.stopPropagation ? n.stopPropagation() : typeof n.cancelBubble != "unknown" && (n.cancelBubble = !0), this.isPropagationStopped = qv)
    },
    persist: function () {},
    isPersistent: qv
  }), t
}
var cm = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function (e) {
      return e.timeStamp || Date.now()
    },
    defaultPrevented: 0,
    isTrusted: 0
  },
  O9 = qo(cm),
  I2 = Dr({}, cm, {
    view: 0,
    detail: 0
  }),
  roe = qo(I2),
  $4, L4, yg, kx = Dr({}, I2, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: D9,
    button: 0,
    buttons: 0,
    relatedTarget: function (e) {
      return e.relatedTarget === void 0 ? e.fromElement === e.srcElement ? e.toElement : e.fromElement : e.relatedTarget
    },
    movementX: function (e) {
      return "movementX" in e ? e.movementX : (e !== yg && (yg && e.type === "mousemove" ? ($4 = e.screenX - yg.screenX, L4 = e.screenY - yg.screenY) : L4 = $4 = 0, yg = e), $4)
    },
    movementY: function (e) {
      return "movementY" in e ? e.movementY : L4
    }
  }),
  YR = qo(kx),
  ioe = Dr({}, kx, {
    dataTransfer: 0
  }),
  soe = qo(ioe),
  ooe = Dr({}, I2, {
    relatedTarget: 0
  }),
  B4 = qo(ooe),
  aoe = Dr({}, cm, {
    animationName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }),
  coe = qo(aoe),
  loe = Dr({}, cm, {
    clipboardData: function (e) {
      return "clipboardData" in e ? e.clipboardData : window.clipboardData
    }
  }),
  uoe = qo(loe),
  doe = Dr({}, cm, {
    data: 0
  }),
  JR = qo(doe),
  foe = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  },
  hoe = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  },
  poe = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey"
  };

function moe(e) {
  var t = this.nativeEvent;
  return t.getModifierState ? t.getModifierState(e) : (e = poe[e]) ? !!t[e] : !1
}

function D9() {
  return moe
}
var goe = Dr({}, I2, {
    key: function (e) {
      if (e.key) {
        var t = foe[e.key] || e.key;
        if (t !== "Unidentified") return t
      }
      return e.type === "keypress" ? (e = Zb(e), e === 13 ? "Enter" : String.fromCharCode(e)) : e.type === "keydown" || e.type === "keyup" ? hoe[e.keyCode] || "Unidentified" : ""
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: D9,
    charCode: function (e) {
      return e.type === "keypress" ? Zb(e) : 0
    },
    keyCode: function (e) {
      return e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0
    },
    which: function (e) {
      return e.type === "keypress" ? Zb(e) : e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0
    }
  }),
  yoe = qo(goe),
  voe = Dr({}, kx, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0
  }),
  XR = qo(voe),
  boe = Dr({}, I2, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: D9
  }),
  woe = qo(boe),
  xoe = Dr({}, cm, {
    propertyName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }),
  Eoe = qo(xoe),
  Soe = Dr({}, kx, {
    deltaX: function (e) {
      return "deltaX" in e ? e.deltaX : "wheelDeltaX" in e ? -e.wheelDeltaX : 0
    },
    deltaY: function (e) {
      return "deltaY" in e ? e.deltaY : "wheelDeltaY" in e ? -e.wheelDeltaY : "wheelDelta" in e ? -e.wheelDelta : 0
    },
    deltaZ: 0,
    deltaMode: 0
  }),
  Coe = qo(Soe),
  Aoe = [9, 13, 27, 32],
  N9 = iu && "CompositionEvent" in window,
  l1 = null;
iu && "documentMode" in document && (l1 = document.documentMode);
var Toe = iu && "TextEvent" in window && !l1,
  sj = iu && (!N9 || l1 && 8 < l1 && 11 >= l1),
  ZR = " ",
  eO = !1;

function oj(e, t) {
  switch (e) {
    case "keyup":
      return Aoe.indexOf(t.keyCode) !== -1;
    case "keydown":
      return t.keyCode !== 229;
    case "keypress":
    case "mousedown":
    case "focusout":
      return !0;
    default:
      return !1
  }
}

function aj(e) {
  return e = e.detail, typeof e == "object" && "data" in e ? e.data : null
}
var O0 = !1;

function koe(e, t) {
  switch (e) {
    case "compositionend":
      return aj(t);
    case "keypress":
      return t.which !== 32 ? null : (eO = !0, ZR);
    case "textInput":
      return e = t.data, e === ZR && eO ? null : e;
    default:
      return null
  }
}

function _oe(e, t) {
  if (O0) return e === "compositionend" || !N9 && oj(e, t) ? (e = ij(), Xb = R9 = sd = null, O0 = !1, e) : null;
  switch (e) {
    case "paste":
      return null;
    case "keypress":
      if (!(t.ctrlKey || t.altKey || t.metaKey) || t.ctrlKey && t.altKey) {
        if (t.char && 1 < t.char.length) return t.char;
        if (t.which) return String.fromCharCode(t.which)
      }
      return null;
    case "compositionend":
      return sj && t.locale !== "ko" ? null : t.data;
    default:
      return null
  }
}
var Ioe = {
  color: !0,
  date: !0,
  datetime: !0,
  "datetime-local": !0,
  email: !0,
  month: !0,
  number: !0,
  password: !0,
  range: !0,
  search: !0,
  tel: !0,
  text: !0,
  time: !0,
  url: !0,
  week: !0
};

function tO(e) {
  var t = e && e.nodeName && e.nodeName.toLowerCase();
  return t === "input" ? !!Ioe[e.type] : t === "textarea"
}

function cj(e, t, n, r) {
  FF(r), t = Fw(t, "onChange"), 0 < t.length && (n = new O9("onChange", "change", null, n, r), e.push({
    event: n,
    listeners: t
  }))
}
var u1 = null,
  L1 = null;

function Poe(e) {
  bj(e, 0)
}

function _x(e) {
  var t = M0(e);
  if (OF(t)) return e
}

function Roe(e, t) {
  if (e === "change") return t
}
var lj = !1;
if (iu) {
  var F4;
  if (iu) {
    var j4 = "oninput" in document;
    if (!j4) {
      var nO = document.createElement("div");
      nO.setAttribute("oninput", "return;"), j4 = typeof nO.oninput == "function"
    }
    F4 = j4
  } else F4 = !1;
  lj = F4 && (!document.documentMode || 9 < document.documentMode)
}

function rO() {
  u1 && (u1.detachEvent("onpropertychange", uj), L1 = u1 = null)
}

function uj(e) {
  if (e.propertyName === "value" && _x(L1)) {
    var t = [];
    cj(t, L1, e, T9(e)), HF(Poe, t)
  }
}

function Ooe(e, t, n) {
  e === "focusin" ? (rO(), u1 = t, L1 = n, u1.attachEvent("onpropertychange", uj)) : e === "focusout" && rO()
}

function Doe(e) {
  if (e === "selectionchange" || e === "keyup" || e === "keydown") return _x(L1)
}

function Noe(e, t) {
  if (e === "click") return _x(t)
}

function Moe(e, t) {
  if (e === "input" || e === "change") return _x(t)
}

function $oe(e, t) {
  return e === t && (e !== 0 || 1 / e === 1 / t) || e !== e && t !== t
}
var xc = typeof Object.is == "function" ? Object.is : $oe;

function B1(e, t) {
  if (xc(e, t)) return !0;
  if (typeof e != "object" || e === null || typeof t != "object" || t === null) return !1;
  var n = Object.keys(e),
    r = Object.keys(t);
  if (n.length !== r.length) return !1;
  for (r = 0; r < n.length; r++) {
    var i = n[r];
    if (!W8.call(t, i) || !xc(e[i], t[i])) return !1
  }
  return !0
}

function iO(e) {
  for (; e && e.firstChild;) e = e.firstChild;
  return e
}

function sO(e, t) {
  var n = iO(e);
  e = 0;
  for (var r; n;) {
    if (n.nodeType === 3) {
      if (r = e + n.textContent.length, e <= t && r >= t) return {
        node: n,
        offset: t - e
      };
      e = r
    }
    e: {
      for (; n;) {
        if (n.nextSibling) {
          n = n.nextSibling;
          break e
        }
        n = n.parentNode
      }
      n = void 0
    }
    n = iO(n)
  }
}

function dj(e, t) {
  return e && t ? e === t ? !0 : e && e.nodeType === 3 ? !1 : t && t.nodeType === 3 ? dj(e, t.parentNode) : "contains" in e ? e.contains(t) : e.compareDocumentPosition ? !!(e.compareDocumentPosition(t) & 16) : !1 : !1
}

function fj() {
  for (var e = window, t = Ow(); t instanceof e.HTMLIFrameElement;) {
    try {
      var n = typeof t.contentWindow.location.href == "string"
    } catch {
      n = !1
    }
    if (n) e = t.contentWindow;
    else break;
    t = Ow(e.document)
  }
  return t
}

function M9(e) {
  var t = e && e.nodeName && e.nodeName.toLowerCase();
  return t && (t === "input" && (e.type === "text" || e.type === "search" || e.type === "tel" || e.type === "url" || e.type === "password") || t === "textarea" || e.contentEditable === "true")
}

function Loe(e) {
  var t = fj(),
    n = e.focusedElem,
    r = e.selectionRange;
  if (t !== n && n && n.ownerDocument && dj(n.ownerDocument.documentElement, n)) {
    if (r !== null && M9(n)) {
      if (t = r.start, e = r.end, e === void 0 && (e = t), "selectionStart" in n) n.selectionStart = t, n.selectionEnd = Math.min(e, n.value.length);
      else if (e = (t = n.ownerDocument || document) && t.defaultView || window, e.getSelection) {
        e = e.getSelection();
        var i = n.textContent.length,
          s = Math.min(r.start, i);
        r = r.end === void 0 ? s : Math.min(r.end, i), !e.extend && s > r && (i = r, r = s, s = i), i = sO(n, s);
        var o = sO(n, r);
        i && o && (e.rangeCount !== 1 || e.anchorNode !== i.node || e.anchorOffset !== i.offset || e.focusNode !== o.node || e.focusOffset !== o.offset) && (t = t.createRange(), t.setStart(i.node, i.offset), e.removeAllRanges(), s > r ? (e.addRange(t), e.extend(o.node, o.offset)) : (t.setEnd(o.node, o.offset), e.addRange(t)))
      }
    }
    for (t = [], e = n; e = e.parentNode;) e.nodeType === 1 && t.push({
      element: e,
      left: e.scrollLeft,
      top: e.scrollTop
    });
    for (typeof n.focus == "function" && n.focus(), n = 0; n < t.length; n++) e = t[n], e.element.scrollLeft = e.left, e.element.scrollTop = e.top
  }
}
var Boe = iu && "documentMode" in document && 11 >= document.documentMode,
  D0 = null,
  uC = null,
  d1 = null,
  dC = !1;

function oO(e, t, n) {
  var r = n.window === n ? n.document : n.nodeType === 9 ? n : n.ownerDocument;
  dC || D0 == null || D0 !== Ow(r) || (r = D0, "selectionStart" in r && M9(r) ? r = {
    start: r.selectionStart,
    end: r.selectionEnd
  } : (r = (r.ownerDocument && r.ownerDocument.defaultView || window).getSelection(), r = {
    anchorNode: r.anchorNode,
    anchorOffset: r.anchorOffset,
    focusNode: r.focusNode,
    focusOffset: r.focusOffset
  }), d1 && B1(d1, r) || (d1 = r, r = Fw(uC, "onSelect"), 0 < r.length && (t = new O9("onSelect", "select", null, t, n), e.push({
    event: t,
    listeners: r
  }), t.target = D0)))
}

function Gv(e, t) {
  var n = {};
  return n[e.toLowerCase()] = t.toLowerCase(), n["Webkit" + e] = "webkit" + t, n["Moz" + e] = "moz" + t, n
}
var N0 = {
    animationend: Gv("Animation", "AnimationEnd"),
    animationiteration: Gv("Animation", "AnimationIteration"),
    animationstart: Gv("Animation", "AnimationStart"),
    transitionend: Gv("Transition", "TransitionEnd")
  },
  U4 = {},
  hj = {};
iu && (hj = document.createElement("div").style, "AnimationEvent" in window || (delete N0.animationend.animation, delete N0.animationiteration.animation, delete N0.animationstart.animation), "TransitionEvent" in window || delete N0.transitionend.transition);

function Ix(e) {
  if (U4[e]) return U4[e];
  if (!N0[e]) return e;
  var t = N0[e],
    n;
  for (n in t)
    if (t.hasOwnProperty(n) && n in hj) return U4[e] = t[n];
  return e
}
var pj = Ix("animationend"),
  mj = Ix("animationiteration"),
  gj = Ix("animationstart"),
  yj = Ix("transitionend"),
  vj = new Map,
  aO = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");

function Md(e, t) {
  vj.set(e, t), xh(t, [e])
}
for (var z4 = 0; z4 < aO.length; z4++) {
  var H4 = aO[z4],
    Foe = H4.toLowerCase(),
    joe = H4[0].toUpperCase() + H4.slice(1);
  Md(Foe, "on" + joe)
}
Md(pj, "onAnimationEnd");
Md(mj, "onAnimationIteration");
Md(gj, "onAnimationStart");
Md("dblclick", "onDoubleClick");
Md("focusin", "onFocus");
Md("focusout", "onBlur");
Md(yj, "onTransitionEnd");
bp("onMouseEnter", ["mouseout", "mouseover"]);
bp("onMouseLeave", ["mouseout", "mouseover"]);
bp("onPointerEnter", ["pointerout", "pointerover"]);
bp("onPointerLeave", ["pointerout", "pointerover"]);
xh("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
xh("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
xh("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
xh("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
xh("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
xh("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var t1 = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),
  Uoe = new Set("cancel close invalid load scroll toggle".split(" ").concat(t1));

function cO(e, t, n) {
  var r = e.type || "unknown-event";
  e.currentTarget = n, Fse(r, t, void 0, e), e.currentTarget = null
}

function bj(e, t) {
  t = (t & 4) !== 0;
  for (var n = 0; n < e.length; n++) {
    var r = e[n],
      i = r.event;
    r = r.listeners;
    e: {
      var s = void 0;
      if (t)
        for (var o = r.length - 1; 0 <= o; o--) {
          var a = r[o],
            c = a.instance,
            l = a.currentTarget;
          if (a = a.listener, c !== s && i.isPropagationStopped()) break e;
          cO(i, a, l), s = c
        } else
          for (o = 0; o < r.length; o++) {
            if (a = r[o], c = a.instance, l = a.currentTarget, a = a.listener, c !== s && i.isPropagationStopped()) break e;
            cO(i, a, l), s = c
          }
    }
  }
  if (Nw) throw e = oC, Nw = !1, oC = null, e
}

function mr(e, t) {
  var n = t[gC];
  n === void 0 && (n = t[gC] = new Set);
  var r = e + "__bubble";
  n.has(r) || (wj(t, e, 2, !1), n.add(r))
}

function V4(e, t, n) {
  var r = 0;
  t && (r |= 4), wj(n, e, r, t)
}
var Kv = "_reactListening" + Math.random().toString(36).slice(2);

function F1(e) {
  if (!e[Kv]) {
    e[Kv] = !0, kF.forEach(function (n) {
      n !== "selectionchange" && (Uoe.has(n) || V4(n, !1, e), V4(n, !0, e))
    });
    var t = e.nodeType === 9 ? e : e.ownerDocument;
    t === null || t[Kv] || (t[Kv] = !0, V4("selectionchange", !1, t))
  }
}

function wj(e, t, n, r) {
  switch (rj(t)) {
    case 1:
      var i = toe;
      break;
    case 4:
      i = noe;
      break;
    default:
      i = P9
  }
  n = i.bind(null, t, n, e), i = void 0, !sC || t !== "touchstart" && t !== "touchmove" && t !== "wheel" || (i = !0), r ? i !== void 0 ? e.addEventListener(t, n, {
    capture: !0,
    passive: i
  }) : e.addEventListener(t, n, !0) : i !== void 0 ? e.addEventListener(t, n, {
    passive: i
  }) : e.addEventListener(t, n, !1)
}

function W4(e, t, n, r, i) {
  var s = r;
  if (!(t & 1) && !(t & 2) && r !== null) e: for (;;) {
    if (r === null) return;
    var o = r.tag;
    if (o === 3 || o === 4) {
      var a = r.stateNode.containerInfo;
      if (a === i || a.nodeType === 8 && a.parentNode === i) break;
      if (o === 4)
        for (o = r.return; o !== null;) {
          var c = o.tag;
          if ((c === 3 || c === 4) && (c = o.stateNode.containerInfo, c === i || c.nodeType === 8 && c.parentNode === i)) return;
          o = o.return
        }
      for (; a !== null;) {
        if (o = kf(a), o === null) return;
        if (c = o.tag, c === 5 || c === 6) {
          r = s = o;
          continue e
        }
        a = a.parentNode
      }
    }
    r = r.return
  }
  HF(function () {
    var l = s,
      u = T9(n),
      f = [];
    e: {
      var h = vj.get(e);
      if (h !== void 0) {
        var g = O9,
          y = e;
        switch (e) {
          case "keypress":
            if (Zb(n) === 0) break e;
          case "keydown":
          case "keyup":
            g = yoe;
            break;
          case "focusin":
            y = "focus", g = B4;
            break;
          case "focusout":
            y = "blur", g = B4;
            break;
          case "beforeblur":
          case "afterblur":
            g = B4;
            break;
          case "click":
            if (n.button === 2) break e;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            g = YR;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            g = soe;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            g = woe;
            break;
          case pj:
          case mj:
          case gj:
            g = coe;
            break;
          case yj:
            g = Eoe;
            break;
          case "scroll":
            g = roe;
            break;
          case "wheel":
            g = Coe;
            break;
          case "copy":
          case "cut":
          case "paste":
            g = uoe;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            g = XR
        }
        var x = (t & 4) !== 0,
          k = !x && e === "scroll",
          _ = x ? h !== null ? h + "Capture" : null : h;
        x = [];
        for (var p = l, v; p !== null;) {
          v = p;
          var S = v.stateNode;
          if (v.tag === 5 && S !== null && (v = S, _ !== null && (S = D1(p, _), S != null && x.push(j1(p, S, v)))), k) break;
          p = p.return
        }
        0 < x.length && (h = new g(h, y, null, n, u), f.push({
          event: h,
          listeners: x
        }))
      }
    }
    if (!(t & 7)) {
      e: {
        if (h = e === "mouseover" || e === "pointerover", g = e === "mouseout" || e === "pointerout", h && n !== rC && (y = n.relatedTarget || n.fromElement) && (kf(y) || y[su])) break e;
        if ((g || h) && (h = u.window === u ? u : (h = u.ownerDocument) ? h.defaultView || h.parentWindow : window, g ? (y = n.relatedTarget || n.toElement, g = l, y = y ? kf(y) : null, y !== null && (k = Eh(y), y !== k || y.tag !== 5 && y.tag !== 6) && (y = null)) : (g = null, y = l), g !== y)) {
          if (x = YR, S = "onMouseLeave", _ = "onMouseEnter", p = "mouse", (e === "pointerout" || e === "pointerover") && (x = XR, S = "onPointerLeave", _ = "onPointerEnter", p = "pointer"), k = g == null ? h : M0(g), v = y == null ? h : M0(y), h = new x(S, p + "leave", g, n, u), h.target = k, h.relatedTarget = v, S = null, kf(u) === l && (x = new x(_, p + "enter", y, n, u), x.target = v, x.relatedTarget = k, S = x), k = S, g && y) t: {
            for (x = g, _ = y, p = 0, v = x; v; v = o0(v)) p++;
            for (v = 0, S = _; S; S = o0(S)) v++;
            for (; 0 < p - v;) x = o0(x),
            p--;
            for (; 0 < v - p;) _ = o0(_),
            v--;
            for (; p--;) {
              if (x === _ || _ !== null && x === _.alternate) break t;
              x = o0(x), _ = o0(_)
            }
            x = null
          }
          else x = null;
          g !== null && lO(f, h, g, x, !1), y !== null && k !== null && lO(f, k, y, x, !0)
        }
      }
      e: {
        if (h = l ? M0(l) : window, g = h.nodeName && h.nodeName.toLowerCase(), g === "select" || g === "input" && h.type === "file") var I = Roe;
        else if (tO(h))
          if (lj) I = Moe;
          else {
            I = Doe;
            var A = Ooe
          }
        else(g = h.nodeName) && g.toLowerCase() === "input" && (h.type === "checkbox" || h.type === "radio") && (I = Noe);
        if (I && (I = I(e, l))) {
          cj(f, I, n, u);
          break e
        }
        A && A(e, h, l),
        e === "focusout" && (A = h._wrapperState) && A.controlled && h.type === "number" && X8(h, "number", h.value)
      }
      switch (A = l ? M0(l) : window, e) {
        case "focusin":
          (tO(A) || A.contentEditable === "true") && (D0 = A, uC = l, d1 = null);
          break;
        case "focusout":
          d1 = uC = D0 = null;
          break;
        case "mousedown":
          dC = !0;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          dC = !1, oO(f, n, u);
          break;
        case "selectionchange":
          if (Boe) break;
        case "keydown":
        case "keyup":
          oO(f, n, u)
      }
      var w;
      if (N9) e: {
        switch (e) {
          case "compositionstart":
            var E = "onCompositionStart";
            break e;
          case "compositionend":
            E = "onCompositionEnd";
            break e;
          case "compositionupdate":
            E = "onCompositionUpdate";
            break e
        }
        E = void 0
      }
      else O0 ? oj(e, n) && (E = "onCompositionEnd") : e === "keydown" && n.keyCode === 229 && (E = "onCompositionStart");E && (sj && n.locale !== "ko" && (O0 || E !== "onCompositionStart" ? E === "onCompositionEnd" && O0 && (w = ij()) : (sd = u, R9 = "value" in sd ? sd.value : sd.textContent, O0 = !0)), A = Fw(l, E), 0 < A.length && (E = new JR(E, e, null, n, u), f.push({
        event: E,
        listeners: A
      }), w ? E.data = w : (w = aj(n), w !== null && (E.data = w)))),
      (w = Toe ? koe(e, n) : _oe(e, n)) && (l = Fw(l, "onBeforeInput"), 0 < l.length && (u = new JR("onBeforeInput", "beforeinput", null, n, u), f.push({
        event: u,
        listeners: l
      }), u.data = w))
    }
    bj(f, t)
  })
}

function j1(e, t, n) {
  return {
    instance: e,
    listener: t,
    currentTarget: n
  }
}

function Fw(e, t) {
  for (var n = t + "Capture", r = []; e !== null;) {
    var i = e,
      s = i.stateNode;
    i.tag === 5 && s !== null && (i = s, s = D1(e, n), s != null && r.unshift(j1(e, s, i)), s = D1(e, t), s != null && r.push(j1(e, s, i))), e = e.return
  }
  return r
}

function o0(e) {
  if (e === null) return null;
  do e = e.return; while (e && e.tag !== 5);
  return e || null
}

function lO(e, t, n, r, i) {
  for (var s = t._reactName, o = []; n !== null && n !== r;) {
    var a = n,
      c = a.alternate,
      l = a.stateNode;
    if (c !== null && c === r) break;
    a.tag === 5 && l !== null && (a = l, i ? (c = D1(n, s), c != null && o.unshift(j1(n, c, a))) : i || (c = D1(n, s), c != null && o.push(j1(n, c, a)))), n = n.return
  }
  o.length !== 0 && e.push({
    event: t,
    listeners: o
  })
}
var zoe = /\r\n?/g,
  Hoe = /\u0000|\uFFFD/g;

function uO(e) {
  return (typeof e == "string" ? e : "" + e).replace(zoe, `
`).replace(Hoe, "")
}

function Qv(e, t, n) {
  if (t = uO(t), uO(e) !== t && n) throw Error(Ke(425))
}

function jw() {}
var fC = null,
  hC = null;

function pC(e, t) {
  return e === "textarea" || e === "noscript" || typeof t.children == "string" || typeof t.children == "number" || typeof t.dangerouslySetInnerHTML == "object" && t.dangerouslySetInnerHTML !== null && t.dangerouslySetInnerHTML.__html != null
}
var mC = typeof setTimeout == "function" ? setTimeout : void 0,
  Voe = typeof clearTimeout == "function" ? clearTimeout : void 0,
  dO = typeof Promise == "function" ? Promise : void 0,
  Woe = typeof queueMicrotask == "function" ? queueMicrotask : typeof dO < "u" ? function (e) {
    return dO.resolve(null).then(e).catch(qoe)
  } : mC;

function qoe(e) {
  setTimeout(function () {
    throw e
  })
}

function q4(e, t) {
  var n = t,
    r = 0;
  do {
    var i = n.nextSibling;
    if (e.removeChild(n), i && i.nodeType === 8)
      if (n = i.data, n === "/$") {
        if (r === 0) {
          e.removeChild(i), $1(t);
          return
        }
        r--
      } else n !== "$" && n !== "$?" && n !== "$!" || r++;
    n = i
  } while (n);
  $1(t)
}

function hd(e) {
  for (; e != null; e = e.nextSibling) {
    var t = e.nodeType;
    if (t === 1 || t === 3) break;
    if (t === 8) {
      if (t = e.data, t === "$" || t === "$!" || t === "$?") break;
      if (t === "/$") return null
    }
  }
  return e
}

function fO(e) {
  e = e.previousSibling;
  for (var t = 0; e;) {
    if (e.nodeType === 8) {
      var n = e.data;
      if (n === "$" || n === "$!" || n === "$?") {
        if (t === 0) return e;
        t--
      } else n === "/$" && t++
    }
    e = e.previousSibling
  }
  return null
}
var lm = Math.random().toString(36).slice(2),
  Gc = "__reactFiber$" + lm,
  U1 = "__reactProps$" + lm,
  su = "__reactContainer$" + lm,
  gC = "__reactEvents$" + lm,
  Goe = "__reactListeners$" + lm,
  Koe = "__reactHandles$" + lm;

function kf(e) {
  var t = e[Gc];
  if (t) return t;
  for (var n = e.parentNode; n;) {
    if (t = n[su] || n[Gc]) {
      if (n = t.alternate, t.child !== null || n !== null && n.child !== null)
        for (e = fO(e); e !== null;) {
          if (n = e[Gc]) return n;
          e = fO(e)
        }
      return t
    }
    e = n, n = e.parentNode
  }
  return null
}

function P2(e) {
  return e = e[Gc] || e[su], !e || e.tag !== 5 && e.tag !== 6 && e.tag !== 13 && e.tag !== 3 ? null : e
}

function M0(e) {
  if (e.tag === 5 || e.tag === 6) return e.stateNode;
  throw Error(Ke(33))
}

function Px(e) {
  return e[U1] || null
}
var yC = [],
  $0 = -1;

function $d(e) {
  return {
    current: e
  }
}

function yr(e) {
  0 > $0 || (e.current = yC[$0], yC[$0] = null, $0--)
}

function cr(e, t) {
  $0++, yC[$0] = e.current, e.current = t
}
var wd = {},
  ls = $d(wd),
  io = $d(!1),
  Qf = wd;

function wp(e, t) {
  var n = e.type.contextTypes;
  if (!n) return wd;
  var r = e.stateNode;
  if (r && r.__reactInternalMemoizedUnmaskedChildContext === t) return r.__reactInternalMemoizedMaskedChildContext;
  var i = {},
    s;
  for (s in n) i[s] = t[s];
  return r && (e = e.stateNode, e.__reactInternalMemoizedUnmaskedChildContext = t, e.__reactInternalMemoizedMaskedChildContext = i), i
}

function so(e) {
  return e = e.childContextTypes, e != null
}

function Uw() {
  yr(io), yr(ls)
}

function hO(e, t, n) {
  if (ls.current !== wd) throw Error(Ke(168));
  cr(ls, t), cr(io, n)
}

function xj(e, t, n) {
  var r = e.stateNode;
  if (t = t.childContextTypes, typeof r.getChildContext != "function") return n;
  r = r.getChildContext();
  for (var i in r)
    if (!(i in t)) throw Error(Ke(108, Ose(e) || "Unknown", i));
  return Dr({}, n, r)
}

function zw(e) {
  return e = (e = e.stateNode) && e.__reactInternalMemoizedMergedChildContext || wd, Qf = ls.current, cr(ls, e), cr(io, io.current), !0
}

function pO(e, t, n) {
  var r = e.stateNode;
  if (!r) throw Error(Ke(169));
  n ? (e = xj(e, t, Qf), r.__reactInternalMemoizedMergedChildContext = e, yr(io), yr(ls), cr(ls, e)) : yr(io), cr(io, n)
}
var Ql = null,
  Rx = !1,
  G4 = !1;

function Ej(e) {
  Ql === null ? Ql = [e] : Ql.push(e)
}

function Qoe(e) {
  Rx = !0, Ej(e)
}

function Ld() {
  if (!G4 && Ql !== null) {
    G4 = !0;
    var e = 0,
      t = qn;
    try {
      var n = Ql;
      for (qn = 1; e < n.length; e++) {
        var r = n[e];
        do r = r(!0); while (r !== null)
      }
      Ql = null, Rx = !1
    } catch (i) {
      throw Ql !== null && (Ql = Ql.slice(e + 1)), GF(k9, Ld), i
    } finally {
      qn = t, G4 = !1
    }
  }
  return null
}
var L0 = [],
  B0 = 0,
  Hw = null,
  Vw = 0,
  ya = [],
  va = 0,
  Yf = null,
  Zl = 1,
  eu = "";

function wf(e, t) {
  L0[B0++] = Vw, L0[B0++] = Hw, Hw = e, Vw = t
}

function Sj(e, t, n) {
  ya[va++] = Zl, ya[va++] = eu, ya[va++] = Yf, Yf = e;
  var r = Zl;
  e = eu;
  var i = 32 - gc(r) - 1;
  r &= ~(1 << i), n += 1;
  var s = 32 - gc(t) + i;
  if (30 < s) {
    var o = i - i % 5;
    s = (r & (1 << o) - 1).toString(32), r >>= o, i -= o, Zl = 1 << 32 - gc(t) + i | n << i | r, eu = s + e
  } else Zl = 1 << s | n << i | r, eu = e
}

function $9(e) {
  e.return !== null && (wf(e, 1), Sj(e, 1, 0))
}

function L9(e) {
  for (; e === Hw;) Hw = L0[--B0], L0[B0] = null, Vw = L0[--B0], L0[B0] = null;
  for (; e === Yf;) Yf = ya[--va], ya[va] = null, eu = ya[--va], ya[va] = null, Zl = ya[--va], ya[va] = null
}
var Fo = null,
  Lo = null,
  Er = !1,
  ac = null;

function Cj(e, t) {
  var n = xa(5, null, null, 0);
  n.elementType = "DELETED", n.stateNode = t, n.return = e, t = e.deletions, t === null ? (e.deletions = [n], e.flags |= 16) : t.push(n)
}

function mO(e, t) {
  switch (e.tag) {
    case 5:
      var n = e.type;
      return t = t.nodeType !== 1 || n.toLowerCase() !== t.nodeName.toLowerCase() ? null : t, t !== null ? (e.stateNode = t, Fo = e, Lo = hd(t.firstChild), !0) : !1;
    case 6:
      return t = e.pendingProps === "" || t.nodeType !== 3 ? null : t, t !== null ? (e.stateNode = t, Fo = e, Lo = null, !0) : !1;
    case 13:
      return t = t.nodeType !== 8 ? null : t, t !== null ? (n = Yf !== null ? {
        id: Zl,
        overflow: eu
      } : null, e.memoizedState = {
        dehydrated: t,
        treeContext: n,
        retryLane: 1073741824
      }, n = xa(18, null, null, 0), n.stateNode = t, n.return = e, e.child = n, Fo = e, Lo = null, !0) : !1;
    default:
      return !1
  }
}

function vC(e) {
  return (e.mode & 1) !== 0 && (e.flags & 128) === 0
}

function bC(e) {
  if (Er) {
    var t = Lo;
    if (t) {
      var n = t;
      if (!mO(e, t)) {
        if (vC(e)) throw Error(Ke(418));
        t = hd(n.nextSibling);
        var r = Fo;
        t && mO(e, t) ? Cj(r, n) : (e.flags = e.flags & -4097 | 2, Er = !1, Fo = e)
      }
    } else {
      if (vC(e)) throw Error(Ke(418));
      e.flags = e.flags & -4097 | 2, Er = !1, Fo = e
    }
  }
}

function gO(e) {
  for (e = e.return; e !== null && e.tag !== 5 && e.tag !== 3 && e.tag !== 13;) e = e.return;
  Fo = e
}

function Yv(e) {
  if (e !== Fo) return !1;
  if (!Er) return gO(e), Er = !0, !1;
  var t;
  if ((t = e.tag !== 3) && !(t = e.tag !== 5) && (t = e.type, t = t !== "head" && t !== "body" && !pC(e.type, e.memoizedProps)), t && (t = Lo)) {
    if (vC(e)) throw Aj(), Error(Ke(418));
    for (; t;) Cj(e, t), t = hd(t.nextSibling)
  }
  if (gO(e), e.tag === 13) {
    if (e = e.memoizedState, e = e !== null ? e.dehydrated : null, !e) throw Error(Ke(317));
    e: {
      for (e = e.nextSibling, t = 0; e;) {
        if (e.nodeType === 8) {
          var n = e.data;
          if (n === "/$") {
            if (t === 0) {
              Lo = hd(e.nextSibling);
              break e
            }
            t--
          } else n !== "$" && n !== "$!" && n !== "$?" || t++
        }
        e = e.nextSibling
      }
      Lo = null
    }
  } else Lo = Fo ? hd(e.stateNode.nextSibling) : null;
  return !0
}

function Aj() {
  for (var e = Lo; e;) e = hd(e.nextSibling)
}

function xp() {
  Lo = Fo = null, Er = !1
}

function B9(e) {
  ac === null ? ac = [e] : ac.push(e)
}
var Yoe = pu.ReactCurrentBatchConfig;

function nc(e, t) {
  if (e && e.defaultProps) {
    t = Dr({}, t), e = e.defaultProps;
    for (var n in e) t[n] === void 0 && (t[n] = e[n]);
    return t
  }
  return t
}
var Ww = $d(null),
  qw = null,
  F0 = null,
  F9 = null;

function j9() {
  F9 = F0 = qw = null
}

function U9(e) {
  var t = Ww.current;
  yr(Ww), e._currentValue = t
}

function wC(e, t, n) {
  for (; e !== null;) {
    var r = e.alternate;
    if ((e.childLanes & t) !== t ? (e.childLanes |= t, r !== null && (r.childLanes |= t)) : r !== null && (r.childLanes & t) !== t && (r.childLanes |= t), e === n) break;
    e = e.return
  }
}

function op(e, t) {
  qw = e, F9 = F0 = null, e = e.dependencies, e !== null && e.firstContext !== null && (e.lanes & t && (no = !0), e.firstContext = null)
}

function Ta(e) {
  var t = e._currentValue;
  if (F9 !== e)
    if (e = {
        context: e,
        memoizedValue: t,
        next: null
      }, F0 === null) {
      if (qw === null) throw Error(Ke(308));
      F0 = e, qw.dependencies = {
        lanes: 0,
        firstContext: e
      }
    } else F0 = F0.next = e;
  return t
}
var _f = null;

function z9(e) {
  _f === null ? _f = [e] : _f.push(e)
}

function Tj(e, t, n, r) {
  var i = t.interleaved;
  return i === null ? (n.next = n, z9(t)) : (n.next = i.next, i.next = n), t.interleaved = n, ou(e, r)
}

function ou(e, t) {
  e.lanes |= t;
  var n = e.alternate;
  for (n !== null && (n.lanes |= t), n = e, e = e.return; e !== null;) e.childLanes |= t, n = e.alternate, n !== null && (n.childLanes |= t), n = e, e = e.return;
  return n.tag === 3 ? n.stateNode : null
}
var Xu = !1;

function H9(e) {
  e.updateQueue = {
    baseState: e.memoizedState,
    firstBaseUpdate: null,
    lastBaseUpdate: null,
    shared: {
      pending: null,
      interleaved: null,
      lanes: 0
    },
    effects: null
  }
}

function kj(e, t) {
  e = e.updateQueue, t.updateQueue === e && (t.updateQueue = {
    baseState: e.baseState,
    firstBaseUpdate: e.firstBaseUpdate,
    lastBaseUpdate: e.lastBaseUpdate,
    shared: e.shared,
    effects: e.effects
  })
}

function nu(e, t) {
  return {
    eventTime: e,
    lane: t,
    tag: 0,
    payload: null,
    callback: null,
    next: null
  }
}

function pd(e, t, n) {
  var r = e.updateQueue;
  if (r === null) return null;
  if (r = r.shared, An & 2) {
    var i = r.pending;
    return i === null ? t.next = t : (t.next = i.next, i.next = t), r.pending = t, ou(e, n)
  }
  return i = r.interleaved, i === null ? (t.next = t, z9(r)) : (t.next = i.next, i.next = t), r.interleaved = t, ou(e, n)
}

function ew(e, t, n) {
  if (t = t.updateQueue, t !== null && (t = t.shared, (n & 4194240) !== 0)) {
    var r = t.lanes;
    r &= e.pendingLanes, n |= r, t.lanes = n, _9(e, n)
  }
}

function yO(e, t) {
  var n = e.updateQueue,
    r = e.alternate;
  if (r !== null && (r = r.updateQueue, n === r)) {
    var i = null,
      s = null;
    if (n = n.firstBaseUpdate, n !== null) {
      do {
        var o = {
          eventTime: n.eventTime,
          lane: n.lane,
          tag: n.tag,
          payload: n.payload,
          callback: n.callback,
          next: null
        };
        s === null ? i = s = o : s = s.next = o, n = n.next
      } while (n !== null);
      s === null ? i = s = t : s = s.next = t
    } else i = s = t;
    n = {
      baseState: r.baseState,
      firstBaseUpdate: i,
      lastBaseUpdate: s,
      shared: r.shared,
      effects: r.effects
    }, e.updateQueue = n;
    return
  }
  e = n.lastBaseUpdate, e === null ? n.firstBaseUpdate = t : e.next = t, n.lastBaseUpdate = t
}

function Gw(e, t, n, r) {
  var i = e.updateQueue;
  Xu = !1;
  var s = i.firstBaseUpdate,
    o = i.lastBaseUpdate,
    a = i.shared.pending;
  if (a !== null) {
    i.shared.pending = null;
    var c = a,
      l = c.next;
    c.next = null, o === null ? s = l : o.next = l, o = c;
    var u = e.alternate;
    u !== null && (u = u.updateQueue, a = u.lastBaseUpdate, a !== o && (a === null ? u.firstBaseUpdate = l : a.next = l, u.lastBaseUpdate = c))
  }
  if (s !== null) {
    var f = i.baseState;
    o = 0, u = l = c = null, a = s;
    do {
      var h = a.lane,
        g = a.eventTime;
      if ((r & h) === h) {
        u !== null && (u = u.next = {
          eventTime: g,
          lane: 0,
          tag: a.tag,
          payload: a.payload,
          callback: a.callback,
          next: null
        });
        e: {
          var y = e,
            x = a;
          switch (h = t, g = n, x.tag) {
            case 1:
              if (y = x.payload, typeof y == "function") {
                f = y.call(g, f, h);
                break e
              }
              f = y;
              break e;
            case 3:
              y.flags = y.flags & -65537 | 128;
            case 0:
              if (y = x.payload, h = typeof y == "function" ? y.call(g, f, h) : y, h == null) break e;
              f = Dr({}, f, h);
              break e;
            case 2:
              Xu = !0
          }
        }
        a.callback !== null && a.lane !== 0 && (e.flags |= 64, h = i.effects, h === null ? i.effects = [a] : h.push(a))
      } else g = {
        eventTime: g,
        lane: h,
        tag: a.tag,
        payload: a.payload,
        callback: a.callback,
        next: null
      }, u === null ? (l = u = g, c = f) : u = u.next = g, o |= h;
      if (a = a.next, a === null) {
        if (a = i.shared.pending, a === null) break;
        h = a, a = h.next, h.next = null, i.lastBaseUpdate = h, i.shared.pending = null
      }
    } while (!0);
    if (u === null && (c = f), i.baseState = c, i.firstBaseUpdate = l, i.lastBaseUpdate = u, t = i.shared.interleaved, t !== null) {
      i = t;
      do o |= i.lane, i = i.next; while (i !== t)
    } else s === null && (i.shared.lanes = 0);
    Xf |= o, e.lanes = o, e.memoizedState = f
  }
}

function vO(e, t, n) {
  if (e = t.effects, t.effects = null, e !== null)
    for (t = 0; t < e.length; t++) {
      var r = e[t],
        i = r.callback;
      if (i !== null) {
        if (r.callback = null, r = n, typeof i != "function") throw Error(Ke(191, i));
        i.call(r)
      }
    }
}
var _j = new TF.Component().refs;

function xC(e, t, n, r) {
  t = e.memoizedState, n = n(r, t), n = n == null ? t : Dr({}, t, n), e.memoizedState = n, e.lanes === 0 && (e.updateQueue.baseState = n)
}
var Ox = {
  isMounted: function (e) {
    return (e = e._reactInternals) ? Eh(e) === e : !1
  },
  enqueueSetState: function (e, t, n) {
    e = e._reactInternals;
    var r = Ts(),
      i = gd(e),
      s = nu(r, i);
    s.payload = t, n != null && (s.callback = n), t = pd(e, s, i), t !== null && (yc(t, e, i, r), ew(t, e, i))
  },
  enqueueReplaceState: function (e, t, n) {
    e = e._reactInternals;
    var r = Ts(),
      i = gd(e),
      s = nu(r, i);
    s.tag = 1, s.payload = t, n != null && (s.callback = n), t = pd(e, s, i), t !== null && (yc(t, e, i, r), ew(t, e, i))
  },
  enqueueForceUpdate: function (e, t) {
    e = e._reactInternals;
    var n = Ts(),
      r = gd(e),
      i = nu(n, r);
    i.tag = 2, t != null && (i.callback = t), t = pd(e, i, r), t !== null && (yc(t, e, r, n), ew(t, e, r))
  }
};

function bO(e, t, n, r, i, s, o) {
  return e = e.stateNode, typeof e.shouldComponentUpdate == "function" ? e.shouldComponentUpdate(r, s, o) : t.prototype && t.prototype.isPureReactComponent ? !B1(n, r) || !B1(i, s) : !0
}

function Ij(e, t, n) {
  var r = !1,
    i = wd,
    s = t.contextType;
  return typeof s == "object" && s !== null ? s = Ta(s) : (i = so(t) ? Qf : ls.current, r = t.contextTypes, s = (r = r != null) ? wp(e, i) : wd), t = new t(n, s), e.memoizedState = t.state !== null && t.state !== void 0 ? t.state : null, t.updater = Ox, e.stateNode = t, t._reactInternals = e, r && (e = e.stateNode, e.__reactInternalMemoizedUnmaskedChildContext = i, e.__reactInternalMemoizedMaskedChildContext = s), t
}

function wO(e, t, n, r) {
  e = t.state, typeof t.componentWillReceiveProps == "function" && t.componentWillReceiveProps(n, r), typeof t.UNSAFE_componentWillReceiveProps == "function" && t.UNSAFE_componentWillReceiveProps(n, r), t.state !== e && Ox.enqueueReplaceState(t, t.state, null)
}

function EC(e, t, n, r) {
  var i = e.stateNode;
  i.props = n, i.state = e.memoizedState, i.refs = _j, H9(e);
  var s = t.contextType;
  typeof s == "object" && s !== null ? i.context = Ta(s) : (s = so(t) ? Qf : ls.current, i.context = wp(e, s)), i.state = e.memoizedState, s = t.getDerivedStateFromProps, typeof s == "function" && (xC(e, t, s, n), i.state = e.memoizedState), typeof t.getDerivedStateFromProps == "function" || typeof i.getSnapshotBeforeUpdate == "function" || typeof i.UNSAFE_componentWillMount != "function" && typeof i.componentWillMount != "function" || (t = i.state, typeof i.componentWillMount == "function" && i.componentWillMount(), typeof i.UNSAFE_componentWillMount == "function" && i.UNSAFE_componentWillMount(), t !== i.state && Ox.enqueueReplaceState(i, i.state, null), Gw(e, n, i, r), i.state = e.memoizedState), typeof i.componentDidMount == "function" && (e.flags |= 4194308)
}

function vg(e, t, n) {
  if (e = n.ref, e !== null && typeof e != "function" && typeof e != "object") {
    if (n._owner) {
      if (n = n._owner, n) {
        if (n.tag !== 1) throw Error(Ke(309));
        var r = n.stateNode
      }
      if (!r) throw Error(Ke(147, e));
      var i = r,
        s = "" + e;
      return t !== null && t.ref !== null && typeof t.ref == "function" && t.ref._stringRef === s ? t.ref : (t = function (o) {
        var a = i.refs;
        a === _j && (a = i.refs = {}), o === null ? delete a[s] : a[s] = o
      }, t._stringRef = s, t)
    }
    if (typeof e != "string") throw Error(Ke(284));
    if (!n._owner) throw Error(Ke(290, e))
  }
  return e
}

function Jv(e, t) {
  throw e = Object.prototype.toString.call(t), Error(Ke(31, e === "[object Object]" ? "object with keys {" + Object.keys(t).join(", ") + "}" : e))
}

function xO(e) {
  var t = e._init;
  return t(e._payload)
}

function Pj(e) {
  function t(_, p) {
    if (e) {
      var v = _.deletions;
      v === null ? (_.deletions = [p], _.flags |= 16) : v.push(p)
    }
  }

  function n(_, p) {
    if (!e) return null;
    for (; p !== null;) t(_, p), p = p.sibling;
    return null
  }

  function r(_, p) {
    for (_ = new Map; p !== null;) p.key !== null ? _.set(p.key, p) : _.set(p.index, p), p = p.sibling;
    return _
  }

  function i(_, p) {
    return _ = yd(_, p), _.index = 0, _.sibling = null, _
  }

  function s(_, p, v) {
    return _.index = v, e ? (v = _.alternate, v !== null ? (v = v.index, v < p ? (_.flags |= 2, p) : v) : (_.flags |= 2, p)) : (_.flags |= 1048576, p)
  }

  function o(_) {
    return e && _.alternate === null && (_.flags |= 2), _
  }

  function a(_, p, v, S) {
    return p === null || p.tag !== 6 ? (p = eS(v, _.mode, S), p.return = _, p) : (p = i(p, v), p.return = _, p)
  }

  function c(_, p, v, S) {
    var I = v.type;
    return I === R0 ? u(_, p, v.props.children, S, v.key) : p !== null && (p.elementType === I || typeof I == "object" && I !== null && I.$$typeof === Ju && xO(I) === p.type) ? (S = i(p, v.props), S.ref = vg(_, p, v), S.return = _, S) : (S = ow(v.type, v.key, v.props, null, _.mode, S), S.ref = vg(_, p, v), S.return = _, S)
  }

  function l(_, p, v, S) {
    return p === null || p.tag !== 4 || p.stateNode.containerInfo !== v.containerInfo || p.stateNode.implementation !== v.implementation ? (p = tS(v, _.mode, S), p.return = _, p) : (p = i(p, v.children || []), p.return = _, p)
  }

  function u(_, p, v, S, I) {
    return p === null || p.tag !== 7 ? (p = Uf(v, _.mode, S, I), p.return = _, p) : (p = i(p, v), p.return = _, p)
  }

  function f(_, p, v) {
    if (typeof p == "string" && p !== "" || typeof p == "number") return p = eS("" + p, _.mode, v), p.return = _, p;
    if (typeof p == "object" && p !== null) {
      switch (p.$$typeof) {
        case jv:
          return v = ow(p.type, p.key, p.props, null, _.mode, v), v.ref = vg(_, null, p), v.return = _, v;
        case P0:
          return p = tS(p, _.mode, v), p.return = _, p;
        case Ju:
          var S = p._init;
          return f(_, S(p._payload), v)
      }
      if (Zg(p) || hg(p)) return p = Uf(p, _.mode, v, null), p.return = _, p;
      Jv(_, p)
    }
    return null
  }

  function h(_, p, v, S) {
    var I = p !== null ? p.key : null;
    if (typeof v == "string" && v !== "" || typeof v == "number") return I !== null ? null : a(_, p, "" + v, S);
    if (typeof v == "object" && v !== null) {
      switch (v.$$typeof) {
        case jv:
          return v.key === I ? c(_, p, v, S) : null;
        case P0:
          return v.key === I ? l(_, p, v, S) : null;
        case Ju:
          return I = v._init, h(_, p, I(v._payload), S)
      }
      if (Zg(v) || hg(v)) return I !== null ? null : u(_, p, v, S, null);
      Jv(_, v)
    }
    return null
  }

  function g(_, p, v, S, I) {
    if (typeof S == "string" && S !== "" || typeof S == "number") return _ = _.get(v) || null, a(p, _, "" + S, I);
    if (typeof S == "object" && S !== null) {
      switch (S.$$typeof) {
        case jv:
          return _ = _.get(S.key === null ? v : S.key) || null, c(p, _, S, I);
        case P0:
          return _ = _.get(S.key === null ? v : S.key) || null, l(p, _, S, I);
        case Ju:
          var A = S._init;
          return g(_, p, v, A(S._payload), I)
      }
      if (Zg(S) || hg(S)) return _ = _.get(v) || null, u(p, _, S, I, null);
      Jv(p, S)
    }
    return null
  }

  function y(_, p, v, S) {
    for (var I = null, A = null, w = p, E = p = 0, D = null; w !== null && E < v.length; E++) {
      w.index > E ? (D = w, w = null) : D = w.sibling;
      var $ = h(_, w, v[E], S);
      if ($ === null) {
        w === null && (w = D);
        break
      }
      e && w && $.alternate === null && t(_, w), p = s($, p, E), A === null ? I = $ : A.sibling = $, A = $, w = D
    }
    if (E === v.length) return n(_, w), Er && wf(_, E), I;
    if (w === null) {
      for (; E < v.length; E++) w = f(_, v[E], S), w !== null && (p = s(w, p, E), A === null ? I = w : A.sibling = w, A = w);
      return Er && wf(_, E), I
    }
    for (w = r(_, w); E < v.length; E++) D = g(w, _, E, v[E], S), D !== null && (e && D.alternate !== null && w.delete(D.key === null ? E : D.key), p = s(D, p, E), A === null ? I = D : A.sibling = D, A = D);
    return e && w.forEach(function (V) {
      return t(_, V)
    }), Er && wf(_, E), I
  }

  function x(_, p, v, S) {
    var I = hg(v);
    if (typeof I != "function") throw Error(Ke(150));
    if (v = I.call(v), v == null) throw Error(Ke(151));
    for (var A = I = null, w = p, E = p = 0, D = null, $ = v.next(); w !== null && !$.done; E++, $ = v.next()) {
      w.index > E ? (D = w, w = null) : D = w.sibling;
      var V = h(_, w, $.value, S);
      if (V === null) {
        w === null && (w = D);
        break
      }
      e && w && V.alternate === null && t(_, w), p = s(V, p, E), A === null ? I = V : A.sibling = V, A = V, w = D
    }
    if ($.done) return n(_, w), Er && wf(_, E), I;
    if (w === null) {
      for (; !$.done; E++, $ = v.next()) $ = f(_, $.value, S), $ !== null && (p = s($, p, E), A === null ? I = $ : A.sibling = $, A = $);
      return Er && wf(_, E), I
    }
    for (w = r(_, w); !$.done; E++, $ = v.next()) $ = g(w, _, E, $.value, S), $ !== null && (e && $.alternate !== null && w.delete($.key === null ? E : $.key), p = s($, p, E), A === null ? I = $ : A.sibling = $, A = $);
    return e && w.forEach(function (G) {
      return t(_, G)
    }), Er && wf(_, E), I
  }

  function k(_, p, v, S) {
    if (typeof v == "object" && v !== null && v.type === R0 && v.key === null && (v = v.props.children), typeof v == "object" && v !== null) {
      switch (v.$$typeof) {
        case jv:
          e: {
            for (var I = v.key, A = p; A !== null;) {
              if (A.key === I) {
                if (I = v.type, I === R0) {
                  if (A.tag === 7) {
                    n(_, A.sibling), p = i(A, v.props.children), p.return = _, _ = p;
                    break e
                  }
                } else if (A.elementType === I || typeof I == "object" && I !== null && I.$$typeof === Ju && xO(I) === A.type) {
                  n(_, A.sibling), p = i(A, v.props), p.ref = vg(_, A, v), p.return = _, _ = p;
                  break e
                }
                n(_, A);
                break
              } else t(_, A);
              A = A.sibling
            }
            v.type === R0 ? (p = Uf(v.props.children, _.mode, S, v.key), p.return = _, _ = p) : (S = ow(v.type, v.key, v.props, null, _.mode, S), S.ref = vg(_, p, v), S.return = _, _ = S)
          }
          return o(_);
        case P0:
          e: {
            for (A = v.key; p !== null;) {
              if (p.key === A)
                if (p.tag === 4 && p.stateNode.containerInfo === v.containerInfo && p.stateNode.implementation === v.implementation) {
                  n(_, p.sibling), p = i(p, v.children || []), p.return = _, _ = p;
                  break e
                } else {
                  n(_, p);
                  break
                }
              else t(_, p);
              p = p.sibling
            }
            p = tS(v, _.mode, S),
            p.return = _,
            _ = p
          }
          return o(_);
        case Ju:
          return A = v._init, k(_, p, A(v._payload), S)
      }
      if (Zg(v)) return y(_, p, v, S);
      if (hg(v)) return x(_, p, v, S);
      Jv(_, v)
    }
    return typeof v == "string" && v !== "" || typeof v == "number" ? (v = "" + v, p !== null && p.tag === 6 ? (n(_, p.sibling), p = i(p, v), p.return = _, _ = p) : (n(_, p), p = eS(v, _.mode, S), p.return = _, _ = p), o(_)) : n(_, p)
  }
  return k
}
var Ep = Pj(!0),
  Rj = Pj(!1),
  R2 = {},
  rl = $d(R2),
  z1 = $d(R2),
  H1 = $d(R2);

function If(e) {
  if (e === R2) throw Error(Ke(174));
  return e
}

function V9(e, t) {
  switch (cr(H1, t), cr(z1, e), cr(rl, R2), e = t.nodeType, e) {
    case 9:
    case 11:
      t = (t = t.documentElement) ? t.namespaceURI : eC(null, "");
      break;
    default:
      e = e === 8 ? t.parentNode : t, t = e.namespaceURI || null, e = e.tagName, t = eC(t, e)
  }
  yr(rl), cr(rl, t)
}

function Sp() {
  yr(rl), yr(z1), yr(H1)
}

function Oj(e) {
  If(H1.current);
  var t = If(rl.current),
    n = eC(t, e.type);
  t !== n && (cr(z1, e), cr(rl, n))
}

function W9(e) {
  z1.current === e && (yr(rl), yr(z1))
}
var Pr = $d(0);

function Kw(e) {
  for (var t = e; t !== null;) {
    if (t.tag === 13) {
      var n = t.memoizedState;
      if (n !== null && (n = n.dehydrated, n === null || n.data === "$?" || n.data === "$!")) return t
    } else if (t.tag === 19 && t.memoizedProps.revealOrder !== void 0) {
      if (t.flags & 128) return t
    } else if (t.child !== null) {
      t.child.return = t, t = t.child;
      continue
    }
    if (t === e) break;
    for (; t.sibling === null;) {
      if (t.return === null || t.return === e) return null;
      t = t.return
    }
    t.sibling.return = t.return, t = t.sibling
  }
  return null
}
var K4 = [];

function q9() {
  for (var e = 0; e < K4.length; e++) K4[e]._workInProgressVersionPrimary = null;
  K4.length = 0
}
var tw = pu.ReactCurrentDispatcher,
  Q4 = pu.ReactCurrentBatchConfig,
  Jf = 0,
  Or = null,
  ui = null,
  bi = null,
  Qw = !1,
  f1 = !1,
  V1 = 0,
  Joe = 0;

function Yi() {
  throw Error(Ke(321))
}

function G9(e, t) {
  if (t === null) return !1;
  for (var n = 0; n < t.length && n < e.length; n++)
    if (!xc(e[n], t[n])) return !1;
  return !0
}

function K9(e, t, n, r, i, s) {
  if (Jf = s, Or = t, t.memoizedState = null, t.updateQueue = null, t.lanes = 0, tw.current = e === null || e.memoizedState === null ? tae : nae, e = n(r, i), f1) {
    s = 0;
    do {
      if (f1 = !1, V1 = 0, 25 <= s) throw Error(Ke(301));
      s += 1, bi = ui = null, t.updateQueue = null, tw.current = rae, e = n(r, i)
    } while (f1)
  }
  if (tw.current = Yw, t = ui !== null && ui.next !== null, Jf = 0, bi = ui = Or = null, Qw = !1, t) throw Error(Ke(300));
  return e
}

function Q9() {
  var e = V1 !== 0;
  return V1 = 0, e
}

function jc() {
  var e = {
    memoizedState: null,
    baseState: null,
    baseQueue: null,
    queue: null,
    next: null
  };
  return bi === null ? Or.memoizedState = bi = e : bi = bi.next = e, bi
}

function ka() {
  if (ui === null) {
    var e = Or.alternate;
    e = e !== null ? e.memoizedState : null
  } else e = ui.next;
  var t = bi === null ? Or.memoizedState : bi.next;
  if (t !== null) bi = t, ui = e;
  else {
    if (e === null) throw Error(Ke(310));
    ui = e, e = {
      memoizedState: ui.memoizedState,
      baseState: ui.baseState,
      baseQueue: ui.baseQueue,
      queue: ui.queue,
      next: null
    }, bi === null ? Or.memoizedState = bi = e : bi = bi.next = e
  }
  return bi
}

function W1(e, t) {
  return typeof t == "function" ? t(e) : t
}

function Y4(e) {
  var t = ka(),
    n = t.queue;
  if (n === null) throw Error(Ke(311));
  n.lastRenderedReducer = e;
  var r = ui,
    i = r.baseQueue,
    s = n.pending;
  if (s !== null) {
    if (i !== null) {
      var o = i.next;
      i.next = s.next, s.next = o
    }
    r.baseQueue = i = s, n.pending = null
  }
  if (i !== null) {
    s = i.next, r = r.baseState;
    var a = o = null,
      c = null,
      l = s;
    do {
      var u = l.lane;
      if ((Jf & u) === u) c !== null && (c = c.next = {
        lane: 0,
        action: l.action,
        hasEagerState: l.hasEagerState,
        eagerState: l.eagerState,
        next: null
      }), r = l.hasEagerState ? l.eagerState : e(r, l.action);
      else {
        var f = {
          lane: u,
          action: l.action,
          hasEagerState: l.hasEagerState,
          eagerState: l.eagerState,
          next: null
        };
        c === null ? (a = c = f, o = r) : c = c.next = f, Or.lanes |= u, Xf |= u
      }
      l = l.next
    } while (l !== null && l !== s);
    c === null ? o = r : c.next = a, xc(r, t.memoizedState) || (no = !0), t.memoizedState = r, t.baseState = o, t.baseQueue = c, n.lastRenderedState = r
  }
  if (e = n.interleaved, e !== null) {
    i = e;
    do s = i.lane, Or.lanes |= s, Xf |= s, i = i.next; while (i !== e)
  } else i === null && (n.lanes = 0);
  return [t.memoizedState, n.dispatch]
}

function J4(e) {
  var t = ka(),
    n = t.queue;
  if (n === null) throw Error(Ke(311));
  n.lastRenderedReducer = e;
  var r = n.dispatch,
    i = n.pending,
    s = t.memoizedState;
  if (i !== null) {
    n.pending = null;
    var o = i = i.next;
    do s = e(s, o.action), o = o.next; while (o !== i);
    xc(s, t.memoizedState) || (no = !0), t.memoizedState = s, t.baseQueue === null && (t.baseState = s), n.lastRenderedState = s
  }
  return [s, r]
}

function Dj() {}

function Nj(e, t) {
  var n = Or,
    r = ka(),
    i = t(),
    s = !xc(r.memoizedState, i);
  if (s && (r.memoizedState = i, no = !0), r = r.queue, Y9(Lj.bind(null, n, r, e), [e]), r.getSnapshot !== t || s || bi !== null && bi.memoizedState.tag & 1) {
    if (n.flags |= 2048, q1(9, $j.bind(null, n, r, i, t), void 0, null), Ci === null) throw Error(Ke(349));
    Jf & 30 || Mj(n, t, i)
  }
  return i
}

function Mj(e, t, n) {
  e.flags |= 16384, e = {
    getSnapshot: t,
    value: n
  }, t = Or.updateQueue, t === null ? (t = {
    lastEffect: null,
    stores: null
  }, Or.updateQueue = t, t.stores = [e]) : (n = t.stores, n === null ? t.stores = [e] : n.push(e))
}

function $j(e, t, n, r) {
  t.value = n, t.getSnapshot = r, Bj(t) && Fj(e)
}

function Lj(e, t, n) {
  return n(function () {
    Bj(t) && Fj(e)
  })
}

function Bj(e) {
  var t = e.getSnapshot;
  e = e.value;
  try {
    var n = t();
    return !xc(e, n)
  } catch {
    return !0
  }
}

function Fj(e) {
  var t = ou(e, 1);
  t !== null && yc(t, e, 1, -1)
}

function EO(e) {
  var t = jc();
  return typeof e == "function" && (e = e()), t.memoizedState = t.baseState = e, e = {
    pending: null,
    interleaved: null,
    lanes: 0,
    dispatch: null,
    lastRenderedReducer: W1,
    lastRenderedState: e
  }, t.queue = e, e = e.dispatch = eae.bind(null, Or, e), [t.memoizedState, e]
}

function q1(e, t, n, r) {
  return e = {
    tag: e,
    create: t,
    destroy: n,
    deps: r,
    next: null
  }, t = Or.updateQueue, t === null ? (t = {
    lastEffect: null,
    stores: null
  }, Or.updateQueue = t, t.lastEffect = e.next = e) : (n = t.lastEffect, n === null ? t.lastEffect = e.next = e : (r = n.next, n.next = e, e.next = r, t.lastEffect = e)), e
}

function jj() {
  return ka().memoizedState
}

function nw(e, t, n, r) {
  var i = jc();
  Or.flags |= e, i.memoizedState = q1(1 | t, n, void 0, r === void 0 ? null : r)
}

function Dx(e, t, n, r) {
  var i = ka();
  r = r === void 0 ? null : r;
  var s = void 0;
  if (ui !== null) {
    var o = ui.memoizedState;
    if (s = o.destroy, r !== null && G9(r, o.deps)) {
      i.memoizedState = q1(t, n, s, r);
      return
    }
  }
  Or.flags |= e, i.memoizedState = q1(1 | t, n, s, r)
}

function SO(e, t) {
  return nw(8390656, 8, e, t)
}

function Y9(e, t) {
  return Dx(2048, 8, e, t)
}

function Uj(e, t) {
  return Dx(4, 2, e, t)
}

function zj(e, t) {
  return Dx(4, 4, e, t)
}

function Hj(e, t) {
  if (typeof t == "function") return e = e(), t(e),
    function () {
      t(null)
    };
  if (t != null) return e = e(), t.current = e,
    function () {
      t.current = null
    }
}

function Vj(e, t, n) {
  return n = n != null ? n.concat([e]) : null, Dx(4, 4, Hj.bind(null, t, e), n)
}

function J9() {}

function Wj(e, t) {
  var n = ka();
  t = t === void 0 ? null : t;
  var r = n.memoizedState;
  return r !== null && t !== null && G9(t, r[1]) ? r[0] : (n.memoizedState = [e, t], e)
}

function qj(e, t) {
  var n = ka();
  t = t === void 0 ? null : t;
  var r = n.memoizedState;
  return r !== null && t !== null && G9(t, r[1]) ? r[0] : (e = e(), n.memoizedState = [e, t], e)
}

function Gj(e, t, n) {
  return Jf & 21 ? (xc(n, t) || (n = YF(), Or.lanes |= n, Xf |= n, e.baseState = !0), t) : (e.baseState && (e.baseState = !1, no = !0), e.memoizedState = n)
}

function Xoe(e, t) {
  var n = qn;
  qn = n !== 0 && 4 > n ? n : 4, e(!0);
  var r = Q4.transition;
  Q4.transition = {};
  try {
    e(!1), t()
  } finally {
    qn = n, Q4.transition = r
  }
}

function Kj() {
  return ka().memoizedState
}

function Zoe(e, t, n) {
  var r = gd(e);
  if (n = {
      lane: r,
      action: n,
      hasEagerState: !1,
      eagerState: null,
      next: null
    }, Qj(e)) Yj(t, n);
  else if (n = Tj(e, t, n, r), n !== null) {
    var i = Ts();
    yc(n, e, r, i), Jj(n, t, r)
  }
}

function eae(e, t, n) {
  var r = gd(e),
    i = {
      lane: r,
      action: n,
      hasEagerState: !1,
      eagerState: null,
      next: null
    };
  if (Qj(e)) Yj(t, i);
  else {
    var s = e.alternate;
    if (e.lanes === 0 && (s === null || s.lanes === 0) && (s = t.lastRenderedReducer, s !== null)) try {
      var o = t.lastRenderedState,
        a = s(o, n);
      if (i.hasEagerState = !0, i.eagerState = a, xc(a, o)) {
        var c = t.interleaved;
        c === null ? (i.next = i, z9(t)) : (i.next = c.next, c.next = i), t.interleaved = i;
        return
      }
    } catch {} finally {}
    n = Tj(e, t, i, r), n !== null && (i = Ts(), yc(n, e, r, i), Jj(n, t, r))
  }
}

function Qj(e) {
  var t = e.alternate;
  return e === Or || t !== null && t === Or
}

function Yj(e, t) {
  f1 = Qw = !0;
  var n = e.pending;
  n === null ? t.next = t : (t.next = n.next, n.next = t), e.pending = t
}

function Jj(e, t, n) {
  if (n & 4194240) {
    var r = t.lanes;
    r &= e.pendingLanes, n |= r, t.lanes = n, _9(e, n)
  }
}
var Yw = {
    readContext: Ta,
    useCallback: Yi,
    useContext: Yi,
    useEffect: Yi,
    useImperativeHandle: Yi,
    useInsertionEffect: Yi,
    useLayoutEffect: Yi,
    useMemo: Yi,
    useReducer: Yi,
    useRef: Yi,
    useState: Yi,
    useDebugValue: Yi,
    useDeferredValue: Yi,
    useTransition: Yi,
    useMutableSource: Yi,
    useSyncExternalStore: Yi,
    useId: Yi,
    unstable_isNewReconciler: !1
  },
  tae = {
    readContext: Ta,
    useCallback: function (e, t) {
      return jc().memoizedState = [e, t === void 0 ? null : t], e
    },
    useContext: Ta,
    useEffect: SO,
    useImperativeHandle: function (e, t, n) {
      return n = n != null ? n.concat([e]) : null, nw(4194308, 4, Hj.bind(null, t, e), n)
    },
    useLayoutEffect: function (e, t) {
      return nw(4194308, 4, e, t)
    },
    useInsertionEffect: function (e, t) {
      return nw(4, 2, e, t)
    },
    useMemo: function (e, t) {
      var n = jc();
      return t = t === void 0 ? null : t, e = e(), n.memoizedState = [e, t], e
    },
    useReducer: function (e, t, n) {
      var r = jc();
      return t = n !== void 0 ? n(t) : t, r.memoizedState = r.baseState = t, e = {
        pending: null,
        interleaved: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: e,
        lastRenderedState: t
      }, r.queue = e, e = e.dispatch = Zoe.bind(null, Or, e), [r.memoizedState, e]
    },
    useRef: function (e) {
      var t = jc();
      return e = {
        current: e
      }, t.memoizedState = e
    },
    useState: EO,
    useDebugValue: J9,
    useDeferredValue: function (e) {
      return jc().memoizedState = e
    },
    useTransition: function () {
      var e = EO(!1),
        t = e[0];
      return e = Xoe.bind(null, e[1]), jc().memoizedState = e, [t, e]
    },
    useMutableSource: function () {},
    useSyncExternalStore: function (e, t, n) {
      var r = Or,
        i = jc();
      if (Er) {
        if (n === void 0) throw Error(Ke(407));
        n = n()
      } else {
        if (n = t(), Ci === null) throw Error(Ke(349));
        Jf & 30 || Mj(r, t, n)
      }
      i.memoizedState = n;
      var s = {
        value: n,
        getSnapshot: t
      };
      return i.queue = s, SO(Lj.bind(null, r, s, e), [e]), r.flags |= 2048, q1(9, $j.bind(null, r, s, n, t), void 0, null), n
    },
    useId: function () {
      var e = jc(),
        t = Ci.identifierPrefix;
      if (Er) {
        var n = eu,
          r = Zl;
        n = (r & ~(1 << 32 - gc(r) - 1)).toString(32) + n, t = ":" + t + "R" + n, n = V1++, 0 < n && (t += "H" + n.toString(32)), t += ":"
      } else n = Joe++, t = ":" + t + "r" + n.toString(32) + ":";
      return e.memoizedState = t
    },
    unstable_isNewReconciler: !1
  },
  nae = {
    readContext: Ta,
    useCallback: Wj,
    useContext: Ta,
    useEffect: Y9,
    useImperativeHandle: Vj,
    useInsertionEffect: Uj,
    useLayoutEffect: zj,
    useMemo: qj,
    useReducer: Y4,
    useRef: jj,
    useState: function () {
      return Y4(W1)
    },
    useDebugValue: J9,
    useDeferredValue: function (e) {
      var t = ka();
      return Gj(t, ui.memoizedState, e)
    },
    useTransition: function () {
      var e = Y4(W1)[0],
        t = ka().memoizedState;
      return [e, t]
    },
    useMutableSource: Dj,
    useSyncExternalStore: Nj,
    useId: Kj,
    unstable_isNewReconciler: !1
  },
  rae = {
    readContext: Ta,
    useCallback: Wj,
    useContext: Ta,
    useEffect: Y9,
    useImperativeHandle: Vj,
    useInsertionEffect: Uj,
    useLayoutEffect: zj,
    useMemo: qj,
    useReducer: J4,
    useRef: jj,
    useState: function () {
      return J4(W1)
    },
    useDebugValue: J9,
    useDeferredValue: function (e) {
      var t = ka();
      return ui === null ? t.memoizedState = e : Gj(t, ui.memoizedState, e)
    },
    useTransition: function () {
      var e = J4(W1)[0],
        t = ka().memoizedState;
      return [e, t]
    },
    useMutableSource: Dj,
    useSyncExternalStore: Nj,
    useId: Kj,
    unstable_isNewReconciler: !1
  };

function Cp(e, t) {
  try {
    var n = "",
      r = t;
    do n += Rse(r), r = r.return; while (r);
    var i = n
  } catch (s) {
    i = `
Error generating stack: ` + s.message + `
` + s.stack
  }
  return {
    value: e,
    source: t,
    stack: i,
    digest: null
  }
}

function X4(e, t, n) {
  return {
    value: e,
    source: null,
    stack: n ?? null,
    digest: t ?? null
  }
}

function SC(e, t) {
  try {
    console.error(t.value)
  } catch (n) {
    setTimeout(function () {
      throw n
    })
  }
}
var iae = typeof WeakMap == "function" ? WeakMap : Map;

function Xj(e, t, n) {
  n = nu(-1, n), n.tag = 3, n.payload = {
    element: null
  };
  var r = t.value;
  return n.callback = function () {
    Xw || (Xw = !0, DC = r), SC(e, t)
  }, n
}

function Zj(e, t, n) {
  n = nu(-1, n), n.tag = 3;
  var r = e.type.getDerivedStateFromError;
  if (typeof r == "function") {
    var i = t.value;
    n.payload = function () {
      return r(i)
    }, n.callback = function () {
      SC(e, t)
    }
  }
  var s = e.stateNode;
  return s !== null && typeof s.componentDidCatch == "function" && (n.callback = function () {
    SC(e, t), typeof r != "function" && (md === null ? md = new Set([this]) : md.add(this));
    var o = t.stack;
    this.componentDidCatch(t.value, {
      componentStack: o !== null ? o : ""
    })
  }), n
}

function CO(e, t, n) {
  var r = e.pingCache;
  if (r === null) {
    r = e.pingCache = new iae;
    var i = new Set;
    r.set(t, i)
  } else i = r.get(t), i === void 0 && (i = new Set, r.set(t, i));
  i.has(n) || (i.add(n), e = vae.bind(null, e, t, n), t.then(e, e))
}

function AO(e) {
  do {
    var t;
    if ((t = e.tag === 13) && (t = e.memoizedState, t = t !== null ? t.dehydrated !== null : !0), t) return e;
    e = e.return
  } while (e !== null);
  return null
}

function TO(e, t, n, r, i) {
  return e.mode & 1 ? (e.flags |= 65536, e.lanes = i, e) : (e === t ? e.flags |= 65536 : (e.flags |= 128, n.flags |= 131072, n.flags &= -52805, n.tag === 1 && (n.alternate === null ? n.tag = 17 : (t = nu(-1, 1), t.tag = 2, pd(n, t, 1))), n.lanes |= 1), e)
}
var sae = pu.ReactCurrentOwner,
  no = !1;

function xs(e, t, n, r) {
  t.child = e === null ? Rj(t, null, n, r) : Ep(t, e.child, n, r)
}

function kO(e, t, n, r, i) {
  n = n.render;
  var s = t.ref;
  return op(t, i), r = K9(e, t, n, r, s, i), n = Q9(), e !== null && !no ? (t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~i, au(e, t, i)) : (Er && n && $9(t), t.flags |= 1, xs(e, t, r, i), t.child)
}

function _O(e, t, n, r, i) {
  if (e === null) {
    var s = n.type;
    return typeof s == "function" && !sT(s) && s.defaultProps === void 0 && n.compare === null && n.defaultProps === void 0 ? (t.tag = 15, t.type = s, eU(e, t, s, r, i)) : (e = ow(n.type, null, r, t, t.mode, i), e.ref = t.ref, e.return = t, t.child = e)
  }
  if (s = e.child, !(e.lanes & i)) {
    var o = s.memoizedProps;
    if (n = n.compare, n = n !== null ? n : B1, n(o, r) && e.ref === t.ref) return au(e, t, i)
  }
  return t.flags |= 1, e = yd(s, r), e.ref = t.ref, e.return = t, t.child = e
}

function eU(e, t, n, r, i) {
  if (e !== null) {
    var s = e.memoizedProps;
    if (B1(s, r) && e.ref === t.ref)
      if (no = !1, t.pendingProps = r = s, (e.lanes & i) !== 0) e.flags & 131072 && (no = !0);
      else return t.lanes = e.lanes, au(e, t, i)
  }
  return CC(e, t, n, r, i)
}

function tU(e, t, n) {
  var r = t.pendingProps,
    i = r.children,
    s = e !== null ? e.memoizedState : null;
  if (r.mode === "hidden")
    if (!(t.mode & 1)) t.memoizedState = {
      baseLanes: 0,
      cachePool: null,
      transitions: null
    }, cr(U0, Io), Io |= n;
    else {
      if (!(n & 1073741824)) return e = s !== null ? s.baseLanes | n : n, t.lanes = t.childLanes = 1073741824, t.memoizedState = {
        baseLanes: e,
        cachePool: null,
        transitions: null
      }, t.updateQueue = null, cr(U0, Io), Io |= e, null;
      t.memoizedState = {
        baseLanes: 0,
        cachePool: null,
        transitions: null
      }, r = s !== null ? s.baseLanes : n, cr(U0, Io), Io |= r
    }
  else s !== null ? (r = s.baseLanes | n, t.memoizedState = null) : r = n, cr(U0, Io), Io |= r;
  return xs(e, t, i, n), t.child
}

function nU(e, t) {
  var n = t.ref;
  (e === null && n !== null || e !== null && e.ref !== n) && (t.flags |= 512, t.flags |= 2097152)
}

function CC(e, t, n, r, i) {
  var s = so(n) ? Qf : ls.current;
  return s = wp(t, s), op(t, i), n = K9(e, t, n, r, s, i), r = Q9(), e !== null && !no ? (t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~i, au(e, t, i)) : (Er && r && $9(t), t.flags |= 1, xs(e, t, n, i), t.child)
}

function IO(e, t, n, r, i) {
  if (so(n)) {
    var s = !0;
    zw(t)
  } else s = !1;
  if (op(t, i), t.stateNode === null) rw(e, t), Ij(t, n, r), EC(t, n, r, i), r = !0;
  else if (e === null) {
    var o = t.stateNode,
      a = t.memoizedProps;
    o.props = a;
    var c = o.context,
      l = n.contextType;
    typeof l == "object" && l !== null ? l = Ta(l) : (l = so(n) ? Qf : ls.current, l = wp(t, l));
    var u = n.getDerivedStateFromProps,
      f = typeof u == "function" || typeof o.getSnapshotBeforeUpdate == "function";
    f || typeof o.UNSAFE_componentWillReceiveProps != "function" && typeof o.componentWillReceiveProps != "function" || (a !== r || c !== l) && wO(t, o, r, l), Xu = !1;
    var h = t.memoizedState;
    o.state = h, Gw(t, r, o, i), c = t.memoizedState, a !== r || h !== c || io.current || Xu ? (typeof u == "function" && (xC(t, n, u, r), c = t.memoizedState), (a = Xu || bO(t, n, a, r, h, c, l)) ? (f || typeof o.UNSAFE_componentWillMount != "function" && typeof o.componentWillMount != "function" || (typeof o.componentWillMount == "function" && o.componentWillMount(), typeof o.UNSAFE_componentWillMount == "function" && o.UNSAFE_componentWillMount()), typeof o.componentDidMount == "function" && (t.flags |= 4194308)) : (typeof o.componentDidMount == "function" && (t.flags |= 4194308), t.memoizedProps = r, t.memoizedState = c), o.props = r, o.state = c, o.context = l, r = a) : (typeof o.componentDidMount == "function" && (t.flags |= 4194308), r = !1)
  } else {
    o = t.stateNode, kj(e, t), a = t.memoizedProps, l = t.type === t.elementType ? a : nc(t.type, a), o.props = l, f = t.pendingProps, h = o.context, c = n.contextType, typeof c == "object" && c !== null ? c = Ta(c) : (c = so(n) ? Qf : ls.current, c = wp(t, c));
    var g = n.getDerivedStateFromProps;
    (u = typeof g == "function" || typeof o.getSnapshotBeforeUpdate == "function") || typeof o.UNSAFE_componentWillReceiveProps != "function" && typeof o.componentWillReceiveProps != "function" || (a !== f || h !== c) && wO(t, o, r, c), Xu = !1, h = t.memoizedState, o.state = h, Gw(t, r, o, i);
    var y = t.memoizedState;
    a !== f || h !== y || io.current || Xu ? (typeof g == "function" && (xC(t, n, g, r), y = t.memoizedState), (l = Xu || bO(t, n, l, r, h, y, c) || !1) ? (u || typeof o.UNSAFE_componentWillUpdate != "function" && typeof o.componentWillUpdate != "function" || (typeof o.componentWillUpdate == "function" && o.componentWillUpdate(r, y, c), typeof o.UNSAFE_componentWillUpdate == "function" && o.UNSAFE_componentWillUpdate(r, y, c)), typeof o.componentDidUpdate == "function" && (t.flags |= 4), typeof o.getSnapshotBeforeUpdate == "function" && (t.flags |= 1024)) : (typeof o.componentDidUpdate != "function" || a === e.memoizedProps && h === e.memoizedState || (t.flags |= 4), typeof o.getSnapshotBeforeUpdate != "function" || a === e.memoizedProps && h === e.memoizedState || (t.flags |= 1024), t.memoizedProps = r, t.memoizedState = y), o.props = r, o.state = y, o.context = c, r = l) : (typeof o.componentDidUpdate != "function" || a === e.memoizedProps && h === e.memoizedState || (t.flags |= 4), typeof o.getSnapshotBeforeUpdate != "function" || a === e.memoizedProps && h === e.memoizedState || (t.flags |= 1024), r = !1)
  }
  return AC(e, t, n, r, s, i)
}

function AC(e, t, n, r, i, s) {
  nU(e, t);
  var o = (t.flags & 128) !== 0;
  if (!r && !o) return i && pO(t, n, !1), au(e, t, s);
  r = t.stateNode, sae.current = t;
  var a = o && typeof n.getDerivedStateFromError != "function" ? null : r.render();
  return t.flags |= 1, e !== null && o ? (t.child = Ep(t, e.child, null, s), t.child = Ep(t, null, a, s)) : xs(e, t, a, s), t.memoizedState = r.state, i && pO(t, n, !0), t.child
}

function rU(e) {
  var t = e.stateNode;
  t.pendingContext ? hO(e, t.pendingContext, t.pendingContext !== t.context) : t.context && hO(e, t.context, !1), V9(e, t.containerInfo)
}

function PO(e, t, n, r, i) {
  return xp(), B9(i), t.flags |= 256, xs(e, t, n, r), t.child
}
var TC = {
  dehydrated: null,
  treeContext: null,
  retryLane: 0
};

function kC(e) {
  return {
    baseLanes: e,
    cachePool: null,
    transitions: null
  }
}

function iU(e, t, n) {
  var r = t.pendingProps,
    i = Pr.current,
    s = !1,
    o = (t.flags & 128) !== 0,
    a;
  if ((a = o) || (a = e !== null && e.memoizedState === null ? !1 : (i & 2) !== 0), a ? (s = !0, t.flags &= -129) : (e === null || e.memoizedState !== null) && (i |= 1), cr(Pr, i & 1), e === null) return bC(t), e = t.memoizedState, e !== null && (e = e.dehydrated, e !== null) ? (t.mode & 1 ? e.data === "$!" ? t.lanes = 8 : t.lanes = 1073741824 : t.lanes = 1, null) : (o = r.children, e = r.fallback, s ? (r = t.mode, s = t.child, o = {
    mode: "hidden",
    children: o
  }, !(r & 1) && s !== null ? (s.childLanes = 0, s.pendingProps = o) : s = $x(o, r, 0, null), e = Uf(e, r, n, null), s.return = t, e.return = t, s.sibling = e, t.child = s, t.child.memoizedState = kC(n), t.memoizedState = TC, e) : X9(t, o));
  if (i = e.memoizedState, i !== null && (a = i.dehydrated, a !== null)) return oae(e, t, o, r, a, i, n);
  if (s) {
    s = r.fallback, o = t.mode, i = e.child, a = i.sibling;
    var c = {
      mode: "hidden",
      children: r.children
    };
    return !(o & 1) && t.child !== i ? (r = t.child, r.childLanes = 0, r.pendingProps = c, t.deletions = null) : (r = yd(i, c), r.subtreeFlags = i.subtreeFlags & 14680064), a !== null ? s = yd(a, s) : (s = Uf(s, o, n, null), s.flags |= 2), s.return = t, r.return = t, r.sibling = s, t.child = r, r = s, s = t.child, o = e.child.memoizedState, o = o === null ? kC(n) : {
      baseLanes: o.baseLanes | n,
      cachePool: null,
      transitions: o.transitions
    }, s.memoizedState = o, s.childLanes = e.childLanes & ~n, t.memoizedState = TC, r
  }
  return s = e.child, e = s.sibling, r = yd(s, {
    mode: "visible",
    children: r.children
  }), !(t.mode & 1) && (r.lanes = n), r.return = t, r.sibling = null, e !== null && (n = t.deletions, n === null ? (t.deletions = [e], t.flags |= 16) : n.push(e)), t.child = r, t.memoizedState = null, r
}

function X9(e, t) {
  return t = $x({
    mode: "visible",
    children: t
  }, e.mode, 0, null), t.return = e, e.child = t
}

function Xv(e, t, n, r) {
  return r !== null && B9(r), Ep(t, e.child, null, n), e = X9(t, t.pendingProps.children), e.flags |= 2, t.memoizedState = null, e
}

function oae(e, t, n, r, i, s, o) {
  if (n) return t.flags & 256 ? (t.flags &= -257, r = X4(Error(Ke(422))), Xv(e, t, o, r)) : t.memoizedState !== null ? (t.child = e.child, t.flags |= 128, null) : (s = r.fallback, i = t.mode, r = $x({
    mode: "visible",
    children: r.children
  }, i, 0, null), s = Uf(s, i, o, null), s.flags |= 2, r.return = t, s.return = t, r.sibling = s, t.child = r, t.mode & 1 && Ep(t, e.child, null, o), t.child.memoizedState = kC(o), t.memoizedState = TC, s);
  if (!(t.mode & 1)) return Xv(e, t, o, null);
  if (i.data === "$!") {
    if (r = i.nextSibling && i.nextSibling.dataset, r) var a = r.dgst;
    return r = a, s = Error(Ke(419)), r = X4(s, r, void 0), Xv(e, t, o, r)
  }
  if (a = (o & e.childLanes) !== 0, no || a) {
    if (r = Ci, r !== null) {
      switch (o & -o) {
        case 4:
          i = 2;
          break;
        case 16:
          i = 8;
          break;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          i = 32;
          break;
        case 536870912:
          i = 268435456;
          break;
        default:
          i = 0
      }
      i = i & (r.suspendedLanes | o) ? 0 : i, i !== 0 && i !== s.retryLane && (s.retryLane = i, ou(e, i), yc(r, e, i, -1))
    }
    return iT(), r = X4(Error(Ke(421))), Xv(e, t, o, r)
  }
  return i.data === "$?" ? (t.flags |= 128, t.child = e.child, t = bae.bind(null, e), i._reactRetry = t, null) : (e = s.treeContext, Lo = hd(i.nextSibling), Fo = t, Er = !0, ac = null, e !== null && (ya[va++] = Zl, ya[va++] = eu, ya[va++] = Yf, Zl = e.id, eu = e.overflow, Yf = t), t = X9(t, r.children), t.flags |= 4096, t)
}

function RO(e, t, n) {
  e.lanes |= t;
  var r = e.alternate;
  r !== null && (r.lanes |= t), wC(e.return, t, n)
}

function Z4(e, t, n, r, i) {
  var s = e.memoizedState;
  s === null ? e.memoizedState = {
    isBackwards: t,
    rendering: null,
    renderingStartTime: 0,
    last: r,
    tail: n,
    tailMode: i
  } : (s.isBackwards = t, s.rendering = null, s.renderingStartTime = 0, s.last = r, s.tail = n, s.tailMode = i)
}

function sU(e, t, n) {
  var r = t.pendingProps,
    i = r.revealOrder,
    s = r.tail;
  if (xs(e, t, r.children, n), r = Pr.current, r & 2) r = r & 1 | 2, t.flags |= 128;
  else {
    if (e !== null && e.flags & 128) e: for (e = t.child; e !== null;) {
      if (e.tag === 13) e.memoizedState !== null && RO(e, n, t);
      else if (e.tag === 19) RO(e, n, t);
      else if (e.child !== null) {
        e.child.return = e, e = e.child;
        continue
      }
      if (e === t) break e;
      for (; e.sibling === null;) {
        if (e.return === null || e.return === t) break e;
        e = e.return
      }
      e.sibling.return = e.return, e = e.sibling
    }
    r &= 1
  }
  if (cr(Pr, r), !(t.mode & 1)) t.memoizedState = null;
  else switch (i) {
    case "forwards":
      for (n = t.child, i = null; n !== null;) e = n.alternate, e !== null && Kw(e) === null && (i = n), n = n.sibling;
      n = i, n === null ? (i = t.child, t.child = null) : (i = n.sibling, n.sibling = null), Z4(t, !1, i, n, s);
      break;
    case "backwards":
      for (n = null, i = t.child, t.child = null; i !== null;) {
        if (e = i.alternate, e !== null && Kw(e) === null) {
          t.child = i;
          break
        }
        e = i.sibling, i.sibling = n, n = i, i = e
      }
      Z4(t, !0, n, null, s);
      break;
    case "together":
      Z4(t, !1, null, null, void 0);
      break;
    default:
      t.memoizedState = null
  }
  return t.child
}

function rw(e, t) {
  !(t.mode & 1) && e !== null && (e.alternate = null, t.alternate = null, t.flags |= 2)
}

function au(e, t, n) {
  if (e !== null && (t.dependencies = e.dependencies), Xf |= t.lanes, !(n & t.childLanes)) return null;
  if (e !== null && t.child !== e.child) throw Error(Ke(153));
  if (t.child !== null) {
    for (e = t.child, n = yd(e, e.pendingProps), t.child = n, n.return = t; e.sibling !== null;) e = e.sibling, n = n.sibling = yd(e, e.pendingProps), n.return = t;
    n.sibling = null
  }
  return t.child
}

function aae(e, t, n) {
  switch (t.tag) {
    case 3:
      rU(t), xp();
      break;
    case 5:
      Oj(t);
      break;
    case 1:
      so(t.type) && zw(t);
      break;
    case 4:
      V9(t, t.stateNode.containerInfo);
      break;
    case 10:
      var r = t.type._context,
        i = t.memoizedProps.value;
      cr(Ww, r._currentValue), r._currentValue = i;
      break;
    case 13:
      if (r = t.memoizedState, r !== null) return r.dehydrated !== null ? (cr(Pr, Pr.current & 1), t.flags |= 128, null) : n & t.child.childLanes ? iU(e, t, n) : (cr(Pr, Pr.current & 1), e = au(e, t, n), e !== null ? e.sibling : null);
      cr(Pr, Pr.current & 1);
      break;
    case 19:
      if (r = (n & t.childLanes) !== 0, e.flags & 128) {
        if (r) return sU(e, t, n);
        t.flags |= 128
      }
      if (i = t.memoizedState, i !== null && (i.rendering = null, i.tail = null, i.lastEffect = null), cr(Pr, Pr.current), r) break;
      return null;
    case 22:
    case 23:
      return t.lanes = 0, tU(e, t, n)
  }
  return au(e, t, n)
}
var oU, _C, aU, cU;
oU = function (e, t) {
  for (var n = t.child; n !== null;) {
    if (n.tag === 5 || n.tag === 6) e.appendChild(n.stateNode);
    else if (n.tag !== 4 && n.child !== null) {
      n.child.return = n, n = n.child;
      continue
    }
    if (n === t) break;
    for (; n.sibling === null;) {
      if (n.return === null || n.return === t) return;
      n = n.return
    }
    n.sibling.return = n.return, n = n.sibling
  }
};
_C = function () {};
aU = function (e, t, n, r) {
  var i = e.memoizedProps;
  if (i !== r) {
    e = t.stateNode, If(rl.current);
    var s = null;
    switch (n) {
      case "input":
        i = Y8(e, i), r = Y8(e, r), s = [];
        break;
      case "select":
        i = Dr({}, i, {
          value: void 0
        }), r = Dr({}, r, {
          value: void 0
        }), s = [];
        break;
      case "textarea":
        i = Z8(e, i), r = Z8(e, r), s = [];
        break;
      default:
        typeof i.onClick != "function" && typeof r.onClick == "function" && (e.onclick = jw)
    }
    tC(n, r);
    var o;
    n = null;
    for (l in i)
      if (!r.hasOwnProperty(l) && i.hasOwnProperty(l) && i[l] != null)
        if (l === "style") {
          var a = i[l];
          for (o in a) a.hasOwnProperty(o) && (n || (n = {}), n[o] = "")
        } else l !== "dangerouslySetInnerHTML" && l !== "children" && l !== "suppressContentEditableWarning" && l !== "suppressHydrationWarning" && l !== "autoFocus" && (R1.hasOwnProperty(l) ? s || (s = []) : (s = s || []).push(l, null));
    for (l in r) {
      var c = r[l];
      if (a = i != null ? i[l] : void 0, r.hasOwnProperty(l) && c !== a && (c != null || a != null))
        if (l === "style")
          if (a) {
            for (o in a) !a.hasOwnProperty(o) || c && c.hasOwnProperty(o) || (n || (n = {}), n[o] = "");
            for (o in c) c.hasOwnProperty(o) && a[o] !== c[o] && (n || (n = {}), n[o] = c[o])
          } else n || (s || (s = []), s.push(l, n)), n = c;
      else l === "dangerouslySetInnerHTML" ? (c = c ? c.__html : void 0, a = a ? a.__html : void 0, c != null && a !== c && (s = s || []).push(l, c)) : l === "children" ? typeof c != "string" && typeof c != "number" || (s = s || []).push(l, "" + c) : l !== "suppressContentEditableWarning" && l !== "suppressHydrationWarning" && (R1.hasOwnProperty(l) ? (c != null && l === "onScroll" && mr("scroll", e), s || a === c || (s = [])) : (s = s || []).push(l, c))
    }
    n && (s = s || []).push("style", n);
    var l = s;
    (t.updateQueue = l) && (t.flags |= 4)
  }
};
cU = function (e, t, n, r) {
  n !== r && (t.flags |= 4)
};

function bg(e, t) {
  if (!Er) switch (e.tailMode) {
    case "hidden":
      t = e.tail;
      for (var n = null; t !== null;) t.alternate !== null && (n = t), t = t.sibling;
      n === null ? e.tail = null : n.sibling = null;
      break;
    case "collapsed":
      n = e.tail;
      for (var r = null; n !== null;) n.alternate !== null && (r = n), n = n.sibling;
      r === null ? t || e.tail === null ? e.tail = null : e.tail.sibling = null : r.sibling = null
  }
}

function Ji(e) {
  var t = e.alternate !== null && e.alternate.child === e.child,
    n = 0,
    r = 0;
  if (t)
    for (var i = e.child; i !== null;) n |= i.lanes | i.childLanes, r |= i.subtreeFlags & 14680064, r |= i.flags & 14680064, i.return = e, i = i.sibling;
  else
    for (i = e.child; i !== null;) n |= i.lanes | i.childLanes, r |= i.subtreeFlags, r |= i.flags, i.return = e, i = i.sibling;
  return e.subtreeFlags |= r, e.childLanes = n, t
}

function cae(e, t, n) {
  var r = t.pendingProps;
  switch (L9(t), t.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return Ji(t), null;
    case 1:
      return so(t.type) && Uw(), Ji(t), null;
    case 3:
      return r = t.stateNode, Sp(), yr(io), yr(ls), q9(), r.pendingContext && (r.context = r.pendingContext, r.pendingContext = null), (e === null || e.child === null) && (Yv(t) ? t.flags |= 4 : e === null || e.memoizedState.isDehydrated && !(t.flags & 256) || (t.flags |= 1024, ac !== null && ($C(ac), ac = null))), _C(e, t), Ji(t), null;
    case 5:
      W9(t);
      var i = If(H1.current);
      if (n = t.type, e !== null && t.stateNode != null) aU(e, t, n, r, i), e.ref !== t.ref && (t.flags |= 512, t.flags |= 2097152);
      else {
        if (!r) {
          if (t.stateNode === null) throw Error(Ke(166));
          return Ji(t), null
        }
        if (e = If(rl.current), Yv(t)) {
          r = t.stateNode, n = t.type;
          var s = t.memoizedProps;
          switch (r[Gc] = t, r[U1] = s, e = (t.mode & 1) !== 0, n) {
            case "dialog":
              mr("cancel", r), mr("close", r);
              break;
            case "iframe":
            case "object":
            case "embed":
              mr("load", r);
              break;
            case "video":
            case "audio":
              for (i = 0; i < t1.length; i++) mr(t1[i], r);
              break;
            case "source":
              mr("error", r);
              break;
            case "img":
            case "image":
            case "link":
              mr("error", r), mr("load", r);
              break;
            case "details":
              mr("toggle", r);
              break;
            case "input":
              jR(r, s), mr("invalid", r);
              break;
            case "select":
              r._wrapperState = {
                wasMultiple: !!s.multiple
              }, mr("invalid", r);
              break;
            case "textarea":
              zR(r, s), mr("invalid", r)
          }
          tC(n, s), i = null;
          for (var o in s)
            if (s.hasOwnProperty(o)) {
              var a = s[o];
              o === "children" ? typeof a == "string" ? r.textContent !== a && (s.suppressHydrationWarning !== !0 && Qv(r.textContent, a, e), i = ["children", a]) : typeof a == "number" && r.textContent !== "" + a && (s.suppressHydrationWarning !== !0 && Qv(r.textContent, a, e), i = ["children", "" + a]) : R1.hasOwnProperty(o) && a != null && o === "onScroll" && mr("scroll", r)
            } switch (n) {
            case "input":
              Uv(r), UR(r, s, !0);
              break;
            case "textarea":
              Uv(r), HR(r);
              break;
            case "select":
            case "option":
              break;
            default:
              typeof s.onClick == "function" && (r.onclick = jw)
          }
          r = i, t.updateQueue = r, r !== null && (t.flags |= 4)
        } else {
          o = i.nodeType === 9 ? i : i.ownerDocument, e === "http://www.w3.org/1999/xhtml" && (e = MF(n)), e === "http://www.w3.org/1999/xhtml" ? n === "script" ? (e = o.createElement("div"), e.innerHTML = "<script><\/script>", e = e.removeChild(e.firstChild)) : typeof r.is == "string" ? e = o.createElement(n, {
            is: r.is
          }) : (e = o.createElement(n), n === "select" && (o = e, r.multiple ? o.multiple = !0 : r.size && (o.size = r.size))) : e = o.createElementNS(e, n), e[Gc] = t, e[U1] = r, oU(e, t, !1, !1), t.stateNode = e;
          e: {
            switch (o = nC(n, r), n) {
              case "dialog":
                mr("cancel", e), mr("close", e), i = r;
                break;
              case "iframe":
              case "object":
              case "embed":
                mr("load", e), i = r;
                break;
              case "video":
              case "audio":
                for (i = 0; i < t1.length; i++) mr(t1[i], e);
                i = r;
                break;
              case "source":
                mr("error", e), i = r;
                break;
              case "img":
              case "image":
              case "link":
                mr("error", e), mr("load", e), i = r;
                break;
              case "details":
                mr("toggle", e), i = r;
                break;
              case "input":
                jR(e, r), i = Y8(e, r), mr("invalid", e);
                break;
              case "option":
                i = r;
                break;
              case "select":
                e._wrapperState = {
                  wasMultiple: !!r.multiple
                }, i = Dr({}, r, {
                  value: void 0
                }), mr("invalid", e);
                break;
              case "textarea":
                zR(e, r), i = Z8(e, r), mr("invalid", e);
                break;
              default:
                i = r
            }
            tC(n, i),
            a = i;
            for (s in a)
              if (a.hasOwnProperty(s)) {
                var c = a[s];
                s === "style" ? BF(e, c) : s === "dangerouslySetInnerHTML" ? (c = c ? c.__html : void 0, c != null && $F(e, c)) : s === "children" ? typeof c == "string" ? (n !== "textarea" || c !== "") && O1(e, c) : typeof c == "number" && O1(e, "" + c) : s !== "suppressContentEditableWarning" && s !== "suppressHydrationWarning" && s !== "autoFocus" && (R1.hasOwnProperty(s) ? c != null && s === "onScroll" && mr("scroll", e) : c != null && E9(e, s, c, o))
              } switch (n) {
              case "input":
                Uv(e), UR(e, r, !1);
                break;
              case "textarea":
                Uv(e), HR(e);
                break;
              case "option":
                r.value != null && e.setAttribute("value", "" + bd(r.value));
                break;
              case "select":
                e.multiple = !!r.multiple, s = r.value, s != null ? np(e, !!r.multiple, s, !1) : r.defaultValue != null && np(e, !!r.multiple, r.defaultValue, !0);
                break;
              default:
                typeof i.onClick == "function" && (e.onclick = jw)
            }
            switch (n) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                r = !!r.autoFocus;
                break e;
              case "img":
                r = !0;
                break e;
              default:
                r = !1
            }
          }
          r && (t.flags |= 4)
        }
        t.ref !== null && (t.flags |= 512, t.flags |= 2097152)
      }
      return Ji(t), null;
    case 6:
      if (e && t.stateNode != null) cU(e, t, e.memoizedProps, r);
      else {
        if (typeof r != "string" && t.stateNode === null) throw Error(Ke(166));
        if (n = If(H1.current), If(rl.current), Yv(t)) {
          if (r = t.stateNode, n = t.memoizedProps, r[Gc] = t, (s = r.nodeValue !== n) && (e = Fo, e !== null)) switch (e.tag) {
            case 3:
              Qv(r.nodeValue, n, (e.mode & 1) !== 0);
              break;
            case 5:
              e.memoizedProps.suppressHydrationWarning !== !0 && Qv(r.nodeValue, n, (e.mode & 1) !== 0)
          }
          s && (t.flags |= 4)
        } else r = (n.nodeType === 9 ? n : n.ownerDocument).createTextNode(r), r[Gc] = t, t.stateNode = r
      }
      return Ji(t), null;
    case 13:
      if (yr(Pr), r = t.memoizedState, e === null || e.memoizedState !== null && e.memoizedState.dehydrated !== null) {
        if (Er && Lo !== null && t.mode & 1 && !(t.flags & 128)) Aj(), xp(), t.flags |= 98560, s = !1;
        else if (s = Yv(t), r !== null && r.dehydrated !== null) {
          if (e === null) {
            if (!s) throw Error(Ke(318));
            if (s = t.memoizedState, s = s !== null ? s.dehydrated : null, !s) throw Error(Ke(317));
            s[Gc] = t
          } else xp(), !(t.flags & 128) && (t.memoizedState = null), t.flags |= 4;
          Ji(t), s = !1
        } else ac !== null && ($C(ac), ac = null), s = !0;
        if (!s) return t.flags & 65536 ? t : null
      }
      return t.flags & 128 ? (t.lanes = n, t) : (r = r !== null, r !== (e !== null && e.memoizedState !== null) && r && (t.child.flags |= 8192, t.mode & 1 && (e === null || Pr.current & 1 ? fi === 0 && (fi = 3) : iT())), t.updateQueue !== null && (t.flags |= 4), Ji(t), null);
    case 4:
      return Sp(), _C(e, t), e === null && F1(t.stateNode.containerInfo), Ji(t), null;
    case 10:
      return U9(t.type._context), Ji(t), null;
    case 17:
      return so(t.type) && Uw(), Ji(t), null;
    case 19:
      if (yr(Pr), s = t.memoizedState, s === null) return Ji(t), null;
      if (r = (t.flags & 128) !== 0, o = s.rendering, o === null)
        if (r) bg(s, !1);
        else {
          if (fi !== 0 || e !== null && e.flags & 128)
            for (e = t.child; e !== null;) {
              if (o = Kw(e), o !== null) {
                for (t.flags |= 128, bg(s, !1), r = o.updateQueue, r !== null && (t.updateQueue = r, t.flags |= 4), t.subtreeFlags = 0, r = n, n = t.child; n !== null;) s = n, e = r, s.flags &= 14680066, o = s.alternate, o === null ? (s.childLanes = 0, s.lanes = e, s.child = null, s.subtreeFlags = 0, s.memoizedProps = null, s.memoizedState = null, s.updateQueue = null, s.dependencies = null, s.stateNode = null) : (s.childLanes = o.childLanes, s.lanes = o.lanes, s.child = o.child, s.subtreeFlags = 0, s.deletions = null, s.memoizedProps = o.memoizedProps, s.memoizedState = o.memoizedState, s.updateQueue = o.updateQueue, s.type = o.type, e = o.dependencies, s.dependencies = e === null ? null : {
                  lanes: e.lanes,
                  firstContext: e.firstContext
                }), n = n.sibling;
                return cr(Pr, Pr.current & 1 | 2), t.child
              }
              e = e.sibling
            }
          s.tail !== null && Gr() > Ap && (t.flags |= 128, r = !0, bg(s, !1), t.lanes = 4194304)
        }
      else {
        if (!r)
          if (e = Kw(o), e !== null) {
            if (t.flags |= 128, r = !0, n = e.updateQueue, n !== null && (t.updateQueue = n, t.flags |= 4), bg(s, !0), s.tail === null && s.tailMode === "hidden" && !o.alternate && !Er) return Ji(t), null
          } else 2 * Gr() - s.renderingStartTime > Ap && n !== 1073741824 && (t.flags |= 128, r = !0, bg(s, !1), t.lanes = 4194304);
        s.isBackwards ? (o.sibling = t.child, t.child = o) : (n = s.last, n !== null ? n.sibling = o : t.child = o, s.last = o)
      }
      return s.tail !== null ? (t = s.tail, s.rendering = t, s.tail = t.sibling, s.renderingStartTime = Gr(), t.sibling = null, n = Pr.current, cr(Pr, r ? n & 1 | 2 : n & 1), t) : (Ji(t), null);
    case 22:
    case 23:
      return rT(), r = t.memoizedState !== null, e !== null && e.memoizedState !== null !== r && (t.flags |= 8192), r && t.mode & 1 ? Io & 1073741824 && (Ji(t), t.subtreeFlags & 6 && (t.flags |= 8192)) : Ji(t), null;
    case 24:
      return null;
    case 25:
      return null
  }
  throw Error(Ke(156, t.tag))
}

function lae(e, t) {
  switch (L9(t), t.tag) {
    case 1:
      return so(t.type) && Uw(), e = t.flags, e & 65536 ? (t.flags = e & -65537 | 128, t) : null;
    case 3:
      return Sp(), yr(io), yr(ls), q9(), e = t.flags, e & 65536 && !(e & 128) ? (t.flags = e & -65537 | 128, t) : null;
    case 5:
      return W9(t), null;
    case 13:
      if (yr(Pr), e = t.memoizedState, e !== null && e.dehydrated !== null) {
        if (t.alternate === null) throw Error(Ke(340));
        xp()
      }
      return e = t.flags, e & 65536 ? (t.flags = e & -65537 | 128, t) : null;
    case 19:
      return yr(Pr), null;
    case 4:
      return Sp(), null;
    case 10:
      return U9(t.type._context), null;
    case 22:
    case 23:
      return rT(), null;
    case 24:
      return null;
    default:
      return null
  }
}
var Zv = !1,
  is = !1,
  uae = typeof WeakSet == "function" ? WeakSet : Set,
  ut = null;

function j0(e, t) {
  var n = e.ref;
  if (n !== null)
    if (typeof n == "function") try {
      n(null)
    } catch (r) {
      Fr(e, t, r)
    } else n.current = null
}

function IC(e, t, n) {
  try {
    n()
  } catch (r) {
    Fr(e, t, r)
  }
}
var OO = !1;

function dae(e, t) {
  if (fC = Lw, e = fj(), M9(e)) {
    if ("selectionStart" in e) var n = {
      start: e.selectionStart,
      end: e.selectionEnd
    };
    else e: {
      n = (n = e.ownerDocument) && n.defaultView || window;
      var r = n.getSelection && n.getSelection();
      if (r && r.rangeCount !== 0) {
        n = r.anchorNode;
        var i = r.anchorOffset,
          s = r.focusNode;
        r = r.focusOffset;
        try {
          n.nodeType, s.nodeType
        } catch {
          n = null;
          break e
        }
        var o = 0,
          a = -1,
          c = -1,
          l = 0,
          u = 0,
          f = e,
          h = null;
        t: for (;;) {
          for (var g; f !== n || i !== 0 && f.nodeType !== 3 || (a = o + i), f !== s || r !== 0 && f.nodeType !== 3 || (c = o + r), f.nodeType === 3 && (o += f.nodeValue.length), (g = f.firstChild) !== null;) h = f, f = g;
          for (;;) {
            if (f === e) break t;
            if (h === n && ++l === i && (a = o), h === s && ++u === r && (c = o), (g = f.nextSibling) !== null) break;
            f = h, h = f.parentNode
          }
          f = g
        }
        n = a === -1 || c === -1 ? null : {
          start: a,
          end: c
        }
      } else n = null
    }
    n = n || {
      start: 0,
      end: 0
    }
  } else n = null;
  for (hC = {
      focusedElem: e,
      selectionRange: n
    }, Lw = !1, ut = t; ut !== null;)
    if (t = ut, e = t.child, (t.subtreeFlags & 1028) !== 0 && e !== null) e.return = t, ut = e;
    else
      for (; ut !== null;) {
        t = ut;
        try {
          var y = t.alternate;
          if (t.flags & 1024) switch (t.tag) {
            case 0:
            case 11:
            case 15:
              break;
            case 1:
              if (y !== null) {
                var x = y.memoizedProps,
                  k = y.memoizedState,
                  _ = t.stateNode,
                  p = _.getSnapshotBeforeUpdate(t.elementType === t.type ? x : nc(t.type, x), k);
                _.__reactInternalSnapshotBeforeUpdate = p
              }
              break;
            case 3:
              var v = t.stateNode.containerInfo;
              v.nodeType === 1 ? v.textContent = "" : v.nodeType === 9 && v.documentElement && v.removeChild(v.documentElement);
              break;
            case 5:
            case 6:
            case 4:
            case 17:
              break;
            default:
              throw Error(Ke(163))
          }
        } catch (S) {
          Fr(t, t.return, S)
        }
        if (e = t.sibling, e !== null) {
          e.return = t.return, ut = e;
          break
        }
        ut = t.return
      }
  return y = OO, OO = !1, y
}

function h1(e, t, n) {
  var r = t.updateQueue;
  if (r = r !== null ? r.lastEffect : null, r !== null) {
    var i = r = r.next;
    do {
      if ((i.tag & e) === e) {
        var s = i.destroy;
        i.destroy = void 0, s !== void 0 && IC(t, n, s)
      }
      i = i.next
    } while (i !== r)
  }
}

function Nx(e, t) {
  if (t = t.updateQueue, t = t !== null ? t.lastEffect : null, t !== null) {
    var n = t = t.next;
    do {
      if ((n.tag & e) === e) {
        var r = n.create;
        n.destroy = r()
      }
      n = n.next
    } while (n !== t)
  }
}

function PC(e) {
  var t = e.ref;
  if (t !== null) {
    var n = e.stateNode;
    switch (e.tag) {
      case 5:
        e = n;
        break;
      default:
        e = n
    }
    typeof t == "function" ? t(e) : t.current = e
  }
}

function lU(e) {
  var t = e.alternate;
  t !== null && (e.alternate = null, lU(t)), e.child = null, e.deletions = null, e.sibling = null, e.tag === 5 && (t = e.stateNode, t !== null && (delete t[Gc], delete t[U1], delete t[gC], delete t[Goe], delete t[Koe])), e.stateNode = null, e.return = null, e.dependencies = null, e.memoizedProps = null, e.memoizedState = null, e.pendingProps = null, e.stateNode = null, e.updateQueue = null
}

function uU(e) {
  return e.tag === 5 || e.tag === 3 || e.tag === 4
}

function DO(e) {
  e: for (;;) {
    for (; e.sibling === null;) {
      if (e.return === null || uU(e.return)) return null;
      e = e.return
    }
    for (e.sibling.return = e.return, e = e.sibling; e.tag !== 5 && e.tag !== 6 && e.tag !== 18;) {
      if (e.flags & 2 || e.child === null || e.tag === 4) continue e;
      e.child.return = e, e = e.child
    }
    if (!(e.flags & 2)) return e.stateNode
  }
}

function RC(e, t, n) {
  var r = e.tag;
  if (r === 5 || r === 6) e = e.stateNode, t ? n.nodeType === 8 ? n.parentNode.insertBefore(e, t) : n.insertBefore(e, t) : (n.nodeType === 8 ? (t = n.parentNode, t.insertBefore(e, n)) : (t = n, t.appendChild(e)), n = n._reactRootContainer, n != null || t.onclick !== null || (t.onclick = jw));
  else if (r !== 4 && (e = e.child, e !== null))
    for (RC(e, t, n), e = e.sibling; e !== null;) RC(e, t, n), e = e.sibling
}

function OC(e, t, n) {
  var r = e.tag;
  if (r === 5 || r === 6) e = e.stateNode, t ? n.insertBefore(e, t) : n.appendChild(e);
  else if (r !== 4 && (e = e.child, e !== null))
    for (OC(e, t, n), e = e.sibling; e !== null;) OC(e, t, n), e = e.sibling
}
var Mi = null,
  sc = !1;

function Uu(e, t, n) {
  for (n = n.child; n !== null;) dU(e, t, n), n = n.sibling
}

function dU(e, t, n) {
  if (nl && typeof nl.onCommitFiberUnmount == "function") try {
    nl.onCommitFiberUnmount(Tx, n)
  } catch {}
  switch (n.tag) {
    case 5:
      is || j0(n, t);
    case 6:
      var r = Mi,
        i = sc;
      Mi = null, Uu(e, t, n), Mi = r, sc = i, Mi !== null && (sc ? (e = Mi, n = n.stateNode, e.nodeType === 8 ? e.parentNode.removeChild(n) : e.removeChild(n)) : Mi.removeChild(n.stateNode));
      break;
    case 18:
      Mi !== null && (sc ? (e = Mi, n = n.stateNode, e.nodeType === 8 ? q4(e.parentNode, n) : e.nodeType === 1 && q4(e, n), $1(e)) : q4(Mi, n.stateNode));
      break;
    case 4:
      r = Mi, i = sc, Mi = n.stateNode.containerInfo, sc = !0, Uu(e, t, n), Mi = r, sc = i;
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      if (!is && (r = n.updateQueue, r !== null && (r = r.lastEffect, r !== null))) {
        i = r = r.next;
        do {
          var s = i,
            o = s.destroy;
          s = s.tag, o !== void 0 && (s & 2 || s & 4) && IC(n, t, o), i = i.next
        } while (i !== r)
      }
      Uu(e, t, n);
      break;
    case 1:
      if (!is && (j0(n, t), r = n.stateNode, typeof r.componentWillUnmount == "function")) try {
        r.props = n.memoizedProps, r.state = n.memoizedState, r.componentWillUnmount()
      } catch (a) {
        Fr(n, t, a)
      }
      Uu(e, t, n);
      break;
    case 21:
      Uu(e, t, n);
      break;
    case 22:
      n.mode & 1 ? (is = (r = is) || n.memoizedState !== null, Uu(e, t, n), is = r) : Uu(e, t, n);
      break;
    default:
      Uu(e, t, n)
  }
}

function NO(e) {
  var t = e.updateQueue;
  if (t !== null) {
    e.updateQueue = null;
    var n = e.stateNode;
    n === null && (n = e.stateNode = new uae), t.forEach(function (r) {
      var i = wae.bind(null, e, r);
      n.has(r) || (n.add(r), r.then(i, i))
    })
  }
}

function Qa(e, t) {
  var n = t.deletions;
  if (n !== null)
    for (var r = 0; r < n.length; r++) {
      var i = n[r];
      try {
        var s = e,
          o = t,
          a = o;
        e: for (; a !== null;) {
          switch (a.tag) {
            case 5:
              Mi = a.stateNode, sc = !1;
              break e;
            case 3:
              Mi = a.stateNode.containerInfo, sc = !0;
              break e;
            case 4:
              Mi = a.stateNode.containerInfo, sc = !0;
              break e
          }
          a = a.return
        }
        if (Mi === null) throw Error(Ke(160));
        dU(s, o, i), Mi = null, sc = !1;
        var c = i.alternate;
        c !== null && (c.return = null), i.return = null
      } catch (l) {
        Fr(i, t, l)
      }
    }
  if (t.subtreeFlags & 12854)
    for (t = t.child; t !== null;) fU(t, e), t = t.sibling
}

function fU(e, t) {
  var n = e.alternate,
    r = e.flags;
  switch (e.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      if (Qa(t, e), $c(e), r & 4) {
        try {
          h1(3, e, e.return), Nx(3, e)
        } catch (x) {
          Fr(e, e.return, x)
        }
        try {
          h1(5, e, e.return)
        } catch (x) {
          Fr(e, e.return, x)
        }
      }
      break;
    case 1:
      Qa(t, e), $c(e), r & 512 && n !== null && j0(n, n.return);
      break;
    case 5:
      if (Qa(t, e), $c(e), r & 512 && n !== null && j0(n, n.return), e.flags & 32) {
        var i = e.stateNode;
        try {
          O1(i, "")
        } catch (x) {
          Fr(e, e.return, x)
        }
      }
      if (r & 4 && (i = e.stateNode, i != null)) {
        var s = e.memoizedProps,
          o = n !== null ? n.memoizedProps : s,
          a = e.type,
          c = e.updateQueue;
        if (e.updateQueue = null, c !== null) try {
          a === "input" && s.type === "radio" && s.name != null && DF(i, s), nC(a, o);
          var l = nC(a, s);
          for (o = 0; o < c.length; o += 2) {
            var u = c[o],
              f = c[o + 1];
            u === "style" ? BF(i, f) : u === "dangerouslySetInnerHTML" ? $F(i, f) : u === "children" ? O1(i, f) : E9(i, u, f, l)
          }
          switch (a) {
            case "input":
              J8(i, s);
              break;
            case "textarea":
              NF(i, s);
              break;
            case "select":
              var h = i._wrapperState.wasMultiple;
              i._wrapperState.wasMultiple = !!s.multiple;
              var g = s.value;
              g != null ? np(i, !!s.multiple, g, !1) : h !== !!s.multiple && (s.defaultValue != null ? np(i, !!s.multiple, s.defaultValue, !0) : np(i, !!s.multiple, s.multiple ? [] : "", !1))
          }
          i[U1] = s
        } catch (x) {
          Fr(e, e.return, x)
        }
      }
      break;
    case 6:
      if (Qa(t, e), $c(e), r & 4) {
        if (e.stateNode === null) throw Error(Ke(162));
        i = e.stateNode, s = e.memoizedProps;
        try {
          i.nodeValue = s
        } catch (x) {
          Fr(e, e.return, x)
        }
      }
      break;
    case 3:
      if (Qa(t, e), $c(e), r & 4 && n !== null && n.memoizedState.isDehydrated) try {
        $1(t.containerInfo)
      } catch (x) {
        Fr(e, e.return, x)
      }
      break;
    case 4:
      Qa(t, e), $c(e);
      break;
    case 13:
      Qa(t, e), $c(e), i = e.child, i.flags & 8192 && (s = i.memoizedState !== null, i.stateNode.isHidden = s, !s || i.alternate !== null && i.alternate.memoizedState !== null || (tT = Gr())), r & 4 && NO(e);
      break;
    case 22:
      if (u = n !== null && n.memoizedState !== null, e.mode & 1 ? (is = (l = is) || u, Qa(t, e), is = l) : Qa(t, e), $c(e), r & 8192) {
        if (l = e.memoizedState !== null, (e.stateNode.isHidden = l) && !u && e.mode & 1)
          for (ut = e, u = e.child; u !== null;) {
            for (f = ut = u; ut !== null;) {
              switch (h = ut, g = h.child, h.tag) {
                case 0:
                case 11:
                case 14:
                case 15:
                  h1(4, h, h.return);
                  break;
                case 1:
                  j0(h, h.return);
                  var y = h.stateNode;
                  if (typeof y.componentWillUnmount == "function") {
                    r = h, n = h.return;
                    try {
                      t = r, y.props = t.memoizedProps, y.state = t.memoizedState, y.componentWillUnmount()
                    } catch (x) {
                      Fr(r, n, x)
                    }
                  }
                  break;
                case 5:
                  j0(h, h.return);
                  break;
                case 22:
                  if (h.memoizedState !== null) {
                    $O(f);
                    continue
                  }
              }
              g !== null ? (g.return = h, ut = g) : $O(f)
            }
            u = u.sibling
          }
        e: for (u = null, f = e;;) {
          if (f.tag === 5) {
            if (u === null) {
              u = f;
              try {
                i = f.stateNode, l ? (s = i.style, typeof s.setProperty == "function" ? s.setProperty("display", "none", "important") : s.display = "none") : (a = f.stateNode, c = f.memoizedProps.style, o = c != null && c.hasOwnProperty("display") ? c.display : null, a.style.display = LF("display", o))
              } catch (x) {
                Fr(e, e.return, x)
              }
            }
          } else if (f.tag === 6) {
            if (u === null) try {
              f.stateNode.nodeValue = l ? "" : f.memoizedProps
            } catch (x) {
              Fr(e, e.return, x)
            }
          } else if ((f.tag !== 22 && f.tag !== 23 || f.memoizedState === null || f === e) && f.child !== null) {
            f.child.return = f, f = f.child;
            continue
          }
          if (f === e) break e;
          for (; f.sibling === null;) {
            if (f.return === null || f.return === e) break e;
            u === f && (u = null), f = f.return
          }
          u === f && (u = null), f.sibling.return = f.return, f = f.sibling
        }
      }
      break;
    case 19:
      Qa(t, e), $c(e), r & 4 && NO(e);
      break;
    case 21:
      break;
    default:
      Qa(t, e), $c(e)
  }
}

function $c(e) {
  var t = e.flags;
  if (t & 2) {
    try {
      e: {
        for (var n = e.return; n !== null;) {
          if (uU(n)) {
            var r = n;
            break e
          }
          n = n.return
        }
        throw Error(Ke(160))
      }
      switch (r.tag) {
        case 5:
          var i = r.stateNode;
          r.flags & 32 && (O1(i, ""), r.flags &= -33);
          var s = DO(e);
          OC(e, s, i);
          break;
        case 3:
        case 4:
          var o = r.stateNode.containerInfo,
            a = DO(e);
          RC(e, a, o);
          break;
        default:
          throw Error(Ke(161))
      }
    }
    catch (c) {
      Fr(e, e.return, c)
    }
    e.flags &= -3
  }
  t & 4096 && (e.flags &= -4097)
}

function fae(e, t, n) {
  ut = e, hU(e)
}

function hU(e, t, n) {
  for (var r = (e.mode & 1) !== 0; ut !== null;) {
    var i = ut,
      s = i.child;
    if (i.tag === 22 && r) {
      var o = i.memoizedState !== null || Zv;
      if (!o) {
        var a = i.alternate,
          c = a !== null && a.memoizedState !== null || is;
        a = Zv;
        var l = is;
        if (Zv = o, (is = c) && !l)
          for (ut = i; ut !== null;) o = ut, c = o.child, o.tag === 22 && o.memoizedState !== null ? LO(i) : c !== null ? (c.return = o, ut = c) : LO(i);
        for (; s !== null;) ut = s, hU(s), s = s.sibling;
        ut = i, Zv = a, is = l
      }
      MO(e)
    } else i.subtreeFlags & 8772 && s !== null ? (s.return = i, ut = s) : MO(e)
  }
}

function MO(e) {
  for (; ut !== null;) {
    var t = ut;
    if (t.flags & 8772) {
      var n = t.alternate;
      try {
        if (t.flags & 8772) switch (t.tag) {
          case 0:
          case 11:
          case 15:
            is || Nx(5, t);
            break;
          case 1:
            var r = t.stateNode;
            if (t.flags & 4 && !is)
              if (n === null) r.componentDidMount();
              else {
                var i = t.elementType === t.type ? n.memoizedProps : nc(t.type, n.memoizedProps);
                r.componentDidUpdate(i, n.memoizedState, r.__reactInternalSnapshotBeforeUpdate)
              } var s = t.updateQueue;
            s !== null && vO(t, s, r);
            break;
          case 3:
            var o = t.updateQueue;
            if (o !== null) {
              if (n = null, t.child !== null) switch (t.child.tag) {
                case 5:
                  n = t.child.stateNode;
                  break;
                case 1:
                  n = t.child.stateNode
              }
              vO(t, o, n)
            }
            break;
          case 5:
            var a = t.stateNode;
            if (n === null && t.flags & 4) {
              n = a;
              var c = t.memoizedProps;
              switch (t.type) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  c.autoFocus && n.focus();
                  break;
                case "img":
                  c.src && (n.src = c.src)
              }
            }
            break;
          case 6:
            break;
          case 4:
            break;
          case 12:
            break;
          case 13:
            if (t.memoizedState === null) {
              var l = t.alternate;
              if (l !== null) {
                var u = l.memoizedState;
                if (u !== null) {
                  var f = u.dehydrated;
                  f !== null && $1(f)
                }
              }
            }
            break;
          case 19:
          case 17:
          case 21:
          case 22:
          case 23:
          case 25:
            break;
          default:
            throw Error(Ke(163))
        }
        is || t.flags & 512 && PC(t)
      } catch (h) {
        Fr(t, t.return, h)
      }
    }
    if (t === e) {
      ut = null;
      break
    }
    if (n = t.sibling, n !== null) {
      n.return = t.return, ut = n;
      break
    }
    ut = t.return
  }
}

function $O(e) {
  for (; ut !== null;) {
    var t = ut;
    if (t === e) {
      ut = null;
      break
    }
    var n = t.sibling;
    if (n !== null) {
      n.return = t.return, ut = n;
      break
    }
    ut = t.return
  }
}

function LO(e) {
  for (; ut !== null;) {
    var t = ut;
    try {
      switch (t.tag) {
        case 0:
        case 11:
        case 15:
          var n = t.return;
          try {
            Nx(4, t)
          } catch (c) {
            Fr(t, n, c)
          }
          break;
        case 1:
          var r = t.stateNode;
          if (typeof r.componentDidMount == "function") {
            var i = t.return;
            try {
              r.componentDidMount()
            } catch (c) {
              Fr(t, i, c)
            }
          }
          var s = t.return;
          try {
            PC(t)
          } catch (c) {
            Fr(t, s, c)
          }
          break;
        case 5:
          var o = t.return;
          try {
            PC(t)
          } catch (c) {
            Fr(t, o, c)
          }
      }
    } catch (c) {
      Fr(t, t.return, c)
    }
    if (t === e) {
      ut = null;
      break
    }
    var a = t.sibling;
    if (a !== null) {
      a.return = t.return, ut = a;
      break
    }
    ut = t.return
  }
}
var hae = Math.ceil,
  Jw = pu.ReactCurrentDispatcher,
  Z9 = pu.ReactCurrentOwner,
  Sa = pu.ReactCurrentBatchConfig,
  An = 0,
  Ci = null,
  ri = null,
  Fi = 0,
  Io = 0,
  U0 = $d(0),
  fi = 0,
  G1 = null,
  Xf = 0,
  Mx = 0,
  eT = 0,
  p1 = null,
  eo = null,
  tT = 0,
  Ap = 1 / 0,
  Vl = null,
  Xw = !1,
  DC = null,
  md = null,
  eb = !1,
  od = null,
  Zw = 0,
  m1 = 0,
  NC = null,
  iw = -1,
  sw = 0;

function Ts() {
  return An & 6 ? Gr() : iw !== -1 ? iw : iw = Gr()
}

function gd(e) {
  return e.mode & 1 ? An & 2 && Fi !== 0 ? Fi & -Fi : Yoe.transition !== null ? (sw === 0 && (sw = YF()), sw) : (e = qn, e !== 0 || (e = window.event, e = e === void 0 ? 16 : rj(e.type)), e) : 1
}

function yc(e, t, n, r) {
  if (50 < m1) throw m1 = 0, NC = null, Error(Ke(185));
  _2(e, n, r), (!(An & 2) || e !== Ci) && (e === Ci && (!(An & 2) && (Mx |= n), fi === 4 && rd(e, Fi)), oo(e, r), n === 1 && An === 0 && !(t.mode & 1) && (Ap = Gr() + 500, Rx && Ld()))
}

function oo(e, t) {
  var n = e.callbackNode;
  Yse(e, t);
  var r = $w(e, e === Ci ? Fi : 0);
  if (r === 0) n !== null && qR(n), e.callbackNode = null, e.callbackPriority = 0;
  else if (t = r & -r, e.callbackPriority !== t) {
    if (n != null && qR(n), t === 1) e.tag === 0 ? Qoe(BO.bind(null, e)) : Ej(BO.bind(null, e)), Woe(function () {
      !(An & 6) && Ld()
    }), n = null;
    else {
      switch (JF(r)) {
        case 1:
          n = k9;
          break;
        case 4:
          n = KF;
          break;
        case 16:
          n = Mw;
          break;
        case 536870912:
          n = QF;
          break;
        default:
          n = Mw
      }
      n = xU(n, pU.bind(null, e))
    }
    e.callbackPriority = t, e.callbackNode = n
  }
}

function pU(e, t) {
  if (iw = -1, sw = 0, An & 6) throw Error(Ke(327));
  var n = e.callbackNode;
  if (ap() && e.callbackNode !== n) return null;
  var r = $w(e, e === Ci ? Fi : 0);
  if (r === 0) return null;
  if (r & 30 || r & e.expiredLanes || t) t = e3(e, r);
  else {
    t = r;
    var i = An;
    An |= 2;
    var s = gU();
    (Ci !== e || Fi !== t) && (Vl = null, Ap = Gr() + 500, jf(e, t));
    do try {
      gae();
      break
    } catch (a) {
      mU(e, a)
    }
    while (!0);
    j9(), Jw.current = s, An = i, ri !== null ? t = 0 : (Ci = null, Fi = 0, t = fi)
  }
  if (t !== 0) {
    if (t === 2 && (i = aC(e), i !== 0 && (r = i, t = MC(e, i))), t === 1) throw n = G1, jf(e, 0), rd(e, r), oo(e, Gr()), n;
    if (t === 6) rd(e, r);
    else {
      if (i = e.current.alternate, !(r & 30) && !pae(i) && (t = e3(e, r), t === 2 && (s = aC(e), s !== 0 && (r = s, t = MC(e, s))), t === 1)) throw n = G1, jf(e, 0), rd(e, r), oo(e, Gr()), n;
      switch (e.finishedWork = i, e.finishedLanes = r, t) {
        case 0:
        case 1:
          throw Error(Ke(345));
        case 2:
          xf(e, eo, Vl);
          break;
        case 3:
          if (rd(e, r), (r & 130023424) === r && (t = tT + 500 - Gr(), 10 < t)) {
            if ($w(e, 0) !== 0) break;
            if (i = e.suspendedLanes, (i & r) !== r) {
              Ts(), e.pingedLanes |= e.suspendedLanes & i;
              break
            }
            e.timeoutHandle = mC(xf.bind(null, e, eo, Vl), t);
            break
          }
          xf(e, eo, Vl);
          break;
        case 4:
          if (rd(e, r), (r & 4194240) === r) break;
          for (t = e.eventTimes, i = -1; 0 < r;) {
            var o = 31 - gc(r);
            s = 1 << o, o = t[o], o > i && (i = o), r &= ~s
          }
          if (r = i, r = Gr() - r, r = (120 > r ? 120 : 480 > r ? 480 : 1080 > r ? 1080 : 1920 > r ? 1920 : 3e3 > r ? 3e3 : 4320 > r ? 4320 : 1960 * hae(r / 1960)) - r, 10 < r) {
            e.timeoutHandle = mC(xf.bind(null, e, eo, Vl), r);
            break
          }
          xf(e, eo, Vl);
          break;
        case 5:
          xf(e, eo, Vl);
          break;
        default:
          throw Error(Ke(329))
      }
    }
  }
  return oo(e, Gr()), e.callbackNode === n ? pU.bind(null, e) : null
}

function MC(e, t) {
  var n = p1;
  return e.current.memoizedState.isDehydrated && (jf(e, t).flags |= 256), e = e3(e, t), e !== 2 && (t = eo, eo = n, t !== null && $C(t)), e
}

function $C(e) {
  eo === null ? eo = e : eo.push.apply(eo, e)
}

function pae(e) {
  for (var t = e;;) {
    if (t.flags & 16384) {
      var n = t.updateQueue;
      if (n !== null && (n = n.stores, n !== null))
        for (var r = 0; r < n.length; r++) {
          var i = n[r],
            s = i.getSnapshot;
          i = i.value;
          try {
            if (!xc(s(), i)) return !1
          } catch {
            return !1
          }
        }
    }
    if (n = t.child, t.subtreeFlags & 16384 && n !== null) n.return = t, t = n;
    else {
      if (t === e) break;
      for (; t.sibling === null;) {
        if (t.return === null || t.return === e) return !0;
        t = t.return
      }
      t.sibling.return = t.return, t = t.sibling
    }
  }
  return !0
}

function rd(e, t) {
  for (t &= ~eT, t &= ~Mx, e.suspendedLanes |= t, e.pingedLanes &= ~t, e = e.expirationTimes; 0 < t;) {
    var n = 31 - gc(t),
      r = 1 << n;
    e[n] = -1, t &= ~r
  }
}

function BO(e) {
  if (An & 6) throw Error(Ke(327));
  ap();
  var t = $w(e, 0);
  if (!(t & 1)) return oo(e, Gr()), null;
  var n = e3(e, t);
  if (e.tag !== 0 && n === 2) {
    var r = aC(e);
    r !== 0 && (t = r, n = MC(e, r))
  }
  if (n === 1) throw n = G1, jf(e, 0), rd(e, t), oo(e, Gr()), n;
  if (n === 6) throw Error(Ke(345));
  return e.finishedWork = e.current.alternate, e.finishedLanes = t, xf(e, eo, Vl), oo(e, Gr()), null
}

function nT(e, t) {
  var n = An;
  An |= 1;
  try {
    return e(t)
  } finally {
    An = n, An === 0 && (Ap = Gr() + 500, Rx && Ld())
  }
}

function Zf(e) {
  od !== null && od.tag === 0 && !(An & 6) && ap();
  var t = An;
  An |= 1;
  var n = Sa.transition,
    r = qn;
  try {
    if (Sa.transition = null, qn = 1, e) return e()
  } finally {
    qn = r, Sa.transition = n, An = t, !(An & 6) && Ld()
  }
}

function rT() {
  Io = U0.current, yr(U0)
}

function jf(e, t) {
  e.finishedWork = null, e.finishedLanes = 0;
  var n = e.timeoutHandle;
  if (n !== -1 && (e.timeoutHandle = -1, Voe(n)), ri !== null)
    for (n = ri.return; n !== null;) {
      var r = n;
      switch (L9(r), r.tag) {
        case 1:
          r = r.type.childContextTypes, r != null && Uw();
          break;
        case 3:
          Sp(), yr(io), yr(ls), q9();
          break;
        case 5:
          W9(r);
          break;
        case 4:
          Sp();
          break;
        case 13:
          yr(Pr);
          break;
        case 19:
          yr(Pr);
          break;
        case 10:
          U9(r.type._context);
          break;
        case 22:
        case 23:
          rT()
      }
      n = n.return
    }
  if (Ci = e, ri = e = yd(e.current, null), Fi = Io = t, fi = 0, G1 = null, eT = Mx = Xf = 0, eo = p1 = null, _f !== null) {
    for (t = 0; t < _f.length; t++)
      if (n = _f[t], r = n.interleaved, r !== null) {
        n.interleaved = null;
        var i = r.next,
          s = n.pending;
        if (s !== null) {
          var o = s.next;
          s.next = i, r.next = o
        }
        n.pending = r
      } _f = null
  }
  return e
}

function mU(e, t) {
  do {
    var n = ri;
    try {
      if (j9(), tw.current = Yw, Qw) {
        for (var r = Or.memoizedState; r !== null;) {
          var i = r.queue;
          i !== null && (i.pending = null), r = r.next
        }
        Qw = !1
      }
      if (Jf = 0, bi = ui = Or = null, f1 = !1, V1 = 0, Z9.current = null, n === null || n.return === null) {
        fi = 1, G1 = t, ri = null;
        break
      }
      e: {
        var s = e,
          o = n.return,
          a = n,
          c = t;
        if (t = Fi, a.flags |= 32768, c !== null && typeof c == "object" && typeof c.then == "function") {
          var l = c,
            u = a,
            f = u.tag;
          if (!(u.mode & 1) && (f === 0 || f === 11 || f === 15)) {
            var h = u.alternate;
            h ? (u.updateQueue = h.updateQueue, u.memoizedState = h.memoizedState, u.lanes = h.lanes) : (u.updateQueue = null, u.memoizedState = null)
          }
          var g = AO(o);
          if (g !== null) {
            g.flags &= -257, TO(g, o, a, s, t), g.mode & 1 && CO(s, l, t), t = g, c = l;
            var y = t.updateQueue;
            if (y === null) {
              var x = new Set;
              x.add(c), t.updateQueue = x
            } else y.add(c);
            break e
          } else {
            if (!(t & 1)) {
              CO(s, l, t), iT();
              break e
            }
            c = Error(Ke(426))
          }
        } else if (Er && a.mode & 1) {
          var k = AO(o);
          if (k !== null) {
            !(k.flags & 65536) && (k.flags |= 256), TO(k, o, a, s, t), B9(Cp(c, a));
            break e
          }
        }
        s = c = Cp(c, a),
        fi !== 4 && (fi = 2),
        p1 === null ? p1 = [s] : p1.push(s),
        s = o;do {
          switch (s.tag) {
            case 3:
              s.flags |= 65536, t &= -t, s.lanes |= t;
              var _ = Xj(s, c, t);
              yO(s, _);
              break e;
            case 1:
              a = c;
              var p = s.type,
                v = s.stateNode;
              if (!(s.flags & 128) && (typeof p.getDerivedStateFromError == "function" || v !== null && typeof v.componentDidCatch == "function" && (md === null || !md.has(v)))) {
                s.flags |= 65536, t &= -t, s.lanes |= t;
                var S = Zj(s, a, t);
                yO(s, S);
                break e
              }
          }
          s = s.return
        } while (s !== null)
      }
      vU(n)
    } catch (I) {
      t = I, ri === n && n !== null && (ri = n = n.return);
      continue
    }
    break
  } while (!0)
}

function gU() {
  var e = Jw.current;
  return Jw.current = Yw, e === null ? Yw : e
}

function iT() {
  (fi === 0 || fi === 3 || fi === 2) && (fi = 4), Ci === null || !(Xf & 268435455) && !(Mx & 268435455) || rd(Ci, Fi)
}

function e3(e, t) {
  var n = An;
  An |= 2;
  var r = gU();
  (Ci !== e || Fi !== t) && (Vl = null, jf(e, t));
  do try {
    mae();
    break
  } catch (i) {
    mU(e, i)
  }
  while (!0);
  if (j9(), An = n, Jw.current = r, ri !== null) throw Error(Ke(261));
  return Ci = null, Fi = 0, fi
}

function mae() {
  for (; ri !== null;) yU(ri)
}

function gae() {
  for (; ri !== null && !Use();) yU(ri)
}

function yU(e) {
  var t = wU(e.alternate, e, Io);
  e.memoizedProps = e.pendingProps, t === null ? vU(e) : ri = t, Z9.current = null
}

function vU(e) {
  var t = e;
  do {
    var n = t.alternate;
    if (e = t.return, t.flags & 32768) {
      if (n = lae(n, t), n !== null) {
        n.flags &= 32767, ri = n;
        return
      }
      if (e !== null) e.flags |= 32768, e.subtreeFlags = 0, e.deletions = null;
      else {
        fi = 6, ri = null;
        return
      }
    } else if (n = cae(n, t, Io), n !== null) {
      ri = n;
      return
    }
    if (t = t.sibling, t !== null) {
      ri = t;
      return
    }
    ri = t = e
  } while (t !== null);
  fi === 0 && (fi = 5)
}

function xf(e, t, n) {
  var r = qn,
    i = Sa.transition;
  try {
    Sa.transition = null, qn = 1, yae(e, t, n, r)
  } finally {
    Sa.transition = i, qn = r
  }
  return null
}

function yae(e, t, n, r) {
  do ap(); while (od !== null);
  if (An & 6) throw Error(Ke(327));
  n = e.finishedWork;
  var i = e.finishedLanes;
  if (n === null) return null;
  if (e.finishedWork = null, e.finishedLanes = 0, n === e.current) throw Error(Ke(177));
  e.callbackNode = null, e.callbackPriority = 0;
  var s = n.lanes | n.childLanes;
  if (Jse(e, s), e === Ci && (ri = Ci = null, Fi = 0), !(n.subtreeFlags & 2064) && !(n.flags & 2064) || eb || (eb = !0, xU(Mw, function () {
      return ap(), null
    })), s = (n.flags & 15990) !== 0, n.subtreeFlags & 15990 || s) {
    s = Sa.transition, Sa.transition = null;
    var o = qn;
    qn = 1;
    var a = An;
    An |= 4, Z9.current = null, dae(e, n), fU(n, e), Loe(hC), Lw = !!fC, hC = fC = null, e.current = n, fae(n), zse(), An = a, qn = o, Sa.transition = s
  } else e.current = n;
  if (eb && (eb = !1, od = e, Zw = i), s = e.pendingLanes, s === 0 && (md = null), Wse(n.stateNode), oo(e, Gr()), t !== null)
    for (r = e.onRecoverableError, n = 0; n < t.length; n++) i = t[n], r(i.value, {
      componentStack: i.stack,
      digest: i.digest
    });
  if (Xw) throw Xw = !1, e = DC, DC = null, e;
  return Zw & 1 && e.tag !== 0 && ap(), s = e.pendingLanes, s & 1 ? e === NC ? m1++ : (m1 = 0, NC = e) : m1 = 0, Ld(), null
}

function ap() {
  if (od !== null) {
    var e = JF(Zw),
      t = Sa.transition,
      n = qn;
    try {
      if (Sa.transition = null, qn = 16 > e ? 16 : e, od === null) var r = !1;
      else {
        if (e = od, od = null, Zw = 0, An & 6) throw Error(Ke(331));
        var i = An;
        for (An |= 4, ut = e.current; ut !== null;) {
          var s = ut,
            o = s.child;
          if (ut.flags & 16) {
            var a = s.deletions;
            if (a !== null) {
              for (var c = 0; c < a.length; c++) {
                var l = a[c];
                for (ut = l; ut !== null;) {
                  var u = ut;
                  switch (u.tag) {
                    case 0:
                    case 11:
                    case 15:
                      h1(8, u, s)
                  }
                  var f = u.child;
                  if (f !== null) f.return = u, ut = f;
                  else
                    for (; ut !== null;) {
                      u = ut;
                      var h = u.sibling,
                        g = u.return;
                      if (lU(u), u === l) {
                        ut = null;
                        break
                      }
                      if (h !== null) {
                        h.return = g, ut = h;
                        break
                      }
                      ut = g
                    }
                }
              }
              var y = s.alternate;
              if (y !== null) {
                var x = y.child;
                if (x !== null) {
                  y.child = null;
                  do {
                    var k = x.sibling;
                    x.sibling = null, x = k
                  } while (x !== null)
                }
              }
              ut = s
            }
          }
          if (s.subtreeFlags & 2064 && o !== null) o.return = s, ut = o;
          else e: for (; ut !== null;) {
            if (s = ut, s.flags & 2048) switch (s.tag) {
              case 0:
              case 11:
              case 15:
                h1(9, s, s.return)
            }
            var _ = s.sibling;
            if (_ !== null) {
              _.return = s.return, ut = _;
              break e
            }
            ut = s.return
          }
        }
        var p = e.current;
        for (ut = p; ut !== null;) {
          o = ut;
          var v = o.child;
          if (o.subtreeFlags & 2064 && v !== null) v.return = o, ut = v;
          else e: for (o = p; ut !== null;) {
            if (a = ut, a.flags & 2048) try {
              switch (a.tag) {
                case 0:
                case 11:
                case 15:
                  Nx(9, a)
              }
            } catch (I) {
              Fr(a, a.return, I)
            }
            if (a === o) {
              ut = null;
              break e
            }
            var S = a.sibling;
            if (S !== null) {
              S.return = a.return, ut = S;
              break e
            }
            ut = a.return
          }
        }
        if (An = i, Ld(), nl && typeof nl.onPostCommitFiberRoot == "function") try {
          nl.onPostCommitFiberRoot(Tx, e)
        } catch {}
        r = !0
      }
      return r
    } finally {
      qn = n, Sa.transition = t
    }
  }
  return !1
}

function FO(e, t, n) {
  t = Cp(n, t), t = Xj(e, t, 1), e = pd(e, t, 1), t = Ts(), e !== null && (_2(e, 1, t), oo(e, t))
}

function Fr(e, t, n) {
  if (e.tag === 3) FO(e, e, n);
  else
    for (; t !== null;) {
      if (t.tag === 3) {
        FO(t, e, n);
        break
      } else if (t.tag === 1) {
        var r = t.stateNode;
        if (typeof t.type.getDerivedStateFromError == "function" || typeof r.componentDidCatch == "function" && (md === null || !md.has(r))) {
          e = Cp(n, e), e = Zj(t, e, 1), t = pd(t, e, 1), e = Ts(), t !== null && (_2(t, 1, e), oo(t, e));
          break
        }
      }
      t = t.return
    }
}

function vae(e, t, n) {
  var r = e.pingCache;
  r !== null && r.delete(t), t = Ts(), e.pingedLanes |= e.suspendedLanes & n, Ci === e && (Fi & n) === n && (fi === 4 || fi === 3 && (Fi & 130023424) === Fi && 500 > Gr() - tT ? jf(e, 0) : eT |= n), oo(e, t)
}

function bU(e, t) {
  t === 0 && (e.mode & 1 ? (t = Vv, Vv <<= 1, !(Vv & 130023424) && (Vv = 4194304)) : t = 1);
  var n = Ts();
  e = ou(e, t), e !== null && (_2(e, t, n), oo(e, n))
}

function bae(e) {
  var t = e.memoizedState,
    n = 0;
  t !== null && (n = t.retryLane), bU(e, n)
}

function wae(e, t) {
  var n = 0;
  switch (e.tag) {
    case 13:
      var r = e.stateNode,
        i = e.memoizedState;
      i !== null && (n = i.retryLane);
      break;
    case 19:
      r = e.stateNode;
      break;
    default:
      throw Error(Ke(314))
  }
  r !== null && r.delete(t), bU(e, n)
}
var wU;
wU = function (e, t, n) {
  if (e !== null)
    if (e.memoizedProps !== t.pendingProps || io.current) no = !0;
    else {
      if (!(e.lanes & n) && !(t.flags & 128)) return no = !1, aae(e, t, n);
      no = !!(e.flags & 131072)
    }
  else no = !1, Er && t.flags & 1048576 && Sj(t, Vw, t.index);
  switch (t.lanes = 0, t.tag) {
    case 2:
      var r = t.type;
      rw(e, t), e = t.pendingProps;
      var i = wp(t, ls.current);
      op(t, n), i = K9(null, t, r, e, i, n);
      var s = Q9();
      return t.flags |= 1, typeof i == "object" && i !== null && typeof i.render == "function" && i.$$typeof === void 0 ? (t.tag = 1, t.memoizedState = null, t.updateQueue = null, so(r) ? (s = !0, zw(t)) : s = !1, t.memoizedState = i.state !== null && i.state !== void 0 ? i.state : null, H9(t), i.updater = Ox, t.stateNode = i, i._reactInternals = t, EC(t, r, e, n), t = AC(null, t, r, !0, s, n)) : (t.tag = 0, Er && s && $9(t), xs(null, t, i, n), t = t.child), t;
    case 16:
      r = t.elementType;
      e: {
        switch (rw(e, t), e = t.pendingProps, i = r._init, r = i(r._payload), t.type = r, i = t.tag = Eae(r), e = nc(r, e), i) {
          case 0:
            t = CC(null, t, r, e, n);
            break e;
          case 1:
            t = IO(null, t, r, e, n);
            break e;
          case 11:
            t = kO(null, t, r, e, n);
            break e;
          case 14:
            t = _O(null, t, r, nc(r.type, e), n);
            break e
        }
        throw Error(Ke(306, r, ""))
      }
      return t;
    case 0:
      return r = t.type, i = t.pendingProps, i = t.elementType === r ? i : nc(r, i), CC(e, t, r, i, n);
    case 1:
      return r = t.type, i = t.pendingProps, i = t.elementType === r ? i : nc(r, i), IO(e, t, r, i, n);
    case 3:
      e: {
        if (rU(t), e === null) throw Error(Ke(387));r = t.pendingProps,
        s = t.memoizedState,
        i = s.element,
        kj(e, t),
        Gw(t, r, null, n);
        var o = t.memoizedState;
        if (r = o.element, s.isDehydrated)
          if (s = {
              element: r,
              isDehydrated: !1,
              cache: o.cache,
              pendingSuspenseBoundaries: o.pendingSuspenseBoundaries,
              transitions: o.transitions
            }, t.updateQueue.baseState = s, t.memoizedState = s, t.flags & 256) {
            i = Cp(Error(Ke(423)), t), t = PO(e, t, r, n, i);
            break e
          } else if (r !== i) {
          i = Cp(Error(Ke(424)), t), t = PO(e, t, r, n, i);
          break e
        } else
          for (Lo = hd(t.stateNode.containerInfo.firstChild), Fo = t, Er = !0, ac = null, n = Rj(t, null, r, n), t.child = n; n;) n.flags = n.flags & -3 | 4096, n = n.sibling;
        else {
          if (xp(), r === i) {
            t = au(e, t, n);
            break e
          }
          xs(e, t, r, n)
        }
        t = t.child
      }
      return t;
    case 5:
      return Oj(t), e === null && bC(t), r = t.type, i = t.pendingProps, s = e !== null ? e.memoizedProps : null, o = i.children, pC(r, i) ? o = null : s !== null && pC(r, s) && (t.flags |= 32), nU(e, t), xs(e, t, o, n), t.child;
    case 6:
      return e === null && bC(t), null;
    case 13:
      return iU(e, t, n);
    case 4:
      return V9(t, t.stateNode.containerInfo), r = t.pendingProps, e === null ? t.child = Ep(t, null, r, n) : xs(e, t, r, n), t.child;
    case 11:
      return r = t.type, i = t.pendingProps, i = t.elementType === r ? i : nc(r, i), kO(e, t, r, i, n);
    case 7:
      return xs(e, t, t.pendingProps, n), t.child;
    case 8:
      return xs(e, t, t.pendingProps.children, n), t.child;
    case 12:
      return xs(e, t, t.pendingProps.children, n), t.child;
    case 10:
      e: {
        if (r = t.type._context, i = t.pendingProps, s = t.memoizedProps, o = i.value, cr(Ww, r._currentValue), r._currentValue = o, s !== null)
          if (xc(s.value, o)) {
            if (s.children === i.children && !io.current) {
              t = au(e, t, n);
              break e
            }
          } else
            for (s = t.child, s !== null && (s.return = t); s !== null;) {
              var a = s.dependencies;
              if (a !== null) {
                o = s.child;
                for (var c = a.firstContext; c !== null;) {
                  if (c.context === r) {
                    if (s.tag === 1) {
                      c = nu(-1, n & -n), c.tag = 2;
                      var l = s.updateQueue;
                      if (l !== null) {
                        l = l.shared;
                        var u = l.pending;
                        u === null ? c.next = c : (c.next = u.next, u.next = c), l.pending = c
                      }
                    }
                    s.lanes |= n, c = s.alternate, c !== null && (c.lanes |= n), wC(s.return, n, t), a.lanes |= n;
                    break
                  }
                  c = c.next
                }
              } else if (s.tag === 10) o = s.type === t.type ? null : s.child;
              else if (s.tag === 18) {
                if (o = s.return, o === null) throw Error(Ke(341));
                o.lanes |= n, a = o.alternate, a !== null && (a.lanes |= n), wC(o, n, t), o = s.sibling
              } else o = s.child;
              if (o !== null) o.return = s;
              else
                for (o = s; o !== null;) {
                  if (o === t) {
                    o = null;
                    break
                  }
                  if (s = o.sibling, s !== null) {
                    s.return = o.return, o = s;
                    break
                  }
                  o = o.return
                }
              s = o
            }
        xs(e, t, i.children, n),
        t = t.child
      }
      return t;
    case 9:
      return i = t.type, r = t.pendingProps.children, op(t, n), i = Ta(i), r = r(i), t.flags |= 1, xs(e, t, r, n), t.child;
    case 14:
      return r = t.type, i = nc(r, t.pendingProps), i = nc(r.type, i), _O(e, t, r, i, n);
    case 15:
      return eU(e, t, t.type, t.pendingProps, n);
    case 17:
      return r = t.type, i = t.pendingProps, i = t.elementType === r ? i : nc(r, i), rw(e, t), t.tag = 1, so(r) ? (e = !0, zw(t)) : e = !1, op(t, n), Ij(t, r, i), EC(t, r, i, n), AC(null, t, r, !0, e, n);
    case 19:
      return sU(e, t, n);
    case 22:
      return tU(e, t, n)
  }
  throw Error(Ke(156, t.tag))
};

function xU(e, t) {
  return GF(e, t)
}

function xae(e, t, n, r) {
  this.tag = e, this.key = n, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = t, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = r, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null
}

function xa(e, t, n, r) {
  return new xae(e, t, n, r)
}

function sT(e) {
  return e = e.prototype, !(!e || !e.isReactComponent)
}

function Eae(e) {
  if (typeof e == "function") return sT(e) ? 1 : 0;
  if (e != null) {
    if (e = e.$$typeof, e === C9) return 11;
    if (e === A9) return 14
  }
  return 2
}

function yd(e, t) {
  var n = e.alternate;
  return n === null ? (n = xa(e.tag, t, e.key, e.mode), n.elementType = e.elementType, n.type = e.type, n.stateNode = e.stateNode, n.alternate = e, e.alternate = n) : (n.pendingProps = t, n.type = e.type, n.flags = 0, n.subtreeFlags = 0, n.deletions = null), n.flags = e.flags & 14680064, n.childLanes = e.childLanes, n.lanes = e.lanes, n.child = e.child, n.memoizedProps = e.memoizedProps, n.memoizedState = e.memoizedState, n.updateQueue = e.updateQueue, t = e.dependencies, n.dependencies = t === null ? null : {
    lanes: t.lanes,
    firstContext: t.firstContext
  }, n.sibling = e.sibling, n.index = e.index, n.ref = e.ref, n
}

function ow(e, t, n, r, i, s) {
  var o = 2;
  if (r = e, typeof e == "function") sT(e) && (o = 1);
  else if (typeof e == "string") o = 5;
  else e: switch (e) {
    case R0:
      return Uf(n.children, i, s, t);
    case S9:
      o = 8, i |= 8;
      break;
    case q8:
      return e = xa(12, n, t, i | 2), e.elementType = q8, e.lanes = s, e;
    case G8:
      return e = xa(13, n, t, i), e.elementType = G8, e.lanes = s, e;
    case K8:
      return e = xa(19, n, t, i), e.elementType = K8, e.lanes = s, e;
    case PF:
      return $x(n, i, s, t);
    default:
      if (typeof e == "object" && e !== null) switch (e.$$typeof) {
        case _F:
          o = 10;
          break e;
        case IF:
          o = 9;
          break e;
        case C9:
          o = 11;
          break e;
        case A9:
          o = 14;
          break e;
        case Ju:
          o = 16, r = null;
          break e
      }
      throw Error(Ke(130, e == null ? e : typeof e, ""))
  }
  return t = xa(o, n, t, i), t.elementType = e, t.type = r, t.lanes = s, t
}

function Uf(e, t, n, r) {
  return e = xa(7, e, r, t), e.lanes = n, e
}

function $x(e, t, n, r) {
  return e = xa(22, e, r, t), e.elementType = PF, e.lanes = n, e.stateNode = {
    isHidden: !1
  }, e
}

function eS(e, t, n) {
  return e = xa(6, e, null, t), e.lanes = n, e
}

function tS(e, t, n) {
  return t = xa(4, e.children !== null ? e.children : [], e.key, t), t.lanes = n, t.stateNode = {
    containerInfo: e.containerInfo,
    pendingChildren: null,
    implementation: e.implementation
  }, t
}

function Sae(e, t, n, r, i) {
  this.tag = t, this.containerInfo = e, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = M4(0), this.expirationTimes = M4(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = M4(0), this.identifierPrefix = r, this.onRecoverableError = i, this.mutableSourceEagerHydrationData = null
}

function oT(e, t, n, r, i, s, o, a, c) {
  return e = new Sae(e, t, n, a, c), t === 1 ? (t = 1, s === !0 && (t |= 8)) : t = 0, s = xa(3, null, null, t), e.current = s, s.stateNode = e, s.memoizedState = {
    element: r,
    isDehydrated: n,
    cache: null,
    transitions: null,
    pendingSuspenseBoundaries: null
  }, H9(s), e
}

function Cae(e, t, n) {
  var r = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
  return {
    $$typeof: P0,
    key: r == null ? null : "" + r,
    children: e,
    containerInfo: t,
    implementation: n
  }
}

function EU(e) {
  if (!e) return wd;
  e = e._reactInternals;
  e: {
    if (Eh(e) !== e || e.tag !== 1) throw Error(Ke(170));
    var t = e;do {
      switch (t.tag) {
        case 3:
          t = t.stateNode.context;
          break e;
        case 1:
          if (so(t.type)) {
            t = t.stateNode.__reactInternalMemoizedMergedChildContext;
            break e
          }
      }
      t = t.return
    } while (t !== null);
    throw Error(Ke(171))
  }
  if (e.tag === 1) {
    var n = e.type;
    if (so(n)) return xj(e, n, t)
  }
  return t
}

function SU(e, t, n, r, i, s, o, a, c) {
  return e = oT(n, r, !0, e, i, s, o, a, c), e.context = EU(null), n = e.current, r = Ts(), i = gd(n), s = nu(r, i), s.callback = t ?? null, pd(n, s, i), e.current.lanes = i, _2(e, i, r), oo(e, r), e
}

function Lx(e, t, n, r) {
  var i = t.current,
    s = Ts(),
    o = gd(i);
  return n = EU(n), t.context === null ? t.context = n : t.pendingContext = n, t = nu(s, o), t.payload = {
    element: e
  }, r = r === void 0 ? null : r, r !== null && (t.callback = r), e = pd(i, t, o), e !== null && (yc(e, i, o, s), ew(e, i, o)), o
}

function t3(e) {
  if (e = e.current, !e.child) return null;
  switch (e.child.tag) {
    case 5:
      return e.child.stateNode;
    default:
      return e.child.stateNode
  }
}

function jO(e, t) {
  if (e = e.memoizedState, e !== null && e.dehydrated !== null) {
    var n = e.retryLane;
    e.retryLane = n !== 0 && n < t ? n : t
  }
}

function aT(e, t) {
  jO(e, t), (e = e.alternate) && jO(e, t)
}

function Aae() {
  return null
}
var CU = typeof reportError == "function" ? reportError : function (e) {
  console.error(e)
};

function cT(e) {
  this._internalRoot = e
}
Bx.prototype.render = cT.prototype.render = function (e) {
  var t = this._internalRoot;
  if (t === null) throw Error(Ke(409));
  Lx(e, t, null, null)
};
Bx.prototype.unmount = cT.prototype.unmount = function () {
  var e = this._internalRoot;
  if (e !== null) {
    this._internalRoot = null;
    var t = e.containerInfo;
    Zf(function () {
      Lx(null, e, null, null)
    }), t[su] = null
  }
};

function Bx(e) {
  this._internalRoot = e
}
Bx.prototype.unstable_scheduleHydration = function (e) {
  if (e) {
    var t = ej();
    e = {
      blockedOn: null,
      target: e,
      priority: t
    };
    for (var n = 0; n < nd.length && t !== 0 && t < nd[n].priority; n++);
    nd.splice(n, 0, e), n === 0 && nj(e)
  }
};

function lT(e) {
  return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11)
}

function Fx(e) {
  return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11 && (e.nodeType !== 8 || e.nodeValue !== " react-mount-point-unstable "))
}

function UO() {}

function Tae(e, t, n, r, i) {
  if (i) {
    if (typeof r == "function") {
      var s = r;
      r = function () {
        var l = t3(o);
        s.call(l)
      }
    }
    var o = SU(t, r, e, 0, null, !1, !1, "", UO);
    return e._reactRootContainer = o, e[su] = o.current, F1(e.nodeType === 8 ? e.parentNode : e), Zf(), o
  }
  for (; i = e.lastChild;) e.removeChild(i);
  if (typeof r == "function") {
    var a = r;
    r = function () {
      var l = t3(c);
      a.call(l)
    }
  }
  var c = oT(e, 0, !1, null, null, !1, !1, "", UO);
  return e._reactRootContainer = c, e[su] = c.current, F1(e.nodeType === 8 ? e.parentNode : e), Zf(function () {
    Lx(t, c, n, r)
  }), c
}

function jx(e, t, n, r, i) {
  var s = n._reactRootContainer;
  if (s) {
    var o = s;
    if (typeof i == "function") {
      var a = i;
      i = function () {
        var c = t3(o);
        a.call(c)
      }
    }
    Lx(t, o, e, i)
  } else o = Tae(n, t, e, i, r);
  return t3(o)
}
XF = function (e) {
  switch (e.tag) {
    case 3:
      var t = e.stateNode;
      if (t.current.memoizedState.isDehydrated) {
        var n = e1(t.pendingLanes);
        n !== 0 && (_9(t, n | 1), oo(t, Gr()), !(An & 6) && (Ap = Gr() + 500, Ld()))
      }
      break;
    case 13:
      Zf(function () {
        var r = ou(e, 1);
        if (r !== null) {
          var i = Ts();
          yc(r, e, 1, i)
        }
      }), aT(e, 1)
  }
};
I9 = function (e) {
  if (e.tag === 13) {
    var t = ou(e, 134217728);
    if (t !== null) {
      var n = Ts();
      yc(t, e, 134217728, n)
    }
    aT(e, 134217728)
  }
};
ZF = function (e) {
  if (e.tag === 13) {
    var t = gd(e),
      n = ou(e, t);
    if (n !== null) {
      var r = Ts();
      yc(n, e, t, r)
    }
    aT(e, t)
  }
};
ej = function () {
  return qn
};
tj = function (e, t) {
  var n = qn;
  try {
    return qn = e, t()
  } finally {
    qn = n
  }
};
iC = function (e, t, n) {
  switch (t) {
    case "input":
      if (J8(e, n), t = n.name, n.type === "radio" && t != null) {
        for (n = e; n.parentNode;) n = n.parentNode;
        for (n = n.querySelectorAll("input[name=" + JSON.stringify("" + t) + '][type="radio"]'), t = 0; t < n.length; t++) {
          var r = n[t];
          if (r !== e && r.form === e.form) {
            var i = Px(r);
            if (!i) throw Error(Ke(90));
            OF(r), J8(r, i)
          }
        }
      }
      break;
    case "textarea":
      NF(e, n);
      break;
    case "select":
      t = n.value, t != null && np(e, !!n.multiple, t, !1)
  }
};
UF = nT;
zF = Zf;
var kae = {
    usingClientEntryPoint: !1,
    Events: [P2, M0, Px, FF, jF, nT]
  },
  wg = {
    findFiberByHostInstance: kf,
    bundleType: 0,
    version: "18.2.0",
    rendererPackageName: "react-dom"
  },
  _ae = {
    bundleType: wg.bundleType,
    version: wg.version,
    rendererPackageName: wg.rendererPackageName,
    rendererConfig: wg.rendererConfig,
    overrideHookState: null,
    overrideHookStateDeletePath: null,
    overrideHookStateRenamePath: null,
    overrideProps: null,
    overridePropsDeletePath: null,
    overridePropsRenamePath: null,
    setErrorHandler: null,
    setSuspenseHandler: null,
    scheduleUpdate: null,
    currentDispatcherRef: pu.ReactCurrentDispatcher,
    findHostInstanceByFiber: function (e) {
      return e = WF(e), e === null ? null : e.stateNode
    },
    findFiberByHostInstance: wg.findFiberByHostInstance || Aae,
    findHostInstancesForRefresh: null,
    scheduleRefresh: null,
    scheduleRoot: null,
    setRefreshHandler: null,
    getCurrentFiber: null,
    reconcilerVersion: "18.2.0-next-9e3b772b8-20220608"
  };
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
  var tb = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!tb.isDisabled && tb.supportsFiber) try {
    Tx = tb.inject(_ae), nl = tb
  } catch {}
}
Wo.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = kae;
Wo.createPortal = function (e, t) {
  var n = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
  if (!lT(t)) throw Error(Ke(200));
  return Cae(e, t, null, n)
};
Wo.createRoot = function (e, t) {
  if (!lT(e)) throw Error(Ke(299));
  var n = !1,
    r = "",
    i = CU;
  return t != null && (t.unstable_strictMode === !0 && (n = !0), t.identifierPrefix !== void 0 && (r = t.identifierPrefix), t.onRecoverableError !== void 0 && (i = t.onRecoverableError)), t = oT(e, 1, !1, null, null, n, !1, r, i), e[su] = t.current, F1(e.nodeType === 8 ? e.parentNode : e), new cT(t)
};
Wo.findDOMNode = function (e) {
  if (e == null) return null;
  if (e.nodeType === 1) return e;
  var t = e._reactInternals;
  if (t === void 0) throw typeof e.render == "function" ? Error(Ke(188)) : (e = Object.keys(e).join(","), Error(Ke(268, e)));
  return e = WF(t), e = e === null ? null : e.stateNode, e
};
Wo.flushSync = function (e) {
  return Zf(e)
};
Wo.hydrate = function (e, t, n) {
  if (!Fx(t)) throw Error(Ke(200));
  return jx(null, e, t, !0, n)
};
Wo.hydrateRoot = function (e, t, n) {
  if (!lT(e)) throw Error(Ke(405));
  var r = n != null && n.hydratedSources || null,
    i = !1,
    s = "",
    o = CU;
  if (n != null && (n.unstable_strictMode === !0 && (i = !0), n.identifierPrefix !== void 0 && (s = n.identifierPrefix), n.onRecoverableError !== void 0 && (o = n.onRecoverableError)), t = SU(t, null, e, 1, n ?? null, i, !1, s, o), e[su] = t.current, F1(e), r)
    for (e = 0; e < r.length; e++) n = r[e], i = n._getVersion, i = i(n._source), t.mutableSourceEagerHydrationData == null ? t.mutableSourceEagerHydrationData = [n, i] : t.mutableSourceEagerHydrationData.push(n, i);
  return new Bx(t)
};
Wo.render = function (e, t, n) {
  if (!Fx(t)) throw Error(Ke(200));
  return jx(null, e, t, !1, n)
};
Wo.unmountComponentAtNode = function (e) {
  if (!Fx(e)) throw Error(Ke(40));
  return e._reactRootContainer ? (Zf(function () {
    jx(null, null, e, !1, function () {
      e._reactRootContainer = null, e[su] = null
    })
  }), !0) : !1
};
Wo.unstable_batchedUpdates = nT;
Wo.unstable_renderSubtreeIntoContainer = function (e, t, n, r) {
  if (!Fx(n)) throw Error(Ke(200));
  if (e == null || e._reactInternals === void 0) throw Error(Ke(38));
  return jx(e, t, n, !1, r)
};
Wo.version = "18.2.0-next-9e3b772b8-20220608";

function AU() {
  if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try {
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(AU)
  } catch (e) {
    console.error(e)
  }
}
AU(), SF.exports = Wo;
var Ux = SF.exports;
const nb = Vo(Ux);
var zO = Ux;
V8.createRoot = zO.createRoot, V8.hydrateRoot = zO.hydrateRoot;
var uT = {},
  TU = {
    exports: {}
  };
(function (e) {
  function t(n) {
    return n && n.__esModule ? n : {
      default: n
    }
  }
  e.exports = t, e.exports.__esModule = !0, e.exports.default = e.exports
})(TU);
var Zt = TU.exports,
  nS = {};

function K() {
  return K = Object.assign ? Object.assign.bind() : function (e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
    }
    return e
  }, K.apply(this, arguments)
}
const Iae = Object.freeze(Object.defineProperty({
  __proto__: null,
  default: K
}, Symbol.toStringTag, {
  value: "Module"
}));

function Jl(e) {
  if (typeof e != "object" || e === null) return !1;
  const t = Object.getPrototypeOf(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e)
}

function kU(e) {
  if (!Jl(e)) return e;
  const t = {};
  return Object.keys(e).forEach(n => {
    t[n] = kU(e[n])
  }), t
}

function ks(e, t, n = {
  clone: !0
}) {
  const r = n.clone ? K({}, e) : e;
  return Jl(e) && Jl(t) && Object.keys(t).forEach(i => {
    i !== "__proto__" && (Jl(t[i]) && i in e && Jl(e[i]) ? r[i] = ks(e[i], t[i], n) : n.clone ? r[i] = Jl(t[i]) ? kU(t[i]) : t[i] : r[i] = t[i])
  }), r
}
const Pae = Object.freeze(Object.defineProperty({
  __proto__: null,
  default: ks,
  isPlainObject: Jl
}, Symbol.toStringTag, {
  value: "Module"
}));

function cu(e) {
  let t = "https://mui.com/production-error/?code=" + e;
  for (let n = 1; n < arguments.length; n += 1) t += "&args[]=" + encodeURIComponent(arguments[n]);
  return "Minified MUI error #" + e + "; visit " + t + " for the full message."
}
const Rae = Object.freeze(Object.defineProperty({
  __proto__: null,
  default: cu
}, Symbol.toStringTag, {
  value: "Module"
}));
var _U = {
    exports: {}
  },
  Kn = {};
/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var dT = Symbol.for("react.element"),
  fT = Symbol.for("react.portal"),
  zx = Symbol.for("react.fragment"),
  Hx = Symbol.for("react.strict_mode"),
  Vx = Symbol.for("react.profiler"),
  Wx = Symbol.for("react.provider"),
  qx = Symbol.for("react.context"),
  Oae = Symbol.for("react.server_context"),
  Gx = Symbol.for("react.forward_ref"),
  Kx = Symbol.for("react.suspense"),
  Qx = Symbol.for("react.suspense_list"),
  Yx = Symbol.for("react.memo"),
  Jx = Symbol.for("react.lazy"),
  Dae = Symbol.for("react.offscreen"),
  IU;
IU = Symbol.for("react.module.reference");

function $a(e) {
  if (typeof e == "object" && e !== null) {
    var t = e.$$typeof;
    switch (t) {
      case dT:
        switch (e = e.type, e) {
          case zx:
          case Vx:
          case Hx:
          case Kx:
          case Qx:
            return e;
          default:
            switch (e = e && e.$$typeof, e) {
              case Oae:
              case qx:
              case Gx:
              case Jx:
              case Yx:
              case Wx:
                return e;
              default:
                return t
            }
        }
        case fT:
          return t
    }
  }
}
Kn.ContextConsumer = qx;
Kn.ContextProvider = Wx;
Kn.Element = dT;
Kn.ForwardRef = Gx;
Kn.Fragment = zx;
Kn.Lazy = Jx;
Kn.Memo = Yx;
Kn.Portal = fT;
Kn.Profiler = Vx;
Kn.StrictMode = Hx;
Kn.Suspense = Kx;
Kn.SuspenseList = Qx;
Kn.isAsyncMode = function () {
  return !1
};
Kn.isConcurrentMode = function () {
  return !1
};
Kn.isContextConsumer = function (e) {
  return $a(e) === qx
};
Kn.isContextProvider = function (e) {
  return $a(e) === Wx
};
Kn.isElement = function (e) {
  return typeof e == "object" && e !== null && e.$$typeof === dT
};
Kn.isForwardRef = function (e) {
  return $a(e) === Gx
};
Kn.isFragment = function (e) {
  return $a(e) === zx
};
Kn.isLazy = function (e) {
  return $a(e) === Jx
};
Kn.isMemo = function (e) {
  return $a(e) === Yx
};
Kn.isPortal = function (e) {
  return $a(e) === fT
};
Kn.isProfiler = function (e) {
  return $a(e) === Vx
};
Kn.isStrictMode = function (e) {
  return $a(e) === Hx
};
Kn.isSuspense = function (e) {
  return $a(e) === Kx
};
Kn.isSuspenseList = function (e) {
  return $a(e) === Qx
};
Kn.isValidElementType = function (e) {
  return typeof e == "string" || typeof e == "function" || e === zx || e === Vx || e === Hx || e === Kx || e === Qx || e === Dae || typeof e == "object" && e !== null && (e.$$typeof === Jx || e.$$typeof === Yx || e.$$typeof === Wx || e.$$typeof === qx || e.$$typeof === Gx || e.$$typeof === IU || e.getModuleId !== void 0)
};
Kn.typeOf = $a;
_U.exports = Kn;
var HO = _U.exports;
const Nae = /^\s*function(?:\s|\s*\/\*.*\*\/\s*)+([^(\s/]*)\s*/;

function PU(e) {
  const t = `${e}`.match(Nae);
  return t && t[1] || ""
}

function RU(e, t = "") {
  return e.displayName || e.name || PU(e) || t
}

function VO(e, t, n) {
  const r = RU(t);
  return e.displayName || (r !== "" ? `${n}(${r})` : n)
}

function Mae(e) {
  if (e != null) {
    if (typeof e == "string") return e;
    if (typeof e == "function") return RU(e, "Component");
    if (typeof e == "object") switch (e.$$typeof) {
      case HO.ForwardRef:
        return VO(e, e.render, "ForwardRef");
      case HO.Memo:
        return VO(e, e.type, "memo");
      default:
        return
    }
  }
}
const $ae = Object.freeze(Object.defineProperty({
  __proto__: null,
  default: Mae,
  getFunctionName: PU
}, Symbol.toStringTag, {
  value: "Module"
}));

function qe(e) {
  if (typeof e != "string") throw new Error(cu(7));
  return e.charAt(0).toUpperCase() + e.slice(1)
}
const Lae = Object.freeze(Object.defineProperty({
  __proto__: null,
  default: qe
}, Symbol.toStringTag, {
  value: "Module"
}));

function LC(...e) {
  return e.reduce((t, n) => n == null ? t : function (...i) {
    t.apply(this, i), n.apply(this, i)
  }, () => {})
}

function um(e, t = 166) {
  let n;

  function r(...i) {
    const s = () => {
      e.apply(this, i)
    };
    clearTimeout(n), n = setTimeout(s, t)
  }
  return r.clear = () => {
    clearTimeout(n)
  }, r
}

function Bae(e, t) {
  return () => null
}

function g1(e, t) {
  var n, r;
  return j.isValidElement(e) && t.indexOf((n = e.type.muiName) != null ? n : (r = e.type) == null || (r = r._payload) == null || (r = r.value) == null ? void 0 : r.muiName) !== -1
}

function ji(e) {
  return e && e.ownerDocument || document
}

function _a(e) {
  return ji(e).defaultView || window
}

function Fae(e, t) {
  return () => null
}

function n3(e, t) {
  typeof e == "function" ? e(t) : e && (e.current = t)
}
const Os = typeof window < "u" ? j.useLayoutEffect : j.useEffect;
let WO = 0;

function jae(e) {
  const [t, n] = j.useState(e), r = e || t;
  return j.useEffect(() => {
    t == null && (WO += 1, n(`mui-${WO}`))
  }, [t]), r
}
const qO = Rw.useId;

function O2(e) {
  if (qO !== void 0) {
    const t = qO();
    return e ?? t
  }
  return jae(e)
}

function Uae(e, t, n, r, i) {
  return null
}

function K1({
  controlled: e,
  default: t,
  name: n,
  state: r = "value"
}) {
  const {
    current: i
  } = j.useRef(e !== void 0), [s, o] = j.useState(t), a = i ? e : s, c = j.useCallback(l => {
    i || o(l)
  }, []);
  return [a, c]
}

function Ea(e) {
  const t = j.useRef(e);
  return Os(() => {
    t.current = e
  }), j.useRef((...n) => (0, t.current)(...n)).current
}

function vr(...e) {
  return j.useMemo(() => e.every(t => t == null) ? null : t => {
    e.forEach(n => {
      n3(n, t)
    })
  }, e)
}
const GO = {};

function zae(e, t) {
  const n = j.useRef(GO);
  return n.current === GO && (n.current = e(t)), n
}
const Hae = [];

function Vae(e) {
  j.useEffect(e, Hae)
}
class D2 {
  constructor() {
    this.currentId = null, this.clear = () => {
      this.currentId !== null && (clearTimeout(this.currentId), this.currentId = null)
    }, this.disposeEffect = () => this.clear
  }
  static create() {
    return new D2
  }
  start(t, n) {
    this.clear(), this.currentId = setTimeout(() => {
      this.currentId = null, n()
    }, t)
  }
}

function Pf() {
  const e = zae(D2.create).current;
  return Vae(e.disposeEffect), e
}
let Xx = !0,
  BC = !1;
const Wae = new D2,
  qae = {
    text: !0,
    search: !0,
    url: !0,
    tel: !0,
    email: !0,
    password: !0,
    number: !0,
    date: !0,
    month: !0,
    week: !0,
    time: !0,
    datetime: !0,
    "datetime-local": !0
  };

function Gae(e) {
  const {
    type: t,
    tagName: n
  } = e;
  return !!(n === "INPUT" && qae[t] && !e.readOnly || n === "TEXTAREA" && !e.readOnly || e.isContentEditable)
}

function Kae(e) {
  e.metaKey || e.altKey || e.ctrlKey || (Xx = !0)
}

function rS() {
  Xx = !1
}

function Qae() {
  this.visibilityState === "hidden" && BC && (Xx = !0)
}

function Yae(e) {
  e.addEventListener("keydown", Kae, !0), e.addEventListener("mousedown", rS, !0), e.addEventListener("pointerdown", rS, !0), e.addEventListener("touchstart", rS, !0), e.addEventListener("visibilitychange", Qae, !0)
}

function Jae(e) {
  const {
    target: t
  } = e;
  try {
    return t.matches(":focus-visible")
  } catch {}
  return Xx || Gae(t)
}

function Zx() {
  const e = j.useCallback(i => {
      i != null && Yae(i.ownerDocument)
    }, []),
    t = j.useRef(!1);

  function n() {
    return t.current ? (BC = !0, Wae.start(100, () => {
      BC = !1
    }), t.current = !1, !0) : !1
  }

  function r(i) {
    return Jae(i) ? (t.current = !0, !0) : !1
  }
  return {
    isFocusVisibleRef: t,
    onFocus: r,
    onBlur: n,
    ref: e
  }
}

function OU(e) {
  const t = e.documentElement.clientWidth;
  return Math.abs(window.innerWidth - t)
}
let a0;

function DU() {
  if (a0) return a0;
  const e = document.createElement("div"),
    t = document.createElement("div");
  return t.style.width = "10px", t.style.height = "1px", e.appendChild(t), e.dir = "rtl", e.style.fontSize = "14px", e.style.width = "4px", e.style.height = "1px", e.style.position = "absolute", e.style.top = "-1000px", e.style.overflow = "scroll", document.body.appendChild(e), a0 = "reverse", e.scrollLeft > 0 ? a0 = "default" : (e.scrollLeft = 1, e.scrollLeft === 0 && (a0 = "negative")), document.body.removeChild(e), a0
}

function Xae(e, t) {
  const n = e.scrollLeft;
  if (t !== "rtl") return n;
  switch (DU()) {
    case "negative":
      return e.scrollWidth - e.clientWidth + n;
    case "reverse":
      return e.scrollWidth - e.clientWidth - n;
    default:
      return n
  }
}
const NU = e => {
  const t = j.useRef({});
  return j.useEffect(() => {
    t.current = e
  }), t.current
};

function Zae(e) {
  return j.Children.toArray(e).filter(t => j.isValidElement(t))
}

function N2(e, t) {
  const n = K({}, t);
  return Object.keys(e).forEach(r => {
    if (r.toString().match(/^(components|slots)$/)) n[r] = K({}, e[r], n[r]);
    else if (r.toString().match(/^(componentsProps|slotProps)$/)) {
      const i = e[r] || {},
        s = t[r];
      n[r] = {}, !s || !Object.keys(s) ? n[r] = i : !i || !Object.keys(i) ? n[r] = s : (n[r] = K({}, s), Object.keys(i).forEach(o => {
        n[r][o] = N2(i[o], s[o])
      }))
    } else n[r] === void 0 && (n[r] = e[r])
  }), n
}

function pt(e, t, n = void 0) {
  const r = {};
  return Object.keys(e).forEach(i => {
    r[i] = e[i].reduce((s, o) => {
      if (o) {
        const a = t(o);
        a !== "" && s.push(a), n && n[o] && s.push(n[o])
      }
      return s
    }, []).join(" ")
  }), r
}
const KO = e => e,
  ece = () => {
    let e = KO;
    return {
      configure(t) {
        e = t
      },
      generate(t) {
        return e(t)
      },
      reset() {
        e = KO
      }
    }
  },
  tce = ece(),
  hT = tce,
  MU = {
    active: "active",
    checked: "checked",
    completed: "completed",
    disabled: "disabled",
    error: "error",
    expanded: "expanded",
    focused: "focused",
    focusVisible: "focusVisible",
    open: "open",
    readOnly: "readOnly",
    required: "required",
    selected: "selected"
  };

function mt(e, t, n = "Mui") {
  const r = MU[t];
  return r ? `${n}-${r}` : `${hT.generate(e)}-${t}`
}

function gt(e, t, n = "Mui") {
  const r = {};
  return t.forEach(i => {
    r[i] = mt(e, i, n)
  }), r
}

function $U(e, t = Number.MIN_SAFE_INTEGER, n = Number.MAX_SAFE_INTEGER) {
  return Math.max(t, Math.min(e, n))
}
const nce = Object.freeze(Object.defineProperty({
  __proto__: null,
  default: $U
}, Symbol.toStringTag, {
  value: "Module"
}));

function Ve(e, t) {
  if (e == null) return {};
  var n = {},
    r = Object.keys(e),
    i, s;
  for (s = 0; s < r.length; s++) i = r[s], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n
}

function LU(e) {
  var t, n, r = "";
  if (typeof e == "string" || typeof e == "number") r += e;
  else if (typeof e == "object")
    if (Array.isArray(e)) {
      var i = e.length;
      for (t = 0; t < i; t++) e[t] && (n = LU(e[t])) && (r && (r += " "), r += n)
    } else
      for (n in e) e[n] && (r && (r += " "), r += n);
  return r
}

function Ye() {
  for (var e, t, n = 0, r = "", i = arguments.length; n < i; n++)(e = arguments[n]) && (t = LU(e)) && (r && (r += " "), r += t);
  return r
}

function BU(e) {
  const {
    theme: t,
    name: n,
    props: r
  } = e;
  return !t || !t.components || !t.components[n] || !t.components[n].defaultProps ? r : N2(t.components[n].defaultProps, r)
}
const rce = ["values", "unit", "step"],
  ice = e => {
    const t = Object.keys(e).map(n => ({
      key: n,
      val: e[n]
    })) || [];
    return t.sort((n, r) => n.val - r.val), t.reduce((n, r) => K({}, n, {
      [r.key]: r.val
    }), {})
  };

function FU(e) {
  const {
    values: t = {
      xs: 0,
      sm: 600,
      md: 900,
      lg: 1200,
      xl: 1536
    },
    unit: n = "px",
    step: r = 5
  } = e, i = Ve(e, rce), s = ice(t), o = Object.keys(s);

  function a(h) {
    return `@media (min-width:${typeof t[h]=="number"?t[h]:h}${n})`
  }

  function c(h) {
    return `@media (max-width:${(typeof t[h]=="number"?t[h]:h)-r/100}${n})`
  }

  function l(h, g) {
    const y = o.indexOf(g);
    return `@media (min-width:${typeof t[h]=="number"?t[h]:h}${n}) and (max-width:${(y!==-1&&typeof t[o[y]]=="number"?t[o[y]]:g)-r/100}${n})`
  }

  function u(h) {
    return o.indexOf(h) + 1 < o.length ? l(h, o[o.indexOf(h) + 1]) : a(h)
  }

  function f(h) {
    const g = o.indexOf(h);
    return g === 0 ? a(o[1]) : g === o.length - 1 ? c(o[g]) : l(h, o[o.indexOf(h) + 1]).replace("@media", "@media not all and")
  }
  return K({
    keys: o,
    values: s,
    up: a,
    down: c,
    between: l,
    only: u,
    not: f,
    unit: n
  }, i)
}
const sce = {
    borderRadius: 4
  },
  oce = sce;

function y1(e, t) {
  return t ? ks(e, t, {
    clone: !1
  }) : e
}
const pT = {
    xs: 0,
    sm: 600,
    md: 900,
    lg: 1200,
    xl: 1536
  },
  QO = {
    keys: ["xs", "sm", "md", "lg", "xl"],
    up: e => `@media (min-width:${pT[e]}px)`
  };

function Ec(e, t, n) {
  const r = e.theme || {};
  if (Array.isArray(t)) {
    const s = r.breakpoints || QO;
    return t.reduce((o, a, c) => (o[s.up(s.keys[c])] = n(t[c]), o), {})
  }
  if (typeof t == "object") {
    const s = r.breakpoints || QO;
    return Object.keys(t).reduce((o, a) => {
      if (Object.keys(s.values || pT).indexOf(a) !== -1) {
        const c = s.up(a);
        o[c] = n(t[a], a)
      } else {
        const c = a;
        o[c] = t[c]
      }
      return o
    }, {})
  }
  return n(t)
}

function jU(e = {}) {
  var t;
  return ((t = e.keys) == null ? void 0 : t.reduce((r, i) => {
    const s = e.up(i);
    return r[s] = {}, r
  }, {})) || {}
}

function UU(e, t) {
  return e.reduce((n, r) => {
    const i = n[r];
    return (!i || Object.keys(i).length === 0) && delete n[r], n
  }, t)
}

function ace(e, ...t) {
  const n = jU(e),
    r = [n, ...t].reduce((i, s) => ks(i, s), {});
  return UU(Object.keys(n), r)
}

function cce(e, t) {
  if (typeof e != "object") return {};
  const n = {},
    r = Object.keys(t);
  return Array.isArray(e) ? r.forEach((i, s) => {
    s < e.length && (n[i] = !0)
  }) : r.forEach(i => {
    e[i] != null && (n[i] = !0)
  }), n
}

function iS({
  values: e,
  breakpoints: t,
  base: n
}) {
  const r = n || cce(e, t),
    i = Object.keys(r);
  if (i.length === 0) return e;
  let s;
  return i.reduce((o, a, c) => (Array.isArray(e) ? (o[a] = e[c] != null ? e[c] : e[s], s = c) : typeof e == "object" ? (o[a] = e[a] != null ? e[a] : e[s], s = a) : o[a] = e, o), {})
}

function Tp(e, t, n = !0) {
  if (!t || typeof t != "string") return null;
  if (e && e.vars && n) {
    const r = `vars.${t}`.split(".").reduce((i, s) => i && i[s] ? i[s] : null, e);
    if (r != null) return r
  }
  return t.split(".").reduce((r, i) => r && r[i] != null ? r[i] : null, e)
}

function r3(e, t, n, r = n) {
  let i;
  return typeof e == "function" ? i = e(n) : Array.isArray(e) ? i = e[n] || r : i = Tp(e, n) || r, t && (i = t(i, r, e)), i
}

function Yr(e) {
  const {
    prop: t,
    cssProperty: n = e.prop,
    themeKey: r,
    transform: i
  } = e, s = o => {
    if (o[t] == null) return null;
    const a = o[t],
      c = o.theme,
      l = Tp(c, r) || {};
    return Ec(o, a, f => {
      let h = r3(l, i, f);
      return f === h && typeof f == "string" && (h = r3(l, i, `${t}${f==="default"?"":qe(f)}`, f)), n === !1 ? h : {
        [n]: h
      }
    })
  };
  return s.propTypes = {}, s.filterProps = [t], s
}

function lce(e) {
  const t = {};
  return n => (t[n] === void 0 && (t[n] = e(n)), t[n])
}
const uce = {
    m: "margin",
    p: "padding"
  },
  dce = {
    t: "Top",
    r: "Right",
    b: "Bottom",
    l: "Left",
    x: ["Left", "Right"],
    y: ["Top", "Bottom"]
  },
  YO = {
    marginX: "mx",
    marginY: "my",
    paddingX: "px",
    paddingY: "py"
  },
  fce = lce(e => {
    if (e.length > 2)
      if (YO[e]) e = YO[e];
      else return [e];
    const [t, n] = e.split(""), r = uce[t], i = dce[n] || "";
    return Array.isArray(i) ? i.map(s => r + s) : [r + i]
  }),
  mT = ["m", "mt", "mr", "mb", "ml", "mx", "my", "margin", "marginTop", "marginRight", "marginBottom", "marginLeft", "marginX", "marginY", "marginInline", "marginInlineStart", "marginInlineEnd", "marginBlock", "marginBlockStart", "marginBlockEnd"],
  gT = ["p", "pt", "pr", "pb", "pl", "px", "py", "padding", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "paddingX", "paddingY", "paddingInline", "paddingInlineStart", "paddingInlineEnd", "paddingBlock", "paddingBlockStart", "paddingBlockEnd"];
[...mT, ...gT];

function M2(e, t, n, r) {
  var i;
  const s = (i = Tp(e, t, !1)) != null ? i : n;
  return typeof s == "number" ? o => typeof o == "string" ? o : s * o : Array.isArray(s) ? o => typeof o == "string" ? o : s[o] : typeof s == "function" ? s : () => {}
}

function yT(e) {
  return M2(e, "spacing", 8)
}

function eh(e, t) {
  if (typeof t == "string" || t == null) return t;
  const n = Math.abs(t),
    r = e(n);
  return t >= 0 ? r : typeof r == "number" ? -r : `-${r}`
}

function hce(e, t) {
  return n => e.reduce((r, i) => (r[i] = eh(t, n), r), {})
}

function pce(e, t, n, r) {
  if (t.indexOf(n) === -1) return null;
  const i = fce(n),
    s = hce(i, r),
    o = e[n];
  return Ec(e, o, s)
}

function zU(e, t) {
  const n = yT(e.theme);
  return Object.keys(e).map(r => pce(e, t, r, n)).reduce(y1, {})
}

function Mr(e) {
  return zU(e, mT)
}
Mr.propTypes = {};
Mr.filterProps = mT;

function $r(e) {
  return zU(e, gT)
}
$r.propTypes = {};
$r.filterProps = gT;

function mce(e = 8) {
  if (e.mui) return e;
  const t = yT({
      spacing: e
    }),
    n = (...r) => (r.length === 0 ? [1] : r).map(s => {
      const o = t(s);
      return typeof o == "number" ? `${o}px` : o
    }).join(" ");
  return n.mui = !0, n
}

function e5(...e) {
  const t = e.reduce((r, i) => (i.filterProps.forEach(s => {
      r[s] = i
    }), r), {}),
    n = r => Object.keys(r).reduce((i, s) => t[s] ? y1(i, t[s](r)) : i, {});
  return n.propTypes = {}, n.filterProps = e.reduce((r, i) => r.concat(i.filterProps), []), n
}

function ba(e) {
  return typeof e != "number" ? e : `${e}px solid`
}

function La(e, t) {
  return Yr({
    prop: e,
    themeKey: "borders",
    transform: t
  })
}
const gce = La("border", ba),
  yce = La("borderTop", ba),
  vce = La("borderRight", ba),
  bce = La("borderBottom", ba),
  wce = La("borderLeft", ba),
  xce = La("borderColor"),
  Ece = La("borderTopColor"),
  Sce = La("borderRightColor"),
  Cce = La("borderBottomColor"),
  Ace = La("borderLeftColor"),
  Tce = La("outline", ba),
  kce = La("outlineColor"),
  t5 = e => {
    if (e.borderRadius !== void 0 && e.borderRadius !== null) {
      const t = M2(e.theme, "shape.borderRadius", 4),
        n = r => ({
          borderRadius: eh(t, r)
        });
      return Ec(e, e.borderRadius, n)
    }
    return null
  };
t5.propTypes = {};
t5.filterProps = ["borderRadius"];
e5(gce, yce, vce, bce, wce, xce, Ece, Sce, Cce, Ace, t5, Tce, kce);
const n5 = e => {
  if (e.gap !== void 0 && e.gap !== null) {
    const t = M2(e.theme, "spacing", 8),
      n = r => ({
        gap: eh(t, r)
      });
    return Ec(e, e.gap, n)
  }
  return null
};
n5.propTypes = {};
n5.filterProps = ["gap"];
const r5 = e => {
  if (e.columnGap !== void 0 && e.columnGap !== null) {
    const t = M2(e.theme, "spacing", 8),
      n = r => ({
        columnGap: eh(t, r)
      });
    return Ec(e, e.columnGap, n)
  }
  return null
};
r5.propTypes = {};
r5.filterProps = ["columnGap"];
const i5 = e => {
  if (e.rowGap !== void 0 && e.rowGap !== null) {
    const t = M2(e.theme, "spacing", 8),
      n = r => ({
        rowGap: eh(t, r)
      });
    return Ec(e, e.rowGap, n)
  }
  return null
};
i5.propTypes = {};
i5.filterProps = ["rowGap"];
const _ce = Yr({
    prop: "gridColumn"
  }),
  Ice = Yr({
    prop: "gridRow"
  }),
  Pce = Yr({
    prop: "gridAutoFlow"
  }),
  Rce = Yr({
    prop: "gridAutoColumns"
  }),
  Oce = Yr({
    prop: "gridAutoRows"
  }),
  Dce = Yr({
    prop: "gridTemplateColumns"
  }),
  Nce = Yr({
    prop: "gridTemplateRows"
  }),
  Mce = Yr({
    prop: "gridTemplateAreas"
  }),
  $ce = Yr({
    prop: "gridArea"
  });
e5(n5, r5, i5, _ce, Ice, Pce, Rce, Oce, Dce, Nce, Mce, $ce);

function cp(e, t) {
  return t === "grey" ? t : e
}
const Lce = Yr({
    prop: "color",
    themeKey: "palette",
    transform: cp
  }),
  Bce = Yr({
    prop: "bgcolor",
    cssProperty: "backgroundColor",
    themeKey: "palette",
    transform: cp
  }),
  Fce = Yr({
    prop: "backgroundColor",
    themeKey: "palette",
    transform: cp
  });
e5(Lce, Bce, Fce);

function No(e) {
  return e <= 1 && e !== 0 ? `${e*100}%` : e
}
const jce = Yr({
    prop: "width",
    transform: No
  }),
  vT = e => {
    if (e.maxWidth !== void 0 && e.maxWidth !== null) {
      const t = n => {
        var r, i;
        const s = ((r = e.theme) == null || (r = r.breakpoints) == null || (r = r.values) == null ? void 0 : r[n]) || pT[n];
        return s ? ((i = e.theme) == null || (i = i.breakpoints) == null ? void 0 : i.unit) !== "px" ? {
          maxWidth: `${s}${e.theme.breakpoints.unit}`
        } : {
          maxWidth: s
        } : {
          maxWidth: No(n)
        }
      };
      return Ec(e, e.maxWidth, t)
    }
    return null
  };
vT.filterProps = ["maxWidth"];
const Uce = Yr({
    prop: "minWidth",
    transform: No
  }),
  zce = Yr({
    prop: "height",
    transform: No
  }),
  Hce = Yr({
    prop: "maxHeight",
    transform: No
  }),
  Vce = Yr({
    prop: "minHeight",
    transform: No
  });
Yr({
  prop: "size",
  cssProperty: "width",
  transform: No
});
Yr({
  prop: "size",
  cssProperty: "height",
  transform: No
});
const Wce = Yr({
  prop: "boxSizing"
});
e5(jce, vT, Uce, zce, Hce, Vce, Wce);
const qce = {
    border: {
      themeKey: "borders",
      transform: ba
    },
    borderTop: {
      themeKey: "borders",
      transform: ba
    },
    borderRight: {
      themeKey: "borders",
      transform: ba
    },
    borderBottom: {
      themeKey: "borders",
      transform: ba
    },
    borderLeft: {
      themeKey: "borders",
      transform: ba
    },
    borderColor: {
      themeKey: "palette"
    },
    borderTopColor: {
      themeKey: "palette"
    },
    borderRightColor: {
      themeKey: "palette"
    },
    borderBottomColor: {
      themeKey: "palette"
    },
    borderLeftColor: {
      themeKey: "palette"
    },
    outline: {
      themeKey: "borders",
      transform: ba
    },
    outlineColor: {
      themeKey: "palette"
    },
    borderRadius: {
      themeKey: "shape.borderRadius",
      style: t5
    },
    color: {
      themeKey: "palette",
      transform: cp
    },
    bgcolor: {
      themeKey: "palette",
      cssProperty: "backgroundColor",
      transform: cp
    },
    backgroundColor: {
      themeKey: "palette",
      transform: cp
    },
    p: {
      style: $r
    },
    pt: {
      style: $r
    },
    pr: {
      style: $r
    },
    pb: {
      style: $r
    },
    pl: {
      style: $r
    },
    px: {
      style: $r
    },
    py: {
      style: $r
    },
    padding: {
      style: $r
    },
    paddingTop: {
      style: $r
    },
    paddingRight: {
      style: $r
    },
    paddingBottom: {
      style: $r
    },
    paddingLeft: {
      style: $r
    },
    paddingX: {
      style: $r
    },
    paddingY: {
      style: $r
    },
    paddingInline: {
      style: $r
    },
    paddingInlineStart: {
      style: $r
    },
    paddingInlineEnd: {
      style: $r
    },
    paddingBlock: {
      style: $r
    },
    paddingBlockStart: {
      style: $r
    },
    paddingBlockEnd: {
      style: $r
    },
    m: {
      style: Mr
    },
    mt: {
      style: Mr
    },
    mr: {
      style: Mr
    },
    mb: {
      style: Mr
    },
    ml: {
      style: Mr
    },
    mx: {
      style: Mr
    },
    my: {
      style: Mr
    },
    margin: {
      style: Mr
    },
    marginTop: {
      style: Mr
    },
    marginRight: {
      style: Mr
    },
    marginBottom: {
      style: Mr
    },
    marginLeft: {
      style: Mr
    },
    marginX: {
      style: Mr
    },
    marginY: {
      style: Mr
    },
    marginInline: {
      style: Mr
    },
    marginInlineStart: {
      style: Mr
    },
    marginInlineEnd: {
      style: Mr
    },
    marginBlock: {
      style: Mr
    },
    marginBlockStart: {
      style: Mr
    },
    marginBlockEnd: {
      style: Mr
    },
    displayPrint: {
      cssProperty: !1,
      transform: e => ({
        "@media print": {
          display: e
        }
      })
    },
    display: {},
    overflow: {},
    textOverflow: {},
    visibility: {},
    whiteSpace: {},
    flexBasis: {},
    flexDirection: {},
    flexWrap: {},
    justifyContent: {},
    alignItems: {},
    alignContent: {},
    order: {},
    flex: {},
    flexGrow: {},
    flexShrink: {},
    alignSelf: {},
    justifyItems: {},
    justifySelf: {},
    gap: {
      style: n5
    },
    rowGap: {
      style: i5
    },
    columnGap: {
      style: r5
    },
    gridColumn: {},
    gridRow: {},
    gridAutoFlow: {},
    gridAutoColumns: {},
    gridAutoRows: {},
    gridTemplateColumns: {},
    gridTemplateRows: {},
    gridTemplateAreas: {},
    gridArea: {},
    position: {},
    zIndex: {
      themeKey: "zIndex"
    },
    top: {},
    right: {},
    bottom: {},
    left: {},
    boxShadow: {
      themeKey: "shadows"
    },
    width: {
      transform: No
    },
    maxWidth: {
      style: vT
    },
    minWidth: {
      transform: No
    },
    height: {
      transform: No
    },
    maxHeight: {
      transform: No
    },
    minHeight: {
      transform: No
    },
    boxSizing: {},
    fontFamily: {
      themeKey: "typography"
    },
    fontSize: {
      themeKey: "typography"
    },
    fontStyle: {
      themeKey: "typography"
    },
    fontWeight: {
      themeKey: "typography"
    },
    letterSpacing: {},
    textTransform: {},
    lineHeight: {},
    textAlign: {},
    typography: {
      cssProperty: !1,
      themeKey: "typography"
    }
  },
  $2 = qce;

function Gce(...e) {
  const t = e.reduce((r, i) => r.concat(Object.keys(i)), []),
    n = new Set(t);
  return e.every(r => n.size === Object.keys(r).length)
}

function Kce(e, t) {
  return typeof e == "function" ? e(t) : e
}

function HU() {
  function e(n, r, i, s) {
    const o = {
        [n]: r,
        theme: i
      },
      a = s[n];
    if (!a) return {
      [n]: r
    };
    const {
      cssProperty: c = n,
      themeKey: l,
      transform: u,
      style: f
    } = a;
    if (r == null) return null;
    if (l === "typography" && r === "inherit") return {
      [n]: r
    };
    const h = Tp(i, l) || {};
    return f ? f(o) : Ec(o, r, y => {
      let x = r3(h, u, y);
      return y === x && typeof y == "string" && (x = r3(h, u, `${n}${y==="default"?"":qe(y)}`, y)), c === !1 ? x : {
        [c]: x
      }
    })
  }

  function t(n) {
    var r;
    const {
      sx: i,
      theme: s = {}
    } = n || {};
    if (!i) return null;
    const o = (r = s.unstable_sxConfig) != null ? r : $2;

    function a(c) {
      let l = c;
      if (typeof c == "function") l = c(s);
      else if (typeof c != "object") return c;
      if (!l) return null;
      const u = jU(s.breakpoints),
        f = Object.keys(u);
      let h = u;
      return Object.keys(l).forEach(g => {
        const y = Kce(l[g], s);
        if (y != null)
          if (typeof y == "object")
            if (o[g]) h = y1(h, e(g, y, s, o));
            else {
              const x = Ec({
                theme: s
              }, y, k => ({
                [g]: k
              }));
              Gce(x, y) ? h[g] = t({
                sx: y,
                theme: s
              }) : h = y1(h, x)
            }
        else h = y1(h, e(g, y, s, o))
      }), UU(f, h)
    }
    return Array.isArray(i) ? i.map(a) : a(i)
  }
  return t
}
const VU = HU();
VU.filterProps = ["sx"];
const L2 = VU;

function WU(e, t) {
  const n = this;
  return n.vars && typeof n.getColorSchemeSelector == "function" ? {
    [n.getColorSchemeSelector(e).replace(/(\[[^\]]+\])/, "*:where($1)")]: t
  } : n.palette.mode === e ? t : {}
}
const Qce = ["breakpoints", "palette", "spacing", "shape"];

function dm(e = {}, ...t) {
  const {
    breakpoints: n = {},
    palette: r = {},
    spacing: i,
    shape: s = {}
  } = e, o = Ve(e, Qce), a = FU(n), c = mce(i);
  let l = ks({
    breakpoints: a,
    direction: "ltr",
    components: {},
    palette: K({
      mode: "light"
    }, r),
    spacing: c,
    shape: K({}, oce, s)
  }, o);
  return l.applyStyles = WU, l = t.reduce((u, f) => ks(u, f), l), l.unstable_sxConfig = K({}, $2, o == null ? void 0 : o.unstable_sxConfig), l.unstable_sx = function (f) {
    return L2({
      sx: f,
      theme: this
    })
  }, l
}
const Yce = Object.freeze(Object.defineProperty({
  __proto__: null,
  default: dm,
  private_createBreakpoints: FU,
  unstable_applyStyles: WU
}, Symbol.toStringTag, {
  value: "Module"
}));

function qU(e) {
  var t = Object.create(null);
  return function (n) {
    return t[n] === void 0 && (t[n] = e(n)), t[n]
  }
}
var Jce = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/,
  Xce = qU(function (e) {
    return Jce.test(e) || e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && e.charCodeAt(2) < 91
  });

function Zce(e) {
  if (e.sheet) return e.sheet;
  for (var t = 0; t < document.styleSheets.length; t++)
    if (document.styleSheets[t].ownerNode === e) return document.styleSheets[t]
}

function ele(e) {
  var t = document.createElement("style");
  return t.setAttribute("data-emotion", e.key), e.nonce !== void 0 && t.setAttribute("nonce", e.nonce), t.appendChild(document.createTextNode("")), t.setAttribute("data-s", ""), t
}
var tle = function () {
    function e(n) {
      var r = this;
      this._insertTag = function (i) {
        var s;
        r.tags.length === 0 ? r.insertionPoint ? s = r.insertionPoint.nextSibling : r.prepend ? s = r.container.firstChild : s = r.before : s = r.tags[r.tags.length - 1].nextSibling, r.container.insertBefore(i, s), r.tags.push(i)
      }, this.isSpeedy = n.speedy === void 0 ? !0 : n.speedy, this.tags = [], this.ctr = 0, this.nonce = n.nonce, this.key = n.key, this.container = n.container, this.prepend = n.prepend, this.insertionPoint = n.insertionPoint, this.before = null
    }
    var t = e.prototype;
    return t.hydrate = function (r) {
      r.forEach(this._insertTag)
    }, t.insert = function (r) {
      this.ctr % (this.isSpeedy ? 65e3 : 1) === 0 && this._insertTag(ele(this));
      var i = this.tags[this.tags.length - 1];
      if (this.isSpeedy) {
        var s = Zce(i);
        try {
          s.insertRule(r, s.cssRules.length)
        } catch {}
      } else i.appendChild(document.createTextNode(r));
      this.ctr++
    }, t.flush = function () {
      this.tags.forEach(function (r) {
        return r.parentNode && r.parentNode.removeChild(r)
      }), this.tags = [], this.ctr = 0
    }, e
  }(),
  es = "-ms-",
  i3 = "-moz-",
  Bn = "-webkit-",
  GU = "comm",
  bT = "rule",
  wT = "decl",
  nle = "@import",
  KU = "@keyframes",
  rle = "@layer",
  ile = Math.abs,
  s5 = String.fromCharCode,
  sle = Object.assign;

function ole(e, t) {
  return Li(e, 0) ^ 45 ? (((t << 2 ^ Li(e, 0)) << 2 ^ Li(e, 1)) << 2 ^ Li(e, 2)) << 2 ^ Li(e, 3) : 0
}

function QU(e) {
  return e.trim()
}

function ale(e, t) {
  return (e = t.exec(e)) ? e[0] : e
}

function Fn(e, t, n) {
  return e.replace(t, n)
}

function FC(e, t) {
  return e.indexOf(t)
}

function Li(e, t) {
  return e.charCodeAt(t) | 0
}

function Q1(e, t, n) {
  return e.slice(t, n)
}

function Vc(e) {
  return e.length
}

function xT(e) {
  return e.length
}

function rb(e, t) {
  return t.push(e), e
}

function cle(e, t) {
  return e.map(t).join("")
}
var o5 = 1,
  kp = 1,
  YU = 0,
  uo = 0,
  ni = 0,
  fm = "";

function a5(e, t, n, r, i, s, o) {
  return {
    value: e,
    root: t,
    parent: n,
    type: r,
    props: i,
    children: s,
    line: o5,
    column: kp,
    length: o,
    return: ""
  }
}

function xg(e, t) {
  return sle(a5("", null, null, "", null, null, 0), e, {
    length: -e.length
  }, t)
}

function lle() {
  return ni
}

function ule() {
  return ni = uo > 0 ? Li(fm, --uo) : 0, kp--, ni === 10 && (kp = 1, o5--), ni
}

function jo() {
  return ni = uo < YU ? Li(fm, uo++) : 0, kp++, ni === 10 && (kp = 1, o5++), ni
}

function il() {
  return Li(fm, uo)
}

function aw() {
  return uo
}

function B2(e, t) {
  return Q1(fm, e, t)
}

function Y1(e) {
  switch (e) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1
  }
  return 0
}

function JU(e) {
  return o5 = kp = 1, YU = Vc(fm = e), uo = 0, []
}

function XU(e) {
  return fm = "", e
}

function cw(e) {
  return QU(B2(uo - 1, jC(e === 91 ? e + 2 : e === 40 ? e + 1 : e)))
}

function dle(e) {
  for (;
    (ni = il()) && ni < 33;) jo();
  return Y1(e) > 2 || Y1(ni) > 3 ? "" : " "
}

function fle(e, t) {
  for (; --t && jo() && !(ni < 48 || ni > 102 || ni > 57 && ni < 65 || ni > 70 && ni < 97););
  return B2(e, aw() + (t < 6 && il() == 32 && jo() == 32))
}

function jC(e) {
  for (; jo();) switch (ni) {
    case e:
      return uo;
    case 34:
    case 39:
      e !== 34 && e !== 39 && jC(ni);
      break;
    case 40:
      e === 41 && jC(e);
      break;
    case 92:
      jo();
      break
  }
  return uo
}

function hle(e, t) {
  for (; jo() && e + ni !== 57;)
    if (e + ni === 84 && il() === 47) break;
  return "/*" + B2(t, uo - 1) + "*" + s5(e === 47 ? e : jo())
}

function ple(e) {
  for (; !Y1(il());) jo();
  return B2(e, uo)
}

function mle(e) {
  return XU(lw("", null, null, null, [""], e = JU(e), 0, [0], e))
}

function lw(e, t, n, r, i, s, o, a, c) {
  for (var l = 0, u = 0, f = o, h = 0, g = 0, y = 0, x = 1, k = 1, _ = 1, p = 0, v = "", S = i, I = s, A = r, w = v; k;) switch (y = p, p = jo()) {
    case 40:
      if (y != 108 && Li(w, f - 1) == 58) {
        FC(w += Fn(cw(p), "&", "&\f"), "&\f") != -1 && (_ = -1);
        break
      }
      case 34:
      case 39:
      case 91:
        w += cw(p);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        w += dle(y);
        break;
      case 92:
        w += fle(aw() - 1, 7);
        continue;
      case 47:
        switch (il()) {
          case 42:
          case 47:
            rb(gle(hle(jo(), aw()), t, n), c);
            break;
          default:
            w += "/"
        }
        break;
      case 123 * x:
        a[l++] = Vc(w) * _;
      case 125 * x:
      case 59:
      case 0:
        switch (p) {
          case 0:
          case 125:
            k = 0;
          case 59 + u:
            _ == -1 && (w = Fn(w, /\f/g, "")), g > 0 && Vc(w) - f && rb(g > 32 ? XO(w + ";", r, n, f - 1) : XO(Fn(w, " ", "") + ";", r, n, f - 2), c);
            break;
          case 59:
            w += ";";
          default:
            if (rb(A = JO(w, t, n, l, u, i, a, v, S = [], I = [], f), s), p === 123)
              if (u === 0) lw(w, t, A, A, S, s, f, a, I);
              else switch (h === 99 && Li(w, 3) === 110 ? 100 : h) {
                case 100:
                case 108:
                case 109:
                case 115:
                  lw(e, A, A, r && rb(JO(e, A, A, 0, 0, i, a, v, i, S = [], f), I), i, I, f, a, r ? S : I);
                  break;
                default:
                  lw(w, A, A, A, [""], I, 0, a, I)
              }
        }
        l = u = g = 0, x = _ = 1, v = w = "", f = o;
        break;
      case 58:
        f = 1 + Vc(w), g = y;
      default:
        if (x < 1) {
          if (p == 123) --x;
          else if (p == 125 && x++ == 0 && ule() == 125) continue
        }
        switch (w += s5(p), p * x) {
          case 38:
            _ = u > 0 ? 1 : (w += "\f", -1);
            break;
          case 44:
            a[l++] = (Vc(w) - 1) * _, _ = 1;
            break;
          case 64:
            il() === 45 && (w += cw(jo())), h = il(), u = f = Vc(v = w += ple(aw())), p++;
            break;
          case 45:
            y === 45 && Vc(w) == 2 && (x = 0)
        }
  }
  return s
}

function JO(e, t, n, r, i, s, o, a, c, l, u) {
  for (var f = i - 1, h = i === 0 ? s : [""], g = xT(h), y = 0, x = 0, k = 0; y < r; ++y)
    for (var _ = 0, p = Q1(e, f + 1, f = ile(x = o[y])), v = e; _ < g; ++_)(v = QU(x > 0 ? h[_] + " " + p : Fn(p, /&\f/g, h[_]))) && (c[k++] = v);
  return a5(e, t, n, i === 0 ? bT : a, c, l, u)
}

function gle(e, t, n) {
  return a5(e, t, n, GU, s5(lle()), Q1(e, 2, -2), 0)
}

function XO(e, t, n, r) {
  return a5(e, t, n, wT, Q1(e, 0, r), Q1(e, r + 1, -1), r)
}

function lp(e, t) {
  for (var n = "", r = xT(e), i = 0; i < r; i++) n += t(e[i], i, e, t) || "";
  return n
}

function yle(e, t, n, r) {
  switch (e.type) {
    case rle:
      if (e.children.length) break;
    case nle:
    case wT:
      return e.return = e.return || e.value;
    case GU:
      return "";
    case KU:
      return e.return = e.value + "{" + lp(e.children, r) + "}";
    case bT:
      e.value = e.props.join(",")
  }
  return Vc(n = lp(e.children, r)) ? e.return = e.value + "{" + n + "}" : ""
}

function vle(e) {
  var t = xT(e);
  return function (n, r, i, s) {
    for (var o = "", a = 0; a < t; a++) o += e[a](n, r, i, s) || "";
    return o
  }
}

function ble(e) {
  return function (t) {
    t.root || (t = t.return) && e(t)
  }
}
var wle = function (t, n, r) {
    for (var i = 0, s = 0; i = s, s = il(), i === 38 && s === 12 && (n[r] = 1), !Y1(s);) jo();
    return B2(t, uo)
  },
  xle = function (t, n) {
    var r = -1,
      i = 44;
    do switch (Y1(i)) {
      case 0:
        i === 38 && il() === 12 && (n[r] = 1), t[r] += wle(uo - 1, n, r);
        break;
      case 2:
        t[r] += cw(i);
        break;
      case 4:
        if (i === 44) {
          t[++r] = il() === 58 ? "&\f" : "", n[r] = t[r].length;
          break
        }
        default:
          t[r] += s5(i)
    }
    while (i = jo());
    return t
  },
  Ele = function (t, n) {
    return XU(xle(JU(t), n))
  },
  ZO = new WeakMap,
  Sle = function (t) {
    if (!(t.type !== "rule" || !t.parent || t.length < 1)) {
      for (var n = t.value, r = t.parent, i = t.column === r.column && t.line === r.line; r.type !== "rule";)
        if (r = r.parent, !r) return;
      if (!(t.props.length === 1 && n.charCodeAt(0) !== 58 && !ZO.get(r)) && !i) {
        ZO.set(t, !0);
        for (var s = [], o = Ele(n, s), a = r.props, c = 0, l = 0; c < o.length; c++)
          for (var u = 0; u < a.length; u++, l++) t.props[l] = s[c] ? o[c].replace(/&\f/g, a[u]) : a[u] + " " + o[c]
      }
    }
  },
  Cle = function (t) {
    if (t.type === "decl") {
      var n = t.value;
      n.charCodeAt(0) === 108 && n.charCodeAt(2) === 98 && (t.return = "", t.value = "")
    }
  };

function ZU(e, t) {
  switch (ole(e, t)) {
    case 5103:
      return Bn + "print-" + e + e;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return Bn + e + e;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return Bn + e + i3 + e + es + e + e;
    case 6828:
    case 4268:
      return Bn + e + es + e + e;
    case 6165:
      return Bn + e + es + "flex-" + e + e;
    case 5187:
      return Bn + e + Fn(e, /(\w+).+(:[^]+)/, Bn + "box-$1$2" + es + "flex-$1$2") + e;
    case 5443:
      return Bn + e + es + "flex-item-" + Fn(e, /flex-|-self/, "") + e;
    case 4675:
      return Bn + e + es + "flex-line-pack" + Fn(e, /align-content|flex-|-self/, "") + e;
    case 5548:
      return Bn + e + es + Fn(e, "shrink", "negative") + e;
    case 5292:
      return Bn + e + es + Fn(e, "basis", "preferred-size") + e;
    case 6060:
      return Bn + "box-" + Fn(e, "-grow", "") + Bn + e + es + Fn(e, "grow", "positive") + e;
    case 4554:
      return Bn + Fn(e, /([^-])(transform)/g, "$1" + Bn + "$2") + e;
    case 6187:
      return Fn(Fn(Fn(e, /(zoom-|grab)/, Bn + "$1"), /(image-set)/, Bn + "$1"), e, "") + e;
    case 5495:
    case 3959:
      return Fn(e, /(image-set\([^]*)/, Bn + "$1$`$1");
    case 4968:
      return Fn(Fn(e, /(.+:)(flex-)?(.*)/, Bn + "box-pack:$3" + es + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + Bn + e + e;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return Fn(e, /(.+)-inline(.+)/, Bn + "$1$2") + e;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (Vc(e) - 1 - t > 6) switch (Li(e, t + 1)) {
        case 109:
          if (Li(e, t + 4) !== 45) break;
        case 102:
          return Fn(e, /(.+:)(.+)-([^]+)/, "$1" + Bn + "$2-$3$1" + i3 + (Li(e, t + 3) == 108 ? "$3" : "$2-$3")) + e;
        case 115:
          return ~FC(e, "stretch") ? ZU(Fn(e, "stretch", "fill-available"), t) + e : e
      }
      break;
    case 4949:
      if (Li(e, t + 1) !== 115) break;
    case 6444:
      switch (Li(e, Vc(e) - 3 - (~FC(e, "!important") && 10))) {
        case 107:
          return Fn(e, ":", ":" + Bn) + e;
        case 101:
          return Fn(e, /(.+:)([^;!]+)(;|!.+)?/, "$1" + Bn + (Li(e, 14) === 45 ? "inline-" : "") + "box$3$1" + Bn + "$2$3$1" + es + "$2box$3") + e
      }
      break;
    case 5936:
      switch (Li(e, t + 11)) {
        case 114:
          return Bn + e + es + Fn(e, /[svh]\w+-[tblr]{2}/, "tb") + e;
        case 108:
          return Bn + e + es + Fn(e, /[svh]\w+-[tblr]{2}/, "tb-rl") + e;
        case 45:
          return Bn + e + es + Fn(e, /[svh]\w+-[tblr]{2}/, "lr") + e
      }
      return Bn + e + es + e + e
  }
  return e
}
var Ale = function (t, n, r, i) {
    if (t.length > -1 && !t.return) switch (t.type) {
      case wT:
        t.return = ZU(t.value, t.length);
        break;
      case KU:
        return lp([xg(t, {
          value: Fn(t.value, "@", "@" + Bn)
        })], i);
      case bT:
        if (t.length) return cle(t.props, function (s) {
          switch (ale(s, /(::plac\w+|:read-\w+)/)) {
            case ":read-only":
            case ":read-write":
              return lp([xg(t, {
                props: [Fn(s, /:(read-\w+)/, ":" + i3 + "$1")]
              })], i);
            case "::placeholder":
              return lp([xg(t, {
                props: [Fn(s, /:(plac\w+)/, ":" + Bn + "input-$1")]
              }), xg(t, {
                props: [Fn(s, /:(plac\w+)/, ":" + i3 + "$1")]
              }), xg(t, {
                props: [Fn(s, /:(plac\w+)/, es + "input-$1")]
              })], i)
          }
          return ""
        })
    }
  },
  Tle = [Ale],
  ez = function (t) {
    var n = t.key;
    if (n === "css") {
      var r = document.querySelectorAll("style[data-emotion]:not([data-s])");
      Array.prototype.forEach.call(r, function (x) {
        var k = x.getAttribute("data-emotion");
        k.indexOf(" ") !== -1 && (document.head.appendChild(x), x.setAttribute("data-s", ""))
      })
    }
    var i = t.stylisPlugins || Tle,
      s = {},
      o, a = [];
    o = t.container || document.head, Array.prototype.forEach.call(document.querySelectorAll('style[data-emotion^="' + n + ' "]'), function (x) {
      for (var k = x.getAttribute("data-emotion").split(" "), _ = 1; _ < k.length; _++) s[k[_]] = !0;
      a.push(x)
    });
    var c, l = [Sle, Cle]; {
      var u, f = [yle, ble(function (x) {
          u.insert(x)
        })],
        h = vle(l.concat(i, f)),
        g = function (k) {
          return lp(mle(k), h)
        };
      c = function (k, _, p, v) {
        u = p, g(k ? k + "{" + _.styles + "}" : _.styles), v && (y.inserted[_.name] = !0)
      }
    }
    var y = {
      key: n,
      sheet: new tle({
        key: n,
        container: o,
        nonce: t.nonce,
        speedy: t.speedy,
        prepend: t.prepend,
        insertionPoint: t.insertionPoint
      }),
      nonce: t.nonce,
      inserted: s,
      registered: {},
      insert: c
    };
    return y.sheet.hydrate(a), y
  },
  tz = {
    exports: {}
  },
  Qn = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Ii = typeof Symbol == "function" && Symbol.for,
  ET = Ii ? Symbol.for("react.element") : 60103,
  ST = Ii ? Symbol.for("react.portal") : 60106,
  c5 = Ii ? Symbol.for("react.fragment") : 60107,
  l5 = Ii ? Symbol.for("react.strict_mode") : 60108,
  u5 = Ii ? Symbol.for("react.profiler") : 60114,
  d5 = Ii ? Symbol.for("react.provider") : 60109,
  f5 = Ii ? Symbol.for("react.context") : 60110,
  CT = Ii ? Symbol.for("react.async_mode") : 60111,
  h5 = Ii ? Symbol.for("react.concurrent_mode") : 60111,
  p5 = Ii ? Symbol.for("react.forward_ref") : 60112,
  m5 = Ii ? Symbol.for("react.suspense") : 60113,
  kle = Ii ? Symbol.for("react.suspense_list") : 60120,
  g5 = Ii ? Symbol.for("react.memo") : 60115,
  y5 = Ii ? Symbol.for("react.lazy") : 60116,
  _le = Ii ? Symbol.for("react.block") : 60121,
  Ile = Ii ? Symbol.for("react.fundamental") : 60117,
  Ple = Ii ? Symbol.for("react.responder") : 60118,
  Rle = Ii ? Symbol.for("react.scope") : 60119;

function Go(e) {
  if (typeof e == "object" && e !== null) {
    var t = e.$$typeof;
    switch (t) {
      case ET:
        switch (e = e.type, e) {
          case CT:
          case h5:
          case c5:
          case u5:
          case l5:
          case m5:
            return e;
          default:
            switch (e = e && e.$$typeof, e) {
              case f5:
              case p5:
              case y5:
              case g5:
              case d5:
                return e;
              default:
                return t
            }
        }
        case ST:
          return t
    }
  }
}

function nz(e) {
  return Go(e) === h5
}
Qn.AsyncMode = CT;
Qn.ConcurrentMode = h5;
Qn.ContextConsumer = f5;
Qn.ContextProvider = d5;
Qn.Element = ET;
Qn.ForwardRef = p5;
Qn.Fragment = c5;
Qn.Lazy = y5;
Qn.Memo = g5;
Qn.Portal = ST;
Qn.Profiler = u5;
Qn.StrictMode = l5;
Qn.Suspense = m5;
Qn.isAsyncMode = function (e) {
  return nz(e) || Go(e) === CT
};
Qn.isConcurrentMode = nz;
Qn.isContextConsumer = function (e) {
  return Go(e) === f5
};
Qn.isContextProvider = function (e) {
  return Go(e) === d5
};
Qn.isElement = function (e) {
  return typeof e == "object" && e !== null && e.$$typeof === ET
};
Qn.isForwardRef = function (e) {
  return Go(e) === p5
};
Qn.isFragment = function (e) {
  return Go(e) === c5
};
Qn.isLazy = function (e) {
  return Go(e) === y5
};
Qn.isMemo = function (e) {
  return Go(e) === g5
};
Qn.isPortal = function (e) {
  return Go(e) === ST
};
Qn.isProfiler = function (e) {
  return Go(e) === u5
};
Qn.isStrictMode = function (e) {
  return Go(e) === l5
};
Qn.isSuspense = function (e) {
  return Go(e) === m5
};
Qn.isValidElementType = function (e) {
  return typeof e == "string" || typeof e == "function" || e === c5 || e === h5 || e === u5 || e === l5 || e === m5 || e === kle || typeof e == "object" && e !== null && (e.$$typeof === y5 || e.$$typeof === g5 || e.$$typeof === d5 || e.$$typeof === f5 || e.$$typeof === p5 || e.$$typeof === Ile || e.$$typeof === Ple || e.$$typeof === Rle || e.$$typeof === _le)
};
Qn.typeOf = Go;
tz.exports = Qn;
var Ole = tz.exports,
  rz = Ole,
  Dle = {
    $$typeof: !0,
    render: !0,
    defaultProps: !0,
    displayName: !0,
    propTypes: !0
  },
  Nle = {
    $$typeof: !0,
    compare: !0,
    defaultProps: !0,
    displayName: !0,
    propTypes: !0,
    type: !0
  },
  iz = {};
iz[rz.ForwardRef] = Dle;
iz[rz.Memo] = Nle;
var Mle = !0;

function $le(e, t, n) {
  var r = "";
  return n.split(" ").forEach(function (i) {
    e[i] !== void 0 ? t.push(e[i] + ";") : r += i + " "
  }), r
}
var sz = function (t, n, r) {
    var i = t.key + "-" + n.name;
    (r === !1 || Mle === !1) && t.registered[i] === void 0 && (t.registered[i] = n.styles)
  },
  oz = function (t, n, r) {
    sz(t, n, r);
    var i = t.key + "-" + n.name;
    if (t.inserted[n.name] === void 0) {
      var s = n;
      do t.insert(n === s ? "." + i : "", s, t.sheet, !0), s = s.next; while (s !== void 0)
    }
  };

function Lle(e) {
  for (var t = 0, n, r = 0, i = e.length; i >= 4; ++r, i -= 4) n = e.charCodeAt(r) & 255 | (e.charCodeAt(++r) & 255) << 8 | (e.charCodeAt(++r) & 255) << 16 | (e.charCodeAt(++r) & 255) << 24, n = (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16), n ^= n >>> 24, t = (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16) ^ (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
  switch (i) {
    case 3:
      t ^= (e.charCodeAt(r + 2) & 255) << 16;
    case 2:
      t ^= (e.charCodeAt(r + 1) & 255) << 8;
    case 1:
      t ^= e.charCodeAt(r) & 255, t = (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16)
  }
  return t ^= t >>> 13, t = (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16), ((t ^ t >>> 15) >>> 0).toString(36)
}
var Ble = {
    animationIterationCount: 1,
    aspectRatio: 1,
    borderImageOutset: 1,
    borderImageSlice: 1,
    borderImageWidth: 1,
    boxFlex: 1,
    boxFlexGroup: 1,
    boxOrdinalGroup: 1,
    columnCount: 1,
    columns: 1,
    flex: 1,
    flexGrow: 1,
    flexPositive: 1,
    flexShrink: 1,
    flexNegative: 1,
    flexOrder: 1,
    gridRow: 1,
    gridRowEnd: 1,
    gridRowSpan: 1,
    gridRowStart: 1,
    gridColumn: 1,
    gridColumnEnd: 1,
    gridColumnSpan: 1,
    gridColumnStart: 1,
    msGridRow: 1,
    msGridRowSpan: 1,
    msGridColumn: 1,
    msGridColumnSpan: 1,
    fontWeight: 1,
    lineHeight: 1,
    opacity: 1,
    order: 1,
    orphans: 1,
    tabSize: 1,
    widows: 1,
    zIndex: 1,
    zoom: 1,
    WebkitLineClamp: 1,
    fillOpacity: 1,
    floodOpacity: 1,
    stopOpacity: 1,
    strokeDasharray: 1,
    strokeDashoffset: 1,
    strokeMiterlimit: 1,
    strokeOpacity: 1,
    strokeWidth: 1
  },
  Fle = /[A-Z]|^ms/g,
  jle = /_EMO_([^_]+?)_([^]*?)_EMO_/g,
  az = function (t) {
    return t.charCodeAt(1) === 45
  },
  eD = function (t) {
    return t != null && typeof t != "boolean"
  },
  sS = qU(function (e) {
    return az(e) ? e : e.replace(Fle, "-$&").toLowerCase()
  }),
  tD = function (t, n) {
    switch (t) {
      case "animation":
      case "animationName":
        if (typeof n == "string") return n.replace(jle, function (r, i, s) {
          return Wc = {
            name: i,
            styles: s,
            next: Wc
          }, i
        })
    }
    return Ble[t] !== 1 && !az(t) && typeof n == "number" && n !== 0 ? n + "px" : n
  };

function J1(e, t, n) {
  if (n == null) return "";
  if (n.__emotion_styles !== void 0) return n;
  switch (typeof n) {
    case "boolean":
      return "";
    case "object": {
      if (n.anim === 1) return Wc = {
        name: n.name,
        styles: n.styles,
        next: Wc
      }, n.name;
      if (n.styles !== void 0) {
        var r = n.next;
        if (r !== void 0)
          for (; r !== void 0;) Wc = {
            name: r.name,
            styles: r.styles,
            next: Wc
          }, r = r.next;
        var i = n.styles + ";";
        return i
      }
      return Ule(e, t, n)
    }
    case "function": {
      if (e !== void 0) {
        var s = Wc,
          o = n(e);
        return Wc = s, J1(e, t, o)
      }
      break
    }
  }
  if (t == null) return n;
  var a = t[n];
  return a !== void 0 ? a : n
}

function Ule(e, t, n) {
  var r = "";
  if (Array.isArray(n))
    for (var i = 0; i < n.length; i++) r += J1(e, t, n[i]) + ";";
  else
    for (var s in n) {
      var o = n[s];
      if (typeof o != "object") t != null && t[o] !== void 0 ? r += s + "{" + t[o] + "}" : eD(o) && (r += sS(s) + ":" + tD(s, o) + ";");
      else if (Array.isArray(o) && typeof o[0] == "string" && (t == null || t[o[0]] === void 0))
        for (var a = 0; a < o.length; a++) eD(o[a]) && (r += sS(s) + ":" + tD(s, o[a]) + ";");
      else {
        var c = J1(e, t, o);
        switch (s) {
          case "animation":
          case "animationName": {
            r += sS(s) + ":" + c + ";";
            break
          }
          default:
            r += s + "{" + c + "}"
        }
      }
    }
  return r
}
var nD = /label:\s*([^\s;\n{]+)\s*(;|$)/g,
  Wc, AT = function (t, n, r) {
    if (t.length === 1 && typeof t[0] == "object" && t[0] !== null && t[0].styles !== void 0) return t[0];
    var i = !0,
      s = "";
    Wc = void 0;
    var o = t[0];
    o == null || o.raw === void 0 ? (i = !1, s += J1(r, n, o)) : s += o[0];
    for (var a = 1; a < t.length; a++) s += J1(r, n, t[a]), i && (s += o[a]);
    nD.lastIndex = 0;
    for (var c = "", l;
      (l = nD.exec(s)) !== null;) c += "-" + l[1];
    var u = Lle(s) + c;
    return {
      name: u,
      styles: s,
      next: Wc
    }
  },
  zle = function (t) {
    return t()
  },
  cz = Rw.useInsertionEffect ? Rw.useInsertionEffect : !1,
  Hle = cz || zle,
  rD = cz || j.useLayoutEffect,
  lz = j.createContext(typeof HTMLElement < "u" ? ez({
    key: "css"
  }) : null),
  Vle = lz.Provider,
  uz = function (t) {
    return j.forwardRef(function (n, r) {
      var i = j.useContext(lz);
      return t(n, i, r)
    })
  },
  F2 = j.createContext({}),
  Wle = uz(function (e, t) {
    var n = e.styles,
      r = AT([n], void 0, j.useContext(F2)),
      i = j.useRef();
    return rD(function () {
      var s = t.key + "-global",
        o = new t.sheet.constructor({
          key: s,
          nonce: t.sheet.nonce,
          container: t.sheet.container,
          speedy: t.sheet.isSpeedy
        }),
        a = !1,
        c = document.querySelector('style[data-emotion="' + s + " " + r.name + '"]');
      return t.sheet.tags.length && (o.before = t.sheet.tags[0]), c !== null && (a = !0, c.setAttribute("data-emotion", s), o.hydrate([c])), i.current = [o, a],
        function () {
          o.flush()
        }
    }, [t]), rD(function () {
      var s = i.current,
        o = s[0],
        a = s[1];
      if (a) {
        s[1] = !1;
        return
      }
      if (r.next !== void 0 && oz(t, r.next, !0), o.tags.length) {
        var c = o.tags[o.tags.length - 1].nextElementSibling;
        o.before = c, o.flush()
      }
      t.insert("", r, o, !1)
    }, [t, r.name]), null
  });

function th() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
  return AT(t)
}
var yl = function () {
    var t = th.apply(void 0, arguments),
      n = "animation-" + t.name;
    return {
      name: n,
      styles: "@keyframes " + n + "{" + t.styles + "}",
      anim: 1,
      toString: function () {
        return "_EMO_" + this.name + "_" + this.styles + "_EMO_"
      }
    }
  },
  qle = Xce,
  Gle = function (t) {
    return t !== "theme"
  },
  iD = function (t) {
    return typeof t == "string" && t.charCodeAt(0) > 96 ? qle : Gle
  },
  sD = function (t, n, r) {
    var i;
    if (n) {
      var s = n.shouldForwardProp;
      i = t.__emotion_forwardProp && s ? function (o) {
        return t.__emotion_forwardProp(o) && s(o)
      } : s
    }
    return typeof i != "function" && r && (i = t.__emotion_forwardProp), i
  },
  Kle = function (t) {
    var n = t.cache,
      r = t.serialized,
      i = t.isStringTag;
    return sz(n, r, i), Hle(function () {
      return oz(n, r, i)
    }), null
  },
  Qle = function e(t, n) {
    var r = t.__emotion_real === t,
      i = r && t.__emotion_base || t,
      s, o;
    n !== void 0 && (s = n.label, o = n.target);
    var a = sD(t, n, r),
      c = a || iD(i),
      l = !c("as");
    return function () {
      var u = arguments,
        f = r && t.__emotion_styles !== void 0 ? t.__emotion_styles.slice(0) : [];
      if (s !== void 0 && f.push("label:" + s + ";"), u[0] == null || u[0].raw === void 0) f.push.apply(f, u);
      else {
        f.push(u[0][0]);
        for (var h = u.length, g = 1; g < h; g++) f.push(u[g], u[0][g])
      }
      var y = uz(function (x, k, _) {
        var p = l && x.as || i,
          v = "",
          S = [],
          I = x;
        if (x.theme == null) {
          I = {};
          for (var A in x) I[A] = x[A];
          I.theme = j.useContext(F2)
        }
        typeof x.className == "string" ? v = $le(k.registered, S, x.className) : x.className != null && (v = x.className + " ");
        var w = AT(f.concat(S), k.registered, I);
        v += k.key + "-" + w.name, o !== void 0 && (v += " " + o);
        var E = l && a === void 0 ? iD(p) : c,
          D = {};
        for (var $ in x) l && $ === "as" || E($) && (D[$] = x[$]);
        return D.className = v, D.ref = _, j.createElement(j.Fragment, null, j.createElement(Kle, {
          cache: k,
          serialized: w,
          isStringTag: typeof p == "string"
        }), j.createElement(p, D))
      });
      return y.displayName = s !== void 0 ? s : "Styled(" + (typeof i == "string" ? i : i.displayName || i.name || "Component") + ")", y.defaultProps = t.defaultProps, y.__emotion_real = y, y.__emotion_base = i, y.__emotion_styles = f, y.__emotion_forwardProp = a, Object.defineProperty(y, "toString", {
        value: function () {
          return "." + o
        }
      }), y.withComponent = function (x, k) {
        return e(x, K({}, n, k, {
          shouldForwardProp: sD(y, k, !0)
        })).apply(void 0, f)
      }, y
    }
  },
  Yle = ["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "marquee", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "u", "ul", "var", "video", "wbr", "circle", "clipPath", "defs", "ellipse", "foreignObject", "g", "image", "line", "linearGradient", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "tspan"],
  UC = Qle.bind();
Yle.forEach(function (e) {
  UC[e] = UC(e)
});
let zC;
typeof document == "object" && (zC = ez({
  key: "css",
  prepend: !0
}));

function Jle(e) {
  const {
    injectFirst: t,
    children: n
  } = e;
  return t && zC ? C.jsx(Vle, {
    value: zC,
    children: n
  }) : n
}

function Xle(e) {
  return e == null || Object.keys(e).length === 0
}

function dz(e) {
  const {
    styles: t,
    defaultTheme: n = {}
  } = e, r = typeof t == "function" ? i => t(Xle(i) ? n : i) : t;
  return C.jsx(Wle, {
    styles: r
  })
}

function TT(e, t) {
  return UC(e, t)
}
const fz = (e, t) => {
    Array.isArray(e.__emotion_styles) && (e.__emotion_styles = t(e.__emotion_styles))
  },
  Zle = Object.freeze(Object.defineProperty({
    __proto__: null,
    GlobalStyles: dz,
    StyledEngineProvider: Jle,
    ThemeContext: F2,
    css: th,
    default: TT,
    internal_processStyles: fz,
    keyframes: yl
  }, Symbol.toStringTag, {
    value: "Module"
  }));

function eue(e) {
  return Object.keys(e).length === 0
}

function kT(e = null) {
  const t = j.useContext(F2);
  return !t || eue(t) ? e : t
}
const tue = dm();

function v5(e = tue) {
  return kT(e)
}

function _T({
  props: e,
  name: t,
  defaultTheme: n,
  themeId: r
}) {
  let i = v5(n);
  return r && (i = i[r] || i), BU({
    theme: i,
    name: t,
    props: e
  })
}
const nue = ["sx"],
  rue = e => {
    var t, n;
    const r = {
        systemProps: {},
        otherProps: {}
      },
      i = (t = e == null || (n = e.theme) == null ? void 0 : n.unstable_sxConfig) != null ? t : $2;
    return Object.keys(e).forEach(s => {
      i[s] ? r.systemProps[s] = e[s] : r.otherProps[s] = e[s]
    }), r
  };

function b5(e) {
  const {
    sx: t
  } = e, n = Ve(e, nue), {
    systemProps: r,
    otherProps: i
  } = rue(n);
  let s;
  return Array.isArray(t) ? s = [r, ...t] : typeof t == "function" ? s = (...o) => {
    const a = t(...o);
    return Jl(a) ? K({}, r, a) : r
  } : s = K({}, r, t), K({}, i, {
    sx: s
  })
}
const iue = Object.freeze(Object.defineProperty({
  __proto__: null,
  default: L2,
  extendSxProp: b5,
  unstable_createStyleFunctionSx: HU,
  unstable_defaultSxConfig: $2
}, Symbol.toStringTag, {
  value: "Module"
}));

function sue(e, t) {
  return K({
    toolbar: {
      minHeight: 56,
      [e.up("xs")]: {
        "@media (orientation: landscape)": {
          minHeight: 48
        }
      },
      [e.up("sm")]: {
        minHeight: 64
      }
    }
  }, t)
}
var Jr = {};
const oue = Ds(Rae),
  aue = Ds(nce);
var hz = Zt;
Object.defineProperty(Jr, "__esModule", {
  value: !0
});
var lr = Jr.alpha = bz;
Jr.blend = vue;
Jr.colorChannel = void 0;
var pz = Jr.darken = PT;
Jr.decomposeColor = Ia;
Jr.emphasize = yue;
var cue = Jr.getContrastRatio = hue;
Jr.getLuminance = s3;
Jr.hexToRgb = gz;
Jr.hslToRgb = vz;
var mz = Jr.lighten = RT;
Jr.private_safeAlpha = pue;
Jr.private_safeColorChannel = void 0;
Jr.private_safeDarken = mue;
Jr.private_safeEmphasize = wz;
Jr.private_safeLighten = gue;
Jr.recomposeColor = hm;
Jr.rgbToHex = fue;
var oD = hz(oue),
  lue = hz(aue);

function IT(e, t = 0, n = 1) {
  return (0, lue.default)(e, t, n)
}

function gz(e) {
  e = e.slice(1);
  const t = new RegExp(`.{1,${e.length>=6?2:1}}`, "g");
  let n = e.match(t);
  return n && n[0].length === 1 && (n = n.map(r => r + r)), n ? `rgb${n.length===4?"a":""}(${n.map((r,i)=>i<3?parseInt(r,16):Math.round(parseInt(r,16)/255*1e3)/1e3).join(", ")})` : ""
}

function uue(e) {
  const t = e.toString(16);
  return t.length === 1 ? `0${t}` : t
}

function Ia(e) {
  if (e.type) return e;
  if (e.charAt(0) === "#") return Ia(gz(e));
  const t = e.indexOf("("),
    n = e.substring(0, t);
  if (["rgb", "rgba", "hsl", "hsla", "color"].indexOf(n) === -1) throw new Error((0, oD.default)(9, e));
  let r = e.substring(t + 1, e.length - 1),
    i;
  if (n === "color") {
    if (r = r.split(" "), i = r.shift(), r.length === 4 && r[3].charAt(0) === "/" && (r[3] = r[3].slice(1)), ["srgb", "display-p3", "a98-rgb", "prophoto-rgb", "rec-2020"].indexOf(i) === -1) throw new Error((0, oD.default)(10, i))
  } else r = r.split(",");
  return r = r.map(s => parseFloat(s)), {
    type: n,
    values: r,
    colorSpace: i
  }
}
const yz = e => {
  const t = Ia(e);
  return t.values.slice(0, 3).map((n, r) => t.type.indexOf("hsl") !== -1 && r !== 0 ? `${n}%` : n).join(" ")
};
Jr.colorChannel = yz;
const due = (e, t) => {
  try {
    return yz(e)
  } catch {
    return e
  }
};
Jr.private_safeColorChannel = due;

function hm(e) {
  const {
    type: t,
    colorSpace: n
  } = e;
  let {
    values: r
  } = e;
  return t.indexOf("rgb") !== -1 ? r = r.map((i, s) => s < 3 ? parseInt(i, 10) : i) : t.indexOf("hsl") !== -1 && (r[1] = `${r[1]}%`, r[2] = `${r[2]}%`), t.indexOf("color") !== -1 ? r = `${n} ${r.join(" ")}` : r = `${r.join(", ")}`, `${t}(${r})`
}

function fue(e) {
  if (e.indexOf("#") === 0) return e;
  const {
    values: t
  } = Ia(e);
  return `#${t.map((n,r)=>uue(r===3?Math.round(255*n):n)).join("")}`
}

function vz(e) {
  e = Ia(e);
  const {
    values: t
  } = e, n = t[0], r = t[1] / 100, i = t[2] / 100, s = r * Math.min(i, 1 - i), o = (l, u = (l + n / 30) % 12) => i - s * Math.max(Math.min(u - 3, 9 - u, 1), -1);
  let a = "rgb";
  const c = [Math.round(o(0) * 255), Math.round(o(8) * 255), Math.round(o(4) * 255)];
  return e.type === "hsla" && (a += "a", c.push(t[3])), hm({
    type: a,
    values: c
  })
}

function s3(e) {
  e = Ia(e);
  let t = e.type === "hsl" || e.type === "hsla" ? Ia(vz(e)).values : e.values;
  return t = t.map(n => (e.type !== "color" && (n /= 255), n <= .03928 ? n / 12.92 : ((n + .055) / 1.055) ** 2.4)), Number((.2126 * t[0] + .7152 * t[1] + .0722 * t[2]).toFixed(3))
}

function hue(e, t) {
  const n = s3(e),
    r = s3(t);
  return (Math.max(n, r) + .05) / (Math.min(n, r) + .05)
}

function bz(e, t) {
  return e = Ia(e), t = IT(t), (e.type === "rgb" || e.type === "hsl") && (e.type += "a"), e.type === "color" ? e.values[3] = `/${t}` : e.values[3] = t, hm(e)
}

function pue(e, t, n) {
  try {
    return bz(e, t)
  } catch {
    return e
  }
}

function PT(e, t) {
  if (e = Ia(e), t = IT(t), e.type.indexOf("hsl") !== -1) e.values[2] *= 1 - t;
  else if (e.type.indexOf("rgb") !== -1 || e.type.indexOf("color") !== -1)
    for (let n = 0; n < 3; n += 1) e.values[n] *= 1 - t;
  return hm(e)
}

function mue(e, t, n) {
  try {
    return PT(e, t)
  } catch {
    return e
  }
}

function RT(e, t) {
  if (e = Ia(e), t = IT(t), e.type.indexOf("hsl") !== -1) e.values[2] += (100 - e.values[2]) * t;
  else if (e.type.indexOf("rgb") !== -1)
    for (let n = 0; n < 3; n += 1) e.values[n] += (255 - e.values[n]) * t;
  else if (e.type.indexOf("color") !== -1)
    for (let n = 0; n < 3; n += 1) e.values[n] += (1 - e.values[n]) * t;
  return hm(e)
}

function gue(e, t, n) {
  try {
    return RT(e, t)
  } catch {
    return e
  }
}

function yue(e, t = .15) {
  return s3(e) > .5 ? PT(e, t) : RT(e, t)
}

function wz(e, t, n) {
  try {
    return wz(e, t)
  } catch {
    return e
  }
}

function vue(e, t, n, r = 1) {
  const i = (c, l) => Math.round((c ** (1 / r) * (1 - n) + l ** (1 / r) * n) ** r),
    s = Ia(e),
    o = Ia(t),
    a = [i(s.values[0], o.values[0]), i(s.values[1], o.values[1]), i(s.values[2], o.values[2])];
  return hm({
    type: "rgb",
    values: a
  })
}
const bue = {
    black: "#000",
    white: "#fff"
  },
  Po = bue,
  wue = {
    50: "#fafafa",
    100: "#f5f5f5",
    200: "#eeeeee",
    300: "#e0e0e0",
    400: "#bdbdbd",
    500: "#9e9e9e",
    600: "#757575",
    700: "#616161",
    800: "#424242",
    900: "#212121",
    A100: "#f5f5f5",
    A200: "#eeeeee",
    A400: "#bdbdbd",
    A700: "#616161"
  },
  xue = wue,
  Eue = {
    50: "#f3e5f5",
    100: "#e1bee7",
    200: "#ce93d8",
    300: "#ba68c8",
    400: "#ab47bc",
    500: "#9c27b0",
    600: "#8e24aa",
    700: "#7b1fa2",
    800: "#6a1b9a",
    900: "#4a148c",
    A100: "#ea80fc",
    A200: "#e040fb",
    A400: "#d500f9",
    A700: "#aa00ff"
  },
  c0 = Eue,
  Sue = {
    50: "#ffebee",
    100: "#ffcdd2",
    200: "#ef9a9a",
    300: "#e57373",
    400: "#ef5350",
    500: "#f44336",
    600: "#e53935",
    700: "#d32f2f",
    800: "#c62828",
    900: "#b71c1c",
    A100: "#ff8a80",
    A200: "#ff5252",
    A400: "#ff1744",
    A700: "#d50000"
  },
  l0 = Sue,
  Cue = {
    50: "#fff3e0",
    100: "#ffe0b2",
    200: "#ffcc80",
    300: "#ffb74d",
    400: "#ffa726",
    500: "#ff9800",
    600: "#fb8c00",
    700: "#f57c00",
    800: "#ef6c00",
    900: "#e65100",
    A100: "#ffd180",
    A200: "#ffab40",
    A400: "#ff9100",
    A700: "#ff6d00"
  },
  Eg = Cue,
  Aue = {
    50: "#e3f2fd",
    100: "#bbdefb",
    200: "#90caf9",
    300: "#64b5f6",
    400: "#42a5f5",
    500: "#2196f3",
    600: "#1e88e5",
    700: "#1976d2",
    800: "#1565c0",
    900: "#0d47a1",
    A100: "#82b1ff",
    A200: "#448aff",
    A400: "#2979ff",
    A700: "#2962ff"
  },
  u0 = Aue,
  Tue = {
    50: "#e1f5fe",
    100: "#b3e5fc",
    200: "#81d4fa",
    300: "#4fc3f7",
    400: "#29b6f6",
    500: "#03a9f4",
    600: "#039be5",
    700: "#0288d1",
    800: "#0277bd",
    900: "#01579b",
    A100: "#80d8ff",
    A200: "#40c4ff",
    A400: "#00b0ff",
    A700: "#0091ea"
  },
  d0 = Tue,
  kue = {
    50: "#e8f5e9",
    100: "#c8e6c9",
    200: "#a5d6a7",
    300: "#81c784",
    400: "#66bb6a",
    500: "#4caf50",
    600: "#43a047",
    700: "#388e3c",
    800: "#2e7d32",
    900: "#1b5e20",
    A100: "#b9f6ca",
    A200: "#69f0ae",
    A400: "#00e676",
    A700: "#00c853"
  },
  f0 = kue,
  _ue = ["mode", "contrastThreshold", "tonalOffset"],
  aD = {
    text: {
      primary: "rgba(0, 0, 0, 0.87)",
      secondary: "rgba(0, 0, 0, 0.6)",
      disabled: "rgba(0, 0, 0, 0.38)"
    },
    divider: "rgba(0, 0, 0, 0.12)",
    background: {
      paper: Po.white,
      default: Po.white
    },
    action: {
      active: "rgba(0, 0, 0, 0.54)",
      hover: "rgba(0, 0, 0, 0.04)",
      hoverOpacity: .04,
      selected: "rgba(0, 0, 0, 0.08)",
      selectedOpacity: .08,
      disabled: "rgba(0, 0, 0, 0.26)",
      disabledBackground: "rgba(0, 0, 0, 0.12)",
      disabledOpacity: .38,
      focus: "rgba(0, 0, 0, 0.12)",
      focusOpacity: .12,
      activatedOpacity: .12
    }
  },
  oS = {
    text: {
      primary: Po.white,
      secondary: "rgba(255, 255, 255, 0.7)",
      disabled: "rgba(255, 255, 255, 0.5)",
      icon: "rgba(255, 255, 255, 0.5)"
    },
    divider: "rgba(255, 255, 255, 0.12)",
    background: {
      paper: "#121212",
      default: "#121212"
    },
    action: {
      active: Po.white,
      hover: "rgba(255, 255, 255, 0.08)",
      hoverOpacity: .08,
      selected: "rgba(255, 255, 255, 0.16)",
      selectedOpacity: .16,
      disabled: "rgba(255, 255, 255, 0.3)",
      disabledBackground: "rgba(255, 255, 255, 0.12)",
      disabledOpacity: .38,
      focus: "rgba(255, 255, 255, 0.12)",
      focusOpacity: .12,
      activatedOpacity: .24
    }
  };

function cD(e, t, n, r) {
  const i = r.light || r,
    s = r.dark || r * 1.5;
  e[t] || (e.hasOwnProperty(n) ? e[t] = e[n] : t === "light" ? e.light = mz(e.main, i) : t === "dark" && (e.dark = pz(e.main, s)))
}

function Iue(e = "light") {
  return e === "dark" ? {
    main: u0[200],
    light: u0[50],
    dark: u0[400]
  } : {
    main: u0[700],
    light: u0[400],
    dark: u0[800]
  }
}

function Pue(e = "light") {
  return e === "dark" ? {
    main: c0[200],
    light: c0[50],
    dark: c0[400]
  } : {
    main: c0[500],
    light: c0[300],
    dark: c0[700]
  }
}

function Rue(e = "light") {
  return e === "dark" ? {
    main: l0[500],
    light: l0[300],
    dark: l0[700]
  } : {
    main: l0[700],
    light: l0[400],
    dark: l0[800]
  }
}

function Oue(e = "light") {
  return e === "dark" ? {
    main: d0[400],
    light: d0[300],
    dark: d0[700]
  } : {
    main: d0[700],
    light: d0[500],
    dark: d0[900]
  }
}

function Due(e = "light") {
  return e === "dark" ? {
    main: f0[400],
    light: f0[300],
    dark: f0[700]
  } : {
    main: f0[800],
    light: f0[500],
    dark: f0[900]
  }
}

function Nue(e = "light") {
  return e === "dark" ? {
    main: Eg[400],
    light: Eg[300],
    dark: Eg[700]
  } : {
    main: "#ed6c02",
    light: Eg[500],
    dark: Eg[900]
  }
}

function Mue(e) {
  const {
    mode: t = "light",
    contrastThreshold: n = 3,
    tonalOffset: r = .2
  } = e, i = Ve(e, _ue), s = e.primary || Iue(t), o = e.secondary || Pue(t), a = e.error || Rue(t), c = e.info || Oue(t), l = e.success || Due(t), u = e.warning || Nue(t);

  function f(x) {
    return cue(x, oS.text.primary) >= n ? oS.text.primary : aD.text.primary
  }
  const h = ({
      color: x,
      name: k,
      mainShade: _ = 500,
      lightShade: p = 300,
      darkShade: v = 700
    }) => {
      if (x = K({}, x), !x.main && x[_] && (x.main = x[_]), !x.hasOwnProperty("main")) throw new Error(cu(11, k ? ` (${k})` : "", _));
      if (typeof x.main != "string") throw new Error(cu(12, k ? ` (${k})` : "", JSON.stringify(x.main)));
      return cD(x, "light", p, r), cD(x, "dark", v, r), x.contrastText || (x.contrastText = f(x.main)), x
    },
    g = {
      dark: oS,
      light: aD
    };
  return ks(K({
    common: K({}, Po),
    mode: t,
    primary: h({
      color: s,
      name: "primary"
    }),
    secondary: h({
      color: o,
      name: "secondary",
      mainShade: "A400",
      lightShade: "A200",
      darkShade: "A700"
    }),
    error: h({
      color: a,
      name: "error"
    }),
    warning: h({
      color: u,
      name: "warning"
    }),
    info: h({
      color: c,
      name: "info"
    }),
    success: h({
      color: l,
      name: "success"
    }),
    grey: xue,
    contrastThreshold: n,
    getContrastText: f,
    augmentColor: h,
    tonalOffset: r
  }, g[t]), i)
}
const $ue = ["fontFamily", "fontSize", "fontWeightLight", "fontWeightRegular", "fontWeightMedium", "fontWeightBold", "htmlFontSize", "allVariants", "pxToRem"];

function Lue(e) {
  return Math.round(e * 1e5) / 1e5
}
const lD = {
    textTransform: "uppercase"
  },
  uD = '"Roboto", "Helvetica", "Arial", sans-serif';

function Bue(e, t) {
  const n = typeof t == "function" ? t(e) : t,
    {
      fontFamily: r = uD,
      fontSize: i = 14,
      fontWeightLight: s = 300,
      fontWeightRegular: o = 400,
      fontWeightMedium: a = 500,
      fontWeightBold: c = 700,
      htmlFontSize: l = 16,
      allVariants: u,
      pxToRem: f
    } = n,
    h = Ve(n, $ue),
    g = i / 14,
    y = f || (_ => `${_/l*g}rem`),
    x = (_, p, v, S, I) => K({
      fontFamily: r,
      fontWeight: _,
      fontSize: y(p),
      lineHeight: v
    }, r === uD ? {
      letterSpacing: `${Lue(S/p)}em`
    } : {}, I, u),
    k = {
      h1: x(s, 96, 1.167, -1.5),
      h2: x(s, 60, 1.2, -.5),
      h3: x(o, 48, 1.167, 0),
      h4: x(o, 34, 1.235, .25),
      h5: x(o, 24, 1.334, 0),
      h6: x(a, 20, 1.6, .15),
      subtitle1: x(o, 16, 1.75, .15),
      subtitle2: x(a, 14, 1.57, .1),
      body1: x(o, 16, 1.5, .15),
      body2: x(o, 14, 1.43, .15),
      button: x(a, 14, 1.75, .4, lD),
      caption: x(o, 12, 1.66, .4),
      overline: x(o, 12, 2.66, 1, lD),
      inherit: {
        fontFamily: "inherit",
        fontWeight: "inherit",
        fontSize: "inherit",
        lineHeight: "inherit",
        letterSpacing: "inherit"
      }
    };
  return ks(K({
    htmlFontSize: l,
    pxToRem: y,
    fontFamily: r,
    fontSize: i,
    fontWeightLight: s,
    fontWeightRegular: o,
    fontWeightMedium: a,
    fontWeightBold: c
  }, k), h, {
    clone: !1
  })
}
const Fue = .2,
  jue = .14,
  Uue = .12;

function wr(...e) {
  return [`${e[0]}px ${e[1]}px ${e[2]}px ${e[3]}px rgba(0,0,0,${Fue})`, `${e[4]}px ${e[5]}px ${e[6]}px ${e[7]}px rgba(0,0,0,${jue})`, `${e[8]}px ${e[9]}px ${e[10]}px ${e[11]}px rgba(0,0,0,${Uue})`].join(",")
}
const zue = ["none", wr(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0), wr(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0), wr(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0), wr(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0), wr(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0), wr(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0), wr(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1), wr(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2), wr(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2), wr(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3), wr(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3), wr(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4), wr(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4), wr(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4), wr(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5), wr(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5), wr(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5), wr(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6), wr(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6), wr(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7), wr(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7), wr(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7), wr(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8), wr(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8)],
  Hue = ["duration", "easing", "delay"],
  Vue = {
    easeInOut: "cubic-bezier(0.4, 0, 0.2, 1)",
    easeOut: "cubic-bezier(0.0, 0, 0.2, 1)",
    easeIn: "cubic-bezier(0.4, 0, 1, 1)",
    sharp: "cubic-bezier(0.4, 0, 0.6, 1)"
  },
  xz = {
    shortest: 150,
    shorter: 200,
    short: 250,
    standard: 300,
    complex: 375,
    enteringScreen: 225,
    leavingScreen: 195
  };

function dD(e) {
  return `${Math.round(e)}ms`
}

function Wue(e) {
  if (!e) return 0;
  const t = e / 36;
  return Math.round((4 + 15 * t ** .25 + t / 5) * 10)
}

function que(e) {
  const t = K({}, Vue, e.easing),
    n = K({}, xz, e.duration);
  return K({
    getAutoHeightDuration: Wue,
    create: (i = ["all"], s = {}) => {
      const {
        duration: o = n.standard,
        easing: a = t.easeInOut,
        delay: c = 0
      } = s;
      return Ve(s, Hue), (Array.isArray(i) ? i : [i]).map(l => `${l} ${typeof o=="string"?o:dD(o)} ${a} ${typeof c=="string"?c:dD(c)}`).join(",")
    }
  }, e, {
    easing: t,
    duration: n
  })
}
const Gue = {
    mobileStepper: 1e3,
    fab: 1050,
    speedDial: 1050,
    appBar: 1100,
    drawer: 1200,
    modal: 1300,
    snackbar: 1400,
    tooltip: 1500
  },
  Kue = Gue,
  Que = ["breakpoints", "mixins", "spacing", "palette", "transitions", "typography", "shape"];

function OT(e = {}, ...t) {
  const {
    mixins: n = {},
    palette: r = {},
    transitions: i = {},
    typography: s = {}
  } = e, o = Ve(e, Que);
  if (e.vars) throw new Error(cu(18));
  const a = Mue(r),
    c = dm(e);
  let l = ks(c, {
    mixins: sue(c.breakpoints, n),
    palette: a,
    shadows: zue.slice(),
    typography: Bue(a, s),
    transitions: que(i),
    zIndex: K({}, Kue)
  });
  return l = ks(l, o), l = t.reduce((u, f) => ks(u, f), l), l.unstable_sxConfig = K({}, $2, o == null ? void 0 : o.unstable_sxConfig), l.unstable_sx = function (f) {
    return L2({
      sx: f,
      theme: this
    })
  }, l
}
const Yue = OT(),
  w5 = Yue,
  nh = "$$material";

function xt({
  props: e,
  name: t
}) {
  return _T({
    props: e,
    name: t,
    defaultTheme: w5,
    themeId: nh
  })
}
var j2 = {};
const Jue = Ds(Iae);
var aS = {
    exports: {}
  },
  fD;

function Xue() {
  return fD || (fD = 1, function (e) {
    function t(n, r) {
      if (n == null) return {};
      var i = {},
        s = Object.keys(n),
        o, a;
      for (a = 0; a < s.length; a++) o = s[a], !(r.indexOf(o) >= 0) && (i[o] = n[o]);
      return i
    }
    e.exports = t, e.exports.__esModule = !0, e.exports.default = e.exports
  }(aS)), aS.exports
}
const Ez = Ds(Zle),
  Zue = Ds(Pae),
  ede = Ds(Lae),
  tde = Ds($ae),
  nde = Ds(Yce),
  rde = Ds(iue);
var pm = Zt;
Object.defineProperty(j2, "__esModule", {
  value: !0
});
var ide = j2.default = yde;
j2.shouldForwardProp = uw;
j2.systemDefaultTheme = void 0;
var pa = pm(Jue),
  HC = pm(Xue()),
  hD = dde(Ez),
  sde = Zue;
pm(ede);
pm(tde);
var ode = pm(nde),
  ade = pm(rde);
const cde = ["ownerState"],
  lde = ["variants"],
  ude = ["name", "slot", "skipVariantsResolver", "skipSx", "overridesResolver"];

function Sz(e) {
  if (typeof WeakMap != "function") return null;
  var t = new WeakMap,
    n = new WeakMap;
  return (Sz = function (r) {
    return r ? n : t
  })(e)
}

function dde(e, t) {
  if (!t && e && e.__esModule) return e;
  if (e === null || typeof e != "object" && typeof e != "function") return {
    default: e
  };
  var n = Sz(t);
  if (n && n.has(e)) return n.get(e);
  var r = {
      __proto__: null
    },
    i = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var s in e)
    if (s !== "default" && Object.prototype.hasOwnProperty.call(e, s)) {
      var o = i ? Object.getOwnPropertyDescriptor(e, s) : null;
      o && (o.get || o.set) ? Object.defineProperty(r, s, o) : r[s] = e[s]
    } return r.default = e, n && n.set(e, r), r
}

function fde(e) {
  return Object.keys(e).length === 0
}

function hde(e) {
  return typeof e == "string" && e.charCodeAt(0) > 96
}

function uw(e) {
  return e !== "ownerState" && e !== "theme" && e !== "sx" && e !== "as"
}
const pde = j2.systemDefaultTheme = (0, ode.default)(),
  mde = e => e && e.charAt(0).toLowerCase() + e.slice(1);

function ib({
  defaultTheme: e,
  theme: t,
  themeId: n
}) {
  return fde(t) ? e : t[n] || t
}

function gde(e) {
  return e ? (t, n) => n[e] : null
}

function dw(e, t) {
  let {
    ownerState: n
  } = t, r = (0, HC.default)(t, cde);
  const i = typeof e == "function" ? e((0, pa.default)({
    ownerState: n
  }, r)) : e;
  if (Array.isArray(i)) return i.flatMap(s => dw(s, (0, pa.default)({
    ownerState: n
  }, r)));
  if (i && typeof i == "object" && Array.isArray(i.variants)) {
    const {
      variants: s = []
    } = i;
    let a = (0, HC.default)(i, lde);
    return s.forEach(c => {
      let l = !0;
      typeof c.props == "function" ? l = c.props((0, pa.default)({
        ownerState: n
      }, r, n)) : Object.keys(c.props).forEach(u => {
        (n == null ? void 0 : n[u]) !== c.props[u] && r[u] !== c.props[u] && (l = !1)
      }), l && (Array.isArray(a) || (a = [a]), a.push(typeof c.style == "function" ? c.style((0, pa.default)({
        ownerState: n
      }, r, n)) : c.style))
    }), a
  }
  return i
}

function yde(e = {}) {
  const {
    themeId: t,
    defaultTheme: n = pde,
    rootShouldForwardProp: r = uw,
    slotShouldForwardProp: i = uw
  } = e, s = o => (0, ade.default)((0, pa.default)({}, o, {
    theme: ib((0, pa.default)({}, o, {
      defaultTheme: n,
      themeId: t
    }))
  }));
  return s.__mui_systemSx = !0, (o, a = {}) => {
    (0, hD.internal_processStyles)(o, I => I.filter(A => !(A != null && A.__mui_systemSx)));
    const {
      name: c,
      slot: l,
      skipVariantsResolver: u,
      skipSx: f,
      overridesResolver: h = gde(mde(l))
    } = a, g = (0, HC.default)(a, ude), y = u !== void 0 ? u : l && l !== "Root" && l !== "root" || !1, x = f || !1;
    let k, _ = uw;
    l === "Root" || l === "root" ? _ = r : l ? _ = i : hde(o) && (_ = void 0);
    const p = (0, hD.default)(o, (0, pa.default)({
        shouldForwardProp: _,
        label: k
      }, g)),
      v = I => typeof I == "function" && I.__emotion_real !== I || (0, sde.isPlainObject)(I) ? A => dw(I, (0, pa.default)({}, A, {
        theme: ib({
          theme: A.theme,
          defaultTheme: n,
          themeId: t
        })
      })) : I,
      S = (I, ...A) => {
        let w = v(I);
        const E = A ? A.map(v) : [];
        c && h && E.push(V => {
          const G = ib((0, pa.default)({}, V, {
            defaultTheme: n,
            themeId: t
          }));
          if (!G.components || !G.components[c] || !G.components[c].styleOverrides) return null;
          const L = G.components[c].styleOverrides,
            b = {};
          return Object.entries(L).forEach(([T, R]) => {
            b[T] = dw(R, (0, pa.default)({}, V, {
              theme: G
            }))
          }), h(V, b)
        }), c && !y && E.push(V => {
          var G;
          const L = ib((0, pa.default)({}, V, {
              defaultTheme: n,
              themeId: t
            })),
            b = L == null || (G = L.components) == null || (G = G[c]) == null ? void 0 : G.variants;
          return dw({
            variants: b
          }, (0, pa.default)({}, V, {
            theme: L
          }))
        }), x || E.push(s);
        const D = E.length - A.length;
        if (Array.isArray(I) && D > 0) {
          const V = new Array(D).fill("");
          w = [...I, ...V], w.raw = [...I.raw, ...V]
        }
        const $ = p(w, ...E);
        return o.muiName && ($.muiName = o.muiName), $
      };
    return p.withConfig && (S.withConfig = p.withConfig), S
  }
}

function Cz(e) {
  return e !== "ownerState" && e !== "theme" && e !== "sx" && e !== "as"
}
const vde = e => Cz(e) && e !== "classes",
  $s = vde,
  me = ide({
    themeId: nh,
    defaultTheme: w5,
    rootShouldForwardProp: $s
  });

function bde(e) {
  return mt("MuiSvgIcon", e)
}
const wde = gt("MuiSvgIcon", ["root", "colorPrimary", "colorSecondary", "colorAction", "colorError", "colorDisabled", "fontSizeInherit", "fontSizeSmall", "fontSizeMedium", "fontSizeLarge"]),
  xde = wde,
  Ede = ["children", "className", "color", "component", "fontSize", "htmlColor", "inheritViewBox", "titleAccess", "viewBox"],
  Sde = e => {
    const {
      color: t,
      fontSize: n,
      classes: r
    } = e, i = {
      root: ["root", t !== "inherit" && `color${qe(t)}`, `fontSize${qe(n)}`]
    };
    return pt(i, bde, r)
  },
  Cde = me("svg", {
    name: "MuiSvgIcon",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, n.color !== "inherit" && t[`color${qe(n.color)}`], t[`fontSize${qe(n.fontSize)}`]]
    }
  })(({
    theme: e,
    ownerState: t
  }) => {
    var n, r, i, s, o, a, c, l, u, f, h, g, y;
    return {
      userSelect: "none",
      width: "1em",
      height: "1em",
      display: "inline-block",
      fill: t.hasSvgAsChild ? void 0 : "currentColor",
      flexShrink: 0,
      transition: (n = e.transitions) == null || (r = n.create) == null ? void 0 : r.call(n, "fill", {
        duration: (i = e.transitions) == null || (i = i.duration) == null ? void 0 : i.shorter
      }),
      fontSize: {
        inherit: "inherit",
        small: ((s = e.typography) == null || (o = s.pxToRem) == null ? void 0 : o.call(s, 20)) || "1.25rem",
        medium: ((a = e.typography) == null || (c = a.pxToRem) == null ? void 0 : c.call(a, 24)) || "1.5rem",
        large: ((l = e.typography) == null || (u = l.pxToRem) == null ? void 0 : u.call(l, 35)) || "2.1875rem"
      } [t.fontSize],
      color: (f = (h = (e.vars || e).palette) == null || (h = h[t.color]) == null ? void 0 : h.main) != null ? f : {
        action: (g = (e.vars || e).palette) == null || (g = g.action) == null ? void 0 : g.active,
        disabled: (y = (e.vars || e).palette) == null || (y = y.action) == null ? void 0 : y.disabled,
        inherit: void 0
      } [t.color]
    }
  }),
  o3 = j.forwardRef(function (t, n) {
    const r = xt({
        props: t,
        name: "MuiSvgIcon"
      }),
      {
        children: i,
        className: s,
        color: o = "inherit",
        component: a = "svg",
        fontSize: c = "medium",
        htmlColor: l,
        inheritViewBox: u = !1,
        titleAccess: f,
        viewBox: h = "0 0 24 24"
      } = r,
      g = Ve(r, Ede),
      y = j.isValidElement(i) && i.type === "svg",
      x = K({}, r, {
        color: o,
        component: a,
        fontSize: c,
        instanceFontSize: t.fontSize,
        inheritViewBox: u,
        viewBox: h,
        hasSvgAsChild: y
      }),
      k = {};
    u || (k.viewBox = h);
    const _ = Sde(x);
    return C.jsxs(Cde, K({
      as: a,
      className: Ye(_.root, s),
      focusable: "false",
      color: l,
      "aria-hidden": f ? void 0 : !0,
      role: f ? "img" : void 0,
      ref: n
    }, k, g, y && i.props, {
      ownerState: x,
      children: [y ? i.props.children : i, f ? C.jsx("title", {
        children: f
      }) : null]
    }))
  });
o3.muiName = "SvgIcon";

function Bd(e, t) {
  function n(r, i) {
    return C.jsx(o3, K({
      "data-testid": `${t}Icon`,
      ref: i
    }, r, {
      children: e
    }))
  }
  return n.muiName = o3.muiName, j.memo(j.forwardRef(n))
}
const Ade = {
    configure: e => {
      hT.configure(e)
    }
  },
  Tde = Object.freeze(Object.defineProperty({
    __proto__: null,
    capitalize: qe,
    createChainedFunction: LC,
    createSvgIcon: Bd,
    debounce: um,
    deprecatedPropType: Bae,
    isMuiElement: g1,
    ownerDocument: ji,
    ownerWindow: _a,
    requirePropFactory: Fae,
    setRef: n3,
    unstable_ClassNameGenerator: Ade,
    unstable_useEnhancedEffect: Os,
    unstable_useId: O2,
    unsupportedProp: Uae,
    useControlled: K1,
    useEventCallback: Ea,
    useForkRef: vr,
    useIsFocusVisible: Zx
  }, Symbol.toStringTag, {
    value: "Module"
  })),
  kde = Ds(Tde);
var pD;

function an() {
  return pD || (pD = 1, function (e) {
    "use client";
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), Object.defineProperty(e, "default", {
      enumerable: !0,
      get: function () {
        return t.createSvgIcon
      }
    });
    var t = kde
  }(nS)), nS
}
var _de = Zt;
Object.defineProperty(uT, "__esModule", {
  value: !0
});
var Az = uT.default = void 0,
  Ide = _de(an()),
  Pde = C;
Az = uT.default = (0, Ide.default)((0, Pde.jsx)("path", {
  d: "M15.41 16.59 10.83 12l4.58-4.59L14 6l-6 6 6 6z"
}), "KeyboardArrowLeft");
var DT = {},
  Rde = Zt;
Object.defineProperty(DT, "__esModule", {
  value: !0
});
var Tz = DT.default = void 0,
  Ode = Rde(an()),
  Dde = C;
Tz = DT.default = (0, Ode.default)((0, Dde.jsx)("path", {
  d: "M8.59 16.59 13.17 12 8.59 7.41 10 6l6 6-6 6z"
}), "KeyboardArrowRight");

function Nde({
  styles: e,
  themeId: t,
  defaultTheme: n = {}
}) {
  const r = v5(n),
    i = typeof e == "function" ? e(t && r[t] || r) : e;
  return C.jsx(dz, {
    styles: i
  })
}

function kz(e) {
  var t, n, r = "";
  if (typeof e == "string" || typeof e == "number") r += e;
  else if (typeof e == "object")
    if (Array.isArray(e)) {
      var i = e.length;
      for (t = 0; t < i; t++) e[t] && (n = kz(e[t])) && (r && (r += " "), r += n)
    } else
      for (n in e) e[n] && (r && (r += " "), r += n);
  return r
}

function NT() {
  for (var e, t, n = 0, r = "", i = arguments.length; n < i; n++)(e = arguments[n]) && (t = kz(e)) && (r && (r += " "), r += t);
  return r
}
const Mde = ["className", "component"];

function $de(e = {}) {
  const {
    themeId: t,
    defaultTheme: n,
    defaultClassName: r = "MuiBox-root",
    generateClassName: i
  } = e, s = TT("div", {
    shouldForwardProp: a => a !== "theme" && a !== "sx" && a !== "as"
  })(L2);
  return j.forwardRef(function (c, l) {
    const u = v5(n),
      f = b5(c),
      {
        className: h,
        component: g = "div"
      } = f,
      y = Ve(f, Mde);
    return C.jsx(s, K({
      as: g,
      ref: l,
      className: NT(h, i ? i(r) : r),
      theme: t && u[t] || u
    }, y))
  })
}
const Lde = ["ownerState"],
  Bde = ["variants"],
  Fde = ["name", "slot", "skipVariantsResolver", "skipSx", "overridesResolver"];

function jde(e) {
  return Object.keys(e).length === 0
}

function Ude(e) {
  return typeof e == "string" && e.charCodeAt(0) > 96
}

function cS(e) {
  return e !== "ownerState" && e !== "theme" && e !== "sx" && e !== "as"
}
const zde = dm(),
  Hde = e => e && e.charAt(0).toLowerCase() + e.slice(1);

function sb({
  defaultTheme: e,
  theme: t,
  themeId: n
}) {
  return jde(t) ? e : t[n] || t
}

function Vde(e) {
  return e ? (t, n) => n[e] : null
}

function fw(e, t) {
  let {
    ownerState: n
  } = t, r = Ve(t, Lde);
  const i = typeof e == "function" ? e(K({
    ownerState: n
  }, r)) : e;
  if (Array.isArray(i)) return i.flatMap(s => fw(s, K({
    ownerState: n
  }, r)));
  if (i && typeof i == "object" && Array.isArray(i.variants)) {
    const {
      variants: s = []
    } = i;
    let a = Ve(i, Bde);
    return s.forEach(c => {
      let l = !0;
      typeof c.props == "function" ? l = c.props(K({
        ownerState: n
      }, r, n)) : Object.keys(c.props).forEach(u => {
        (n == null ? void 0 : n[u]) !== c.props[u] && r[u] !== c.props[u] && (l = !1)
      }), l && (Array.isArray(a) || (a = [a]), a.push(typeof c.style == "function" ? c.style(K({
        ownerState: n
      }, r, n)) : c.style))
    }), a
  }
  return i
}

function Wde(e = {}) {
  const {
    themeId: t,
    defaultTheme: n = zde,
    rootShouldForwardProp: r = cS,
    slotShouldForwardProp: i = cS
  } = e, s = o => L2(K({}, o, {
    theme: sb(K({}, o, {
      defaultTheme: n,
      themeId: t
    }))
  }));
  return s.__mui_systemSx = !0, (o, a = {}) => {
    fz(o, I => I.filter(A => !(A != null && A.__mui_systemSx)));
    const {
      name: c,
      slot: l,
      skipVariantsResolver: u,
      skipSx: f,
      overridesResolver: h = Vde(Hde(l))
    } = a, g = Ve(a, Fde), y = u !== void 0 ? u : l && l !== "Root" && l !== "root" || !1, x = f || !1;
    let k, _ = cS;
    l === "Root" || l === "root" ? _ = r : l ? _ = i : Ude(o) && (_ = void 0);
    const p = TT(o, K({
        shouldForwardProp: _,
        label: k
      }, g)),
      v = I => typeof I == "function" && I.__emotion_real !== I || Jl(I) ? A => fw(I, K({}, A, {
        theme: sb({
          theme: A.theme,
          defaultTheme: n,
          themeId: t
        })
      })) : I,
      S = (I, ...A) => {
        let w = v(I);
        const E = A ? A.map(v) : [];
        c && h && E.push(V => {
          const G = sb(K({}, V, {
            defaultTheme: n,
            themeId: t
          }));
          if (!G.components || !G.components[c] || !G.components[c].styleOverrides) return null;
          const L = G.components[c].styleOverrides,
            b = {};
          return Object.entries(L).forEach(([T, R]) => {
            b[T] = fw(R, K({}, V, {
              theme: G
            }))
          }), h(V, b)
        }), c && !y && E.push(V => {
          var G;
          const L = sb(K({}, V, {
              defaultTheme: n,
              themeId: t
            })),
            b = L == null || (G = L.components) == null || (G = G[c]) == null ? void 0 : G.variants;
          return fw({
            variants: b
          }, K({}, V, {
            theme: L
          }))
        }), x || E.push(s);
        const D = E.length - A.length;
        if (Array.isArray(I) && D > 0) {
          const V = new Array(D).fill("");
          w = [...I, ...V], w.raw = [...I.raw, ...V]
        }
        const $ = p(w, ...E);
        return o.muiName && ($.muiName = o.muiName), $
      };
    return p.withConfig && (S.withConfig = p.withConfig), S
  }
}
const _z = Wde();

function qde(e, t, n, r, i) {
  const [s, o] = j.useState(() => i && n ? n(e).matches : r ? r(e).matches : t);
  return Os(() => {
    let a = !0;
    if (!n) return;
    const c = n(e),
      l = () => {
        a && o(c.matches)
      };
    return l(), c.addListener(l), () => {
      a = !1, c.removeListener(l)
    }
  }, [e, n]), s
}
const Iz = j.useSyncExternalStore;

function Gde(e, t, n, r, i) {
  const s = j.useCallback(() => t, [t]),
    o = j.useMemo(() => {
      if (i && n) return () => n(e).matches;
      if (r !== null) {
        const {
          matches: u
        } = r(e);
        return () => u
      }
      return s
    }, [s, e, r, i, n]),
    [a, c] = j.useMemo(() => {
      if (n === null) return [s, () => () => {}];
      const u = n(e);
      return [() => u.matches, f => (u.addListener(f), () => {
        u.removeListener(f)
      })]
    }, [s, n, e]);
  return Iz(c, a, o)
}

function x5(e, t = {}) {
  const n = kT(),
    r = typeof window < "u" && typeof window.matchMedia < "u",
    {
      defaultMatches: i = !1,
      matchMedia: s = r ? window.matchMedia : null,
      ssrMatchMedia: o = null,
      noSsr: a = !1
    } = BU({
      name: "MuiUseMediaQuery",
      props: t,
      theme: n
    });
  let c = typeof e == "function" ? e(n) : e;
  return c = c.replace(/^@media( ?)/m, ""), (Iz !== void 0 ? Gde : qde)(c, i, s, o, a)
}

function MT(e, t = 0, n = 1) {
  return $U(e, t, n)
}

function Kde(e) {
  e = e.slice(1);
  const t = new RegExp(`.{1,${e.length>=6?2:1}}`, "g");
  let n = e.match(t);
  return n && n[0].length === 1 && (n = n.map(r => r + r)), n ? `rgb${n.length===4?"a":""}(${n.map((r,i)=>i<3?parseInt(r,16):Math.round(parseInt(r,16)/255*1e3)/1e3).join(", ")})` : ""
}

function rh(e) {
  if (e.type) return e;
  if (e.charAt(0) === "#") return rh(Kde(e));
  const t = e.indexOf("("),
    n = e.substring(0, t);
  if (["rgb", "rgba", "hsl", "hsla", "color"].indexOf(n) === -1) throw new Error(cu(9, e));
  let r = e.substring(t + 1, e.length - 1),
    i;
  if (n === "color") {
    if (r = r.split(" "), i = r.shift(), r.length === 4 && r[3].charAt(0) === "/" && (r[3] = r[3].slice(1)), ["srgb", "display-p3", "a98-rgb", "prophoto-rgb", "rec-2020"].indexOf(i) === -1) throw new Error(cu(10, i))
  } else r = r.split(",");
  return r = r.map(s => parseFloat(s)), {
    type: n,
    values: r,
    colorSpace: i
  }
}

function E5(e) {
  const {
    type: t,
    colorSpace: n
  } = e;
  let {
    values: r
  } = e;
  return t.indexOf("rgb") !== -1 ? r = r.map((i, s) => s < 3 ? parseInt(i, 10) : i) : t.indexOf("hsl") !== -1 && (r[1] = `${r[1]}%`, r[2] = `${r[2]}%`), t.indexOf("color") !== -1 ? r = `${n} ${r.join(" ")}` : r = `${r.join(", ")}`, `${t}(${r})`
}

function Qde(e) {
  e = rh(e);
  const {
    values: t
  } = e, n = t[0], r = t[1] / 100, i = t[2] / 100, s = r * Math.min(i, 1 - i), o = (l, u = (l + n / 30) % 12) => i - s * Math.max(Math.min(u - 3, 9 - u, 1), -1);
  let a = "rgb";
  const c = [Math.round(o(0) * 255), Math.round(o(8) * 255), Math.round(o(4) * 255)];
  return e.type === "hsla" && (a += "a", c.push(t[3])), E5({
    type: a,
    values: c
  })
}

function mD(e) {
  e = rh(e);
  let t = e.type === "hsl" || e.type === "hsla" ? rh(Qde(e)).values : e.values;
  return t = t.map(n => (e.type !== "color" && (n /= 255), n <= .03928 ? n / 12.92 : ((n + .055) / 1.055) ** 2.4)), Number((.2126 * t[0] + .7152 * t[1] + .0722 * t[2]).toFixed(3))
}

function gD(e, t) {
  const n = mD(e),
    r = mD(t);
  return (Math.max(n, r) + .05) / (Math.min(n, r) + .05)
}

function Vt(e, t) {
  return e = rh(e), t = MT(t), (e.type === "rgb" || e.type === "hsl") && (e.type += "a"), e.type === "color" ? e.values[3] = `/${t}` : e.values[3] = t, E5(e)
}

function lu(e, t) {
  if (e = rh(e), t = MT(t), e.type.indexOf("hsl") !== -1) e.values[2] *= 1 - t;
  else if (e.type.indexOf("rgb") !== -1 || e.type.indexOf("color") !== -1)
    for (let n = 0; n < 3; n += 1) e.values[n] *= 1 - t;
  return E5(e)
}

function xd(e, t) {
  if (e = rh(e), t = MT(t), e.type.indexOf("hsl") !== -1) e.values[2] += (100 - e.values[2]) * t;
  else if (e.type.indexOf("rgb") !== -1)
    for (let n = 0; n < 3; n += 1) e.values[n] += (255 - e.values[n]) * t;
  else if (e.type.indexOf("color") !== -1)
    for (let n = 0; n < 3; n += 1) e.values[n] += (1 - e.values[n]) * t;
  return E5(e)
}
const Yde = j.createContext(null),
  Pz = Yde;

function Rz() {
  return j.useContext(Pz)
}
const Jde = typeof Symbol == "function" && Symbol.for,
  Xde = Jde ? Symbol.for("mui.nested") : "__THEME_NESTED__";

function Zde(e, t) {
  return typeof t == "function" ? t(e) : K({}, e, t)
}

function efe(e) {
  const {
    children: t,
    theme: n
  } = e, r = Rz(), i = j.useMemo(() => {
    const s = r === null ? n : Zde(r, n);
    return s != null && (s[Xde] = r !== null), s
  }, [n, r]);
  return C.jsx(Pz.Provider, {
    value: i,
    children: t
  })
}
const tfe = ["value"],
  Oz = j.createContext();

function nfe(e) {
  let {
    value: t
  } = e, n = Ve(e, tfe);
  return C.jsx(Oz.Provider, K({
    value: t ?? !0
  }, n))
}
const U2 = () => {
    const e = j.useContext(Oz);
    return e ?? !1
  },
  yD = {};

function vD(e, t, n, r = !1) {
  return j.useMemo(() => {
    const i = e && t[e] || t;
    if (typeof n == "function") {
      const s = n(i),
        o = e ? K({}, t, {
          [e]: s
        }) : s;
      return r ? () => o : o
    }
    return e ? K({}, t, {
      [e]: n
    }) : K({}, t, n)
  }, [e, t, n, r])
}

function rfe(e) {
  const {
    children: t,
    theme: n,
    themeId: r
  } = e, i = kT(yD), s = Rz() || yD, o = vD(r, i, n), a = vD(r, s, n, !0), c = o.direction === "rtl";
  return C.jsx(efe, {
    theme: a,
    children: C.jsx(F2.Provider, {
      value: o,
      children: C.jsx(nfe, {
        value: c,
        children: t
      })
    })
  })
}

function X1(e) {
  "@babel/helpers - typeof";
  return X1 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (t) {
    return typeof t
  } : function (t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
  }, X1(e)
}

function ife(e, t) {
  if (X1(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (X1(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.")
  }
  return (t === "string" ? String : Number)(e)
}

function sfe(e) {
  var t = ife(e, "string");
  return X1(t) == "symbol" ? t : t + ""
}
const ofe = ["className", "component", "disableGutters", "fixed", "maxWidth", "classes"],
  afe = dm(),
  cfe = _z("div", {
    name: "MuiContainer",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, t[`maxWidth${qe(String(n.maxWidth))}`], n.fixed && t.fixed, n.disableGutters && t.disableGutters]
    }
  }),
  lfe = e => _T({
    props: e,
    name: "MuiContainer",
    defaultTheme: afe
  }),
  ufe = (e, t) => {
    const n = c => mt(t, c),
      {
        classes: r,
        fixed: i,
        disableGutters: s,
        maxWidth: o
      } = e,
      a = {
        root: ["root", o && `maxWidth${qe(String(o))}`, i && "fixed", s && "disableGutters"]
      };
    return pt(a, n, r)
  };

function dfe(e = {}) {
  const {
    createStyledComponent: t = cfe,
    useThemeProps: n = lfe,
    componentName: r = "MuiContainer"
  } = e, i = t(({
    theme: o,
    ownerState: a
  }) => K({
    width: "100%",
    marginLeft: "auto",
    boxSizing: "border-box",
    marginRight: "auto",
    display: "block"
  }, !a.disableGutters && {
    paddingLeft: o.spacing(2),
    paddingRight: o.spacing(2),
    [o.breakpoints.up("sm")]: {
      paddingLeft: o.spacing(3),
      paddingRight: o.spacing(3)
    }
  }), ({
    theme: o,
    ownerState: a
  }) => a.fixed && Object.keys(o.breakpoints.values).reduce((c, l) => {
    const u = l,
      f = o.breakpoints.values[u];
    return f !== 0 && (c[o.breakpoints.up(u)] = {
      maxWidth: `${f}${o.breakpoints.unit}`
    }), c
  }, {}), ({
    theme: o,
    ownerState: a
  }) => K({}, a.maxWidth === "xs" && {
    [o.breakpoints.up("xs")]: {
      maxWidth: Math.max(o.breakpoints.values.xs, 444)
    }
  }, a.maxWidth && a.maxWidth !== "xs" && {
    [o.breakpoints.up(a.maxWidth)]: {
      maxWidth: `${o.breakpoints.values[a.maxWidth]}${o.breakpoints.unit}`
    }
  }));
  return j.forwardRef(function (a, c) {
    const l = n(a),
      {
        className: u,
        component: f = "div",
        disableGutters: h = !1,
        fixed: g = !1,
        maxWidth: y = "lg"
      } = l,
      x = Ve(l, ofe),
      k = K({}, l, {
        component: f,
        disableGutters: h,
        fixed: g,
        maxWidth: y
      }),
      _ = ufe(k, r);
    return C.jsx(i, K({
      as: f,
      ownerState: k,
      className: NT(_.root, u),
      ref: c
    }, x))
  })
}
const ffe = ["component", "direction", "spacing", "divider", "children", "className", "useFlexGap"],
  hfe = dm(),
  pfe = _z("div", {
    name: "MuiStack",
    slot: "Root",
    overridesResolver: (e, t) => t.root
  });

function mfe(e) {
  return _T({
    props: e,
    name: "MuiStack",
    defaultTheme: hfe
  })
}

function gfe(e, t) {
  const n = j.Children.toArray(e).filter(Boolean);
  return n.reduce((r, i, s) => (r.push(i), s < n.length - 1 && r.push(j.cloneElement(t, {
    key: `separator-${s}`
  })), r), [])
}
const yfe = e => ({
    row: "Left",
    "row-reverse": "Right",
    column: "Top",
    "column-reverse": "Bottom"
  })[e],
  vfe = ({
    ownerState: e,
    theme: t
  }) => {
    let n = K({
      display: "flex",
      flexDirection: "column"
    }, Ec({
      theme: t
    }, iS({
      values: e.direction,
      breakpoints: t.breakpoints.values
    }), r => ({
      flexDirection: r
    })));
    if (e.spacing) {
      const r = yT(t),
        i = Object.keys(t.breakpoints.values).reduce((c, l) => ((typeof e.spacing == "object" && e.spacing[l] != null || typeof e.direction == "object" && e.direction[l] != null) && (c[l] = !0), c), {}),
        s = iS({
          values: e.direction,
          base: i
        }),
        o = iS({
          values: e.spacing,
          base: i
        });
      typeof s == "object" && Object.keys(s).forEach((c, l, u) => {
        if (!s[c]) {
          const h = l > 0 ? s[u[l - 1]] : "column";
          s[c] = h
        }
      }), n = ks(n, Ec({
        theme: t
      }, o, (c, l) => e.useFlexGap ? {
        gap: eh(r, c)
      } : {
        "& > :not(style):not(style)": {
          margin: 0
        },
        "& > :not(style) ~ :not(style)": {
          [`margin${yfe(l?s[l]:e.direction)}`]: eh(r, c)
        }
      }))
    }
    return n = ace(t.breakpoints, n), n
  };

function bfe(e = {}) {
  const {
    createStyledComponent: t = pfe,
    useThemeProps: n = mfe,
    componentName: r = "MuiStack"
  } = e, i = () => pt({
    root: ["root"]
  }, c => mt(r, c), {}), s = t(vfe);
  return j.forwardRef(function (c, l) {
    const u = n(c),
      f = b5(u),
      {
        component: h = "div",
        direction: g = "column",
        spacing: y = 0,
        divider: x,
        children: k,
        className: _,
        useFlexGap: p = !1
      } = f,
      v = Ve(f, ffe),
      S = {
        direction: g,
        spacing: y,
        useFlexGap: p
      },
      I = i();
    return C.jsx(s, K({
      as: h,
      ownerState: S,
      ref: l,
      className: NT(I.root, _)
    }, v, {
      children: x ? gfe(k, x) : k
    }))
  })
}

function wfe(e) {
  return String(e).match(/[\d.\-+]*\s*(.*)/)[1] || ""
}

function xfe(e) {
  return parseFloat(e)
}

function vl() {
  const e = v5(w5);
  return e[nh] || e
}
const Efe = ["theme"];

function Sfe(e) {
  let {
    theme: t
  } = e, n = Ve(e, Efe);
  const r = t[nh];
  return C.jsx(rfe, K({}, n, {
    themeId: r ? nh : void 0,
    theme: r || t
  }))
}
const bD = e => {
  let t;
  return e < 1 ? t = 5.11916 * e ** 2 : t = 4.5 * Math.log(e + 1) + 2, (t / 100).toFixed(2)
};

function $T(e) {
  return xt
}

function VC(e, t) {
  return VC = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (r, i) {
    return r.__proto__ = i, r
  }, VC(e, t)
}

function Dz(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, VC(e, t)
}
const wD = {
    disabled: !1
  },
  a3 = Jt.createContext(null);
var Cfe = function (t) {
    return t.scrollTop
  },
  n1 = "unmounted",
  Ef = "exited",
  Sf = "entering",
  E0 = "entered",
  WC = "exiting",
  mu = function (e) {
    Dz(t, e);

    function t(r, i) {
      var s;
      s = e.call(this, r, i) || this;
      var o = i,
        a = o && !o.isMounting ? r.enter : r.appear,
        c;
      return s.appearStatus = null, r.in ? a ? (c = Ef, s.appearStatus = Sf) : c = E0 : r.unmountOnExit || r.mountOnEnter ? c = n1 : c = Ef, s.state = {
        status: c
      }, s.nextCallback = null, s
    }
    t.getDerivedStateFromProps = function (i, s) {
      var o = i.in;
      return o && s.status === n1 ? {
        status: Ef
      } : null
    };
    var n = t.prototype;
    return n.componentDidMount = function () {
      this.updateStatus(!0, this.appearStatus)
    }, n.componentDidUpdate = function (i) {
      var s = null;
      if (i !== this.props) {
        var o = this.state.status;
        this.props.in ? o !== Sf && o !== E0 && (s = Sf) : (o === Sf || o === E0) && (s = WC)
      }
      this.updateStatus(!1, s)
    }, n.componentWillUnmount = function () {
      this.cancelNextCallback()
    }, n.getTimeouts = function () {
      var i = this.props.timeout,
        s, o, a;
      return s = o = a = i, i != null && typeof i != "number" && (s = i.exit, o = i.enter, a = i.appear !== void 0 ? i.appear : o), {
        exit: s,
        enter: o,
        appear: a
      }
    }, n.updateStatus = function (i, s) {
      if (i === void 0 && (i = !1), s !== null)
        if (this.cancelNextCallback(), s === Sf) {
          if (this.props.unmountOnExit || this.props.mountOnEnter) {
            var o = this.props.nodeRef ? this.props.nodeRef.current : nb.findDOMNode(this);
            o && Cfe(o)
          }
          this.performEnter(i)
        } else this.performExit();
      else this.props.unmountOnExit && this.state.status === Ef && this.setState({
        status: n1
      })
    }, n.performEnter = function (i) {
      var s = this,
        o = this.props.enter,
        a = this.context ? this.context.isMounting : i,
        c = this.props.nodeRef ? [a] : [nb.findDOMNode(this), a],
        l = c[0],
        u = c[1],
        f = this.getTimeouts(),
        h = a ? f.appear : f.enter;
      if (!i && !o || wD.disabled) {
        this.safeSetState({
          status: E0
        }, function () {
          s.props.onEntered(l)
        });
        return
      }
      this.props.onEnter(l, u), this.safeSetState({
        status: Sf
      }, function () {
        s.props.onEntering(l, u), s.onTransitionEnd(h, function () {
          s.safeSetState({
            status: E0
          }, function () {
            s.props.onEntered(l, u)
          })
        })
      })
    }, n.performExit = function () {
      var i = this,
        s = this.props.exit,
        o = this.getTimeouts(),
        a = this.props.nodeRef ? void 0 : nb.findDOMNode(this);
      if (!s || wD.disabled) {
        this.safeSetState({
          status: Ef
        }, function () {
          i.props.onExited(a)
        });
        return
      }
      this.props.onExit(a), this.safeSetState({
        status: WC
      }, function () {
        i.props.onExiting(a), i.onTransitionEnd(o.exit, function () {
          i.safeSetState({
            status: Ef
          }, function () {
            i.props.onExited(a)
          })
        })
      })
    }, n.cancelNextCallback = function () {
      this.nextCallback !== null && (this.nextCallback.cancel(), this.nextCallback = null)
    }, n.safeSetState = function (i, s) {
      s = this.setNextCallback(s), this.setState(i, s)
    }, n.setNextCallback = function (i) {
      var s = this,
        o = !0;
      return this.nextCallback = function (a) {
        o && (o = !1, s.nextCallback = null, i(a))
      }, this.nextCallback.cancel = function () {
        o = !1
      }, this.nextCallback
    }, n.onTransitionEnd = function (i, s) {
      this.setNextCallback(s);
      var o = this.props.nodeRef ? this.props.nodeRef.current : nb.findDOMNode(this),
        a = i == null && !this.props.addEndListener;
      if (!o || a) {
        setTimeout(this.nextCallback, 0);
        return
      }
      if (this.props.addEndListener) {
        var c = this.props.nodeRef ? [this.nextCallback] : [o, this.nextCallback],
          l = c[0],
          u = c[1];
        this.props.addEndListener(l, u)
      }
      i != null && setTimeout(this.nextCallback, i)
    }, n.render = function () {
      var i = this.state.status;
      if (i === n1) return null;
      var s = this.props,
        o = s.children;
      s.in, s.mountOnEnter, s.unmountOnExit, s.appear, s.enter, s.exit, s.timeout, s.addEndListener, s.onEnter, s.onEntering, s.onEntered, s.onExit, s.onExiting, s.onExited, s.nodeRef;
      var a = Ve(s, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
      return Jt.createElement(a3.Provider, {
        value: null
      }, typeof o == "function" ? o(i, a) : Jt.cloneElement(Jt.Children.only(o), a))
    }, t
  }(Jt.Component);
mu.contextType = a3;
mu.propTypes = {};

function h0() {}
mu.defaultProps = {
  in: !1,
  mountOnEnter: !1,
  unmountOnExit: !1,
  appear: !1,
  enter: !0,
  exit: !0,
  onEnter: h0,
  onEntering: h0,
  onEntered: h0,
  onExit: h0,
  onExiting: h0,
  onExited: h0
};
mu.UNMOUNTED = n1;
mu.EXITED = Ef;
mu.ENTERING = Sf;
mu.ENTERED = E0;
mu.EXITING = WC;
const S5 = mu;

function Afe(e) {
  if (e === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e
}

function LT(e, t) {
  var n = function (s) {
      return t && j.isValidElement(s) ? t(s) : s
    },
    r = Object.create(null);
  return e && j.Children.map(e, function (i) {
    return i
  }).forEach(function (i) {
    r[i.key] = n(i)
  }), r
}

function Tfe(e, t) {
  e = e || {}, t = t || {};

  function n(u) {
    return u in t ? t[u] : e[u]
  }
  var r = Object.create(null),
    i = [];
  for (var s in e) s in t ? i.length && (r[s] = i, i = []) : i.push(s);
  var o, a = {};
  for (var c in t) {
    if (r[c])
      for (o = 0; o < r[c].length; o++) {
        var l = r[c][o];
        a[r[c][o]] = n(l)
      }
    a[c] = n(c)
  }
  for (o = 0; o < i.length; o++) a[i[o]] = n(i[o]);
  return a
}

function Rf(e, t, n) {
  return n[t] != null ? n[t] : e.props[t]
}

function kfe(e, t) {
  return LT(e.children, function (n) {
    return j.cloneElement(n, {
      onExited: t.bind(null, n),
      in: !0,
      appear: Rf(n, "appear", e),
      enter: Rf(n, "enter", e),
      exit: Rf(n, "exit", e)
    })
  })
}

function _fe(e, t, n) {
  var r = LT(e.children),
    i = Tfe(t, r);
  return Object.keys(i).forEach(function (s) {
    var o = i[s];
    if (j.isValidElement(o)) {
      var a = s in t,
        c = s in r,
        l = t[s],
        u = j.isValidElement(l) && !l.props.in;
      c && (!a || u) ? i[s] = j.cloneElement(o, {
        onExited: n.bind(null, o),
        in: !0,
        exit: Rf(o, "exit", e),
        enter: Rf(o, "enter", e)
      }) : !c && a && !u ? i[s] = j.cloneElement(o, {
        in: !1
      }) : c && a && j.isValidElement(l) && (i[s] = j.cloneElement(o, {
        onExited: n.bind(null, o),
        in: l.props.in,
        exit: Rf(o, "exit", e),
        enter: Rf(o, "enter", e)
      }))
    }
  }), i
}
var Ife = Object.values || function (e) {
    return Object.keys(e).map(function (t) {
      return e[t]
    })
  },
  Pfe = {
    component: "div",
    childFactory: function (t) {
      return t
    }
  },
  BT = function (e) {
    Dz(t, e);

    function t(r, i) {
      var s;
      s = e.call(this, r, i) || this;
      var o = s.handleExited.bind(Afe(s));
      return s.state = {
        contextValue: {
          isMounting: !0
        },
        handleExited: o,
        firstRender: !0
      }, s
    }
    var n = t.prototype;
    return n.componentDidMount = function () {
      this.mounted = !0, this.setState({
        contextValue: {
          isMounting: !1
        }
      })
    }, n.componentWillUnmount = function () {
      this.mounted = !1
    }, t.getDerivedStateFromProps = function (i, s) {
      var o = s.children,
        a = s.handleExited,
        c = s.firstRender;
      return {
        children: c ? kfe(i, a) : _fe(i, o, a),
        firstRender: !1
      }
    }, n.handleExited = function (i, s) {
      var o = LT(this.props.children);
      i.key in o || (i.props.onExited && i.props.onExited(s), this.mounted && this.setState(function (a) {
        var c = K({}, a.children);
        return delete c[i.key], {
          children: c
        }
      }))
    }, n.render = function () {
      var i = this.props,
        s = i.component,
        o = i.childFactory,
        a = Ve(i, ["component", "childFactory"]),
        c = this.state.contextValue,
        l = Ife(this.state.children).map(o);
      return delete a.appear, delete a.enter, delete a.exit, s === null ? Jt.createElement(a3.Provider, {
        value: c
      }, l) : Jt.createElement(a3.Provider, {
        value: c
      }, Jt.createElement(s, a, l))
    }, t
  }(Jt.Component);
BT.propTypes = {};
BT.defaultProps = Pfe;
const Rfe = BT,
  FT = e => e.scrollTop;

function Ed(e, t) {
  var n, r;
  const {
    timeout: i,
    easing: s,
    style: o = {}
  } = e;
  return {
    duration: (n = o.transitionDuration) != null ? n : typeof i == "number" ? i : i[t.mode] || 0,
    easing: (r = o.transitionTimingFunction) != null ? r : typeof s == "object" ? s[t.mode] : s,
    delay: o.transitionDelay
  }
}

function Ofe(e) {
  return mt("MuiCollapse", e)
}
gt("MuiCollapse", ["root", "horizontal", "vertical", "entered", "hidden", "wrapper", "wrapperInner"]);
const Dfe = ["addEndListener", "children", "className", "collapsedSize", "component", "easing", "in", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "orientation", "style", "timeout", "TransitionComponent"],
  Nfe = e => {
    const {
      orientation: t,
      classes: n
    } = e, r = {
      root: ["root", `${t}`],
      entered: ["entered"],
      hidden: ["hidden"],
      wrapper: ["wrapper", `${t}`],
      wrapperInner: ["wrapperInner", `${t}`]
    };
    return pt(r, Ofe, n)
  },
  Mfe = me("div", {
    name: "MuiCollapse",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, t[n.orientation], n.state === "entered" && t.entered, n.state === "exited" && !n.in && n.collapsedSize === "0px" && t.hidden]
    }
  })(({
    theme: e,
    ownerState: t
  }) => K({
    height: 0,
    overflow: "hidden",
    transition: e.transitions.create("height")
  }, t.orientation === "horizontal" && {
    height: "auto",
    width: 0,
    transition: e.transitions.create("width")
  }, t.state === "entered" && K({
    height: "auto",
    overflow: "visible"
  }, t.orientation === "horizontal" && {
    width: "auto"
  }), t.state === "exited" && !t.in && t.collapsedSize === "0px" && {
    visibility: "hidden"
  })),
  $fe = me("div", {
    name: "MuiCollapse",
    slot: "Wrapper",
    overridesResolver: (e, t) => t.wrapper
  })(({
    ownerState: e
  }) => K({
    display: "flex",
    width: "100%"
  }, e.orientation === "horizontal" && {
    width: "auto",
    height: "100%"
  })),
  Lfe = me("div", {
    name: "MuiCollapse",
    slot: "WrapperInner",
    overridesResolver: (e, t) => t.wrapperInner
  })(({
    ownerState: e
  }) => K({
    width: "100%"
  }, e.orientation === "horizontal" && {
    width: "auto",
    height: "100%"
  })),
  Nz = j.forwardRef(function (t, n) {
    const r = xt({
        props: t,
        name: "MuiCollapse"
      }),
      {
        addEndListener: i,
        children: s,
        className: o,
        collapsedSize: a = "0px",
        component: c,
        easing: l,
        in: u,
        onEnter: f,
        onEntered: h,
        onEntering: g,
        onExit: y,
        onExited: x,
        onExiting: k,
        orientation: _ = "vertical",
        style: p,
        timeout: v = xz.standard,
        TransitionComponent: S = S5
      } = r,
      I = Ve(r, Dfe),
      A = K({}, r, {
        orientation: _,
        collapsedSize: a
      }),
      w = Nfe(A),
      E = vl(),
      D = Pf(),
      $ = j.useRef(null),
      V = j.useRef(),
      G = typeof a == "number" ? `${a}px` : a,
      L = _ === "horizontal",
      b = L ? "width" : "height",
      T = j.useRef(null),
      R = vr(n, T),
      N = ne => X => {
        if (ne) {
          const Z = T.current;
          X === void 0 ? ne(Z) : ne(Z, X)
        }
      },
      O = () => $.current ? $.current[L ? "clientWidth" : "clientHeight"] : 0,
      U = N((ne, X) => {
        $.current && L && ($.current.style.position = "absolute"), ne.style[b] = G, f && f(ne, X)
      }),
      q = N((ne, X) => {
        const Z = O();
        $.current && L && ($.current.style.position = "");
        const {
          duration: te,
          easing: F
        } = Ed({
          style: p,
          timeout: v,
          easing: l
        }, {
          mode: "enter"
        });
        if (v === "auto") {
          const J = E.transitions.getAutoHeightDuration(Z);
          ne.style.transitionDuration = `${J}ms`, V.current = J
        } else ne.style.transitionDuration = typeof te == "string" ? te : `${te}ms`;
        ne.style[b] = `${Z}px`, ne.style.transitionTimingFunction = F, g && g(ne, X)
      }),
      W = N((ne, X) => {
        ne.style[b] = "auto", h && h(ne, X)
      }),
      M = N(ne => {
        ne.style[b] = `${O()}px`, y && y(ne)
      }),
      Q = N(x),
      he = N(ne => {
        const X = O(),
          {
            duration: Z,
            easing: te
          } = Ed({
            style: p,
            timeout: v,
            easing: l
          }, {
            mode: "exit"
          });
        if (v === "auto") {
          const F = E.transitions.getAutoHeightDuration(X);
          ne.style.transitionDuration = `${F}ms`, V.current = F
        } else ne.style.transitionDuration = typeof Z == "string" ? Z : `${Z}ms`;
        ne.style[b] = G, ne.style.transitionTimingFunction = te, k && k(ne)
      }),
      H = ne => {
        v === "auto" && D.start(V.current || 0, ne), i && i(T.current, ne)
      };
    return C.jsx(S, K({
      in: u,
      onEnter: U,
      onEntered: W,
      onEntering: q,
      onExit: M,
      onExited: Q,
      onExiting: he,
      addEndListener: H,
      nodeRef: T,
      timeout: v === "auto" ? null : v
    }, I, {
      children: (ne, X) => C.jsx(Mfe, K({
        as: c,
        className: Ye(w.root, o, {
          entered: w.entered,
          exited: !u && G === "0px" && w.hidden
        } [ne]),
        style: K({
          [L ? "minWidth" : "minHeight"]: G
        }, p),
        ref: R
      }, X, {
        ownerState: K({}, A, {
          state: ne
        }),
        children: C.jsx($fe, {
          ownerState: K({}, A, {
            state: ne
          }),
          className: w.wrapper,
          ref: $,
          children: C.jsx(Lfe, {
            ownerState: K({}, A, {
              state: ne
            }),
            className: w.wrapperInner,
            children: s
          })
        })
      }))
    }))
  });
Nz.muiSupportAuto = !0;
const fo = Nz;

function Bfe(e) {
  return mt("MuiPaper", e)
}
gt("MuiPaper", ["root", "rounded", "outlined", "elevation", "elevation0", "elevation1", "elevation2", "elevation3", "elevation4", "elevation5", "elevation6", "elevation7", "elevation8", "elevation9", "elevation10", "elevation11", "elevation12", "elevation13", "elevation14", "elevation15", "elevation16", "elevation17", "elevation18", "elevation19", "elevation20", "elevation21", "elevation22", "elevation23", "elevation24"]);
const Ffe = ["className", "component", "elevation", "square", "variant"],
  jfe = e => {
    const {
      square: t,
      elevation: n,
      variant: r,
      classes: i
    } = e, s = {
      root: ["root", r, !t && "rounded", r === "elevation" && `elevation${n}`]
    };
    return pt(s, Bfe, i)
  },
  Ufe = me("div", {
    name: "MuiPaper",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, t[n.variant], !n.square && t.rounded, n.variant === "elevation" && t[`elevation${n.elevation}`]]
    }
  })(({
    theme: e,
    ownerState: t
  }) => {
    var n;
    return K({
      backgroundColor: (e.vars || e).palette.background.paper,
      color: (e.vars || e).palette.text.primary,
      transition: e.transitions.create("box-shadow")
    }, !t.square && {
      borderRadius: e.shape.borderRadius
    }, t.variant === "outlined" && {
      border: `1px solid ${(e.vars||e).palette.divider}`
    }, t.variant === "elevation" && K({
      boxShadow: (e.vars || e).shadows[t.elevation]
    }, !e.vars && e.palette.mode === "dark" && {
      backgroundImage: `linear-gradient(${lr("#fff",bD(t.elevation))}, ${lr("#fff",bD(t.elevation))})`
    }, e.vars && {
      backgroundImage: (n = e.vars.overlays) == null ? void 0 : n[t.elevation]
    }))
  }),
  zfe = j.forwardRef(function (t, n) {
    const r = xt({
        props: t,
        name: "MuiPaper"
      }),
      {
        className: i,
        component: s = "div",
        elevation: o = 1,
        square: a = !1,
        variant: c = "elevation"
      } = r,
      l = Ve(r, Ffe),
      u = K({}, r, {
        component: s,
        elevation: o,
        square: a,
        variant: c
      }),
      f = jfe(u);
    return C.jsx(Ufe, K({
      as: s,
      ownerState: u,
      className: Ye(f.root, i),
      ref: n
    }, l))
  }),
  z2 = zfe;

function _p(e) {
  return typeof e == "string"
}

function z0(e, t, n) {
  return e === void 0 || _p(e) ? t : K({}, t, {
    ownerState: K({}, t.ownerState, n)
  })
}
const Hfe = {
    disableDefaultClasses: !1
  },
  Vfe = j.createContext(Hfe);

function Wfe(e) {
  const {
    disableDefaultClasses: t
  } = j.useContext(Vfe);
  return n => t ? "" : e(n)
}

function Mz(e, t = []) {
  if (e === void 0) return {};
  const n = {};
  return Object.keys(e).filter(r => r.match(/^on[A-Z]/) && typeof e[r] == "function" && !t.includes(r)).forEach(r => {
    n[r] = e[r]
  }), n
}

function $z(e, t, n) {
  return typeof e == "function" ? e(t, n) : e
}

function Lz(e) {
  var t, n, r = "";
  if (typeof e == "string" || typeof e == "number") r += e;
  else if (typeof e == "object")
    if (Array.isArray(e)) {
      var i = e.length;
      for (t = 0; t < i; t++) e[t] && (n = Lz(e[t])) && (r && (r += " "), r += n)
    } else
      for (n in e) e[n] && (r && (r += " "), r += n);
  return r
}

function xD() {
  for (var e, t, n = 0, r = "", i = arguments.length; n < i; n++)(e = arguments[n]) && (t = Lz(e)) && (r && (r += " "), r += t);
  return r
}

function ED(e) {
  if (e === void 0) return {};
  const t = {};
  return Object.keys(e).filter(n => !(n.match(/^on[A-Z]/) && typeof e[n] == "function")).forEach(n => {
    t[n] = e[n]
  }), t
}

function Bz(e) {
  const {
    getSlotProps: t,
    additionalProps: n,
    externalSlotProps: r,
    externalForwardedProps: i,
    className: s
  } = e;
  if (!t) {
    const g = xD(n == null ? void 0 : n.className, s, i == null ? void 0 : i.className, r == null ? void 0 : r.className),
      y = K({}, n == null ? void 0 : n.style, i == null ? void 0 : i.style, r == null ? void 0 : r.style),
      x = K({}, n, i, r);
    return g.length > 0 && (x.className = g), Object.keys(y).length > 0 && (x.style = y), {
      props: x,
      internalRef: void 0
    }
  }
  const o = Mz(K({}, i, r)),
    a = ED(r),
    c = ED(i),
    l = t(o),
    u = xD(l == null ? void 0 : l.className, n == null ? void 0 : n.className, s, i == null ? void 0 : i.className, r == null ? void 0 : r.className),
    f = K({}, l == null ? void 0 : l.style, n == null ? void 0 : n.style, i == null ? void 0 : i.style, r == null ? void 0 : r.style),
    h = K({}, l, n, c, a);
  return u.length > 0 && (h.className = u), Object.keys(f).length > 0 && (h.style = f), {
    props: h,
    internalRef: l.ref
  }
}
const qfe = ["elementType", "externalSlotProps", "ownerState", "skipResolvingSlotProps"];

function zo(e) {
  var t;
  const {
    elementType: n,
    externalSlotProps: r,
    ownerState: i,
    skipResolvingSlotProps: s = !1
  } = e, o = Ve(e, qfe), a = s ? {} : $z(r, i), {
    props: c,
    internalRef: l
  } = Bz(K({}, o, {
    externalSlotProps: a
  })), u = vr(l, a == null ? void 0 : a.ref, (t = e.additionalProps) == null ? void 0 : t.ref);
  return z0(n, K({}, c, {
    ref: u
  }), i)
}
const Gfe = ["className", "elementType", "ownerState", "externalForwardedProps", "getSlotOwnerState", "internalForwardedProps"],
  Kfe = ["component", "slots", "slotProps"],
  Qfe = ["component"];

function Yfe(e, t) {
  const {
    className: n,
    elementType: r,
    ownerState: i,
    externalForwardedProps: s,
    getSlotOwnerState: o,
    internalForwardedProps: a
  } = t, c = Ve(t, Gfe), {
    component: l,
    slots: u = {
      [e]: void 0
    },
    slotProps: f = {
      [e]: void 0
    }
  } = s, h = Ve(s, Kfe), g = u[e] || r, y = $z(f[e], i), x = Bz(K({
    className: n
  }, c, {
    externalForwardedProps: e === "root" ? h : void 0,
    externalSlotProps: y
  })), {
    props: {
      component: k
    },
    internalRef: _
  } = x, p = Ve(x.props, Qfe), v = vr(_, y == null ? void 0 : y.ref, t.ref), S = o ? o(p) : {}, I = K({}, i, S), A = e === "root" ? k || l : k, w = z0(g, K({}, e === "root" && !l && !u[e] && a, e !== "root" && !u[e] && a, p, A && {
    as: A
  }, {
    ref: v
  }), I);
  return Object.keys(S).forEach(E => {
    delete w[E]
  }), [g, w]
}

function Jfe(e) {
  const {
    className: t,
    classes: n,
    pulsate: r = !1,
    rippleX: i,
    rippleY: s,
    rippleSize: o,
    in: a,
    onExited: c,
    timeout: l
  } = e, [u, f] = j.useState(!1), h = Ye(t, n.ripple, n.rippleVisible, r && n.ripplePulsate), g = {
    width: o,
    height: o,
    top: -(o / 2) + s,
    left: -(o / 2) + i
  }, y = Ye(n.child, u && n.childLeaving, r && n.childPulsate);
  return !a && !u && f(!0), j.useEffect(() => {
    if (!a && c != null) {
      const x = setTimeout(c, l);
      return () => {
        clearTimeout(x)
      }
    }
  }, [c, a, l]), C.jsx("span", {
    className: h,
    style: g,
    children: C.jsx("span", {
      className: y
    })
  })
}
const Xfe = gt("MuiTouchRipple", ["root", "ripple", "rippleVisible", "ripplePulsate", "child", "childLeaving", "childPulsate"]),
  Zs = Xfe,
  Zfe = ["center", "classes", "className"];
let C5 = e => e,
  SD, CD, AD, TD;
const qC = 550,
  ehe = 80,
  the = yl(SD || (SD = C5 `
  0% {
    transform: scale(0);
    opacity: 0.1;
  }

  100% {
    transform: scale(1);
    opacity: 0.3;
  }
`)),
  nhe = yl(CD || (CD = C5 `
  0% {
    opacity: 1;
  }

  100% {
    opacity: 0;
  }
`)),
  rhe = yl(AD || (AD = C5 `
  0% {
    transform: scale(1);
  }

  50% {
    transform: scale(0.92);
  }

  100% {
    transform: scale(1);
  }
`)),
  ihe = me("span", {
    name: "MuiTouchRipple",
    slot: "Root"
  })({
    overflow: "hidden",
    pointerEvents: "none",
    position: "absolute",
    zIndex: 0,
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    borderRadius: "inherit"
  }),
  she = me(Jfe, {
    name: "MuiTouchRipple",
    slot: "Ripple"
  })(TD || (TD = C5 `
  opacity: 0;
  position: absolute;

  &.${0} {
    opacity: 0.3;
    transform: scale(1);
    animation-name: ${0};
    animation-duration: ${0}ms;
    animation-timing-function: ${0};
  }

  &.${0} {
    animation-duration: ${0}ms;
  }

  & .${0} {
    opacity: 1;
    display: block;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background-color: currentColor;
  }

  & .${0} {
    opacity: 0;
    animation-name: ${0};
    animation-duration: ${0}ms;
    animation-timing-function: ${0};
  }

  & .${0} {
    position: absolute;
    /* @noflip */
    left: 0px;
    top: 0;
    animation-name: ${0};
    animation-duration: 2500ms;
    animation-timing-function: ${0};
    animation-iteration-count: infinite;
    animation-delay: 200ms;
  }
`), Zs.rippleVisible, the, qC, ({
    theme: e
  }) => e.transitions.easing.easeInOut, Zs.ripplePulsate, ({
    theme: e
  }) => e.transitions.duration.shorter, Zs.child, Zs.childLeaving, nhe, qC, ({
    theme: e
  }) => e.transitions.easing.easeInOut, Zs.childPulsate, rhe, ({
    theme: e
  }) => e.transitions.easing.easeInOut),
  ohe = j.forwardRef(function (t, n) {
    const r = xt({
        props: t,
        name: "MuiTouchRipple"
      }),
      {
        center: i = !1,
        classes: s = {},
        className: o
      } = r,
      a = Ve(r, Zfe),
      [c, l] = j.useState([]),
      u = j.useRef(0),
      f = j.useRef(null);
    j.useEffect(() => {
      f.current && (f.current(), f.current = null)
    }, [c]);
    const h = j.useRef(!1),
      g = Pf(),
      y = j.useRef(null),
      x = j.useRef(null),
      k = j.useCallback(S => {
        const {
          pulsate: I,
          rippleX: A,
          rippleY: w,
          rippleSize: E,
          cb: D
        } = S;
        l($ => [...$, C.jsx(she, {
          classes: {
            ripple: Ye(s.ripple, Zs.ripple),
            rippleVisible: Ye(s.rippleVisible, Zs.rippleVisible),
            ripplePulsate: Ye(s.ripplePulsate, Zs.ripplePulsate),
            child: Ye(s.child, Zs.child),
            childLeaving: Ye(s.childLeaving, Zs.childLeaving),
            childPulsate: Ye(s.childPulsate, Zs.childPulsate)
          },
          timeout: qC,
          pulsate: I,
          rippleX: A,
          rippleY: w,
          rippleSize: E
        }, u.current)]), u.current += 1, f.current = D
      }, [s]),
      _ = j.useCallback((S = {}, I = {}, A = () => {}) => {
        const {
          pulsate: w = !1,
          center: E = i || I.pulsate,
          fakeElement: D = !1
        } = I;
        if ((S == null ? void 0 : S.type) === "mousedown" && h.current) {
          h.current = !1;
          return
        }(S == null ? void 0 : S.type) === "touchstart" && (h.current = !0);
        const $ = D ? null : x.current,
          V = $ ? $.getBoundingClientRect() : {
            width: 0,
            height: 0,
            left: 0,
            top: 0
          };
        let G, L, b;
        if (E || S === void 0 || S.clientX === 0 && S.clientY === 0 || !S.clientX && !S.touches) G = Math.round(V.width / 2), L = Math.round(V.height / 2);
        else {
          const {
            clientX: T,
            clientY: R
          } = S.touches && S.touches.length > 0 ? S.touches[0] : S;
          G = Math.round(T - V.left), L = Math.round(R - V.top)
        }
        if (E) b = Math.sqrt((2 * V.width ** 2 + V.height ** 2) / 3), b % 2 === 0 && (b += 1);
        else {
          const T = Math.max(Math.abs(($ ? $.clientWidth : 0) - G), G) * 2 + 2,
            R = Math.max(Math.abs(($ ? $.clientHeight : 0) - L), L) * 2 + 2;
          b = Math.sqrt(T ** 2 + R ** 2)
        }
        S != null && S.touches ? y.current === null && (y.current = () => {
          k({
            pulsate: w,
            rippleX: G,
            rippleY: L,
            rippleSize: b,
            cb: A
          })
        }, g.start(ehe, () => {
          y.current && (y.current(), y.current = null)
        })) : k({
          pulsate: w,
          rippleX: G,
          rippleY: L,
          rippleSize: b,
          cb: A
        })
      }, [i, k, g]),
      p = j.useCallback(() => {
        _({}, {
          pulsate: !0
        })
      }, [_]),
      v = j.useCallback((S, I) => {
        if (g.clear(), (S == null ? void 0 : S.type) === "touchend" && y.current) {
          y.current(), y.current = null, g.start(0, () => {
            v(S, I)
          });
          return
        }
        y.current = null, l(A => A.length > 0 ? A.slice(1) : A), f.current = I
      }, [g]);
    return j.useImperativeHandle(n, () => ({
      pulsate: p,
      start: _,
      stop: v
    }), [p, _, v]), C.jsx(ihe, K({
      className: Ye(Zs.root, s.root, o),
      ref: x
    }, a, {
      children: C.jsx(Rfe, {
        component: null,
        exit: !0,
        children: c
      })
    }))
  }),
  ahe = ohe;

function che(e) {
  return mt("MuiButtonBase", e)
}
const lhe = gt("MuiButtonBase", ["root", "disabled", "focusVisible"]),
  uhe = ["action", "centerRipple", "children", "className", "component", "disabled", "disableRipple", "disableTouchRipple", "focusRipple", "focusVisibleClassName", "LinkComponent", "onBlur", "onClick", "onContextMenu", "onDragLeave", "onFocus", "onFocusVisible", "onKeyDown", "onKeyUp", "onMouseDown", "onMouseLeave", "onMouseUp", "onTouchEnd", "onTouchMove", "onTouchStart", "tabIndex", "TouchRippleProps", "touchRippleRef", "type"],
  dhe = e => {
    const {
      disabled: t,
      focusVisible: n,
      focusVisibleClassName: r,
      classes: i
    } = e, o = pt({
      root: ["root", t && "disabled", n && "focusVisible"]
    }, che, i);
    return n && r && (o.root += ` ${r}`), o
  },
  fhe = me("button", {
    name: "MuiButtonBase",
    slot: "Root",
    overridesResolver: (e, t) => t.root
  })({
    display: "inline-flex",
    alignItems: "center",
    justifyContent: "center",
    position: "relative",
    boxSizing: "border-box",
    WebkitTapHighlightColor: "transparent",
    backgroundColor: "transparent",
    outline: 0,
    border: 0,
    margin: 0,
    borderRadius: 0,
    padding: 0,
    cursor: "pointer",
    userSelect: "none",
    verticalAlign: "middle",
    MozAppearance: "none",
    WebkitAppearance: "none",
    textDecoration: "none",
    color: "inherit",
    "&::-moz-focus-inner": {
      borderStyle: "none"
    },
    [`&.${lhe.disabled}`]: {
      pointerEvents: "none",
      cursor: "default"
    },
    "@media print": {
      colorAdjust: "exact"
    }
  }),
  hhe = j.forwardRef(function (t, n) {
    const r = xt({
        props: t,
        name: "MuiButtonBase"
      }),
      {
        action: i,
        centerRipple: s = !1,
        children: o,
        className: a,
        component: c = "button",
        disabled: l = !1,
        disableRipple: u = !1,
        disableTouchRipple: f = !1,
        focusRipple: h = !1,
        LinkComponent: g = "a",
        onBlur: y,
        onClick: x,
        onContextMenu: k,
        onDragLeave: _,
        onFocus: p,
        onFocusVisible: v,
        onKeyDown: S,
        onKeyUp: I,
        onMouseDown: A,
        onMouseLeave: w,
        onMouseUp: E,
        onTouchEnd: D,
        onTouchMove: $,
        onTouchStart: V,
        tabIndex: G = 0,
        TouchRippleProps: L,
        touchRippleRef: b,
        type: T
      } = r,
      R = Ve(r, uhe),
      N = j.useRef(null),
      O = j.useRef(null),
      U = vr(O, b),
      {
        isFocusVisibleRef: q,
        onFocus: W,
        onBlur: M,
        ref: Q
      } = Zx(),
      [he, H] = j.useState(!1);
    l && he && H(!1), j.useImperativeHandle(i, () => ({
      focusVisible: () => {
        H(!0), N.current.focus()
      }
    }), []);
    const [ne, X] = j.useState(!1);
    j.useEffect(() => {
      X(!0)
    }, []);
    const Z = ne && !u && !l;
    j.useEffect(() => {
      he && h && !u && ne && O.current.pulsate()
    }, [u, h, he, ne]);

    function te(ke, ze, ct = f) {
      return Ea(Xe => (ze && ze(Xe), !ct && O.current && O.current[ke](Xe), !0))
    }
    const F = te("start", A),
      J = te("stop", k),
      ie = te("stop", _),
      ce = te("stop", E),
      ue = te("stop", ke => {
        he && ke.preventDefault(), w && w(ke)
      }),
      ge = te("start", V),
      et = te("stop", D),
      He = te("stop", $),
      se = te("stop", ke => {
        M(ke), q.current === !1 && H(!1), y && y(ke)
      }, !1),
      pe = Ea(ke => {
        N.current || (N.current = ke.currentTarget), W(ke), q.current === !0 && (H(!0), v && v(ke)), p && p(ke)
      }),
      de = () => {
        const ke = N.current;
        return c && c !== "button" && !(ke.tagName === "A" && ke.href)
      },
      we = j.useRef(!1),
      Ce = Ea(ke => {
        h && !we.current && he && O.current && ke.key === " " && (we.current = !0, O.current.stop(ke, () => {
          O.current.start(ke)
        })), ke.target === ke.currentTarget && de() && ke.key === " " && ke.preventDefault(), S && S(ke), ke.target === ke.currentTarget && de() && ke.key === "Enter" && !l && (ke.preventDefault(), x && x(ke))
      }),
      be = Ea(ke => {
        h && ke.key === " " && O.current && he && !ke.defaultPrevented && (we.current = !1, O.current.stop(ke, () => {
          O.current.pulsate(ke)
        })), I && I(ke), x && ke.target === ke.currentTarget && de() && ke.key === " " && !ke.defaultPrevented && x(ke)
      });
    let Se = c;
    Se === "button" && (R.href || R.to) && (Se = g);
    const Fe = {};
    Se === "button" ? (Fe.type = T === void 0 ? "button" : T, Fe.disabled = l) : (!R.href && !R.to && (Fe.role = "button"), l && (Fe["aria-disabled"] = l));
    const Ne = vr(n, Q, N),
      Me = K({}, r, {
        centerRipple: s,
        component: c,
        disabled: l,
        disableRipple: u,
        disableTouchRipple: f,
        focusRipple: h,
        tabIndex: G,
        focusVisible: he
      }),
      We = dhe(Me);
    return C.jsxs(fhe, K({
      as: Se,
      className: Ye(We.root, a),
      ownerState: Me,
      onBlur: se,
      onClick: x,
      onContextMenu: J,
      onFocus: pe,
      onKeyDown: Ce,
      onKeyUp: be,
      onMouseDown: F,
      onMouseLeave: ue,
      onMouseUp: ce,
      onDragLeave: ie,
      onTouchEnd: et,
      onTouchMove: He,
      onTouchStart: ge,
      ref: Ne,
      tabIndex: l ? -1 : G,
      type: T
    }, Fe, R, {
      children: [o, Z ? C.jsx(ahe, K({
        ref: U,
        center: s
      }, L)) : null]
    }))
  }),
  gu = hhe;

function phe(e) {
  return mt("MuiIconButton", e)
}
const mhe = gt("MuiIconButton", ["root", "disabled", "colorInherit", "colorPrimary", "colorSecondary", "colorError", "colorInfo", "colorSuccess", "colorWarning", "edgeStart", "edgeEnd", "sizeSmall", "sizeMedium", "sizeLarge"]),
  ghe = ["edge", "children", "className", "color", "disabled", "disableFocusRipple", "size"],
  yhe = e => {
    const {
      classes: t,
      disabled: n,
      color: r,
      edge: i,
      size: s
    } = e, o = {
      root: ["root", n && "disabled", r !== "default" && `color${qe(r)}`, i && `edge${qe(i)}`, `size${qe(s)}`]
    };
    return pt(o, phe, t)
  },
  vhe = me(gu, {
    name: "MuiIconButton",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, n.color !== "default" && t[`color${qe(n.color)}`], n.edge && t[`edge${qe(n.edge)}`], t[`size${qe(n.size)}`]]
    }
  })(({
    theme: e,
    ownerState: t
  }) => K({
    textAlign: "center",
    flex: "0 0 auto",
    fontSize: e.typography.pxToRem(24),
    padding: 8,
    borderRadius: "50%",
    overflow: "visible",
    color: (e.vars || e).palette.action.active,
    transition: e.transitions.create("background-color", {
      duration: e.transitions.duration.shortest
    })
  }, !t.disableRipple && {
    "&:hover": {
      backgroundColor: e.vars ? `rgba(${e.vars.palette.action.activeChannel} / ${e.vars.palette.action.hoverOpacity})` : lr(e.palette.action.active, e.palette.action.hoverOpacity),
      "@media (hover: none)": {
        backgroundColor: "transparent"
      }
    }
  }, t.edge === "start" && {
    marginLeft: t.size === "small" ? -3 : -12
  }, t.edge === "end" && {
    marginRight: t.size === "small" ? -3 : -12
  }), ({
    theme: e,
    ownerState: t
  }) => {
    var n;
    const r = (n = (e.vars || e).palette) == null ? void 0 : n[t.color];
    return K({}, t.color === "inherit" && {
      color: "inherit"
    }, t.color !== "inherit" && t.color !== "default" && K({
      color: r == null ? void 0 : r.main
    }, !t.disableRipple && {
      "&:hover": K({}, r && {
        backgroundColor: e.vars ? `rgba(${r.mainChannel} / ${e.vars.palette.action.hoverOpacity})` : lr(r.main, e.palette.action.hoverOpacity)
      }, {
        "@media (hover: none)": {
          backgroundColor: "transparent"
        }
      })
    }), t.size === "small" && {
      padding: 5,
      fontSize: e.typography.pxToRem(18)
    }, t.size === "large" && {
      padding: 12,
      fontSize: e.typography.pxToRem(28)
    }, {
      [`&.${mhe.disabled}`]: {
        backgroundColor: "transparent",
        color: (e.vars || e).palette.action.disabled
      }
    })
  }),
  bhe = j.forwardRef(function (t, n) {
    const r = xt({
        props: t,
        name: "MuiIconButton"
      }),
      {
        edge: i = !1,
        children: s,
        className: o,
        color: a = "default",
        disabled: c = !1,
        disableFocusRipple: l = !1,
        size: u = "medium"
      } = r,
      f = Ve(r, ghe),
      h = K({}, r, {
        edge: i,
        color: a,
        disabled: c,
        disableFocusRipple: l,
        size: u
      }),
      g = yhe(h);
    return C.jsx(vhe, K({
      className: Ye(g.root, o),
      centerRipple: !0,
      focusRipple: !l,
      disabled: c,
      ref: n
    }, f, {
      ownerState: h,
      children: s
    }))
  }),
  _s = bhe;

function whe(e) {
  return mt("MuiTypography", e)
}
gt("MuiTypography", ["root", "h1", "h2", "h3", "h4", "h5", "h6", "subtitle1", "subtitle2", "body1", "body2", "inherit", "button", "caption", "overline", "alignLeft", "alignRight", "alignCenter", "alignJustify", "noWrap", "gutterBottom", "paragraph"]);
const xhe = ["align", "className", "component", "gutterBottom", "noWrap", "paragraph", "variant", "variantMapping"],
  Ehe = e => {
    const {
      align: t,
      gutterBottom: n,
      noWrap: r,
      paragraph: i,
      variant: s,
      classes: o
    } = e, a = {
      root: ["root", s, e.align !== "inherit" && `align${qe(t)}`, n && "gutterBottom", r && "noWrap", i && "paragraph"]
    };
    return pt(a, whe, o)
  },
  She = me("span", {
    name: "MuiTypography",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, n.variant && t[n.variant], n.align !== "inherit" && t[`align${qe(n.align)}`], n.noWrap && t.noWrap, n.gutterBottom && t.gutterBottom, n.paragraph && t.paragraph]
    }
  })(({
    theme: e,
    ownerState: t
  }) => K({
    margin: 0
  }, t.variant === "inherit" && {
    font: "inherit"
  }, t.variant !== "inherit" && e.typography[t.variant], t.align !== "inherit" && {
    textAlign: t.align
  }, t.noWrap && {
    overflow: "hidden",
    textOverflow: "ellipsis",
    whiteSpace: "nowrap"
  }, t.gutterBottom && {
    marginBottom: "0.35em"
  }, t.paragraph && {
    marginBottom: 16
  })),
  kD = {
    h1: "h1",
    h2: "h2",
    h3: "h3",
    h4: "h4",
    h5: "h5",
    h6: "h6",
    subtitle1: "h6",
    subtitle2: "h6",
    body1: "p",
    body2: "p",
    inherit: "p"
  },
  Che = {
    primary: "primary.main",
    textPrimary: "text.primary",
    secondary: "secondary.main",
    textSecondary: "text.secondary",
    error: "error.main"
  },
  Ahe = e => Che[e] || e,
  The = j.forwardRef(function (t, n) {
    const r = xt({
        props: t,
        name: "MuiTypography"
      }),
      i = Ahe(r.color),
      s = b5(K({}, r, {
        color: i
      })),
      {
        align: o = "inherit",
        className: a,
        component: c,
        gutterBottom: l = !1,
        noWrap: u = !1,
        paragraph: f = !1,
        variant: h = "body1",
        variantMapping: g = kD
      } = s,
      y = Ve(s, xhe),
      x = K({}, s, {
        align: o,
        color: i,
        className: a,
        component: c,
        gutterBottom: l,
        noWrap: u,
        paragraph: f,
        variant: h,
        variantMapping: g
      }),
      k = c || (f ? "p" : g[h] || kD[h]) || "span",
      _ = Ehe(x);
    return C.jsx(She, K({
      as: k,
      ref: n,
      ownerState: x,
      className: Ye(_.root, a)
    }, y))
  }),
  Ue = The;

function khe(e) {
  return mt("MuiAppBar", e)
}
gt("MuiAppBar", ["root", "positionFixed", "positionAbsolute", "positionSticky", "positionStatic", "positionRelative", "colorDefault", "colorPrimary", "colorSecondary", "colorInherit", "colorTransparent", "colorError", "colorInfo", "colorSuccess", "colorWarning"]);
const _he = ["className", "color", "enableColorOnDark", "position"],
  Ihe = e => {
    const {
      color: t,
      position: n,
      classes: r
    } = e, i = {
      root: ["root", `color${qe(t)}`, `position${qe(n)}`]
    };
    return pt(i, khe, r)
  },
  ob = (e, t) => e ? `${e==null?void 0:e.replace(")","")}, ${t})` : t,
  Phe = me(z2, {
    name: "MuiAppBar",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, t[`position${qe(n.position)}`], t[`color${qe(n.color)}`]]
    }
  })(({
    theme: e,
    ownerState: t
  }) => {
    const n = e.palette.mode === "light" ? e.palette.grey[100] : e.palette.grey[900];
    return K({
      display: "flex",
      flexDirection: "column",
      width: "100%",
      boxSizing: "border-box",
      flexShrink: 0
    }, t.position === "fixed" && {
      position: "fixed",
      zIndex: (e.vars || e).zIndex.appBar,
      top: 0,
      left: "auto",
      right: 0,
      "@media print": {
        position: "absolute"
      }
    }, t.position === "absolute" && {
      position: "absolute",
      zIndex: (e.vars || e).zIndex.appBar,
      top: 0,
      left: "auto",
      right: 0
    }, t.position === "sticky" && {
      position: "sticky",
      zIndex: (e.vars || e).zIndex.appBar,
      top: 0,
      left: "auto",
      right: 0
    }, t.position === "static" && {
      position: "static"
    }, t.position === "relative" && {
      position: "relative"
    }, !e.vars && K({}, t.color === "default" && {
      backgroundColor: n,
      color: e.palette.getContrastText(n)
    }, t.color && t.color !== "default" && t.color !== "inherit" && t.color !== "transparent" && {
      backgroundColor: e.palette[t.color].main,
      color: e.palette[t.color].contrastText
    }, t.color === "inherit" && {
      color: "inherit"
    }, e.palette.mode === "dark" && !t.enableColorOnDark && {
      backgroundColor: null,
      color: null
    }, t.color === "transparent" && K({
      backgroundColor: "transparent",
      color: "inherit"
    }, e.palette.mode === "dark" && {
      backgroundImage: "none"
    })), e.vars && K({}, t.color === "default" && {
      "--AppBar-background": t.enableColorOnDark ? e.vars.palette.AppBar.defaultBg : ob(e.vars.palette.AppBar.darkBg, e.vars.palette.AppBar.defaultBg),
      "--AppBar-color": t.enableColorOnDark ? e.vars.palette.text.primary : ob(e.vars.palette.AppBar.darkColor, e.vars.palette.text.primary)
    }, t.color && !t.color.match(/^(default|inherit|transparent)$/) && {
      "--AppBar-background": t.enableColorOnDark ? e.vars.palette[t.color].main : ob(e.vars.palette.AppBar.darkBg, e.vars.palette[t.color].main),
      "--AppBar-color": t.enableColorOnDark ? e.vars.palette[t.color].contrastText : ob(e.vars.palette.AppBar.darkColor, e.vars.palette[t.color].contrastText)
    }, {
      backgroundColor: "var(--AppBar-background)",
      color: t.color === "inherit" ? "inherit" : "var(--AppBar-color)"
    }, t.color === "transparent" && {
      backgroundImage: "none",
      backgroundColor: "transparent",
      color: "inherit"
    }))
  }),
  Rhe = j.forwardRef(function (t, n) {
    const r = xt({
        props: t,
        name: "MuiAppBar"
      }),
      {
        className: i,
        color: s = "primary",
        enableColorOnDark: o = !1,
        position: a = "fixed"
      } = r,
      c = Ve(r, _he),
      l = K({}, r, {
        color: s,
        position: a,
        enableColorOnDark: o
      }),
      u = Ihe(l);
    return C.jsx(Phe, K({
      square: !0,
      component: "header",
      ownerState: l,
      elevation: 4,
      className: Ye(u.root, i, a === "fixed" && "mui-fixed"),
      ref: n
    }, c))
  }),
  Ohe = Rhe;

function Dhe(e) {
  const {
    badgeContent: t,
    invisible: n = !1,
    max: r = 99,
    showZero: i = !1
  } = e, s = NU({
    badgeContent: t,
    max: r
  });
  let o = n;
  n === !1 && t === 0 && !i && (o = !0);
  const {
    badgeContent: a,
    max: c = r
  } = o ? s : e, l = a && Number(a) > c ? `${c}+` : a;
  return {
    badgeContent: a,
    invisible: o,
    max: c,
    displayValue: l
  }
}
const Fz = "base";

function Nhe(e) {
  return `${Fz}--${e}`
}

function Mhe(e, t) {
  return `${Fz}-${e}-${t}`
}

function jz(e, t) {
  const n = MU[t];
  return n ? Nhe(n) : Mhe(e, t)
}

function $he(e, t) {
  const n = {};
  return t.forEach(r => {
    n[r] = jz(e, r)
  }), n
}
const Lhe = ["input", "select", "textarea", "a[href]", "button", "[tabindex]", "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable="false"])'].join(",");

function Bhe(e) {
  const t = parseInt(e.getAttribute("tabindex") || "", 10);
  return Number.isNaN(t) ? e.contentEditable === "true" || (e.nodeName === "AUDIO" || e.nodeName === "VIDEO" || e.nodeName === "DETAILS") && e.getAttribute("tabindex") === null ? 0 : e.tabIndex : t
}

function Fhe(e) {
  if (e.tagName !== "INPUT" || e.type !== "radio" || !e.name) return !1;
  const t = r => e.ownerDocument.querySelector(`input[type="radio"]${r}`);
  let n = t(`[name="${e.name}"]:checked`);
  return n || (n = t(`[name="${e.name}"]`)), n !== e
}

function jhe(e) {
  return !(e.disabled || e.tagName === "INPUT" && e.type === "hidden" || Fhe(e))
}

function Uhe(e) {
  const t = [],
    n = [];
  return Array.from(e.querySelectorAll(Lhe)).forEach((r, i) => {
    const s = Bhe(r);
    s === -1 || !jhe(r) || (s === 0 ? t.push(r) : n.push({
      documentOrder: i,
      tabIndex: s,
      node: r
    }))
  }), n.sort((r, i) => r.tabIndex === i.tabIndex ? r.documentOrder - i.documentOrder : r.tabIndex - i.tabIndex).map(r => r.node).concat(t)
}

function zhe() {
  return !0
}

function Hhe(e) {
  const {
    children: t,
    disableAutoFocus: n = !1,
    disableEnforceFocus: r = !1,
    disableRestoreFocus: i = !1,
    getTabbable: s = Uhe,
    isEnabled: o = zhe,
    open: a
  } = e, c = j.useRef(!1), l = j.useRef(null), u = j.useRef(null), f = j.useRef(null), h = j.useRef(null), g = j.useRef(!1), y = j.useRef(null), x = vr(t.ref, y), k = j.useRef(null);
  j.useEffect(() => {
    !a || !y.current || (g.current = !n)
  }, [n, a]), j.useEffect(() => {
    if (!a || !y.current) return;
    const v = ji(y.current);
    return y.current.contains(v.activeElement) || (y.current.hasAttribute("tabIndex") || y.current.setAttribute("tabIndex", "-1"), g.current && y.current.focus()), () => {
      i || (f.current && f.current.focus && (c.current = !0, f.current.focus()), f.current = null)
    }
  }, [a]), j.useEffect(() => {
    if (!a || !y.current) return;
    const v = ji(y.current),
      S = w => {
        k.current = w, !(r || !o() || w.key !== "Tab") && v.activeElement === y.current && w.shiftKey && (c.current = !0, u.current && u.current.focus())
      },
      I = () => {
        const w = y.current;
        if (w === null) return;
        if (!v.hasFocus() || !o() || c.current) {
          c.current = !1;
          return
        }
        if (w.contains(v.activeElement) || r && v.activeElement !== l.current && v.activeElement !== u.current) return;
        if (v.activeElement !== h.current) h.current = null;
        else if (h.current !== null) return;
        if (!g.current) return;
        let E = [];
        if ((v.activeElement === l.current || v.activeElement === u.current) && (E = s(y.current)), E.length > 0) {
          var D, $;
          const V = !!((D = k.current) != null && D.shiftKey && (($ = k.current) == null ? void 0 : $.key) === "Tab"),
            G = E[0],
            L = E[E.length - 1];
          typeof G != "string" && typeof L != "string" && (V ? L.focus() : G.focus())
        } else w.focus()
      };
    v.addEventListener("focusin", I), v.addEventListener("keydown", S, !0);
    const A = setInterval(() => {
      v.activeElement && v.activeElement.tagName === "BODY" && I()
    }, 50);
    return () => {
      clearInterval(A), v.removeEventListener("focusin", I), v.removeEventListener("keydown", S, !0)
    }
  }, [n, r, i, o, a, s]);
  const _ = v => {
      f.current === null && (f.current = v.relatedTarget), g.current = !0, h.current = v.target;
      const S = t.props.onFocus;
      S && S(v)
    },
    p = v => {
      f.current === null && (f.current = v.relatedTarget), g.current = !0
    };
  return C.jsxs(j.Fragment, {
    children: [C.jsx("div", {
      tabIndex: a ? 0 : -1,
      onFocus: p,
      ref: l,
      "data-testid": "sentinelStart"
    }), j.cloneElement(t, {
      ref: x,
      onFocus: _
    }), C.jsx("div", {
      tabIndex: a ? 0 : -1,
      onFocus: p,
      ref: u,
      "data-testid": "sentinelEnd"
    })]
  })
}

function Vhe(e) {
  return typeof e == "function" ? e() : e
}
const Uz = j.forwardRef(function (t, n) {
  const {
    children: r,
    container: i,
    disablePortal: s = !1
  } = t, [o, a] = j.useState(null), c = vr(j.isValidElement(r) ? r.ref : null, n);
  if (Os(() => {
      s || a(Vhe(i) || document.body)
    }, [i, s]), Os(() => {
      if (o && !s) return n3(n, o), () => {
        n3(n, null)
      }
    }, [n, o, s]), s) {
    if (j.isValidElement(r)) {
      const l = {
        ref: c
      };
      return j.cloneElement(r, l)
    }
    return C.jsx(j.Fragment, {
      children: r
    })
  }
  return C.jsx(j.Fragment, {
    children: o && Ux.createPortal(r, o)
  })
});

function Whe(e) {
  const t = ji(e);
  return t.body === e ? _a(e).innerWidth > t.documentElement.clientWidth : e.scrollHeight > e.clientHeight
}

function v1(e, t) {
  t ? e.setAttribute("aria-hidden", "true") : e.removeAttribute("aria-hidden")
}

function _D(e) {
  return parseInt(_a(e).getComputedStyle(e).paddingRight, 10) || 0
}

function qhe(e) {
  const n = ["TEMPLATE", "SCRIPT", "STYLE", "LINK", "MAP", "META", "NOSCRIPT", "PICTURE", "COL", "COLGROUP", "PARAM", "SLOT", "SOURCE", "TRACK"].indexOf(e.tagName) !== -1,
    r = e.tagName === "INPUT" && e.getAttribute("type") === "hidden";
  return n || r
}

function ID(e, t, n, r, i) {
  const s = [t, n, ...r];
  [].forEach.call(e.children, o => {
    const a = s.indexOf(o) === -1,
      c = !qhe(o);
    a && c && v1(o, i)
  })
}

function lS(e, t) {
  let n = -1;
  return e.some((r, i) => t(r) ? (n = i, !0) : !1), n
}

function Ghe(e, t) {
  const n = [],
    r = e.container;
  if (!t.disableScrollLock) {
    if (Whe(r)) {
      const o = OU(ji(r));
      n.push({
        value: r.style.paddingRight,
        property: "padding-right",
        el: r
      }), r.style.paddingRight = `${_D(r)+o}px`;
      const a = ji(r).querySelectorAll(".mui-fixed");
      [].forEach.call(a, c => {
        n.push({
          value: c.style.paddingRight,
          property: "padding-right",
          el: c
        }), c.style.paddingRight = `${_D(c)+o}px`
      })
    }
    let s;
    if (r.parentNode instanceof DocumentFragment) s = ji(r).body;
    else {
      const o = r.parentElement,
        a = _a(r);
      s = (o == null ? void 0 : o.nodeName) === "HTML" && a.getComputedStyle(o).overflowY === "scroll" ? o : r
    }
    n.push({
      value: s.style.overflow,
      property: "overflow",
      el: s
    }, {
      value: s.style.overflowX,
      property: "overflow-x",
      el: s
    }, {
      value: s.style.overflowY,
      property: "overflow-y",
      el: s
    }), s.style.overflow = "hidden"
  }
  return () => {
    n.forEach(({
      value: s,
      el: o,
      property: a
    }) => {
      s ? o.style.setProperty(a, s) : o.style.removeProperty(a)
    })
  }
}

function Khe(e) {
  const t = [];
  return [].forEach.call(e.children, n => {
    n.getAttribute("aria-hidden") === "true" && t.push(n)
  }), t
}
class Qhe {
  constructor() {
    this.containers = void 0, this.modals = void 0, this.modals = [], this.containers = []
  }
  add(t, n) {
    let r = this.modals.indexOf(t);
    if (r !== -1) return r;
    r = this.modals.length, this.modals.push(t), t.modalRef && v1(t.modalRef, !1);
    const i = Khe(n);
    ID(n, t.mount, t.modalRef, i, !0);
    const s = lS(this.containers, o => o.container === n);
    return s !== -1 ? (this.containers[s].modals.push(t), r) : (this.containers.push({
      modals: [t],
      container: n,
      restore: null,
      hiddenSiblings: i
    }), r)
  }
  mount(t, n) {
    const r = lS(this.containers, s => s.modals.indexOf(t) !== -1),
      i = this.containers[r];
    i.restore || (i.restore = Ghe(i, n))
  }
  remove(t, n = !0) {
    const r = this.modals.indexOf(t);
    if (r === -1) return r;
    const i = lS(this.containers, o => o.modals.indexOf(t) !== -1),
      s = this.containers[i];
    if (s.modals.splice(s.modals.indexOf(t), 1), this.modals.splice(r, 1), s.modals.length === 0) s.restore && s.restore(), t.modalRef && v1(t.modalRef, n), ID(s.container, t.mount, t.modalRef, s.hiddenSiblings, !1), this.containers.splice(i, 1);
    else {
      const o = s.modals[s.modals.length - 1];
      o.modalRef && v1(o.modalRef, !1)
    }
    return r
  }
  isTopModal(t) {
    return this.modals.length > 0 && this.modals[this.modals.length - 1] === t
  }
}

function Yhe(e) {
  return typeof e == "function" ? e() : e
}

function Jhe(e) {
  return e ? e.props.hasOwnProperty("in") : !1
}
const Xhe = new Qhe;

function Zhe(e) {
  const {
    container: t,
    disableEscapeKeyDown: n = !1,
    disableScrollLock: r = !1,
    manager: i = Xhe,
    closeAfterTransition: s = !1,
    onTransitionEnter: o,
    onTransitionExited: a,
    children: c,
    onClose: l,
    open: u,
    rootRef: f
  } = e, h = j.useRef({}), g = j.useRef(null), y = j.useRef(null), x = vr(y, f), [k, _] = j.useState(!u), p = Jhe(c);
  let v = !0;
  (e["aria-hidden"] === "false" || e["aria-hidden"] === !1) && (v = !1);
  const S = () => ji(g.current),
    I = () => (h.current.modalRef = y.current, h.current.mount = g.current, h.current),
    A = () => {
      i.mount(I(), {
        disableScrollLock: r
      }), y.current && (y.current.scrollTop = 0)
    },
    w = Ea(() => {
      const R = Yhe(t) || S().body;
      i.add(I(), R), y.current && A()
    }),
    E = j.useCallback(() => i.isTopModal(I()), [i]),
    D = Ea(R => {
      g.current = R, R && (u && E() ? A() : y.current && v1(y.current, v))
    }),
    $ = j.useCallback(() => {
      i.remove(I(), v)
    }, [v, i]);
  j.useEffect(() => () => {
    $()
  }, [$]), j.useEffect(() => {
    u ? w() : (!p || !s) && $()
  }, [u, $, p, s, w]);
  const V = R => N => {
      var O;
      (O = R.onKeyDown) == null || O.call(R, N), !(N.key !== "Escape" || N.which === 229 || !E()) && (n || (N.stopPropagation(), l && l(N, "escapeKeyDown")))
    },
    G = R => N => {
      var O;
      (O = R.onClick) == null || O.call(R, N), N.target === N.currentTarget && l && l(N, "backdropClick")
    };
  return {
    getRootProps: (R = {}) => {
      const N = Mz(e);
      delete N.onTransitionEnter, delete N.onTransitionExited;
      const O = K({}, N, R);
      return K({
        role: "presentation"
      }, O, {
        onKeyDown: V(O),
        ref: x
      })
    },
    getBackdropProps: (R = {}) => {
      const N = R;
      return K({
        "aria-hidden": !0
      }, N, {
        onClick: G(N),
        open: u
      })
    },
    getTransitionProps: () => {
      const R = () => {
          _(!1), o && o()
        },
        N = () => {
          _(!0), a && a(), s && $()
        };
      return {
        onEnter: LC(R, c == null ? void 0 : c.props.onEnter),
        onExited: LC(N, c == null ? void 0 : c.props.onExited)
      }
    },
    rootRef: x,
    portalRef: D,
    isTopModal: E,
    exited: k,
    hasTransition: p
  }
}
var ao = "top",
  Pa = "bottom",
  Ra = "right",
  co = "left",
  jT = "auto",
  H2 = [ao, Pa, Ra, co],
  Ip = "start",
  Z1 = "end",
  e0e = "clippingParents",
  zz = "viewport",
  Sg = "popper",
  t0e = "reference",
  PD = H2.reduce(function (e, t) {
    return e.concat([t + "-" + Ip, t + "-" + Z1])
  }, []),
  Hz = [].concat(H2, [jT]).reduce(function (e, t) {
    return e.concat([t, t + "-" + Ip, t + "-" + Z1])
  }, []),
  n0e = "beforeRead",
  r0e = "read",
  i0e = "afterRead",
  s0e = "beforeMain",
  o0e = "main",
  a0e = "afterMain",
  c0e = "beforeWrite",
  l0e = "write",
  u0e = "afterWrite",
  d0e = [n0e, r0e, i0e, s0e, o0e, a0e, c0e, l0e, u0e];

function dl(e) {
  return e ? (e.nodeName || "").toLowerCase() : null
}

function Ho(e) {
  if (e == null) return window;
  if (e.toString() !== "[object Window]") {
    var t = e.ownerDocument;
    return t && t.defaultView || window
  }
  return e
}

function ih(e) {
  var t = Ho(e).Element;
  return e instanceof t || e instanceof Element
}

function Ca(e) {
  var t = Ho(e).HTMLElement;
  return e instanceof t || e instanceof HTMLElement
}

function UT(e) {
  if (typeof ShadowRoot > "u") return !1;
  var t = Ho(e).ShadowRoot;
  return e instanceof t || e instanceof ShadowRoot
}

function f0e(e) {
  var t = e.state;
  Object.keys(t.elements).forEach(function (n) {
    var r = t.styles[n] || {},
      i = t.attributes[n] || {},
      s = t.elements[n];
    !Ca(s) || !dl(s) || (Object.assign(s.style, r), Object.keys(i).forEach(function (o) {
      var a = i[o];
      a === !1 ? s.removeAttribute(o) : s.setAttribute(o, a === !0 ? "" : a)
    }))
  })
}

function h0e(e) {
  var t = e.state,
    n = {
      popper: {
        position: t.options.strategy,
        left: "0",
        top: "0",
        margin: "0"
      },
      arrow: {
        position: "absolute"
      },
      reference: {}
    };
  return Object.assign(t.elements.popper.style, n.popper), t.styles = n, t.elements.arrow && Object.assign(t.elements.arrow.style, n.arrow),
    function () {
      Object.keys(t.elements).forEach(function (r) {
        var i = t.elements[r],
          s = t.attributes[r] || {},
          o = Object.keys(t.styles.hasOwnProperty(r) ? t.styles[r] : n[r]),
          a = o.reduce(function (c, l) {
            return c[l] = "", c
          }, {});
        !Ca(i) || !dl(i) || (Object.assign(i.style, a), Object.keys(s).forEach(function (c) {
          i.removeAttribute(c)
        }))
      })
    }
}
const p0e = {
  name: "applyStyles",
  enabled: !0,
  phase: "write",
  fn: f0e,
  effect: h0e,
  requires: ["computeStyles"]
};

function sl(e) {
  return e.split("-")[0]
}
var zf = Math.max,
  c3 = Math.min,
  Pp = Math.round;

function GC() {
  var e = navigator.userAgentData;
  return e != null && e.brands && Array.isArray(e.brands) ? e.brands.map(function (t) {
    return t.brand + "/" + t.version
  }).join(" ") : navigator.userAgent
}

function Vz() {
  return !/^((?!chrome|android).)*safari/i.test(GC())
}

function Rp(e, t, n) {
  t === void 0 && (t = !1), n === void 0 && (n = !1);
  var r = e.getBoundingClientRect(),
    i = 1,
    s = 1;
  t && Ca(e) && (i = e.offsetWidth > 0 && Pp(r.width) / e.offsetWidth || 1, s = e.offsetHeight > 0 && Pp(r.height) / e.offsetHeight || 1);
  var o = ih(e) ? Ho(e) : window,
    a = o.visualViewport,
    c = !Vz() && n,
    l = (r.left + (c && a ? a.offsetLeft : 0)) / i,
    u = (r.top + (c && a ? a.offsetTop : 0)) / s,
    f = r.width / i,
    h = r.height / s;
  return {
    width: f,
    height: h,
    top: u,
    right: l + f,
    bottom: u + h,
    left: l,
    x: l,
    y: u
  }
}

function zT(e) {
  var t = Rp(e),
    n = e.offsetWidth,
    r = e.offsetHeight;
  return Math.abs(t.width - n) <= 1 && (n = t.width), Math.abs(t.height - r) <= 1 && (r = t.height), {
    x: e.offsetLeft,
    y: e.offsetTop,
    width: n,
    height: r
  }
}

function Wz(e, t) {
  var n = t.getRootNode && t.getRootNode();
  if (e.contains(t)) return !0;
  if (n && UT(n)) {
    var r = t;
    do {
      if (r && e.isSameNode(r)) return !0;
      r = r.parentNode || r.host
    } while (r)
  }
  return !1
}

function uu(e) {
  return Ho(e).getComputedStyle(e)
}

function m0e(e) {
  return ["table", "td", "th"].indexOf(dl(e)) >= 0
}

function Fd(e) {
  return ((ih(e) ? e.ownerDocument : e.document) || window.document).documentElement
}

function A5(e) {
  return dl(e) === "html" ? e : e.assignedSlot || e.parentNode || (UT(e) ? e.host : null) || Fd(e)
}

function RD(e) {
  return !Ca(e) || uu(e).position === "fixed" ? null : e.offsetParent
}

function g0e(e) {
  var t = /firefox/i.test(GC()),
    n = /Trident/i.test(GC());
  if (n && Ca(e)) {
    var r = uu(e);
    if (r.position === "fixed") return null
  }
  var i = A5(e);
  for (UT(i) && (i = i.host); Ca(i) && ["html", "body"].indexOf(dl(i)) < 0;) {
    var s = uu(i);
    if (s.transform !== "none" || s.perspective !== "none" || s.contain === "paint" || ["transform", "perspective"].indexOf(s.willChange) !== -1 || t && s.willChange === "filter" || t && s.filter && s.filter !== "none") return i;
    i = i.parentNode
  }
  return null
}

function V2(e) {
  for (var t = Ho(e), n = RD(e); n && m0e(n) && uu(n).position === "static";) n = RD(n);
  return n && (dl(n) === "html" || dl(n) === "body" && uu(n).position === "static") ? t : n || g0e(e) || t
}

function HT(e) {
  return ["top", "bottom"].indexOf(e) >= 0 ? "x" : "y"
}

function b1(e, t, n) {
  return zf(e, c3(t, n))
}

function y0e(e, t, n) {
  var r = b1(e, t, n);
  return r > n ? n : r
}

function qz() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  }
}

function Gz(e) {
  return Object.assign({}, qz(), e)
}

function Kz(e, t) {
  return t.reduce(function (n, r) {
    return n[r] = e, n
  }, {})
}
var v0e = function (t, n) {
  return t = typeof t == "function" ? t(Object.assign({}, n.rects, {
    placement: n.placement
  })) : t, Gz(typeof t != "number" ? t : Kz(t, H2))
};

function b0e(e) {
  var t, n = e.state,
    r = e.name,
    i = e.options,
    s = n.elements.arrow,
    o = n.modifiersData.popperOffsets,
    a = sl(n.placement),
    c = HT(a),
    l = [co, Ra].indexOf(a) >= 0,
    u = l ? "height" : "width";
  if (!(!s || !o)) {
    var f = v0e(i.padding, n),
      h = zT(s),
      g = c === "y" ? ao : co,
      y = c === "y" ? Pa : Ra,
      x = n.rects.reference[u] + n.rects.reference[c] - o[c] - n.rects.popper[u],
      k = o[c] - n.rects.reference[c],
      _ = V2(s),
      p = _ ? c === "y" ? _.clientHeight || 0 : _.clientWidth || 0 : 0,
      v = x / 2 - k / 2,
      S = f[g],
      I = p - h[u] - f[y],
      A = p / 2 - h[u] / 2 + v,
      w = b1(S, A, I),
      E = c;
    n.modifiersData[r] = (t = {}, t[E] = w, t.centerOffset = w - A, t)
  }
}

function w0e(e) {
  var t = e.state,
    n = e.options,
    r = n.element,
    i = r === void 0 ? "[data-popper-arrow]" : r;
  i != null && (typeof i == "string" && (i = t.elements.popper.querySelector(i), !i) || Wz(t.elements.popper, i) && (t.elements.arrow = i))
}
const x0e = {
  name: "arrow",
  enabled: !0,
  phase: "main",
  fn: b0e,
  effect: w0e,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};

function Op(e) {
  return e.split("-")[1]
}
var E0e = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};

function S0e(e, t) {
  var n = e.x,
    r = e.y,
    i = t.devicePixelRatio || 1;
  return {
    x: Pp(n * i) / i || 0,
    y: Pp(r * i) / i || 0
  }
}

function OD(e) {
  var t, n = e.popper,
    r = e.popperRect,
    i = e.placement,
    s = e.variation,
    o = e.offsets,
    a = e.position,
    c = e.gpuAcceleration,
    l = e.adaptive,
    u = e.roundOffsets,
    f = e.isFixed,
    h = o.x,
    g = h === void 0 ? 0 : h,
    y = o.y,
    x = y === void 0 ? 0 : y,
    k = typeof u == "function" ? u({
      x: g,
      y: x
    }) : {
      x: g,
      y: x
    };
  g = k.x, x = k.y;
  var _ = o.hasOwnProperty("x"),
    p = o.hasOwnProperty("y"),
    v = co,
    S = ao,
    I = window;
  if (l) {
    var A = V2(n),
      w = "clientHeight",
      E = "clientWidth";
    if (A === Ho(n) && (A = Fd(n), uu(A).position !== "static" && a === "absolute" && (w = "scrollHeight", E = "scrollWidth")), A = A, i === ao || (i === co || i === Ra) && s === Z1) {
      S = Pa;
      var D = f && A === I && I.visualViewport ? I.visualViewport.height : A[w];
      x -= D - r.height, x *= c ? 1 : -1
    }
    if (i === co || (i === ao || i === Pa) && s === Z1) {
      v = Ra;
      var $ = f && A === I && I.visualViewport ? I.visualViewport.width : A[E];
      g -= $ - r.width, g *= c ? 1 : -1
    }
  }
  var V = Object.assign({
      position: a
    }, l && E0e),
    G = u === !0 ? S0e({
      x: g,
      y: x
    }, Ho(n)) : {
      x: g,
      y: x
    };
  if (g = G.x, x = G.y, c) {
    var L;
    return Object.assign({}, V, (L = {}, L[S] = p ? "0" : "", L[v] = _ ? "0" : "", L.transform = (I.devicePixelRatio || 1) <= 1 ? "translate(" + g + "px, " + x + "px)" : "translate3d(" + g + "px, " + x + "px, 0)", L))
  }
  return Object.assign({}, V, (t = {}, t[S] = p ? x + "px" : "", t[v] = _ ? g + "px" : "", t.transform = "", t))
}

function C0e(e) {
  var t = e.state,
    n = e.options,
    r = n.gpuAcceleration,
    i = r === void 0 ? !0 : r,
    s = n.adaptive,
    o = s === void 0 ? !0 : s,
    a = n.roundOffsets,
    c = a === void 0 ? !0 : a,
    l = {
      placement: sl(t.placement),
      variation: Op(t.placement),
      popper: t.elements.popper,
      popperRect: t.rects.popper,
      gpuAcceleration: i,
      isFixed: t.options.strategy === "fixed"
    };
  t.modifiersData.popperOffsets != null && (t.styles.popper = Object.assign({}, t.styles.popper, OD(Object.assign({}, l, {
    offsets: t.modifiersData.popperOffsets,
    position: t.options.strategy,
    adaptive: o,
    roundOffsets: c
  })))), t.modifiersData.arrow != null && (t.styles.arrow = Object.assign({}, t.styles.arrow, OD(Object.assign({}, l, {
    offsets: t.modifiersData.arrow,
    position: "absolute",
    adaptive: !1,
    roundOffsets: c
  })))), t.attributes.popper = Object.assign({}, t.attributes.popper, {
    "data-popper-placement": t.placement
  })
}
const A0e = {
  name: "computeStyles",
  enabled: !0,
  phase: "beforeWrite",
  fn: C0e,
  data: {}
};
var ab = {
  passive: !0
};

function T0e(e) {
  var t = e.state,
    n = e.instance,
    r = e.options,
    i = r.scroll,
    s = i === void 0 ? !0 : i,
    o = r.resize,
    a = o === void 0 ? !0 : o,
    c = Ho(t.elements.popper),
    l = [].concat(t.scrollParents.reference, t.scrollParents.popper);
  return s && l.forEach(function (u) {
      u.addEventListener("scroll", n.update, ab)
    }), a && c.addEventListener("resize", n.update, ab),
    function () {
      s && l.forEach(function (u) {
        u.removeEventListener("scroll", n.update, ab)
      }), a && c.removeEventListener("resize", n.update, ab)
    }
}
const k0e = {
  name: "eventListeners",
  enabled: !0,
  phase: "write",
  fn: function () {},
  effect: T0e,
  data: {}
};
var _0e = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};

function hw(e) {
  return e.replace(/left|right|bottom|top/g, function (t) {
    return _0e[t]
  })
}
var I0e = {
  start: "end",
  end: "start"
};

function DD(e) {
  return e.replace(/start|end/g, function (t) {
    return I0e[t]
  })
}

function VT(e) {
  var t = Ho(e),
    n = t.pageXOffset,
    r = t.pageYOffset;
  return {
    scrollLeft: n,
    scrollTop: r
  }
}

function WT(e) {
  return Rp(Fd(e)).left + VT(e).scrollLeft
}

function P0e(e, t) {
  var n = Ho(e),
    r = Fd(e),
    i = n.visualViewport,
    s = r.clientWidth,
    o = r.clientHeight,
    a = 0,
    c = 0;
  if (i) {
    s = i.width, o = i.height;
    var l = Vz();
    (l || !l && t === "fixed") && (a = i.offsetLeft, c = i.offsetTop)
  }
  return {
    width: s,
    height: o,
    x: a + WT(e),
    y: c
  }
}

function R0e(e) {
  var t, n = Fd(e),
    r = VT(e),
    i = (t = e.ownerDocument) == null ? void 0 : t.body,
    s = zf(n.scrollWidth, n.clientWidth, i ? i.scrollWidth : 0, i ? i.clientWidth : 0),
    o = zf(n.scrollHeight, n.clientHeight, i ? i.scrollHeight : 0, i ? i.clientHeight : 0),
    a = -r.scrollLeft + WT(e),
    c = -r.scrollTop;
  return uu(i || n).direction === "rtl" && (a += zf(n.clientWidth, i ? i.clientWidth : 0) - s), {
    width: s,
    height: o,
    x: a,
    y: c
  }
}

function qT(e) {
  var t = uu(e),
    n = t.overflow,
    r = t.overflowX,
    i = t.overflowY;
  return /auto|scroll|overlay|hidden/.test(n + i + r)
}

function Qz(e) {
  return ["html", "body", "#document"].indexOf(dl(e)) >= 0 ? e.ownerDocument.body : Ca(e) && qT(e) ? e : Qz(A5(e))
}

function w1(e, t) {
  var n;
  t === void 0 && (t = []);
  var r = Qz(e),
    i = r === ((n = e.ownerDocument) == null ? void 0 : n.body),
    s = Ho(r),
    o = i ? [s].concat(s.visualViewport || [], qT(r) ? r : []) : r,
    a = t.concat(o);
  return i ? a : a.concat(w1(A5(o)))
}

function KC(e) {
  return Object.assign({}, e, {
    left: e.x,
    top: e.y,
    right: e.x + e.width,
    bottom: e.y + e.height
  })
}

function O0e(e, t) {
  var n = Rp(e, !1, t === "fixed");
  return n.top = n.top + e.clientTop, n.left = n.left + e.clientLeft, n.bottom = n.top + e.clientHeight, n.right = n.left + e.clientWidth, n.width = e.clientWidth, n.height = e.clientHeight, n.x = n.left, n.y = n.top, n
}

function ND(e, t, n) {
  return t === zz ? KC(P0e(e, n)) : ih(t) ? O0e(t, n) : KC(R0e(Fd(e)))
}

function D0e(e) {
  var t = w1(A5(e)),
    n = ["absolute", "fixed"].indexOf(uu(e).position) >= 0,
    r = n && Ca(e) ? V2(e) : e;
  return ih(r) ? t.filter(function (i) {
    return ih(i) && Wz(i, r) && dl(i) !== "body"
  }) : []
}

function N0e(e, t, n, r) {
  var i = t === "clippingParents" ? D0e(e) : [].concat(t),
    s = [].concat(i, [n]),
    o = s[0],
    a = s.reduce(function (c, l) {
      var u = ND(e, l, r);
      return c.top = zf(u.top, c.top), c.right = c3(u.right, c.right), c.bottom = c3(u.bottom, c.bottom), c.left = zf(u.left, c.left), c
    }, ND(e, o, r));
  return a.width = a.right - a.left, a.height = a.bottom - a.top, a.x = a.left, a.y = a.top, a
}

function Yz(e) {
  var t = e.reference,
    n = e.element,
    r = e.placement,
    i = r ? sl(r) : null,
    s = r ? Op(r) : null,
    o = t.x + t.width / 2 - n.width / 2,
    a = t.y + t.height / 2 - n.height / 2,
    c;
  switch (i) {
    case ao:
      c = {
        x: o,
        y: t.y - n.height
      };
      break;
    case Pa:
      c = {
        x: o,
        y: t.y + t.height
      };
      break;
    case Ra:
      c = {
        x: t.x + t.width,
        y: a
      };
      break;
    case co:
      c = {
        x: t.x - n.width,
        y: a
      };
      break;
    default:
      c = {
        x: t.x,
        y: t.y
      }
  }
  var l = i ? HT(i) : null;
  if (l != null) {
    var u = l === "y" ? "height" : "width";
    switch (s) {
      case Ip:
        c[l] = c[l] - (t[u] / 2 - n[u] / 2);
        break;
      case Z1:
        c[l] = c[l] + (t[u] / 2 - n[u] / 2);
        break
    }
  }
  return c
}

function e2(e, t) {
  t === void 0 && (t = {});
  var n = t,
    r = n.placement,
    i = r === void 0 ? e.placement : r,
    s = n.strategy,
    o = s === void 0 ? e.strategy : s,
    a = n.boundary,
    c = a === void 0 ? e0e : a,
    l = n.rootBoundary,
    u = l === void 0 ? zz : l,
    f = n.elementContext,
    h = f === void 0 ? Sg : f,
    g = n.altBoundary,
    y = g === void 0 ? !1 : g,
    x = n.padding,
    k = x === void 0 ? 0 : x,
    _ = Gz(typeof k != "number" ? k : Kz(k, H2)),
    p = h === Sg ? t0e : Sg,
    v = e.rects.popper,
    S = e.elements[y ? p : h],
    I = N0e(ih(S) ? S : S.contextElement || Fd(e.elements.popper), c, u, o),
    A = Rp(e.elements.reference),
    w = Yz({
      reference: A,
      element: v,
      strategy: "absolute",
      placement: i
    }),
    E = KC(Object.assign({}, v, w)),
    D = h === Sg ? E : A,
    $ = {
      top: I.top - D.top + _.top,
      bottom: D.bottom - I.bottom + _.bottom,
      left: I.left - D.left + _.left,
      right: D.right - I.right + _.right
    },
    V = e.modifiersData.offset;
  if (h === Sg && V) {
    var G = V[i];
    Object.keys($).forEach(function (L) {
      var b = [Ra, Pa].indexOf(L) >= 0 ? 1 : -1,
        T = [ao, Pa].indexOf(L) >= 0 ? "y" : "x";
      $[L] += G[T] * b
    })
  }
  return $
}

function M0e(e, t) {
  t === void 0 && (t = {});
  var n = t,
    r = n.placement,
    i = n.boundary,
    s = n.rootBoundary,
    o = n.padding,
    a = n.flipVariations,
    c = n.allowedAutoPlacements,
    l = c === void 0 ? Hz : c,
    u = Op(r),
    f = u ? a ? PD : PD.filter(function (y) {
      return Op(y) === u
    }) : H2,
    h = f.filter(function (y) {
      return l.indexOf(y) >= 0
    });
  h.length === 0 && (h = f);
  var g = h.reduce(function (y, x) {
    return y[x] = e2(e, {
      placement: x,
      boundary: i,
      rootBoundary: s,
      padding: o
    })[sl(x)], y
  }, {});
  return Object.keys(g).sort(function (y, x) {
    return g[y] - g[x]
  })
}

function $0e(e) {
  if (sl(e) === jT) return [];
  var t = hw(e);
  return [DD(e), t, DD(t)]
}

function L0e(e) {
  var t = e.state,
    n = e.options,
    r = e.name;
  if (!t.modifiersData[r]._skip) {
    for (var i = n.mainAxis, s = i === void 0 ? !0 : i, o = n.altAxis, a = o === void 0 ? !0 : o, c = n.fallbackPlacements, l = n.padding, u = n.boundary, f = n.rootBoundary, h = n.altBoundary, g = n.flipVariations, y = g === void 0 ? !0 : g, x = n.allowedAutoPlacements, k = t.options.placement, _ = sl(k), p = _ === k, v = c || (p || !y ? [hw(k)] : $0e(k)), S = [k].concat(v).reduce(function (he, H) {
        return he.concat(sl(H) === jT ? M0e(t, {
          placement: H,
          boundary: u,
          rootBoundary: f,
          padding: l,
          flipVariations: y,
          allowedAutoPlacements: x
        }) : H)
      }, []), I = t.rects.reference, A = t.rects.popper, w = new Map, E = !0, D = S[0], $ = 0; $ < S.length; $++) {
      var V = S[$],
        G = sl(V),
        L = Op(V) === Ip,
        b = [ao, Pa].indexOf(G) >= 0,
        T = b ? "width" : "height",
        R = e2(t, {
          placement: V,
          boundary: u,
          rootBoundary: f,
          altBoundary: h,
          padding: l
        }),
        N = b ? L ? Ra : co : L ? Pa : ao;
      I[T] > A[T] && (N = hw(N));
      var O = hw(N),
        U = [];
      if (s && U.push(R[G] <= 0), a && U.push(R[N] <= 0, R[O] <= 0), U.every(function (he) {
          return he
        })) {
        D = V, E = !1;
        break
      }
      w.set(V, U)
    }
    if (E)
      for (var q = y ? 3 : 1, W = function (H) {
          var ne = S.find(function (X) {
            var Z = w.get(X);
            if (Z) return Z.slice(0, H).every(function (te) {
              return te
            })
          });
          if (ne) return D = ne, "break"
        }, M = q; M > 0; M--) {
        var Q = W(M);
        if (Q === "break") break
      }
    t.placement !== D && (t.modifiersData[r]._skip = !0, t.placement = D, t.reset = !0)
  }
}
const B0e = {
  name: "flip",
  enabled: !0,
  phase: "main",
  fn: L0e,
  requiresIfExists: ["offset"],
  data: {
    _skip: !1
  }
};

function MD(e, t, n) {
  return n === void 0 && (n = {
    x: 0,
    y: 0
  }), {
    top: e.top - t.height - n.y,
    right: e.right - t.width + n.x,
    bottom: e.bottom - t.height + n.y,
    left: e.left - t.width - n.x
  }
}

function $D(e) {
  return [ao, Ra, Pa, co].some(function (t) {
    return e[t] >= 0
  })
}

function F0e(e) {
  var t = e.state,
    n = e.name,
    r = t.rects.reference,
    i = t.rects.popper,
    s = t.modifiersData.preventOverflow,
    o = e2(t, {
      elementContext: "reference"
    }),
    a = e2(t, {
      altBoundary: !0
    }),
    c = MD(o, r),
    l = MD(a, i, s),
    u = $D(c),
    f = $D(l);
  t.modifiersData[n] = {
    referenceClippingOffsets: c,
    popperEscapeOffsets: l,
    isReferenceHidden: u,
    hasPopperEscaped: f
  }, t.attributes.popper = Object.assign({}, t.attributes.popper, {
    "data-popper-reference-hidden": u,
    "data-popper-escaped": f
  })
}
const j0e = {
  name: "hide",
  enabled: !0,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: F0e
};

function U0e(e, t, n) {
  var r = sl(e),
    i = [co, ao].indexOf(r) >= 0 ? -1 : 1,
    s = typeof n == "function" ? n(Object.assign({}, t, {
      placement: e
    })) : n,
    o = s[0],
    a = s[1];
  return o = o || 0, a = (a || 0) * i, [co, Ra].indexOf(r) >= 0 ? {
    x: a,
    y: o
  } : {
    x: o,
    y: a
  }
}

function z0e(e) {
  var t = e.state,
    n = e.options,
    r = e.name,
    i = n.offset,
    s = i === void 0 ? [0, 0] : i,
    o = Hz.reduce(function (u, f) {
      return u[f] = U0e(f, t.rects, s), u
    }, {}),
    a = o[t.placement],
    c = a.x,
    l = a.y;
  t.modifiersData.popperOffsets != null && (t.modifiersData.popperOffsets.x += c, t.modifiersData.popperOffsets.y += l), t.modifiersData[r] = o
}
const H0e = {
  name: "offset",
  enabled: !0,
  phase: "main",
  requires: ["popperOffsets"],
  fn: z0e
};

function V0e(e) {
  var t = e.state,
    n = e.name;
  t.modifiersData[n] = Yz({
    reference: t.rects.reference,
    element: t.rects.popper,
    strategy: "absolute",
    placement: t.placement
  })
}
const W0e = {
  name: "popperOffsets",
  enabled: !0,
  phase: "read",
  fn: V0e,
  data: {}
};

function q0e(e) {
  return e === "x" ? "y" : "x"
}

function G0e(e) {
  var t = e.state,
    n = e.options,
    r = e.name,
    i = n.mainAxis,
    s = i === void 0 ? !0 : i,
    o = n.altAxis,
    a = o === void 0 ? !1 : o,
    c = n.boundary,
    l = n.rootBoundary,
    u = n.altBoundary,
    f = n.padding,
    h = n.tether,
    g = h === void 0 ? !0 : h,
    y = n.tetherOffset,
    x = y === void 0 ? 0 : y,
    k = e2(t, {
      boundary: c,
      rootBoundary: l,
      padding: f,
      altBoundary: u
    }),
    _ = sl(t.placement),
    p = Op(t.placement),
    v = !p,
    S = HT(_),
    I = q0e(S),
    A = t.modifiersData.popperOffsets,
    w = t.rects.reference,
    E = t.rects.popper,
    D = typeof x == "function" ? x(Object.assign({}, t.rects, {
      placement: t.placement
    })) : x,
    $ = typeof D == "number" ? {
      mainAxis: D,
      altAxis: D
    } : Object.assign({
      mainAxis: 0,
      altAxis: 0
    }, D),
    V = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null,
    G = {
      x: 0,
      y: 0
    };
  if (A) {
    if (s) {
      var L, b = S === "y" ? ao : co,
        T = S === "y" ? Pa : Ra,
        R = S === "y" ? "height" : "width",
        N = A[S],
        O = N + k[b],
        U = N - k[T],
        q = g ? -E[R] / 2 : 0,
        W = p === Ip ? w[R] : E[R],
        M = p === Ip ? -E[R] : -w[R],
        Q = t.elements.arrow,
        he = g && Q ? zT(Q) : {
          width: 0,
          height: 0
        },
        H = t.modifiersData["arrow#persistent"] ? t.modifiersData["arrow#persistent"].padding : qz(),
        ne = H[b],
        X = H[T],
        Z = b1(0, w[R], he[R]),
        te = v ? w[R] / 2 - q - Z - ne - $.mainAxis : W - Z - ne - $.mainAxis,
        F = v ? -w[R] / 2 + q + Z + X + $.mainAxis : M + Z + X + $.mainAxis,
        J = t.elements.arrow && V2(t.elements.arrow),
        ie = J ? S === "y" ? J.clientTop || 0 : J.clientLeft || 0 : 0,
        ce = (L = V == null ? void 0 : V[S]) != null ? L : 0,
        ue = N + te - ce - ie,
        ge = N + F - ce,
        et = b1(g ? c3(O, ue) : O, N, g ? zf(U, ge) : U);
      A[S] = et, G[S] = et - N
    }
    if (a) {
      var He, se = S === "x" ? ao : co,
        pe = S === "x" ? Pa : Ra,
        de = A[I],
        we = I === "y" ? "height" : "width",
        Ce = de + k[se],
        be = de - k[pe],
        Se = [ao, co].indexOf(_) !== -1,
        Fe = (He = V == null ? void 0 : V[I]) != null ? He : 0,
        Ne = Se ? Ce : de - w[we] - E[we] - Fe + $.altAxis,
        Me = Se ? de + w[we] + E[we] - Fe - $.altAxis : be,
        We = g && Se ? y0e(Ne, de, Me) : b1(g ? Ne : Ce, de, g ? Me : be);
      A[I] = We, G[I] = We - de
    }
    t.modifiersData[r] = G
  }
}
const K0e = {
  name: "preventOverflow",
  enabled: !0,
  phase: "main",
  fn: G0e,
  requiresIfExists: ["offset"]
};

function Q0e(e) {
  return {
    scrollLeft: e.scrollLeft,
    scrollTop: e.scrollTop
  }
}

function Y0e(e) {
  return e === Ho(e) || !Ca(e) ? VT(e) : Q0e(e)
}

function J0e(e) {
  var t = e.getBoundingClientRect(),
    n = Pp(t.width) / e.offsetWidth || 1,
    r = Pp(t.height) / e.offsetHeight || 1;
  return n !== 1 || r !== 1
}

function X0e(e, t, n) {
  n === void 0 && (n = !1);
  var r = Ca(t),
    i = Ca(t) && J0e(t),
    s = Fd(t),
    o = Rp(e, i, n),
    a = {
      scrollLeft: 0,
      scrollTop: 0
    },
    c = {
      x: 0,
      y: 0
    };
  return (r || !r && !n) && ((dl(t) !== "body" || qT(s)) && (a = Y0e(t)), Ca(t) ? (c = Rp(t, !0), c.x += t.clientLeft, c.y += t.clientTop) : s && (c.x = WT(s))), {
    x: o.left + a.scrollLeft - c.x,
    y: o.top + a.scrollTop - c.y,
    width: o.width,
    height: o.height
  }
}

function Z0e(e) {
  var t = new Map,
    n = new Set,
    r = [];
  e.forEach(function (s) {
    t.set(s.name, s)
  });

  function i(s) {
    n.add(s.name);
    var o = [].concat(s.requires || [], s.requiresIfExists || []);
    o.forEach(function (a) {
      if (!n.has(a)) {
        var c = t.get(a);
        c && i(c)
      }
    }), r.push(s)
  }
  return e.forEach(function (s) {
    n.has(s.name) || i(s)
  }), r
}

function epe(e) {
  var t = Z0e(e);
  return d0e.reduce(function (n, r) {
    return n.concat(t.filter(function (i) {
      return i.phase === r
    }))
  }, [])
}

function tpe(e) {
  var t;
  return function () {
    return t || (t = new Promise(function (n) {
      Promise.resolve().then(function () {
        t = void 0, n(e())
      })
    })), t
  }
}

function npe(e) {
  var t = e.reduce(function (n, r) {
    var i = n[r.name];
    return n[r.name] = i ? Object.assign({}, i, r, {
      options: Object.assign({}, i.options, r.options),
      data: Object.assign({}, i.data, r.data)
    }) : r, n
  }, {});
  return Object.keys(t).map(function (n) {
    return t[n]
  })
}
var LD = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};

function BD() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
  return !t.some(function (r) {
    return !(r && typeof r.getBoundingClientRect == "function")
  })
}

function rpe(e) {
  e === void 0 && (e = {});
  var t = e,
    n = t.defaultModifiers,
    r = n === void 0 ? [] : n,
    i = t.defaultOptions,
    s = i === void 0 ? LD : i;
  return function (a, c, l) {
    l === void 0 && (l = s);
    var u = {
        placement: "bottom",
        orderedModifiers: [],
        options: Object.assign({}, LD, s),
        modifiersData: {},
        elements: {
          reference: a,
          popper: c
        },
        attributes: {},
        styles: {}
      },
      f = [],
      h = !1,
      g = {
        state: u,
        setOptions: function (_) {
          var p = typeof _ == "function" ? _(u.options) : _;
          x(), u.options = Object.assign({}, s, u.options, p), u.scrollParents = {
            reference: ih(a) ? w1(a) : a.contextElement ? w1(a.contextElement) : [],
            popper: w1(c)
          };
          var v = epe(npe([].concat(r, u.options.modifiers)));
          return u.orderedModifiers = v.filter(function (S) {
            return S.enabled
          }), y(), g.update()
        },
        forceUpdate: function () {
          if (!h) {
            var _ = u.elements,
              p = _.reference,
              v = _.popper;
            if (BD(p, v)) {
              u.rects = {
                reference: X0e(p, V2(v), u.options.strategy === "fixed"),
                popper: zT(v)
              }, u.reset = !1, u.placement = u.options.placement, u.orderedModifiers.forEach(function ($) {
                return u.modifiersData[$.name] = Object.assign({}, $.data)
              });
              for (var S = 0; S < u.orderedModifiers.length; S++) {
                if (u.reset === !0) {
                  u.reset = !1, S = -1;
                  continue
                }
                var I = u.orderedModifiers[S],
                  A = I.fn,
                  w = I.options,
                  E = w === void 0 ? {} : w,
                  D = I.name;
                typeof A == "function" && (u = A({
                  state: u,
                  options: E,
                  name: D,
                  instance: g
                }) || u)
              }
            }
          }
        },
        update: tpe(function () {
          return new Promise(function (k) {
            g.forceUpdate(), k(u)
          })
        }),
        destroy: function () {
          x(), h = !0
        }
      };
    if (!BD(a, c)) return g;
    g.setOptions(l).then(function (k) {
      !h && l.onFirstUpdate && l.onFirstUpdate(k)
    });

    function y() {
      u.orderedModifiers.forEach(function (k) {
        var _ = k.name,
          p = k.options,
          v = p === void 0 ? {} : p,
          S = k.effect;
        if (typeof S == "function") {
          var I = S({
              state: u,
              name: _,
              instance: g,
              options: v
            }),
            A = function () {};
          f.push(I || A)
        }
      })
    }

    function x() {
      f.forEach(function (k) {
        return k()
      }), f = []
    }
    return g
  }
}
var ipe = [k0e, W0e, A0e, p0e, H0e, B0e, K0e, x0e, j0e],
  spe = rpe({
    defaultModifiers: ipe
  });
const Jz = "Popper";

function ope(e) {
  return jz(Jz, e)
}
$he(Jz, ["root"]);
const ape = ["anchorEl", "children", "direction", "disablePortal", "modifiers", "open", "placement", "popperOptions", "popperRef", "slotProps", "slots", "TransitionProps", "ownerState"],
  cpe = ["anchorEl", "children", "container", "direction", "disablePortal", "keepMounted", "modifiers", "open", "placement", "popperOptions", "popperRef", "style", "transition", "slotProps", "slots"];

function lpe(e, t) {
  if (t === "ltr") return e;
  switch (e) {
    case "bottom-end":
      return "bottom-start";
    case "bottom-start":
      return "bottom-end";
    case "top-end":
      return "top-start";
    case "top-start":
      return "top-end";
    default:
      return e
  }
}

function QC(e) {
  return typeof e == "function" ? e() : e
}

function upe(e) {
  return e.nodeType !== void 0
}
const dpe = () => pt({
    root: ["root"]
  }, Wfe(ope)),
  fpe = {},
  hpe = j.forwardRef(function (t, n) {
    var r;
    const {
      anchorEl: i,
      children: s,
      direction: o,
      disablePortal: a,
      modifiers: c,
      open: l,
      placement: u,
      popperOptions: f,
      popperRef: h,
      slotProps: g = {},
      slots: y = {},
      TransitionProps: x
    } = t, k = Ve(t, ape), _ = j.useRef(null), p = vr(_, n), v = j.useRef(null), S = vr(v, h), I = j.useRef(S);
    Os(() => {
      I.current = S
    }, [S]), j.useImperativeHandle(h, () => v.current, []);
    const A = lpe(u, o),
      [w, E] = j.useState(A),
      [D, $] = j.useState(QC(i));
    j.useEffect(() => {
      v.current && v.current.forceUpdate()
    }), j.useEffect(() => {
      i && $(QC(i))
    }, [i]), Os(() => {
      if (!D || !l) return;
      const T = O => {
        E(O.placement)
      };
      let R = [{
        name: "preventOverflow",
        options: {
          altBoundary: a
        }
      }, {
        name: "flip",
        options: {
          altBoundary: a
        }
      }, {
        name: "onUpdate",
        enabled: !0,
        phase: "afterWrite",
        fn: ({
          state: O
        }) => {
          T(O)
        }
      }];
      c != null && (R = R.concat(c)), f && f.modifiers != null && (R = R.concat(f.modifiers));
      const N = spe(D, _.current, K({
        placement: A
      }, f, {
        modifiers: R
      }));
      return I.current(N), () => {
        N.destroy(), I.current(null)
      }
    }, [D, a, c, l, f, A]);
    const V = {
      placement: w
    };
    x !== null && (V.TransitionProps = x);
    const G = dpe(),
      L = (r = y.root) != null ? r : "div",
      b = zo({
        elementType: L,
        externalSlotProps: g.root,
        externalForwardedProps: k,
        additionalProps: {
          role: "tooltip",
          ref: p
        },
        ownerState: t,
        className: G.root
      });
    return C.jsx(L, K({}, b, {
      children: typeof s == "function" ? s(V) : s
    }))
  }),
  ppe = j.forwardRef(function (t, n) {
    const {
      anchorEl: r,
      children: i,
      container: s,
      direction: o = "ltr",
      disablePortal: a = !1,
      keepMounted: c = !1,
      modifiers: l,
      open: u,
      placement: f = "bottom",
      popperOptions: h = fpe,
      popperRef: g,
      style: y,
      transition: x = !1,
      slotProps: k = {},
      slots: _ = {}
    } = t, p = Ve(t, cpe), [v, S] = j.useState(!0), I = () => {
      S(!1)
    }, A = () => {
      S(!0)
    };
    if (!c && !u && (!x || v)) return null;
    let w;
    if (s) w = s;
    else if (r) {
      const $ = QC(r);
      w = $ && upe($) ? ji($).body : ji(null).body
    }
    const E = !u && c && (!x || v) ? "none" : void 0,
      D = x ? {
        in: u,
        onEnter: I,
        onExited: A
      } : void 0;
    return C.jsx(Uz, {
      disablePortal: a,
      container: w,
      children: C.jsx(hpe, K({
        anchorEl: r,
        direction: o,
        disablePortal: a,
        modifiers: l,
        ref: n,
        open: x ? !v : u,
        placement: f,
        popperOptions: h,
        popperRef: g,
        slotProps: k,
        slots: _
      }, p, {
        style: K({
          position: "fixed",
          top: 0,
          left: 0,
          display: E
        }, y),
        TransitionProps: D,
        children: i
      }))
    })
  }),
  mpe = ["onChange", "maxRows", "minRows", "style", "value"];

function cb(e) {
  return parseInt(e, 10) || 0
}
const gpe = {
  shadow: {
    visibility: "hidden",
    position: "absolute",
    overflow: "hidden",
    height: 0,
    top: 0,
    left: 0,
    transform: "translateZ(0)"
  }
};

function ype(e) {
  return e == null || Object.keys(e).length === 0 || e.outerHeightStyle === 0 && !e.overflowing
}
const vpe = j.forwardRef(function (t, n) {
  const {
    onChange: r,
    maxRows: i,
    minRows: s = 1,
    style: o,
    value: a
  } = t, c = Ve(t, mpe), {
    current: l
  } = j.useRef(a != null), u = j.useRef(null), f = vr(n, u), h = j.useRef(null), g = j.useCallback(() => {
    const k = u.current,
      p = _a(k).getComputedStyle(k);
    if (p.width === "0px") return {
      outerHeightStyle: 0,
      overflowing: !1
    };
    const v = h.current;
    v.style.width = p.width, v.value = k.value || t.placeholder || "x", v.value.slice(-1) === `
` && (v.value += " ");
    const S = p.boxSizing,
      I = cb(p.paddingBottom) + cb(p.paddingTop),
      A = cb(p.borderBottomWidth) + cb(p.borderTopWidth),
      w = v.scrollHeight;
    v.value = "x";
    const E = v.scrollHeight;
    let D = w;
    s && (D = Math.max(Number(s) * E, D)), i && (D = Math.min(Number(i) * E, D)), D = Math.max(D, E);
    const $ = D + (S === "border-box" ? I + A : 0),
      V = Math.abs(D - w) <= 1;
    return {
      outerHeightStyle: $,
      overflowing: V
    }
  }, [i, s, t.placeholder]), y = j.useCallback(() => {
    const k = g();
    if (ype(k)) return;
    const _ = u.current;
    _.style.height = `${k.outerHeightStyle}px`, _.style.overflow = k.overflowing ? "hidden" : ""
  }, [g]);
  Os(() => {
    const k = () => {
      y()
    };
    let _;
    const p = um(k),
      v = u.current,
      S = _a(v);
    S.addEventListener("resize", p);
    let I;
    return typeof ResizeObserver < "u" && (I = new ResizeObserver(k), I.observe(v)), () => {
      p.clear(), cancelAnimationFrame(_), S.removeEventListener("resize", p), I && I.disconnect()
    }
  }, [g, y]), Os(() => {
    y()
  });
  const x = k => {
    l || y(), r && r(k)
  };
  return C.jsxs(j.Fragment, {
    children: [C.jsx("textarea", K({
      value: a,
      onChange: x,
      ref: f,
      rows: s,
      style: o
    }, c)), C.jsx("textarea", {
      "aria-hidden": !0,
      className: t.className,
      readOnly: !0,
      ref: h,
      tabIndex: -1,
      style: K({}, gpe.shadow, o, {
        paddingTop: 0,
        paddingBottom: 0
      })
    })]
  })
});
var GT = {};
Object.defineProperty(GT, "__esModule", {
  value: !0
});
var Xz = GT.default = void 0,
  bpe = xpe(j),
  wpe = Ez;

function Zz(e) {
  if (typeof WeakMap != "function") return null;
  var t = new WeakMap,
    n = new WeakMap;
  return (Zz = function (r) {
    return r ? n : t
  })(e)
}

function xpe(e, t) {
  if (!t && e && e.__esModule) return e;
  if (e === null || typeof e != "object" && typeof e != "function") return {
    default: e
  };
  var n = Zz(t);
  if (n && n.has(e)) return n.get(e);
  var r = {
      __proto__: null
    },
    i = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var s in e)
    if (s !== "default" && Object.prototype.hasOwnProperty.call(e, s)) {
      var o = i ? Object.getOwnPropertyDescriptor(e, s) : null;
      o && (o.get || o.set) ? Object.defineProperty(r, s, o) : r[s] = e[s]
    } return r.default = e, n && n.set(e, r), r
}

function Epe(e) {
  return Object.keys(e).length === 0
}

function Spe(e = null) {
  const t = bpe.useContext(wpe.ThemeContext);
  return !t || Epe(t) ? e : t
}
Xz = GT.default = Spe;
const Cpe = ["anchorEl", "component", "components", "componentsProps", "container", "disablePortal", "keepMounted", "modifiers", "open", "placement", "popperOptions", "popperRef", "transition", "slots", "slotProps"],
  Ape = me(ppe, {
    name: "MuiPopper",
    slot: "Root",
    overridesResolver: (e, t) => t.root
  })({}),
  Tpe = j.forwardRef(function (t, n) {
    var r;
    const i = Xz(),
      s = xt({
        props: t,
        name: "MuiPopper"
      }),
      {
        anchorEl: o,
        component: a,
        components: c,
        componentsProps: l,
        container: u,
        disablePortal: f,
        keepMounted: h,
        modifiers: g,
        open: y,
        placement: x,
        popperOptions: k,
        popperRef: _,
        transition: p,
        slots: v,
        slotProps: S
      } = s,
      I = Ve(s, Cpe),
      A = (r = v == null ? void 0 : v.root) != null ? r : c == null ? void 0 : c.Root,
      w = K({
        anchorEl: o,
        container: u,
        disablePortal: f,
        keepMounted: h,
        modifiers: g,
        open: y,
        placement: x,
        popperOptions: k,
        popperRef: _,
        transition: p
      }, I);
    return C.jsx(Ape, K({
      as: a,
      direction: i == null ? void 0 : i.direction,
      slots: {
        root: A
      },
      slotProps: S ?? l
    }, w, {
      ref: n
    }))
  }),
  eH = Tpe;

function T5({
  props: e,
  states: t,
  muiFormControl: n
}) {
  return t.reduce((r, i) => (r[i] = e[i], n && typeof e[i] > "u" && (r[i] = n[i]), r), {})
}
const kpe = j.createContext(void 0),
  k5 = kpe;

function mm() {
  return j.useContext(k5)
}

function _pe(e) {
  return C.jsx(Nde, K({}, e, {
    defaultTheme: w5,
    themeId: nh
  }))
}

function FD(e) {
  return e != null && !(Array.isArray(e) && e.length === 0)
}

function l3(e, t = !1) {
  return e && (FD(e.value) && e.value !== "" || t && FD(e.defaultValue) && e.defaultValue !== "")
}

function Ipe(e) {
  return e.startAdornment
}

function Ppe(e) {
  return mt("MuiInputBase", e)
}
const Rpe = gt("MuiInputBase", ["root", "formControl", "focused", "disabled", "adornedStart", "adornedEnd", "error", "sizeSmall", "multiline", "colorSecondary", "fullWidth", "hiddenLabel", "readOnly", "input", "inputSizeSmall", "inputMultiline", "inputTypeSearch", "inputAdornedStart", "inputAdornedEnd", "inputHiddenLabel"]),
  as = Rpe,
  Ope = ["aria-describedby", "autoComplete", "autoFocus", "className", "color", "components", "componentsProps", "defaultValue", "disabled", "disableInjectingGlobalStyles", "endAdornment", "error", "fullWidth", "id", "inputComponent", "inputProps", "inputRef", "margin", "maxRows", "minRows", "multiline", "name", "onBlur", "onChange", "onClick", "onFocus", "onKeyDown", "onKeyUp", "placeholder", "readOnly", "renderSuffix", "rows", "size", "slotProps", "slots", "startAdornment", "type", "value"],
  _5 = (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.formControl && t.formControl, n.startAdornment && t.adornedStart, n.endAdornment && t.adornedEnd, n.error && t.error, n.size === "small" && t.sizeSmall, n.multiline && t.multiline, n.color && t[`color${qe(n.color)}`], n.fullWidth && t.fullWidth, n.hiddenLabel && t.hiddenLabel]
  },
  I5 = (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.input, n.size === "small" && t.inputSizeSmall, n.multiline && t.inputMultiline, n.type === "search" && t.inputTypeSearch, n.startAdornment && t.inputAdornedStart, n.endAdornment && t.inputAdornedEnd, n.hiddenLabel && t.inputHiddenLabel]
  },
  Dpe = e => {
    const {
      classes: t,
      color: n,
      disabled: r,
      error: i,
      endAdornment: s,
      focused: o,
      formControl: a,
      fullWidth: c,
      hiddenLabel: l,
      multiline: u,
      readOnly: f,
      size: h,
      startAdornment: g,
      type: y
    } = e, x = {
      root: ["root", `color${qe(n)}`, r && "disabled", i && "error", c && "fullWidth", o && "focused", a && "formControl", h && h !== "medium" && `size${qe(h)}`, u && "multiline", g && "adornedStart", s && "adornedEnd", l && "hiddenLabel", f && "readOnly"],
      input: ["input", r && "disabled", y === "search" && "inputTypeSearch", u && "inputMultiline", h === "small" && "inputSizeSmall", l && "inputHiddenLabel", g && "inputAdornedStart", s && "inputAdornedEnd", f && "readOnly"]
    };
    return pt(x, Ppe, t)
  },
  P5 = me("div", {
    name: "MuiInputBase",
    slot: "Root",
    overridesResolver: _5
  })(({
    theme: e,
    ownerState: t
  }) => K({}, e.typography.body1, {
    color: (e.vars || e).palette.text.primary,
    lineHeight: "1.4375em",
    boxSizing: "border-box",
    position: "relative",
    cursor: "text",
    display: "inline-flex",
    alignItems: "center",
    [`&.${as.disabled}`]: {
      color: (e.vars || e).palette.text.disabled,
      cursor: "default"
    }
  }, t.multiline && K({
    padding: "4px 0 5px"
  }, t.size === "small" && {
    paddingTop: 1
  }), t.fullWidth && {
    width: "100%"
  })),
  R5 = me("input", {
    name: "MuiInputBase",
    slot: "Input",
    overridesResolver: I5
  })(({
    theme: e,
    ownerState: t
  }) => {
    const n = e.palette.mode === "light",
      r = K({
        color: "currentColor"
      }, e.vars ? {
        opacity: e.vars.opacity.inputPlaceholder
      } : {
        opacity: n ? .42 : .5
      }, {
        transition: e.transitions.create("opacity", {
          duration: e.transitions.duration.shorter
        })
      }),
      i = {
        opacity: "0 !important"
      },
      s = e.vars ? {
        opacity: e.vars.opacity.inputPlaceholder
      } : {
        opacity: n ? .42 : .5
      };
    return K({
      font: "inherit",
      letterSpacing: "inherit",
      color: "currentColor",
      padding: "4px 0 5px",
      border: 0,
      boxSizing: "content-box",
      background: "none",
      height: "1.4375em",
      margin: 0,
      WebkitTapHighlightColor: "transparent",
      display: "block",
      minWidth: 0,
      width: "100%",
      animationName: "mui-auto-fill-cancel",
      animationDuration: "10ms",
      "&::-webkit-input-placeholder": r,
      "&::-moz-placeholder": r,
      "&:-ms-input-placeholder": r,
      "&::-ms-input-placeholder": r,
      "&:focus": {
        outline: 0
      },
      "&:invalid": {
        boxShadow: "none"
      },
      "&::-webkit-search-decoration": {
        WebkitAppearance: "none"
      },
      [`label[data-shrink=false] + .${as.formControl} &`]: {
        "&::-webkit-input-placeholder": i,
        "&::-moz-placeholder": i,
        "&:-ms-input-placeholder": i,
        "&::-ms-input-placeholder": i,
        "&:focus::-webkit-input-placeholder": s,
        "&:focus::-moz-placeholder": s,
        "&:focus:-ms-input-placeholder": s,
        "&:focus::-ms-input-placeholder": s
      },
      [`&.${as.disabled}`]: {
        opacity: 1,
        WebkitTextFillColor: (e.vars || e).palette.text.disabled
      },
      "&:-webkit-autofill": {
        animationDuration: "5000s",
        animationName: "mui-auto-fill"
      }
    }, t.size === "small" && {
      paddingTop: 1
    }, t.multiline && {
      height: "auto",
      resize: "none",
      padding: 0,
      paddingTop: 0
    }, t.type === "search" && {
      MozAppearance: "textfield"
    })
  }),
  Npe = C.jsx(_pe, {
    styles: {
      "@keyframes mui-auto-fill": {
        from: {
          display: "block"
        }
      },
      "@keyframes mui-auto-fill-cancel": {
        from: {
          display: "block"
        }
      }
    }
  }),
  Mpe = j.forwardRef(function (t, n) {
    var r;
    const i = xt({
        props: t,
        name: "MuiInputBase"
      }),
      {
        "aria-describedby": s,
        autoComplete: o,
        autoFocus: a,
        className: c,
        components: l = {},
        componentsProps: u = {},
        defaultValue: f,
        disabled: h,
        disableInjectingGlobalStyles: g,
        endAdornment: y,
        fullWidth: x = !1,
        id: k,
        inputComponent: _ = "input",
        inputProps: p = {},
        inputRef: v,
        maxRows: S,
        minRows: I,
        multiline: A = !1,
        name: w,
        onBlur: E,
        onChange: D,
        onClick: $,
        onFocus: V,
        onKeyDown: G,
        onKeyUp: L,
        placeholder: b,
        readOnly: T,
        renderSuffix: R,
        rows: N,
        slotProps: O = {},
        slots: U = {},
        startAdornment: q,
        type: W = "text",
        value: M
      } = i,
      Q = Ve(i, Ope),
      he = p.value != null ? p.value : M,
      {
        current: H
      } = j.useRef(he != null),
      ne = j.useRef(),
      X = j.useCallback(We => {}, []),
      Z = vr(ne, v, p.ref, X),
      [te, F] = j.useState(!1),
      J = mm(),
      ie = T5({
        props: i,
        muiFormControl: J,
        states: ["color", "disabled", "error", "hiddenLabel", "size", "required", "filled"]
      });
    ie.focused = J ? J.focused : te, j.useEffect(() => {
      !J && h && te && (F(!1), E && E())
    }, [J, h, te, E]);
    const ce = J && J.onFilled,
      ue = J && J.onEmpty,
      ge = j.useCallback(We => {
        l3(We) ? ce && ce() : ue && ue()
      }, [ce, ue]);
    Os(() => {
      H && ge({
        value: he
      })
    }, [he, ge, H]);
    const et = We => {
        if (ie.disabled) {
          We.stopPropagation();
          return
        }
        V && V(We), p.onFocus && p.onFocus(We), J && J.onFocus ? J.onFocus(We) : F(!0)
      },
      He = We => {
        E && E(We), p.onBlur && p.onBlur(We), J && J.onBlur ? J.onBlur(We) : F(!1)
      },
      se = (We, ...ke) => {
        if (!H) {
          const ze = We.target || ne.current;
          if (ze == null) throw new Error(cu(1));
          ge({
            value: ze.value
          })
        }
        p.onChange && p.onChange(We, ...ke), D && D(We, ...ke)
      };
    j.useEffect(() => {
      ge(ne.current)
    }, []);
    const pe = We => {
      ne.current && We.currentTarget === We.target && ne.current.focus(), $ && $(We)
    };
    let de = _,
      we = p;
    A && de === "input" && (N ? we = K({
      type: void 0,
      minRows: N,
      maxRows: N
    }, we) : we = K({
      type: void 0,
      maxRows: S,
      minRows: I
    }, we), de = vpe);
    const Ce = We => {
      ge(We.animationName === "mui-auto-fill-cancel" ? ne.current : {
        value: "x"
      })
    };
    j.useEffect(() => {
      J && J.setAdornedStart(!!q)
    }, [J, q]);
    const be = K({}, i, {
        color: ie.color || "primary",
        disabled: ie.disabled,
        endAdornment: y,
        error: ie.error,
        focused: ie.focused,
        formControl: J,
        fullWidth: x,
        hiddenLabel: ie.hiddenLabel,
        multiline: A,
        size: ie.size,
        startAdornment: q,
        type: W
      }),
      Se = Dpe(be),
      Fe = U.root || l.Root || P5,
      Ne = O.root || u.root || {},
      Me = U.input || l.Input || R5;
    return we = K({}, we, (r = O.input) != null ? r : u.input), C.jsxs(j.Fragment, {
      children: [!g && Npe, C.jsxs(Fe, K({}, Ne, !_p(Fe) && {
        ownerState: K({}, be, Ne.ownerState)
      }, {
        ref: n,
        onClick: pe
      }, Q, {
        className: Ye(Se.root, Ne.className, c, T && "MuiInputBase-readOnly"),
        children: [q, C.jsx(k5.Provider, {
          value: null,
          children: C.jsx(Me, K({
            ownerState: be,
            "aria-invalid": ie.error,
            "aria-describedby": s,
            autoComplete: o,
            autoFocus: a,
            defaultValue: f,
            disabled: ie.disabled,
            id: k,
            onAnimationStart: Ce,
            name: w,
            placeholder: b,
            readOnly: T,
            required: ie.required,
            rows: N,
            value: he,
            onKeyDown: G,
            onKeyUp: L,
            type: W
          }, we, !_p(Me) && {
            as: de,
            ownerState: K({}, be, we.ownerState)
          }, {
            ref: Z,
            className: Ye(Se.input, we.className, T && "MuiInputBase-readOnly"),
            onBlur: He,
            onChange: se,
            onFocus: et
          }))
        }), y, R ? R(K({}, ie, {
          startAdornment: q
        })) : null]
      }))]
    })
  }),
  gm = Mpe;

function $pe(e) {
  return mt("MuiInput", e)
}
const Lpe = K({}, as, gt("MuiInput", ["root", "underline", "input"])),
  Cg = Lpe;

function Bpe(e) {
  return mt("MuiOutlinedInput", e)
}
const Fpe = K({}, as, gt("MuiOutlinedInput", ["root", "notchedOutline", "input"])),
  Hl = Fpe;

function jpe(e) {
  return mt("MuiFilledInput", e)
}
const Upe = K({}, as, gt("MuiFilledInput", ["root", "underline", "input"])),
  hf = Upe,
  zpe = Bd(C.jsx("path", {
    d: "M7 10l5 5 5-5z"
  }), "ArrowDropDown"),
  Hpe = Bd(C.jsx("path", {
    d: "M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"
  }), "Person");

function Vpe(e) {
  return mt("MuiAvatar", e)
}
const Wpe = gt("MuiAvatar", ["root", "colorDefault", "circular", "rounded", "square", "img", "fallback"]),
  tH = Wpe,
  qpe = ["alt", "children", "className", "component", "slots", "slotProps", "imgProps", "sizes", "src", "srcSet", "variant"],
  Gpe = $T(),
  Kpe = e => {
    const {
      classes: t,
      variant: n,
      colorDefault: r
    } = e;
    return pt({
      root: ["root", n, r && "colorDefault"],
      img: ["img"],
      fallback: ["fallback"]
    }, Vpe, t)
  },
  Qpe = me("div", {
    name: "MuiAvatar",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, t[n.variant], n.colorDefault && t.colorDefault]
    }
  })(({
    theme: e
  }) => ({
    position: "relative",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    flexShrink: 0,
    width: 40,
    height: 40,
    fontFamily: e.typography.fontFamily,
    fontSize: e.typography.pxToRem(20),
    lineHeight: 1,
    borderRadius: "50%",
    overflow: "hidden",
    userSelect: "none",
    variants: [{
      props: {
        variant: "rounded"
      },
      style: {
        borderRadius: (e.vars || e).shape.borderRadius
      }
    }, {
      props: {
        variant: "square"
      },
      style: {
        borderRadius: 0
      }
    }, {
      props: {
        colorDefault: !0
      },
      style: K({
        color: (e.vars || e).palette.background.default
      }, e.vars ? {
        backgroundColor: e.vars.palette.Avatar.defaultBg
      } : K({
        backgroundColor: e.palette.grey[400]
      }, e.applyStyles("dark", {
        backgroundColor: e.palette.grey[600]
      })))
    }]
  })),
  Ype = me("img", {
    name: "MuiAvatar",
    slot: "Img",
    overridesResolver: (e, t) => t.img
  })({
    width: "100%",
    height: "100%",
    textAlign: "center",
    objectFit: "cover",
    color: "transparent",
    textIndent: 1e4
  }),
  Jpe = me(Hpe, {
    name: "MuiAvatar",
    slot: "Fallback",
    overridesResolver: (e, t) => t.fallback
  })({
    width: "75%",
    height: "75%"
  });

function Xpe({
  crossOrigin: e,
  referrerPolicy: t,
  src: n,
  srcSet: r
}) {
  const [i, s] = j.useState(!1);
  return j.useEffect(() => {
    if (!n && !r) return;
    s(!1);
    let o = !0;
    const a = new Image;
    return a.onload = () => {
      o && s("loaded")
    }, a.onerror = () => {
      o && s("error")
    }, a.crossOrigin = e, a.referrerPolicy = t, a.src = n, r && (a.srcset = r), () => {
      o = !1
    }
  }, [e, t, n, r]), i
}
const Zpe = j.forwardRef(function (t, n) {
    const r = Gpe({
        props: t,
        name: "MuiAvatar"
      }),
      {
        alt: i,
        children: s,
        className: o,
        component: a = "div",
        slots: c = {},
        slotProps: l = {},
        imgProps: u,
        sizes: f,
        src: h,
        srcSet: g,
        variant: y = "circular"
      } = r,
      x = Ve(r, qpe);
    let k = null;
    const _ = Xpe(K({}, u, {
        src: h,
        srcSet: g
      })),
      p = h || g,
      v = p && _ !== "error",
      S = K({}, r, {
        colorDefault: !v,
        component: a,
        variant: y
      }),
      I = Kpe(S),
      [A, w] = Yfe("img", {
        className: I.img,
        elementType: Ype,
        externalForwardedProps: {
          slots: c,
          slotProps: {
            img: K({}, u, l.img)
          }
        },
        additionalProps: {
          alt: i,
          src: h,
          srcSet: g,
          sizes: f
        },
        ownerState: S
      });
    return v ? k = C.jsx(A, K({}, w)) : s || s === 0 ? k = s : p && i ? k = i[0] : k = C.jsx(Jpe, {
      ownerState: S,
      className: I.fallback
    }), C.jsx(Qpe, K({
      as: a,
      ownerState: S,
      className: Ye(I.root, o),
      ref: n
    }, x, {
      children: k
    }))
  }),
  bl = Zpe;

function eme(e) {
  return mt("MuiAvatarGroup", e)
}
const tme = gt("MuiAvatarGroup", ["root", "avatar"]),
  nme = tme,
  rme = ["children", "className", "component", "componentsProps", "max", "renderSurplus", "slotProps", "spacing", "total", "variant"],
  jD = {
    small: -16,
    medium: null
  },
  ime = e => {
    const {
      classes: t
    } = e;
    return pt({
      root: ["root"],
      avatar: ["avatar"]
    }, eme, t)
  },
  sme = me("div", {
    name: "MuiAvatarGroup",
    slot: "Root",
    overridesResolver: (e, t) => K({
      [`& .${nme.avatar}`]: t.avatar
    }, t.root)
  })(({
    theme: e,
    ownerState: t
  }) => {
    const n = t.spacing && jD[t.spacing] !== void 0 ? jD[t.spacing] : -t.spacing;
    return {
      [`& .${tH.root}`]: {
        border: `2px solid ${(e.vars||e).palette.background.default}`,
        boxSizing: "content-box",
        marginLeft: n ?? -8,
        "&:last-child": {
          marginLeft: 0
        }
      },
      display: "flex",
      flexDirection: "row-reverse"
    }
  }),
  ome = j.forwardRef(function (t, n) {
    var r;
    const i = xt({
        props: t,
        name: "MuiAvatarGroup"
      }),
      {
        children: s,
        className: o,
        component: a = "div",
        componentsProps: c = {},
        max: l = 5,
        renderSurplus: u,
        slotProps: f = {},
        spacing: h = "medium",
        total: g,
        variant: y = "circular"
      } = i,
      x = Ve(i, rme);
    let k = l < 2 ? 2 : l;
    const _ = K({}, i, {
        max: l,
        spacing: h,
        component: a,
        variant: y
      }),
      p = ime(_),
      v = j.Children.toArray(s).filter(D => j.isValidElement(D)),
      S = g || v.length;
    S === k && (k += 1), k = Math.min(S + 1, k);
    const I = Math.min(v.length, k - 1),
      A = Math.max(S - k, S - I, 0),
      w = u ? u(A) : `+${A}`,
      E = (r = f.additionalAvatar) != null ? r : c.additionalAvatar;
    return C.jsxs(sme, K({
      as: a,
      ownerState: _,
      className: Ye(p.root, o),
      ref: n
    }, x, {
      children: [A ? C.jsx(bl, K({
        variant: y
      }, E, {
        className: Ye(p.avatar, E == null ? void 0 : E.className),
        children: w
      })) : null, v.slice(0, I).reverse().map(D => j.cloneElement(D, {
        className: Ye(D.props.className, p.avatar),
        variant: D.props.variant || y
      }))]
    }))
  }),
  ame = ome,
  cme = ["addEndListener", "appear", "children", "easing", "in", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "style", "timeout", "TransitionComponent"],
  lme = {
    entering: {
      opacity: 1
    },
    entered: {
      opacity: 1
    }
  },
  ume = j.forwardRef(function (t, n) {
    const r = vl(),
      i = {
        enter: r.transitions.duration.enteringScreen,
        exit: r.transitions.duration.leavingScreen
      },
      {
        addEndListener: s,
        appear: o = !0,
        children: a,
        easing: c,
        in: l,
        onEnter: u,
        onEntered: f,
        onEntering: h,
        onExit: g,
        onExited: y,
        onExiting: x,
        style: k,
        timeout: _ = i,
        TransitionComponent: p = S5
      } = t,
      v = Ve(t, cme),
      S = j.useRef(null),
      I = vr(S, a.ref, n),
      A = b => T => {
        if (b) {
          const R = S.current;
          T === void 0 ? b(R) : b(R, T)
        }
      },
      w = A(h),
      E = A((b, T) => {
        FT(b);
        const R = Ed({
          style: k,
          timeout: _,
          easing: c
        }, {
          mode: "enter"
        });
        b.style.webkitTransition = r.transitions.create("opacity", R), b.style.transition = r.transitions.create("opacity", R), u && u(b, T)
      }),
      D = A(f),
      $ = A(x),
      V = A(b => {
        const T = Ed({
          style: k,
          timeout: _,
          easing: c
        }, {
          mode: "exit"
        });
        b.style.webkitTransition = r.transitions.create("opacity", T), b.style.transition = r.transitions.create("opacity", T), g && g(b)
      }),
      G = A(y),
      L = b => {
        s && s(S.current, b)
      };
    return C.jsx(p, K({
      appear: o,
      in: l,
      nodeRef: S,
      onEnter: E,
      onEntered: D,
      onEntering: w,
      onExit: V,
      onExited: G,
      onExiting: $,
      addEndListener: L,
      timeout: _
    }, v, {
      children: (b, T) => j.cloneElement(a, K({
        style: K({
          opacity: 0,
          visibility: b === "exited" && !l ? "hidden" : void 0
        }, lme[b], k, a.props.style),
        ref: I
      }, T))
    }))
  }),
  nH = ume;

function dme(e) {
  return mt("MuiBackdrop", e)
}
gt("MuiBackdrop", ["root", "invisible"]);
const fme = ["children", "className", "component", "components", "componentsProps", "invisible", "open", "slotProps", "slots", "TransitionComponent", "transitionDuration"],
  hme = e => {
    const {
      classes: t,
      invisible: n
    } = e;
    return pt({
      root: ["root", n && "invisible"]
    }, dme, t)
  },
  pme = me("div", {
    name: "MuiBackdrop",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, n.invisible && t.invisible]
    }
  })(({
    ownerState: e
  }) => K({
    position: "fixed",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    right: 0,
    bottom: 0,
    top: 0,
    left: 0,
    backgroundColor: "rgba(0, 0, 0, 0.5)",
    WebkitTapHighlightColor: "transparent"
  }, e.invisible && {
    backgroundColor: "transparent"
  })),
  mme = j.forwardRef(function (t, n) {
    var r, i, s;
    const o = xt({
        props: t,
        name: "MuiBackdrop"
      }),
      {
        children: a,
        className: c,
        component: l = "div",
        components: u = {},
        componentsProps: f = {},
        invisible: h = !1,
        open: g,
        slotProps: y = {},
        slots: x = {},
        TransitionComponent: k = nH,
        transitionDuration: _
      } = o,
      p = Ve(o, fme),
      v = K({}, o, {
        component: l,
        invisible: h
      }),
      S = hme(v),
      I = (r = y.root) != null ? r : f.root;
    return C.jsx(k, K({
      in: g,
      timeout: _
    }, p, {
      children: C.jsx(pme, K({
        "aria-hidden": !0
      }, I, {
        as: (i = (s = x.root) != null ? s : u.Root) != null ? i : l,
        className: Ye(S.root, c, I == null ? void 0 : I.className),
        ownerState: K({}, v, I == null ? void 0 : I.ownerState),
        classes: S,
        ref: n,
        children: a
      }))
    }))
  }),
  rH = mme;

function gme(e) {
  return mt("MuiBadge", e)
}
const yme = gt("MuiBadge", ["root", "badge", "dot", "standard", "anchorOriginTopRight", "anchorOriginBottomRight", "anchorOriginTopLeft", "anchorOriginBottomLeft", "invisible", "colorError", "colorInfo", "colorPrimary", "colorSecondary", "colorSuccess", "colorWarning", "overlapRectangular", "overlapCircular", "anchorOriginTopLeftCircular", "anchorOriginTopLeftRectangular", "anchorOriginTopRightCircular", "anchorOriginTopRightRectangular", "anchorOriginBottomLeftCircular", "anchorOriginBottomLeftRectangular", "anchorOriginBottomRightCircular", "anchorOriginBottomRightRectangular"]),
  rc = yme,
  vme = ["anchorOrigin", "className", "classes", "component", "components", "componentsProps", "children", "overlap", "color", "invisible", "max", "badgeContent", "slots", "slotProps", "showZero", "variant"],
  uS = 10,
  dS = 4,
  bme = $T(),
  wme = e => {
    const {
      color: t,
      anchorOrigin: n,
      invisible: r,
      overlap: i,
      variant: s,
      classes: o = {}
    } = e, a = {
      root: ["root"],
      badge: ["badge", s, r && "invisible", `anchorOrigin${qe(n.vertical)}${qe(n.horizontal)}`, `anchorOrigin${qe(n.vertical)}${qe(n.horizontal)}${qe(i)}`, `overlap${qe(i)}`, t !== "default" && `color${qe(t)}`]
    };
    return pt(a, gme, o)
  },
  xme = me("span", {
    name: "MuiBadge",
    slot: "Root",
    overridesResolver: (e, t) => t.root
  })({
    position: "relative",
    display: "inline-flex",
    verticalAlign: "middle",
    flexShrink: 0
  }),
  Eme = me("span", {
    name: "MuiBadge",
    slot: "Badge",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.badge, t[n.variant], t[`anchorOrigin${qe(n.anchorOrigin.vertical)}${qe(n.anchorOrigin.horizontal)}${qe(n.overlap)}`], n.color !== "default" && t[`color${qe(n.color)}`], n.invisible && t.invisible]
    }
  })(({
    theme: e
  }) => {
    var t;
    return {
      display: "flex",
      flexDirection: "row",
      flexWrap: "wrap",
      justifyContent: "center",
      alignContent: "center",
      alignItems: "center",
      position: "absolute",
      boxSizing: "border-box",
      fontFamily: e.typography.fontFamily,
      fontWeight: e.typography.fontWeightMedium,
      fontSize: e.typography.pxToRem(12),
      minWidth: uS * 2,
      lineHeight: 1,
      padding: "0 6px",
      height: uS * 2,
      borderRadius: uS,
      zIndex: 1,
      transition: e.transitions.create("transform", {
        easing: e.transitions.easing.easeInOut,
        duration: e.transitions.duration.enteringScreen
      }),
      variants: [...Object.keys(((t = e.vars) != null ? t : e).palette).filter(n => {
        var r, i;
        return ((r = e.vars) != null ? r : e).palette[n].main && ((i = e.vars) != null ? i : e).palette[n].contrastText
      }).map(n => ({
        props: {
          color: n
        },
        style: {
          backgroundColor: (e.vars || e).palette[n].main,
          color: (e.vars || e).palette[n].contrastText
        }
      })), {
        props: {
          variant: "dot"
        },
        style: {
          borderRadius: dS,
          height: dS * 2,
          minWidth: dS * 2,
          padding: 0
        }
      }, {
        props: ({
          ownerState: n
        }) => n.anchorOrigin.vertical === "top" && n.anchorOrigin.horizontal === "right" && n.overlap === "rectangular",
        style: {
          top: 0,
          right: 0,
          transform: "scale(1) translate(50%, -50%)",
          transformOrigin: "100% 0%",
          [`&.${rc.invisible}`]: {
            transform: "scale(0) translate(50%, -50%)"
          }
        }
      }, {
        props: ({
          ownerState: n
        }) => n.anchorOrigin.vertical === "bottom" && n.anchorOrigin.horizontal === "right" && n.overlap === "rectangular",
        style: {
          bottom: 0,
          right: 0,
          transform: "scale(1) translate(50%, 50%)",
          transformOrigin: "100% 100%",
          [`&.${rc.invisible}`]: {
            transform: "scale(0) translate(50%, 50%)"
          }
        }
      }, {
        props: ({
          ownerState: n
        }) => n.anchorOrigin.vertical === "top" && n.anchorOrigin.horizontal === "left" && n.overlap === "rectangular",
        style: {
          top: 0,
          left: 0,
          transform: "scale(1) translate(-50%, -50%)",
          transformOrigin: "0% 0%",
          [`&.${rc.invisible}`]: {
            transform: "scale(0) translate(-50%, -50%)"
          }
        }
      }, {
        props: ({
          ownerState: n
        }) => n.anchorOrigin.vertical === "bottom" && n.anchorOrigin.horizontal === "left" && n.overlap === "rectangular",
        style: {
          bottom: 0,
          left: 0,
          transform: "scale(1) translate(-50%, 50%)",
          transformOrigin: "0% 100%",
          [`&.${rc.invisible}`]: {
            transform: "scale(0) translate(-50%, 50%)"
          }
        }
      }, {
        props: ({
          ownerState: n
        }) => n.anchorOrigin.vertical === "top" && n.anchorOrigin.horizontal === "right" && n.overlap === "circular",
        style: {
          top: "14%",
          right: "14%",
          transform: "scale(1) translate(50%, -50%)",
          transformOrigin: "100% 0%",
          [`&.${rc.invisible}`]: {
            transform: "scale(0) translate(50%, -50%)"
          }
        }
      }, {
        props: ({
          ownerState: n
        }) => n.anchorOrigin.vertical === "bottom" && n.anchorOrigin.horizontal === "right" && n.overlap === "circular",
        style: {
          bottom: "14%",
          right: "14%",
          transform: "scale(1) translate(50%, 50%)",
          transformOrigin: "100% 100%",
          [`&.${rc.invisible}`]: {
            transform: "scale(0) translate(50%, 50%)"
          }
        }
      }, {
        props: ({
          ownerState: n
        }) => n.anchorOrigin.vertical === "top" && n.anchorOrigin.horizontal === "left" && n.overlap === "circular",
        style: {
          top: "14%",
          left: "14%",
          transform: "scale(1) translate(-50%, -50%)",
          transformOrigin: "0% 0%",
          [`&.${rc.invisible}`]: {
            transform: "scale(0) translate(-50%, -50%)"
          }
        }
      }, {
        props: ({
          ownerState: n
        }) => n.anchorOrigin.vertical === "bottom" && n.anchorOrigin.horizontal === "left" && n.overlap === "circular",
        style: {
          bottom: "14%",
          left: "14%",
          transform: "scale(1) translate(-50%, 50%)",
          transformOrigin: "0% 100%",
          [`&.${rc.invisible}`]: {
            transform: "scale(0) translate(-50%, 50%)"
          }
        }
      }, {
        props: {
          invisible: !0
        },
        style: {
          transition: e.transitions.create("transform", {
            easing: e.transitions.easing.easeInOut,
            duration: e.transitions.duration.leavingScreen
          })
        }
      }]
    }
  }),
  Sme = j.forwardRef(function (t, n) {
    var r, i, s, o, a, c;
    const l = bme({
        props: t,
        name: "MuiBadge"
      }),
      {
        anchorOrigin: u = {
          vertical: "top",
          horizontal: "right"
        },
        className: f,
        component: h,
        components: g = {},
        componentsProps: y = {},
        children: x,
        overlap: k = "rectangular",
        color: _ = "default",
        invisible: p = !1,
        max: v = 99,
        badgeContent: S,
        slots: I,
        slotProps: A,
        showZero: w = !1,
        variant: E = "standard"
      } = l,
      D = Ve(l, vme),
      {
        badgeContent: $,
        invisible: V,
        max: G,
        displayValue: L
      } = Dhe({
        max: v,
        invisible: p,
        badgeContent: S,
        showZero: w
      }),
      b = NU({
        anchorOrigin: u,
        color: _,
        overlap: k,
        variant: E,
        badgeContent: S
      }),
      T = V || $ == null && E !== "dot",
      {
        color: R = _,
        overlap: N = k,
        anchorOrigin: O = u,
        variant: U = E
      } = T ? b : l,
      q = U !== "dot" ? L : void 0,
      W = K({}, l, {
        badgeContent: $,
        invisible: T,
        max: G,
        displayValue: q,
        showZero: w,
        anchorOrigin: O,
        color: R,
        overlap: N,
        variant: U
      }),
      M = wme(W),
      Q = (r = (i = I == null ? void 0 : I.root) != null ? i : g.Root) != null ? r : xme,
      he = (s = (o = I == null ? void 0 : I.badge) != null ? o : g.Badge) != null ? s : Eme,
      H = (a = A == null ? void 0 : A.root) != null ? a : y.root,
      ne = (c = A == null ? void 0 : A.badge) != null ? c : y.badge,
      X = zo({
        elementType: Q,
        externalSlotProps: H,
        externalForwardedProps: D,
        additionalProps: {
          ref: n,
          as: h
        },
        ownerState: W,
        className: Ye(H == null ? void 0 : H.className, M.root, f)
      }),
      Z = zo({
        elementType: he,
        externalSlotProps: ne,
        ownerState: W,
        className: Ye(M.badge, ne == null ? void 0 : ne.className)
      });
    return C.jsxs(Q, K({}, X, {
      children: [x, C.jsx(he, K({}, Z, {
        children: q
      }))]
    }))
  }),
  KT = Sme,
  Cme = gt("MuiBox", ["root"]),
  Ame = Cme,
  Tme = OT(),
  kme = $de({
    themeId: nh,
    defaultTheme: Tme,
    defaultClassName: Ame.root,
    generateClassName: hT.generate
  }),
  Pe = kme;

function _me(e) {
  return mt("MuiButton", e)
}
const Ime = gt("MuiButton", ["root", "text", "textInherit", "textPrimary", "textSecondary", "textSuccess", "textError", "textInfo", "textWarning", "outlined", "outlinedInherit", "outlinedPrimary", "outlinedSecondary", "outlinedSuccess", "outlinedError", "outlinedInfo", "outlinedWarning", "contained", "containedInherit", "containedPrimary", "containedSecondary", "containedSuccess", "containedError", "containedInfo", "containedWarning", "disableElevation", "focusVisible", "disabled", "colorInherit", "colorPrimary", "colorSecondary", "colorSuccess", "colorError", "colorInfo", "colorWarning", "textSizeSmall", "textSizeMedium", "textSizeLarge", "outlinedSizeSmall", "outlinedSizeMedium", "outlinedSizeLarge", "containedSizeSmall", "containedSizeMedium", "containedSizeLarge", "sizeMedium", "sizeSmall", "sizeLarge", "fullWidth", "startIcon", "endIcon", "icon", "iconSizeSmall", "iconSizeMedium", "iconSizeLarge"]),
  H0 = Ime,
  Pme = j.createContext({}),
  iH = Pme,
  Rme = j.createContext(void 0),
  Ome = Rme,
  Dme = ["children", "color", "component", "className", "disabled", "disableElevation", "disableFocusRipple", "endIcon", "focusVisibleClassName", "fullWidth", "size", "startIcon", "type", "variant"],
  Nme = e => {
    const {
      color: t,
      disableElevation: n,
      fullWidth: r,
      size: i,
      variant: s,
      classes: o
    } = e, a = {
      root: ["root", s, `${s}${qe(t)}`, `size${qe(i)}`, `${s}Size${qe(i)}`, `color${qe(t)}`, n && "disableElevation", r && "fullWidth"],
      label: ["label"],
      startIcon: ["icon", "startIcon", `iconSize${qe(i)}`],
      endIcon: ["icon", "endIcon", `iconSize${qe(i)}`]
    }, c = pt(a, _me, o);
    return K({}, o, c)
  },
  sH = e => K({}, e.size === "small" && {
    "& > *:nth-of-type(1)": {
      fontSize: 18
    }
  }, e.size === "medium" && {
    "& > *:nth-of-type(1)": {
      fontSize: 20
    }
  }, e.size === "large" && {
    "& > *:nth-of-type(1)": {
      fontSize: 22
    }
  }),
  Mme = me(gu, {
    shouldForwardProp: e => $s(e) || e === "classes",
    name: "MuiButton",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, t[n.variant], t[`${n.variant}${qe(n.color)}`], t[`size${qe(n.size)}`], t[`${n.variant}Size${qe(n.size)}`], n.color === "inherit" && t.colorInherit, n.disableElevation && t.disableElevation, n.fullWidth && t.fullWidth]
    }
  })(({
    theme: e,
    ownerState: t
  }) => {
    var n, r;
    const i = e.palette.mode === "light" ? e.palette.grey[300] : e.palette.grey[800],
      s = e.palette.mode === "light" ? e.palette.grey.A100 : e.palette.grey[700];
    return K({}, e.typography.button, {
      minWidth: 64,
      padding: "6px 16px",
      borderRadius: (e.vars || e).shape.borderRadius,
      transition: e.transitions.create(["background-color", "box-shadow", "border-color", "color"], {
        duration: e.transitions.duration.short
      }),
      "&:hover": K({
        textDecoration: "none",
        backgroundColor: e.vars ? `rgba(${e.vars.palette.text.primaryChannel} / ${e.vars.palette.action.hoverOpacity})` : lr(e.palette.text.primary, e.palette.action.hoverOpacity),
        "@media (hover: none)": {
          backgroundColor: "transparent"
        }
      }, t.variant === "text" && t.color !== "inherit" && {
        backgroundColor: e.vars ? `rgba(${e.vars.palette[t.color].mainChannel} / ${e.vars.palette.action.hoverOpacity})` : lr(e.palette[t.color].main, e.palette.action.hoverOpacity),
        "@media (hover: none)": {
          backgroundColor: "transparent"
        }
      }, t.variant === "outlined" && t.color !== "inherit" && {
        border: `1px solid ${(e.vars||e).palette[t.color].main}`,
        backgroundColor: e.vars ? `rgba(${e.vars.palette[t.color].mainChannel} / ${e.vars.palette.action.hoverOpacity})` : lr(e.palette[t.color].main, e.palette.action.hoverOpacity),
        "@media (hover: none)": {
          backgroundColor: "transparent"
        }
      }, t.variant === "contained" && {
        backgroundColor: e.vars ? e.vars.palette.Button.inheritContainedHoverBg : s,
        boxShadow: (e.vars || e).shadows[4],
        "@media (hover: none)": {
          boxShadow: (e.vars || e).shadows[2],
          backgroundColor: (e.vars || e).palette.grey[300]
        }
      }, t.variant === "contained" && t.color !== "inherit" && {
        backgroundColor: (e.vars || e).palette[t.color].dark,
        "@media (hover: none)": {
          backgroundColor: (e.vars || e).palette[t.color].main
        }
      }),
      "&:active": K({}, t.variant === "contained" && {
        boxShadow: (e.vars || e).shadows[8]
      }),
      [`&.${H0.focusVisible}`]: K({}, t.variant === "contained" && {
        boxShadow: (e.vars || e).shadows[6]
      }),
      [`&.${H0.disabled}`]: K({
        color: (e.vars || e).palette.action.disabled
      }, t.variant === "outlined" && {
        border: `1px solid ${(e.vars||e).palette.action.disabledBackground}`
      }, t.variant === "contained" && {
        color: (e.vars || e).palette.action.disabled,
        boxShadow: (e.vars || e).shadows[0],
        backgroundColor: (e.vars || e).palette.action.disabledBackground
      })
    }, t.variant === "text" && {
      padding: "6px 8px"
    }, t.variant === "text" && t.color !== "inherit" && {
      color: (e.vars || e).palette[t.color].main
    }, t.variant === "outlined" && {
      padding: "5px 15px",
      border: "1px solid currentColor"
    }, t.variant === "outlined" && t.color !== "inherit" && {
      color: (e.vars || e).palette[t.color].main,
      border: e.vars ? `1px solid rgba(${e.vars.palette[t.color].mainChannel} / 0.5)` : `1px solid ${lr(e.palette[t.color].main,.5)}`
    }, t.variant === "contained" && {
      color: e.vars ? e.vars.palette.text.primary : (n = (r = e.palette).getContrastText) == null ? void 0 : n.call(r, e.palette.grey[300]),
      backgroundColor: e.vars ? e.vars.palette.Button.inheritContainedBg : i,
      boxShadow: (e.vars || e).shadows[2]
    }, t.variant === "contained" && t.color !== "inherit" && {
      color: (e.vars || e).palette[t.color].contrastText,
      backgroundColor: (e.vars || e).palette[t.color].main
    }, t.color === "inherit" && {
      color: "inherit",
      borderColor: "currentColor"
    }, t.size === "small" && t.variant === "text" && {
      padding: "4px 5px",
      fontSize: e.typography.pxToRem(13)
    }, t.size === "large" && t.variant === "text" && {
      padding: "8px 11px",
      fontSize: e.typography.pxToRem(15)
    }, t.size === "small" && t.variant === "outlined" && {
      padding: "3px 9px",
      fontSize: e.typography.pxToRem(13)
    }, t.size === "large" && t.variant === "outlined" && {
      padding: "7px 21px",
      fontSize: e.typography.pxToRem(15)
    }, t.size === "small" && t.variant === "contained" && {
      padding: "4px 10px",
      fontSize: e.typography.pxToRem(13)
    }, t.size === "large" && t.variant === "contained" && {
      padding: "8px 22px",
      fontSize: e.typography.pxToRem(15)
    }, t.fullWidth && {
      width: "100%"
    })
  }, ({
    ownerState: e
  }) => e.disableElevation && {
    boxShadow: "none",
    "&:hover": {
      boxShadow: "none"
    },
    [`&.${H0.focusVisible}`]: {
      boxShadow: "none"
    },
    "&:active": {
      boxShadow: "none"
    },
    [`&.${H0.disabled}`]: {
      boxShadow: "none"
    }
  }),
  $me = me("span", {
    name: "MuiButton",
    slot: "StartIcon",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.startIcon, t[`iconSize${qe(n.size)}`]]
    }
  })(({
    ownerState: e
  }) => K({
    display: "inherit",
    marginRight: 8,
    marginLeft: -4
  }, e.size === "small" && {
    marginLeft: -2
  }, sH(e))),
  Lme = me("span", {
    name: "MuiButton",
    slot: "EndIcon",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.endIcon, t[`iconSize${qe(n.size)}`]]
    }
  })(({
    ownerState: e
  }) => K({
    display: "inherit",
    marginRight: -4,
    marginLeft: 8
  }, e.size === "small" && {
    marginRight: -2
  }, sH(e))),
  Bme = j.forwardRef(function (t, n) {
    const r = j.useContext(iH),
      i = j.useContext(Ome),
      s = N2(r, t),
      o = xt({
        props: s,
        name: "MuiButton"
      }),
      {
        children: a,
        color: c = "primary",
        component: l = "button",
        className: u,
        disabled: f = !1,
        disableElevation: h = !1,
        disableFocusRipple: g = !1,
        endIcon: y,
        focusVisibleClassName: x,
        fullWidth: k = !1,
        size: _ = "medium",
        startIcon: p,
        type: v,
        variant: S = "text"
      } = o,
      I = Ve(o, Dme),
      A = K({}, o, {
        color: c,
        component: l,
        disabled: f,
        disableElevation: h,
        disableFocusRipple: g,
        fullWidth: k,
        size: _,
        type: v,
        variant: S
      }),
      w = Nme(A),
      E = p && C.jsx($me, {
        className: w.startIcon,
        ownerState: A,
        children: p
      }),
      D = y && C.jsx(Lme, {
        className: w.endIcon,
        ownerState: A,
        children: y
      }),
      $ = i || "";
    return C.jsxs(Mme, K({
      ownerState: A,
      className: Ye(r.className, w.root, u, $),
      component: l,
      disabled: f,
      focusRipple: !g,
      focusVisibleClassName: Ye(w.focusVisible, x),
      ref: n,
      type: v
    }, I, {
      classes: w,
      children: [E, a, D]
    }))
  }),
  ur = Bme;

function Fme(e) {
  return mt("MuiCardHeader", e)
}
const jme = gt("MuiCardHeader", ["root", "avatar", "action", "content", "title", "subheader"]),
  Hf = jme,
  Ume = ["action", "avatar", "className", "component", "disableTypography", "subheader", "subheaderTypographyProps", "title", "titleTypographyProps"],
  zme = e => {
    const {
      classes: t
    } = e;
    return pt({
      root: ["root"],
      avatar: ["avatar"],
      action: ["action"],
      content: ["content"],
      title: ["title"],
      subheader: ["subheader"]
    }, Fme, t)
  },
  Hme = me("div", {
    name: "MuiCardHeader",
    slot: "Root",
    overridesResolver: (e, t) => K({
      [`& .${Hf.title}`]: t.title,
      [`& .${Hf.subheader}`]: t.subheader
    }, t.root)
  })({
    display: "flex",
    alignItems: "center",
    padding: 16
  }),
  Vme = me("div", {
    name: "MuiCardHeader",
    slot: "Avatar",
    overridesResolver: (e, t) => t.avatar
  })({
    display: "flex",
    flex: "0 0 auto",
    marginRight: 16
  }),
  Wme = me("div", {
    name: "MuiCardHeader",
    slot: "Action",
    overridesResolver: (e, t) => t.action
  })({
    flex: "0 0 auto",
    alignSelf: "flex-start",
    marginTop: -4,
    marginRight: -8,
    marginBottom: -4
  }),
  qme = me("div", {
    name: "MuiCardHeader",
    slot: "Content",
    overridesResolver: (e, t) => t.content
  })({
    flex: "1 1 auto"
  }),
  Gme = j.forwardRef(function (t, n) {
    const r = xt({
        props: t,
        name: "MuiCardHeader"
      }),
      {
        action: i,
        avatar: s,
        className: o,
        component: a = "div",
        disableTypography: c = !1,
        subheader: l,
        subheaderTypographyProps: u,
        title: f,
        titleTypographyProps: h
      } = r,
      g = Ve(r, Ume),
      y = K({}, r, {
        component: a,
        disableTypography: c
      }),
      x = zme(y);
    let k = f;
    k != null && k.type !== Ue && !c && (k = C.jsx(Ue, K({
      variant: s ? "body2" : "h5",
      className: x.title,
      component: "span",
      display: "block"
    }, h, {
      children: k
    })));
    let _ = l;
    return _ != null && _.type !== Ue && !c && (_ = C.jsx(Ue, K({
      variant: s ? "body2" : "body1",
      className: x.subheader,
      color: "text.secondary",
      component: "span",
      display: "block"
    }, u, {
      children: _
    }))), C.jsxs(Hme, K({
      className: Ye(x.root, o),
      as: a,
      ref: n,
      ownerState: y
    }, g, {
      children: [s && C.jsx(Vme, {
        className: x.avatar,
        ownerState: y,
        children: s
      }), C.jsxs(qme, {
        className: x.content,
        ownerState: y,
        children: [k, _]
      }), i && C.jsx(Wme, {
        className: x.action,
        ownerState: y,
        children: i
      })]
    }))
  }),
  Kme = Gme;

function Qme(e) {
  return mt("PrivateSwitchBase", e)
}
gt("PrivateSwitchBase", ["root", "checked", "disabled", "input", "edgeStart", "edgeEnd"]);
const Yme = ["autoFocus", "checked", "checkedIcon", "className", "defaultChecked", "disabled", "disableFocusRipple", "edge", "icon", "id", "inputProps", "inputRef", "name", "onBlur", "onChange", "onFocus", "readOnly", "required", "tabIndex", "type", "value"],
  Jme = e => {
    const {
      classes: t,
      checked: n,
      disabled: r,
      edge: i
    } = e, s = {
      root: ["root", n && "checked", r && "disabled", i && `edge${qe(i)}`],
      input: ["input"]
    };
    return pt(s, Qme, t)
  },
  Xme = me(gu)(({
    ownerState: e
  }) => K({
    padding: 9,
    borderRadius: "50%"
  }, e.edge === "start" && {
    marginLeft: e.size === "small" ? -3 : -12
  }, e.edge === "end" && {
    marginRight: e.size === "small" ? -3 : -12
  })),
  Zme = me("input", {
    shouldForwardProp: $s
  })({
    cursor: "inherit",
    position: "absolute",
    opacity: 0,
    width: "100%",
    height: "100%",
    top: 0,
    left: 0,
    margin: 0,
    padding: 0,
    zIndex: 1
  }),
  ege = j.forwardRef(function (t, n) {
    const {
      autoFocus: r,
      checked: i,
      checkedIcon: s,
      className: o,
      defaultChecked: a,
      disabled: c,
      disableFocusRipple: l = !1,
      edge: u = !1,
      icon: f,
      id: h,
      inputProps: g,
      inputRef: y,
      name: x,
      onBlur: k,
      onChange: _,
      onFocus: p,
      readOnly: v,
      required: S = !1,
      tabIndex: I,
      type: A,
      value: w
    } = t, E = Ve(t, Yme), [D, $] = K1({
      controlled: i,
      default: !!a,
      name: "SwitchBase",
      state: "checked"
    }), V = mm(), G = U => {
      p && p(U), V && V.onFocus && V.onFocus(U)
    }, L = U => {
      k && k(U), V && V.onBlur && V.onBlur(U)
    }, b = U => {
      if (U.nativeEvent.defaultPrevented) return;
      const q = U.target.checked;
      $(q), _ && _(U, q)
    };
    let T = c;
    V && typeof T > "u" && (T = V.disabled);
    const R = A === "checkbox" || A === "radio",
      N = K({}, t, {
        checked: D,
        disabled: T,
        disableFocusRipple: l,
        edge: u
      }),
      O = Jme(N);
    return C.jsxs(Xme, K({
      component: "span",
      className: Ye(O.root, o),
      centerRipple: !0,
      focusRipple: !l,
      disabled: T,
      tabIndex: null,
      role: void 0,
      onFocus: G,
      onBlur: L,
      ownerState: N,
      ref: n
    }, E, {
      children: [C.jsx(Zme, K({
        autoFocus: r,
        checked: i,
        defaultChecked: a,
        className: O.input,
        disabled: T,
        id: R ? h : void 0,
        name: x,
        onChange: b,
        readOnly: v,
        ref: y,
        required: S,
        ownerState: N,
        tabIndex: I,
        type: A
      }, A === "checkbox" && w === void 0 ? {} : {
        value: w
      }, g)), D ? s : f]
    }))
  }),
  tge = ege;

function nge(e) {
  return mt("MuiCircularProgress", e)
}
const rge = gt("MuiCircularProgress", ["root", "determinate", "indeterminate", "colorPrimary", "colorSecondary", "svg", "circle", "circleDeterminate", "circleIndeterminate", "circleDisableShrink"]),
  ige = ["className", "color", "disableShrink", "size", "style", "thickness", "value", "variant"];
let O5 = e => e,
  UD, zD, HD, VD;
const zu = 44,
  sge = yl(UD || (UD = O5 `
  0% {
    transform: rotate(0deg);
  }

  100% {
    transform: rotate(360deg);
  }
`)),
  oge = yl(zD || (zD = O5 `
  0% {
    stroke-dasharray: 1px, 200px;
    stroke-dashoffset: 0;
  }

  50% {
    stroke-dasharray: 100px, 200px;
    stroke-dashoffset: -15px;
  }

  100% {
    stroke-dasharray: 100px, 200px;
    stroke-dashoffset: -125px;
  }
`)),
  age = e => {
    const {
      classes: t,
      variant: n,
      color: r,
      disableShrink: i
    } = e, s = {
      root: ["root", n, `color${qe(r)}`],
      svg: ["svg"],
      circle: ["circle", `circle${qe(n)}`, i && "circleDisableShrink"]
    };
    return pt(s, nge, t)
  },
  cge = me("span", {
    name: "MuiCircularProgress",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, t[n.variant], t[`color${qe(n.color)}`]]
    }
  })(({
    ownerState: e,
    theme: t
  }) => K({
    display: "inline-block"
  }, e.variant === "determinate" && {
    transition: t.transitions.create("transform")
  }, e.color !== "inherit" && {
    color: (t.vars || t).palette[e.color].main
  }), ({
    ownerState: e
  }) => e.variant === "indeterminate" && th(HD || (HD = O5 `
      animation: ${0} 1.4s linear infinite;
    `), sge)),
  lge = me("svg", {
    name: "MuiCircularProgress",
    slot: "Svg",
    overridesResolver: (e, t) => t.svg
  })({
    display: "block"
  }),
  uge = me("circle", {
    name: "MuiCircularProgress",
    slot: "Circle",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.circle, t[`circle${qe(n.variant)}`], n.disableShrink && t.circleDisableShrink]
    }
  })(({
    ownerState: e,
    theme: t
  }) => K({
    stroke: "currentColor"
  }, e.variant === "determinate" && {
    transition: t.transitions.create("stroke-dashoffset")
  }, e.variant === "indeterminate" && {
    strokeDasharray: "80px, 200px",
    strokeDashoffset: 0
  }), ({
    ownerState: e
  }) => e.variant === "indeterminate" && !e.disableShrink && th(VD || (VD = O5 `
      animation: ${0} 1.4s ease-in-out infinite;
    `), oge)),
  dge = j.forwardRef(function (t, n) {
    const r = xt({
        props: t,
        name: "MuiCircularProgress"
      }),
      {
        className: i,
        color: s = "primary",
        disableShrink: o = !1,
        size: a = 40,
        style: c,
        thickness: l = 3.6,
        value: u = 0,
        variant: f = "indeterminate"
      } = r,
      h = Ve(r, ige),
      g = K({}, r, {
        color: s,
        disableShrink: o,
        size: a,
        thickness: l,
        value: u,
        variant: f
      }),
      y = age(g),
      x = {},
      k = {},
      _ = {};
    if (f === "determinate") {
      const p = 2 * Math.PI * ((zu - l) / 2);
      x.strokeDasharray = p.toFixed(3), _["aria-valuenow"] = Math.round(u), x.strokeDashoffset = `${((100-u)/100*p).toFixed(3)}px`, k.transform = "rotate(-90deg)"
    }
    return C.jsx(cge, K({
      className: Ye(y.root, i),
      style: K({
        width: a,
        height: a
      }, k, c),
      ownerState: g,
      ref: n,
      role: "progressbar"
    }, _, h, {
      children: C.jsx(lge, {
        className: y.svg,
        ownerState: g,
        viewBox: `${zu/2} ${zu/2} ${zu} ${zu}`,
        children: C.jsx(uge, {
          className: y.circle,
          style: x,
          ownerState: g,
          cx: zu,
          cy: zu,
          r: (zu - l) / 2,
          fill: "none",
          strokeWidth: l
        })
      })
    }))
  }),
  u3 = dge,
  fge = dfe({
    createStyledComponent: me("div", {
      name: "MuiContainer",
      slot: "Root",
      overridesResolver: (e, t) => {
        const {
          ownerState: n
        } = e;
        return [t.root, t[`maxWidth${qe(String(n.maxWidth))}`], n.fixed && t.fixed, n.disableGutters && t.disableGutters]
      }
    }),
    useThemeProps: e => xt({
      props: e,
      name: "MuiContainer"
    })
  }),
  yo = fge,
  hge = (e, t) => K({
    WebkitFontSmoothing: "antialiased",
    MozOsxFontSmoothing: "grayscale",
    boxSizing: "border-box",
    WebkitTextSizeAdjust: "100%"
  }, t && !e.vars && {
    colorScheme: e.palette.mode
  }),
  pge = e => K({
    color: (e.vars || e).palette.text.primary
  }, e.typography.body1, {
    backgroundColor: (e.vars || e).palette.background.default,
    "@media print": {
      backgroundColor: (e.vars || e).palette.common.white
    }
  });

function mge(e) {
  return mt("MuiModal", e)
}
gt("MuiModal", ["root", "hidden", "backdrop"]);
const gge = ["BackdropComponent", "BackdropProps", "classes", "className", "closeAfterTransition", "children", "container", "component", "components", "componentsProps", "disableAutoFocus", "disableEnforceFocus", "disableEscapeKeyDown", "disablePortal", "disableRestoreFocus", "disableScrollLock", "hideBackdrop", "keepMounted", "onBackdropClick", "onClose", "onTransitionEnter", "onTransitionExited", "open", "slotProps", "slots", "theme"],
  yge = e => {
    const {
      open: t,
      exited: n,
      classes: r
    } = e;
    return pt({
      root: ["root", !t && n && "hidden"],
      backdrop: ["backdrop"]
    }, mge, r)
  },
  vge = me("div", {
    name: "MuiModal",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, !n.open && n.exited && t.hidden]
    }
  })(({
    theme: e,
    ownerState: t
  }) => K({
    position: "fixed",
    zIndex: (e.vars || e).zIndex.modal,
    right: 0,
    bottom: 0,
    top: 0,
    left: 0
  }, !t.open && t.exited && {
    visibility: "hidden"
  })),
  bge = me(rH, {
    name: "MuiModal",
    slot: "Backdrop",
    overridesResolver: (e, t) => t.backdrop
  })({
    zIndex: -1
  }),
  wge = j.forwardRef(function (t, n) {
    var r, i, s, o, a, c;
    const l = xt({
        name: "MuiModal",
        props: t
      }),
      {
        BackdropComponent: u = bge,
        BackdropProps: f,
        className: h,
        closeAfterTransition: g = !1,
        children: y,
        container: x,
        component: k,
        components: _ = {},
        componentsProps: p = {},
        disableAutoFocus: v = !1,
        disableEnforceFocus: S = !1,
        disableEscapeKeyDown: I = !1,
        disablePortal: A = !1,
        disableRestoreFocus: w = !1,
        disableScrollLock: E = !1,
        hideBackdrop: D = !1,
        keepMounted: $ = !1,
        onBackdropClick: V,
        open: G,
        slotProps: L,
        slots: b
      } = l,
      T = Ve(l, gge),
      R = K({}, l, {
        closeAfterTransition: g,
        disableAutoFocus: v,
        disableEnforceFocus: S,
        disableEscapeKeyDown: I,
        disablePortal: A,
        disableRestoreFocus: w,
        disableScrollLock: E,
        hideBackdrop: D,
        keepMounted: $
      }),
      {
        getRootProps: N,
        getBackdropProps: O,
        getTransitionProps: U,
        portalRef: q,
        isTopModal: W,
        exited: M,
        hasTransition: Q
      } = Zhe(K({}, R, {
        rootRef: n
      })),
      he = K({}, R, {
        exited: M
      }),
      H = yge(he),
      ne = {};
    if (y.props.tabIndex === void 0 && (ne.tabIndex = "-1"), Q) {
      const {
        onEnter: ce,
        onExited: ue
      } = U();
      ne.onEnter = ce, ne.onExited = ue
    }
    const X = (r = (i = b == null ? void 0 : b.root) != null ? i : _.Root) != null ? r : vge,
      Z = (s = (o = b == null ? void 0 : b.backdrop) != null ? o : _.Backdrop) != null ? s : u,
      te = (a = L == null ? void 0 : L.root) != null ? a : p.root,
      F = (c = L == null ? void 0 : L.backdrop) != null ? c : p.backdrop,
      J = zo({
        elementType: X,
        externalSlotProps: te,
        externalForwardedProps: T,
        getSlotProps: N,
        additionalProps: {
          ref: n,
          as: k
        },
        ownerState: he,
        className: Ye(h, te == null ? void 0 : te.className, H == null ? void 0 : H.root, !he.open && he.exited && (H == null ? void 0 : H.hidden))
      }),
      ie = zo({
        elementType: Z,
        externalSlotProps: F,
        additionalProps: f,
        getSlotProps: ce => O(K({}, ce, {
          onClick: ue => {
            V && V(ue), ce != null && ce.onClick && ce.onClick(ue)
          }
        })),
        className: Ye(F == null ? void 0 : F.className, f == null ? void 0 : f.className, H == null ? void 0 : H.backdrop),
        ownerState: he
      });
    return !$ && !G && (!Q || M) ? null : C.jsx(Uz, {
      ref: q,
      container: x,
      disablePortal: A,
      children: C.jsxs(X, K({}, J, {
        children: [!D && u ? C.jsx(Z, K({}, ie)) : null, C.jsx(Hhe, {
          disableEnforceFocus: S,
          disableAutoFocus: v,
          disableRestoreFocus: w,
          isEnabled: W,
          open: G,
          children: j.cloneElement(y, ne)
        })]
      }))
    })
  }),
  QT = wge;

function xge(e) {
  return mt("MuiDialog", e)
}
const Ege = gt("MuiDialog", ["root", "scrollPaper", "scrollBody", "container", "paper", "paperScrollPaper", "paperScrollBody", "paperWidthFalse", "paperWidthXs", "paperWidthSm", "paperWidthMd", "paperWidthLg", "paperWidthXl", "paperFullWidth", "paperFullScreen"]),
  fS = Ege,
  Sge = j.createContext({}),
  oH = Sge,
  Cge = ["aria-describedby", "aria-labelledby", "BackdropComponent", "BackdropProps", "children", "className", "disableEscapeKeyDown", "fullScreen", "fullWidth", "maxWidth", "onBackdropClick", "onClose", "open", "PaperComponent", "PaperProps", "scroll", "TransitionComponent", "transitionDuration", "TransitionProps"],
  Age = me(rH, {
    name: "MuiDialog",
    slot: "Backdrop",
    overrides: (e, t) => t.backdrop
  })({
    zIndex: -1
  }),
  Tge = e => {
    const {
      classes: t,
      scroll: n,
      maxWidth: r,
      fullWidth: i,
      fullScreen: s
    } = e, o = {
      root: ["root"],
      container: ["container", `scroll${qe(n)}`],
      paper: ["paper", `paperScroll${qe(n)}`, `paperWidth${qe(String(r))}`, i && "paperFullWidth", s && "paperFullScreen"]
    };
    return pt(o, xge, t)
  },
  kge = me(QT, {
    name: "MuiDialog",
    slot: "Root",
    overridesResolver: (e, t) => t.root
  })({
    "@media print": {
      position: "absolute !important"
    }
  }),
  _ge = me("div", {
    name: "MuiDialog",
    slot: "Container",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.container, t[`scroll${qe(n.scroll)}`]]
    }
  })(({
    ownerState: e
  }) => K({
    height: "100%",
    "@media print": {
      height: "auto"
    },
    outline: 0
  }, e.scroll === "paper" && {
    display: "flex",
    justifyContent: "center",
    alignItems: "center"
  }, e.scroll === "body" && {
    overflowY: "auto",
    overflowX: "hidden",
    textAlign: "center",
    "&::after": {
      content: '""',
      display: "inline-block",
      verticalAlign: "middle",
      height: "100%",
      width: "0"
    }
  })),
  Ige = me(z2, {
    name: "MuiDialog",
    slot: "Paper",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.paper, t[`scrollPaper${qe(n.scroll)}`], t[`paperWidth${qe(String(n.maxWidth))}`], n.fullWidth && t.paperFullWidth, n.fullScreen && t.paperFullScreen]
    }
  })(({
    theme: e,
    ownerState: t
  }) => K({
    margin: 32,
    position: "relative",
    overflowY: "auto",
    "@media print": {
      overflowY: "visible",
      boxShadow: "none"
    }
  }, t.scroll === "paper" && {
    display: "flex",
    flexDirection: "column",
    maxHeight: "calc(100% - 64px)"
  }, t.scroll === "body" && {
    display: "inline-block",
    verticalAlign: "middle",
    textAlign: "left"
  }, !t.maxWidth && {
    maxWidth: "calc(100% - 64px)"
  }, t.maxWidth === "xs" && {
    maxWidth: e.breakpoints.unit === "px" ? Math.max(e.breakpoints.values.xs, 444) : `max(${e.breakpoints.values.xs}${e.breakpoints.unit}, 444px)`,
    [`&.${fS.paperScrollBody}`]: {
      [e.breakpoints.down(Math.max(e.breakpoints.values.xs, 444) + 32 * 2)]: {
        maxWidth: "calc(100% - 64px)"
      }
    }
  }, t.maxWidth && t.maxWidth !== "xs" && {
    maxWidth: `${e.breakpoints.values[t.maxWidth]}${e.breakpoints.unit}`,
    [`&.${fS.paperScrollBody}`]: {
      [e.breakpoints.down(e.breakpoints.values[t.maxWidth] + 32 * 2)]: {
        maxWidth: "calc(100% - 64px)"
      }
    }
  }, t.fullWidth && {
    width: "calc(100% - 64px)"
  }, t.fullScreen && {
    margin: 0,
    width: "100%",
    maxWidth: "100%",
    height: "100%",
    maxHeight: "none",
    borderRadius: 0,
    [`&.${fS.paperScrollBody}`]: {
      margin: 0,
      maxWidth: "100%"
    }
  })),
  Pge = j.forwardRef(function (t, n) {
    const r = xt({
        props: t,
        name: "MuiDialog"
      }),
      i = vl(),
      s = {
        enter: i.transitions.duration.enteringScreen,
        exit: i.transitions.duration.leavingScreen
      },
      {
        "aria-describedby": o,
        "aria-labelledby": a,
        BackdropComponent: c,
        BackdropProps: l,
        children: u,
        className: f,
        disableEscapeKeyDown: h = !1,
        fullScreen: g = !1,
        fullWidth: y = !1,
        maxWidth: x = "sm",
        onBackdropClick: k,
        onClose: _,
        open: p,
        PaperComponent: v = z2,
        PaperProps: S = {},
        scroll: I = "paper",
        TransitionComponent: A = nH,
        transitionDuration: w = s,
        TransitionProps: E
      } = r,
      D = Ve(r, Cge),
      $ = K({}, r, {
        disableEscapeKeyDown: h,
        fullScreen: g,
        fullWidth: y,
        maxWidth: x,
        scroll: I
      }),
      V = Tge($),
      G = j.useRef(),
      L = N => {
        G.current = N.target === N.currentTarget
      },
      b = N => {
        G.current && (G.current = null, k && k(N), _ && _(N, "backdropClick"))
      },
      T = O2(a),
      R = j.useMemo(() => ({
        titleId: T
      }), [T]);
    return C.jsx(kge, K({
      className: Ye(V.root, f),
      closeAfterTransition: !0,
      components: {
        Backdrop: Age
      },
      componentsProps: {
        backdrop: K({
          transitionDuration: w,
          as: c
        }, l)
      },
      disableEscapeKeyDown: h,
      onClose: _,
      open: p,
      ref: n,
      onClick: b,
      ownerState: $
    }, D, {
      children: C.jsx(A, K({
        appear: !0,
        in: p,
        timeout: w,
        role: "presentation"
      }, E, {
        children: C.jsx(_ge, {
          className: Ye(V.container),
          onMouseDown: L,
          ownerState: $,
          children: C.jsx(Ige, K({
            as: v,
            elevation: 24,
            role: "dialog",
            "aria-describedby": o,
            "aria-labelledby": T
          }, S, {
            className: Ye(V.paper, S.className),
            ownerState: $,
            children: C.jsx(oH.Provider, {
              value: R,
              children: u
            })
          }))
        })
      }))
    }))
  }),
  Rge = Pge;

function Oge(e) {
  return mt("MuiDialogActions", e)
}
const Dge = gt("MuiDialogActions", ["root", "spacing"]),
  Nge = Dge,
  Mge = ["className", "disableSpacing"],
  $ge = e => {
    const {
      classes: t,
      disableSpacing: n
    } = e;
    return pt({
      root: ["root", !n && "spacing"]
    }, Oge, t)
  },
  Lge = me("div", {
    name: "MuiDialogActions",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, !n.disableSpacing && t.spacing]
    }
  })(({
    ownerState: e
  }) => K({
    display: "flex",
    alignItems: "center",
    padding: 8,
    justifyContent: "flex-end",
    flex: "0 0 auto"
  }, !e.disableSpacing && {
    "& > :not(style) ~ :not(style)": {
      marginLeft: 8
    }
  })),
  Bge = j.forwardRef(function (t, n) {
    const r = xt({
        props: t,
        name: "MuiDialogActions"
      }),
      {
        className: i,
        disableSpacing: s = !1
      } = r,
      o = Ve(r, Mge),
      a = K({}, r, {
        disableSpacing: s
      }),
      c = $ge(a);
    return C.jsx(Lge, K({
      className: Ye(c.root, i),
      ownerState: a,
      ref: n
    }, o))
  }),
  W2 = Bge;

function Fge(e) {
  return mt("MuiDialogContent", e)
}
gt("MuiDialogContent", ["root", "dividers"]);

function jge(e) {
  return mt("MuiDialogTitle", e)
}
const Uge = gt("MuiDialogTitle", ["root"]),
  zge = Uge,
  Hge = ["className", "dividers"],
  Vge = e => {
    const {
      classes: t,
      dividers: n
    } = e;
    return pt({
      root: ["root", n && "dividers"]
    }, Fge, t)
  },
  Wge = me("div", {
    name: "MuiDialogContent",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, n.dividers && t.dividers]
    }
  })(({
    theme: e,
    ownerState: t
  }) => K({
    flex: "1 1 auto",
    WebkitOverflowScrolling: "touch",
    overflowY: "auto",
    padding: "20px 24px"
  }, t.dividers ? {
    padding: "16px 24px",
    borderTop: `1px solid ${(e.vars||e).palette.divider}`,
    borderBottom: `1px solid ${(e.vars||e).palette.divider}`
  } : {
    [`.${zge.root} + &`]: {
      paddingTop: 0
    }
  })),
  qge = j.forwardRef(function (t, n) {
    const r = xt({
        props: t,
        name: "MuiDialogContent"
      }),
      {
        className: i,
        dividers: s = !1
      } = r,
      o = Ve(r, Hge),
      a = K({}, r, {
        dividers: s
      }),
      c = Vge(a);
    return C.jsx(Wge, K({
      className: Ye(c.root, i),
      ownerState: a,
      ref: n
    }, o))
  }),
  q2 = qge;

function Gge(e) {
  return mt("MuiDialogContentText", e)
}
gt("MuiDialogContentText", ["root"]);
const Kge = ["children", "className"],
  Qge = e => {
    const {
      classes: t
    } = e, r = pt({
      root: ["root"]
    }, Gge, t);
    return K({}, t, r)
  },
  Yge = me(Ue, {
    shouldForwardProp: e => $s(e) || e === "classes",
    name: "MuiDialogContentText",
    slot: "Root",
    overridesResolver: (e, t) => t.root
  })({}),
  Jge = j.forwardRef(function (t, n) {
    const r = xt({
        props: t,
        name: "MuiDialogContentText"
      }),
      {
        className: i
      } = r,
      s = Ve(r, Kge),
      o = Qge(s);
    return C.jsx(Yge, K({
      component: "p",
      variant: "body1",
      color: "text.secondary",
      ref: n,
      ownerState: s,
      className: Ye(o.root, i)
    }, r, {
      classes: o
    }))
  }),
  G2 = Jge,
  Xge = ["className", "id"],
  Zge = e => {
    const {
      classes: t
    } = e;
    return pt({
      root: ["root"]
    }, jge, t)
  },
  e1e = me(Ue, {
    name: "MuiDialogTitle",
    slot: "Root",
    overridesResolver: (e, t) => t.root
  })({
    padding: "16px 24px",
    flex: "0 0 auto"
  }),
  t1e = j.forwardRef(function (t, n) {
    const r = xt({
        props: t,
        name: "MuiDialogTitle"
      }),
      {
        className: i,
        id: s
      } = r,
      o = Ve(r, Xge),
      a = r,
      c = Zge(a),
      {
        titleId: l = s
      } = j.useContext(oH);
    return C.jsx(e1e, K({
      component: "h2",
      className: Ye(c.root, i),
      ownerState: a,
      ref: n,
      variant: "h6",
      id: s ?? l
    }, o))
  }),
  D5 = t1e;

function n1e(e) {
  return mt("MuiDivider", e)
}
const r1e = gt("MuiDivider", ["root", "absolute", "fullWidth", "inset", "middle", "flexItem", "light", "vertical", "withChildren", "withChildrenVertical", "textAlignRight", "textAlignLeft", "wrapper", "wrapperVertical"]),
  WD = r1e,
  i1e = ["absolute", "children", "className", "component", "flexItem", "light", "orientation", "role", "textAlign", "variant"],
  s1e = e => {
    const {
      absolute: t,
      children: n,
      classes: r,
      flexItem: i,
      light: s,
      orientation: o,
      textAlign: a,
      variant: c
    } = e;
    return pt({
      root: ["root", t && "absolute", c, s && "light", o === "vertical" && "vertical", i && "flexItem", n && "withChildren", n && o === "vertical" && "withChildrenVertical", a === "right" && o !== "vertical" && "textAlignRight", a === "left" && o !== "vertical" && "textAlignLeft"],
      wrapper: ["wrapper", o === "vertical" && "wrapperVertical"]
    }, n1e, r)
  },
  o1e = me("div", {
    name: "MuiDivider",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, n.absolute && t.absolute, t[n.variant], n.light && t.light, n.orientation === "vertical" && t.vertical, n.flexItem && t.flexItem, n.children && t.withChildren, n.children && n.orientation === "vertical" && t.withChildrenVertical, n.textAlign === "right" && n.orientation !== "vertical" && t.textAlignRight, n.textAlign === "left" && n.orientation !== "vertical" && t.textAlignLeft]
    }
  })(({
    theme: e,
    ownerState: t
  }) => K({
    margin: 0,
    flexShrink: 0,
    borderWidth: 0,
    borderStyle: "solid",
    borderColor: (e.vars || e).palette.divider,
    borderBottomWidth: "thin"
  }, t.absolute && {
    position: "absolute",
    bottom: 0,
    left: 0,
    width: "100%"
  }, t.light && {
    borderColor: e.vars ? `rgba(${e.vars.palette.dividerChannel} / 0.08)` : lr(e.palette.divider, .08)
  }, t.variant === "inset" && {
    marginLeft: 72
  }, t.variant === "middle" && t.orientation === "horizontal" && {
    marginLeft: e.spacing(2),
    marginRight: e.spacing(2)
  }, t.variant === "middle" && t.orientation === "vertical" && {
    marginTop: e.spacing(1),
    marginBottom: e.spacing(1)
  }, t.orientation === "vertical" && {
    height: "100%",
    borderBottomWidth: 0,
    borderRightWidth: "thin"
  }, t.flexItem && {
    alignSelf: "stretch",
    height: "auto"
  }), ({
    ownerState: e
  }) => K({}, e.children && {
    display: "flex",
    whiteSpace: "nowrap",
    textAlign: "center",
    border: 0,
    "&::before, &::after": {
      content: '""',
      alignSelf: "center"
    }
  }), ({
    theme: e,
    ownerState: t
  }) => K({}, t.children && t.orientation !== "vertical" && {
    "&::before, &::after": {
      width: "100%",
      borderTop: `thin solid ${(e.vars||e).palette.divider}`
    }
  }), ({
    theme: e,
    ownerState: t
  }) => K({}, t.children && t.orientation === "vertical" && {
    flexDirection: "column",
    "&::before, &::after": {
      height: "100%",
      borderLeft: `thin solid ${(e.vars||e).palette.divider}`
    }
  }), ({
    ownerState: e
  }) => K({}, e.textAlign === "right" && e.orientation !== "vertical" && {
    "&::before": {
      width: "90%"
    },
    "&::after": {
      width: "10%"
    }
  }, e.textAlign === "left" && e.orientation !== "vertical" && {
    "&::before": {
      width: "10%"
    },
    "&::after": {
      width: "90%"
    }
  })),
  a1e = me("span", {
    name: "MuiDivider",
    slot: "Wrapper",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.wrapper, n.orientation === "vertical" && t.wrapperVertical]
    }
  })(({
    theme: e,
    ownerState: t
  }) => K({
    display: "inline-block",
    paddingLeft: `calc(${e.spacing(1)} * 1.2)`,
    paddingRight: `calc(${e.spacing(1)} * 1.2)`
  }, t.orientation === "vertical" && {
    paddingTop: `calc(${e.spacing(1)} * 1.2)`,
    paddingBottom: `calc(${e.spacing(1)} * 1.2)`
  })),
  aH = j.forwardRef(function (t, n) {
    const r = xt({
        props: t,
        name: "MuiDivider"
      }),
      {
        absolute: i = !1,
        children: s,
        className: o,
        component: a = s ? "div" : "hr",
        flexItem: c = !1,
        light: l = !1,
        orientation: u = "horizontal",
        role: f = a !== "hr" ? "separator" : void 0,
        textAlign: h = "center",
        variant: g = "fullWidth"
      } = r,
      y = Ve(r, i1e),
      x = K({}, r, {
        absolute: i,
        component: a,
        flexItem: c,
        light: l,
        orientation: u,
        role: f,
        textAlign: h,
        variant: g
      }),
      k = s1e(x);
    return C.jsx(o1e, K({
      as: a,
      className: Ye(k.root, o),
      role: f,
      ref: n,
      ownerState: x
    }, y, {
      children: s ? C.jsx(a1e, {
        className: k.wrapper,
        ownerState: x,
        children: s
      }) : null
    }))
  });
aH.muiSkipListHighlight = !0;
const c1e = aH,
  l1e = ["addEndListener", "appear", "children", "container", "direction", "easing", "in", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "style", "timeout", "TransitionComponent"];

function u1e(e, t, n) {
  const r = t.getBoundingClientRect(),
    i = n && n.getBoundingClientRect(),
    s = _a(t);
  let o;
  if (t.fakeTransform) o = t.fakeTransform;
  else {
    const l = s.getComputedStyle(t);
    o = l.getPropertyValue("-webkit-transform") || l.getPropertyValue("transform")
  }
  let a = 0,
    c = 0;
  if (o && o !== "none" && typeof o == "string") {
    const l = o.split("(")[1].split(")")[0].split(",");
    a = parseInt(l[4], 10), c = parseInt(l[5], 10)
  }
  return e === "left" ? i ? `translateX(${i.right+a-r.left}px)` : `translateX(${s.innerWidth+a-r.left}px)` : e === "right" ? i ? `translateX(-${r.right-i.left-a}px)` : `translateX(-${r.left+r.width-a}px)` : e === "up" ? i ? `translateY(${i.bottom+c-r.top}px)` : `translateY(${s.innerHeight+c-r.top}px)` : i ? `translateY(-${r.top-i.top+r.height-c}px)` : `translateY(-${r.top+r.height-c}px)`
}

function d1e(e) {
  return typeof e == "function" ? e() : e
}

function lb(e, t, n) {
  const r = d1e(n),
    i = u1e(e, t, r);
  i && (t.style.webkitTransform = i, t.style.transform = i)
}
const f1e = j.forwardRef(function (t, n) {
    const r = vl(),
      i = {
        enter: r.transitions.easing.easeOut,
        exit: r.transitions.easing.sharp
      },
      s = {
        enter: r.transitions.duration.enteringScreen,
        exit: r.transitions.duration.leavingScreen
      },
      {
        addEndListener: o,
        appear: a = !0,
        children: c,
        container: l,
        direction: u = "down",
        easing: f = i,
        in: h,
        onEnter: g,
        onEntered: y,
        onEntering: x,
        onExit: k,
        onExited: _,
        onExiting: p,
        style: v,
        timeout: S = s,
        TransitionComponent: I = S5
      } = t,
      A = Ve(t, l1e),
      w = j.useRef(null),
      E = vr(c.ref, w, n),
      D = O => U => {
        O && (U === void 0 ? O(w.current) : O(w.current, U))
      },
      $ = D((O, U) => {
        lb(u, O, l), FT(O), g && g(O, U)
      }),
      V = D((O, U) => {
        const q = Ed({
          timeout: S,
          style: v,
          easing: f
        }, {
          mode: "enter"
        });
        O.style.webkitTransition = r.transitions.create("-webkit-transform", K({}, q)), O.style.transition = r.transitions.create("transform", K({}, q)), O.style.webkitTransform = "none", O.style.transform = "none", x && x(O, U)
      }),
      G = D(y),
      L = D(p),
      b = D(O => {
        const U = Ed({
          timeout: S,
          style: v,
          easing: f
        }, {
          mode: "exit"
        });
        O.style.webkitTransition = r.transitions.create("-webkit-transform", U), O.style.transition = r.transitions.create("transform", U), lb(u, O, l), k && k(O)
      }),
      T = D(O => {
        O.style.webkitTransition = "", O.style.transition = "", _ && _(O)
      }),
      R = O => {
        o && o(w.current, O)
      },
      N = j.useCallback(() => {
        w.current && lb(u, w.current, l)
      }, [u, l]);
    return j.useEffect(() => {
      if (h || u === "down" || u === "right") return;
      const O = um(() => {
          w.current && lb(u, w.current, l)
        }),
        U = _a(w.current);
      return U.addEventListener("resize", O), () => {
        O.clear(), U.removeEventListener("resize", O)
      }
    }, [u, h, l]), j.useEffect(() => {
      h || N()
    }, [h, N]), C.jsx(I, K({
      nodeRef: w,
      onEnter: $,
      onEntered: G,
      onEntering: V,
      onExit: b,
      onExited: T,
      onExiting: L,
      addEndListener: R,
      appear: a,
      in: h,
      timeout: S
    }, A, {
      children: (O, U) => j.cloneElement(c, K({
        ref: E,
        style: K({
          visibility: O === "exited" && !h ? "hidden" : void 0
        }, v, c.props.style)
      }, U))
    }))
  }),
  YC = f1e;

function h1e(e) {
  return mt("MuiDrawer", e)
}
gt("MuiDrawer", ["root", "docked", "paper", "paperAnchorLeft", "paperAnchorRight", "paperAnchorTop", "paperAnchorBottom", "paperAnchorDockedLeft", "paperAnchorDockedRight", "paperAnchorDockedTop", "paperAnchorDockedBottom", "modal"]);
const p1e = ["BackdropProps"],
  m1e = ["anchor", "BackdropProps", "children", "className", "elevation", "hideBackdrop", "ModalProps", "onClose", "open", "PaperProps", "SlideProps", "TransitionComponent", "transitionDuration", "variant"],
  cH = (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, (n.variant === "permanent" || n.variant === "persistent") && t.docked, t.modal]
  },
  g1e = e => {
    const {
      classes: t,
      anchor: n,
      variant: r
    } = e, i = {
      root: ["root"],
      docked: [(r === "permanent" || r === "persistent") && "docked"],
      modal: ["modal"],
      paper: ["paper", `paperAnchor${qe(n)}`, r !== "temporary" && `paperAnchorDocked${qe(n)}`]
    };
    return pt(i, h1e, t)
  },
  y1e = me(QT, {
    name: "MuiDrawer",
    slot: "Root",
    overridesResolver: cH
  })(({
    theme: e
  }) => ({
    zIndex: (e.vars || e).zIndex.drawer
  })),
  qD = me("div", {
    shouldForwardProp: $s,
    name: "MuiDrawer",
    slot: "Docked",
    skipVariantsResolver: !1,
    overridesResolver: cH
  })({
    flex: "0 0 auto"
  }),
  v1e = me(z2, {
    name: "MuiDrawer",
    slot: "Paper",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.paper, t[`paperAnchor${qe(n.anchor)}`], n.variant !== "temporary" && t[`paperAnchorDocked${qe(n.anchor)}`]]
    }
  })(({
    theme: e,
    ownerState: t
  }) => K({
    overflowY: "auto",
    display: "flex",
    flexDirection: "column",
    height: "100%",
    flex: "1 0 auto",
    zIndex: (e.vars || e).zIndex.drawer,
    WebkitOverflowScrolling: "touch",
    position: "fixed",
    top: 0,
    outline: 0
  }, t.anchor === "left" && {
    left: 0
  }, t.anchor === "top" && {
    top: 0,
    left: 0,
    right: 0,
    height: "auto",
    maxHeight: "100%"
  }, t.anchor === "right" && {
    right: 0
  }, t.anchor === "bottom" && {
    top: "auto",
    left: 0,
    bottom: 0,
    right: 0,
    height: "auto",
    maxHeight: "100%"
  }, t.anchor === "left" && t.variant !== "temporary" && {
    borderRight: `1px solid ${(e.vars||e).palette.divider}`
  }, t.anchor === "top" && t.variant !== "temporary" && {
    borderBottom: `1px solid ${(e.vars||e).palette.divider}`
  }, t.anchor === "right" && t.variant !== "temporary" && {
    borderLeft: `1px solid ${(e.vars||e).palette.divider}`
  }, t.anchor === "bottom" && t.variant !== "temporary" && {
    borderTop: `1px solid ${(e.vars||e).palette.divider}`
  })),
  lH = {
    left: "right",
    right: "left",
    top: "down",
    bottom: "up"
  };

function b1e(e) {
  return ["left", "right"].indexOf(e) !== -1
}

function w1e({
  direction: e
}, t) {
  return e === "rtl" && b1e(t) ? lH[t] : t
}
const x1e = j.forwardRef(function (t, n) {
    const r = xt({
        props: t,
        name: "MuiDrawer"
      }),
      i = vl(),
      s = U2(),
      o = {
        enter: i.transitions.duration.enteringScreen,
        exit: i.transitions.duration.leavingScreen
      },
      {
        anchor: a = "left",
        BackdropProps: c,
        children: l,
        className: u,
        elevation: f = 16,
        hideBackdrop: h = !1,
        ModalProps: {
          BackdropProps: g
        } = {},
        onClose: y,
        open: x = !1,
        PaperProps: k = {},
        SlideProps: _,
        TransitionComponent: p = YC,
        transitionDuration: v = o,
        variant: S = "temporary"
      } = r,
      I = Ve(r.ModalProps, p1e),
      A = Ve(r, m1e),
      w = j.useRef(!1);
    j.useEffect(() => {
      w.current = !0
    }, []);
    const E = w1e({
        direction: s ? "rtl" : "ltr"
      }, a),
      $ = K({}, r, {
        anchor: a,
        elevation: f,
        open: x,
        variant: S
      }, A),
      V = g1e($),
      G = C.jsx(v1e, K({
        elevation: S === "temporary" ? f : 0,
        square: !0
      }, k, {
        className: Ye(V.paper, k.className),
        ownerState: $,
        children: l
      }));
    if (S === "permanent") return C.jsx(qD, K({
      className: Ye(V.root, V.docked, u),
      ownerState: $,
      ref: n
    }, A, {
      children: G
    }));
    const L = C.jsx(p, K({
      in: x,
      direction: lH[E],
      timeout: v,
      appear: w.current
    }, _, {
      children: G
    }));
    return S === "persistent" ? C.jsx(qD, K({
      className: Ye(V.root, V.docked, u),
      ownerState: $,
      ref: n
    }, A, {
      children: L
    })) : C.jsx(y1e, K({
      BackdropProps: K({}, c, g, {
        transitionDuration: v
      }),
      className: Ye(V.root, V.modal, u),
      open: x,
      ownerState: $,
      onClose: y,
      hideBackdrop: h,
      ref: n
    }, A, I, {
      children: L
    }))
  }),
  uH = x1e,
  E1e = ["disableUnderline", "components", "componentsProps", "fullWidth", "hiddenLabel", "inputComponent", "multiline", "slotProps", "slots", "type"],
  S1e = e => {
    const {
      classes: t,
      disableUnderline: n
    } = e, i = pt({
      root: ["root", !n && "underline"],
      input: ["input"]
    }, jpe, t);
    return K({}, t, i)
  },
  C1e = me(P5, {
    shouldForwardProp: e => $s(e) || e === "classes",
    name: "MuiFilledInput",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [..._5(e, t), !n.disableUnderline && t.underline]
    }
  })(({
    theme: e,
    ownerState: t
  }) => {
    var n;
    const r = e.palette.mode === "light",
      i = r ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)",
      s = r ? "rgba(0, 0, 0, 0.06)" : "rgba(255, 255, 255, 0.09)",
      o = r ? "rgba(0, 0, 0, 0.09)" : "rgba(255, 255, 255, 0.13)",
      a = r ? "rgba(0, 0, 0, 0.12)" : "rgba(255, 255, 255, 0.12)";
    return K({
      position: "relative",
      backgroundColor: e.vars ? e.vars.palette.FilledInput.bg : s,
      borderTopLeftRadius: (e.vars || e).shape.borderRadius,
      borderTopRightRadius: (e.vars || e).shape.borderRadius,
      transition: e.transitions.create("background-color", {
        duration: e.transitions.duration.shorter,
        easing: e.transitions.easing.easeOut
      }),
      "&:hover": {
        backgroundColor: e.vars ? e.vars.palette.FilledInput.hoverBg : o,
        "@media (hover: none)": {
          backgroundColor: e.vars ? e.vars.palette.FilledInput.bg : s
        }
      },
      [`&.${hf.focused}`]: {
        backgroundColor: e.vars ? e.vars.palette.FilledInput.bg : s
      },
      [`&.${hf.disabled}`]: {
        backgroundColor: e.vars ? e.vars.palette.FilledInput.disabledBg : a
      }
    }, !t.disableUnderline && {
      "&::after": {
        borderBottom: `2px solid ${(n=(e.vars||e).palette[t.color||"primary"])==null?void 0:n.main}`,
        left: 0,
        bottom: 0,
        content: '""',
        position: "absolute",
        right: 0,
        transform: "scaleX(0)",
        transition: e.transitions.create("transform", {
          duration: e.transitions.duration.shorter,
          easing: e.transitions.easing.easeOut
        }),
        pointerEvents: "none"
      },
      [`&.${hf.focused}:after`]: {
        transform: "scaleX(1) translateX(0)"
      },
      [`&.${hf.error}`]: {
        "&::before, &::after": {
          borderBottomColor: (e.vars || e).palette.error.main
        }
      },
      "&::before": {
        borderBottom: `1px solid ${e.vars?`rgba(${e.vars.palette.common.onBackgroundChannel} / ${e.vars.opacity.inputUnderline})`:i}`,
        left: 0,
        bottom: 0,
        content: '"\\00a0"',
        position: "absolute",
        right: 0,
        transition: e.transitions.create("border-bottom-color", {
          duration: e.transitions.duration.shorter
        }),
        pointerEvents: "none"
      },
      [`&:hover:not(.${hf.disabled}, .${hf.error}):before`]: {
        borderBottom: `1px solid ${(e.vars||e).palette.text.primary}`
      },
      [`&.${hf.disabled}:before`]: {
        borderBottomStyle: "dotted"
      }
    }, t.startAdornment && {
      paddingLeft: 12
    }, t.endAdornment && {
      paddingRight: 12
    }, t.multiline && K({
      padding: "25px 12px 8px"
    }, t.size === "small" && {
      paddingTop: 21,
      paddingBottom: 4
    }, t.hiddenLabel && {
      paddingTop: 16,
      paddingBottom: 17
    }, t.hiddenLabel && t.size === "small" && {
      paddingTop: 8,
      paddingBottom: 9
    }))
  }),
  A1e = me(R5, {
    name: "MuiFilledInput",
    slot: "Input",
    overridesResolver: I5
  })(({
    theme: e,
    ownerState: t
  }) => K({
    paddingTop: 25,
    paddingRight: 12,
    paddingBottom: 8,
    paddingLeft: 12
  }, !e.vars && {
    "&:-webkit-autofill": {
      WebkitBoxShadow: e.palette.mode === "light" ? null : "0 0 0 100px #266798 inset",
      WebkitTextFillColor: e.palette.mode === "light" ? null : "#fff",
      caretColor: e.palette.mode === "light" ? null : "#fff",
      borderTopLeftRadius: "inherit",
      borderTopRightRadius: "inherit"
    }
  }, e.vars && {
    "&:-webkit-autofill": {
      borderTopLeftRadius: "inherit",
      borderTopRightRadius: "inherit"
    },
    [e.getColorSchemeSelector("dark")]: {
      "&:-webkit-autofill": {
        WebkitBoxShadow: "0 0 0 100px #266798 inset",
        WebkitTextFillColor: "#fff",
        caretColor: "#fff"
      }
    }
  }, t.size === "small" && {
    paddingTop: 21,
    paddingBottom: 4
  }, t.hiddenLabel && {
    paddingTop: 16,
    paddingBottom: 17
  }, t.startAdornment && {
    paddingLeft: 0
  }, t.endAdornment && {
    paddingRight: 0
  }, t.hiddenLabel && t.size === "small" && {
    paddingTop: 8,
    paddingBottom: 9
  }, t.multiline && {
    paddingTop: 0,
    paddingBottom: 0,
    paddingLeft: 0,
    paddingRight: 0
  })),
  dH = j.forwardRef(function (t, n) {
    var r, i, s, o;
    const a = xt({
        props: t,
        name: "MuiFilledInput"
      }),
      {
        components: c = {},
        componentsProps: l,
        fullWidth: u = !1,
        inputComponent: f = "input",
        multiline: h = !1,
        slotProps: g,
        slots: y = {},
        type: x = "text"
      } = a,
      k = Ve(a, E1e),
      _ = K({}, a, {
        fullWidth: u,
        inputComponent: f,
        multiline: h,
        type: x
      }),
      p = S1e(a),
      v = {
        root: {
          ownerState: _
        },
        input: {
          ownerState: _
        }
      },
      S = g ?? l ? ks(v, g ?? l) : v,
      I = (r = (i = y.root) != null ? i : c.Root) != null ? r : C1e,
      A = (s = (o = y.input) != null ? o : c.Input) != null ? s : A1e;
    return C.jsx(gm, K({
      slots: {
        root: I,
        input: A
      },
      componentsProps: S,
      fullWidth: u,
      inputComponent: f,
      multiline: h,
      ref: n,
      type: x
    }, k, {
      classes: p
    }))
  });
dH.muiName = "Input";
const T1e = dH;

function k1e(e) {
  return mt("MuiFormControl", e)
}
gt("MuiFormControl", ["root", "marginNone", "marginNormal", "marginDense", "fullWidth", "disabled"]);
const _1e = ["children", "className", "color", "component", "disabled", "error", "focused", "fullWidth", "hiddenLabel", "margin", "required", "size", "variant"],
  I1e = e => {
    const {
      classes: t,
      margin: n,
      fullWidth: r
    } = e, i = {
      root: ["root", n !== "none" && `margin${qe(n)}`, r && "fullWidth"]
    };
    return pt(i, k1e, t)
  },
  P1e = me("div", {
    name: "MuiFormControl",
    slot: "Root",
    overridesResolver: ({
      ownerState: e
    }, t) => K({}, t.root, t[`margin${qe(e.margin)}`], e.fullWidth && t.fullWidth)
  })(({
    ownerState: e
  }) => K({
    display: "inline-flex",
    flexDirection: "column",
    position: "relative",
    minWidth: 0,
    padding: 0,
    margin: 0,
    border: 0,
    verticalAlign: "top"
  }, e.margin === "normal" && {
    marginTop: 16,
    marginBottom: 8
  }, e.margin === "dense" && {
    marginTop: 8,
    marginBottom: 4
  }, e.fullWidth && {
    width: "100%"
  })),
  R1e = j.forwardRef(function (t, n) {
    const r = xt({
        props: t,
        name: "MuiFormControl"
      }),
      {
        children: i,
        className: s,
        color: o = "primary",
        component: a = "div",
        disabled: c = !1,
        error: l = !1,
        focused: u,
        fullWidth: f = !1,
        hiddenLabel: h = !1,
        margin: g = "none",
        required: y = !1,
        size: x = "medium",
        variant: k = "outlined"
      } = r,
      _ = Ve(r, _1e),
      p = K({}, r, {
        color: o,
        component: a,
        disabled: c,
        error: l,
        fullWidth: f,
        hiddenLabel: h,
        margin: g,
        required: y,
        size: x,
        variant: k
      }),
      v = I1e(p),
      [S, I] = j.useState(() => {
        let L = !1;
        return i && j.Children.forEach(i, b => {
          if (!g1(b, ["Input", "Select"])) return;
          const T = g1(b, ["Select"]) ? b.props.input : b;
          T && Ipe(T.props) && (L = !0)
        }), L
      }),
      [A, w] = j.useState(() => {
        let L = !1;
        return i && j.Children.forEach(i, b => {
          g1(b, ["Input", "Select"]) && (l3(b.props, !0) || l3(b.props.inputProps, !0)) && (L = !0)
        }), L
      }),
      [E, D] = j.useState(!1);
    c && E && D(!1);
    const $ = u !== void 0 && !c ? u : E;
    let V;
    const G = j.useMemo(() => ({
      adornedStart: S,
      setAdornedStart: I,
      color: o,
      disabled: c,
      error: l,
      filled: A,
      focused: $,
      fullWidth: f,
      hiddenLabel: h,
      size: x,
      onBlur: () => {
        D(!1)
      },
      onEmpty: () => {
        w(!1)
      },
      onFilled: () => {
        w(!0)
      },
      onFocus: () => {
        D(!0)
      },
      registerEffect: V,
      required: y,
      variant: k
    }), [S, o, c, l, A, $, f, h, V, y, x, k]);
    return C.jsx(k5.Provider, {
      value: G,
      children: C.jsx(P1e, K({
        as: a,
        ownerState: p,
        className: Ye(v.root, s),
        ref: n
      }, _, {
        children: i
      }))
    })
  }),
  Sh = R1e,
  O1e = bfe({
    createStyledComponent: me("div", {
      name: "MuiStack",
      slot: "Root",
      overridesResolver: (e, t) => t.root
    }),
    useThemeProps: e => xt({
      props: e,
      name: "MuiStack"
    })
  }),
  N5 = O1e;

function D1e(e) {
  return mt("MuiFormHelperText", e)
}
const N1e = gt("MuiFormHelperText", ["root", "error", "disabled", "sizeSmall", "sizeMedium", "contained", "focused", "filled", "required"]),
  GD = N1e;
var KD;
const M1e = ["children", "className", "component", "disabled", "error", "filled", "focused", "margin", "required", "variant"],
  $1e = e => {
    const {
      classes: t,
      contained: n,
      size: r,
      disabled: i,
      error: s,
      filled: o,
      focused: a,
      required: c
    } = e, l = {
      root: ["root", i && "disabled", s && "error", r && `size${qe(r)}`, n && "contained", a && "focused", o && "filled", c && "required"]
    };
    return pt(l, D1e, t)
  },
  L1e = me("p", {
    name: "MuiFormHelperText",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, n.size && t[`size${qe(n.size)}`], n.contained && t.contained, n.filled && t.filled]
    }
  })(({
    theme: e,
    ownerState: t
  }) => K({
    color: (e.vars || e).palette.text.secondary
  }, e.typography.caption, {
    textAlign: "left",
    marginTop: 3,
    marginRight: 0,
    marginBottom: 0,
    marginLeft: 0,
    [`&.${GD.disabled}`]: {
      color: (e.vars || e).palette.text.disabled
    },
    [`&.${GD.error}`]: {
      color: (e.vars || e).palette.error.main
    }
  }, t.size === "small" && {
    marginTop: 4
  }, t.contained && {
    marginLeft: 14,
    marginRight: 14
  })),
  B1e = j.forwardRef(function (t, n) {
    const r = xt({
        props: t,
        name: "MuiFormHelperText"
      }),
      {
        children: i,
        className: s,
        component: o = "p"
      } = r,
      a = Ve(r, M1e),
      c = mm(),
      l = T5({
        props: r,
        muiFormControl: c,
        states: ["variant", "size", "disabled", "error", "filled", "focused", "required"]
      }),
      u = K({}, r, {
        component: o,
        contained: l.variant === "filled" || l.variant === "outlined",
        variant: l.variant,
        size: l.size,
        disabled: l.disabled,
        error: l.error,
        filled: l.filled,
        focused: l.focused,
        required: l.required
      }),
      f = $1e(u);
    return C.jsx(L1e, K({
      as: o,
      ownerState: u,
      className: Ye(f.root, s),
      ref: n
    }, a, {
      children: i === " " ? KD || (KD = C.jsx("span", {
        className: "notranslate",
        children: "​"
      })) : i
    }))
  }),
  fH = B1e,
  F1e = ["addEndListener", "appear", "children", "easing", "in", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "style", "timeout", "TransitionComponent"];

function JC(e) {
  return `scale(${e}, ${e**2})`
}
const j1e = {
    entering: {
      opacity: 1,
      transform: JC(1)
    },
    entered: {
      opacity: 1,
      transform: "none"
    }
  },
  hS = typeof navigator < "u" && /^((?!chrome|android).)*(safari|mobile)/i.test(navigator.userAgent) && /(os |version\/)15(.|_)4/i.test(navigator.userAgent),
  hH = j.forwardRef(function (t, n) {
    const {
      addEndListener: r,
      appear: i = !0,
      children: s,
      easing: o,
      in: a,
      onEnter: c,
      onEntered: l,
      onEntering: u,
      onExit: f,
      onExited: h,
      onExiting: g,
      style: y,
      timeout: x = "auto",
      TransitionComponent: k = S5
    } = t, _ = Ve(t, F1e), p = Pf(), v = j.useRef(), S = vl(), I = j.useRef(null), A = vr(I, s.ref, n), w = T => R => {
      if (T) {
        const N = I.current;
        R === void 0 ? T(N) : T(N, R)
      }
    }, E = w(u), D = w((T, R) => {
      FT(T);
      const {
        duration: N,
        delay: O,
        easing: U
      } = Ed({
        style: y,
        timeout: x,
        easing: o
      }, {
        mode: "enter"
      });
      let q;
      x === "auto" ? (q = S.transitions.getAutoHeightDuration(T.clientHeight), v.current = q) : q = N, T.style.transition = [S.transitions.create("opacity", {
        duration: q,
        delay: O
      }), S.transitions.create("transform", {
        duration: hS ? q : q * .666,
        delay: O,
        easing: U
      })].join(","), c && c(T, R)
    }), $ = w(l), V = w(g), G = w(T => {
      const {
        duration: R,
        delay: N,
        easing: O
      } = Ed({
        style: y,
        timeout: x,
        easing: o
      }, {
        mode: "exit"
      });
      let U;
      x === "auto" ? (U = S.transitions.getAutoHeightDuration(T.clientHeight), v.current = U) : U = R, T.style.transition = [S.transitions.create("opacity", {
        duration: U,
        delay: N
      }), S.transitions.create("transform", {
        duration: hS ? U : U * .666,
        delay: hS ? N : N || U * .333,
        easing: O
      })].join(","), T.style.opacity = 0, T.style.transform = JC(.75), f && f(T)
    }), L = w(h), b = T => {
      x === "auto" && p.start(v.current || 0, T), r && r(I.current, T)
    };
    return C.jsx(k, K({
      appear: i,
      in: a,
      nodeRef: I,
      onEnter: D,
      onEntered: $,
      onEntering: E,
      onExit: G,
      onExited: L,
      onExiting: V,
      addEndListener: b,
      timeout: x === "auto" ? null : x
    }, _, {
      children: (T, R) => j.cloneElement(s, K({
        style: K({
          opacity: 0,
          transform: JC(.75),
          visibility: T === "exited" && !a ? "hidden" : void 0
        }, j1e[T], y, s.props.style),
        ref: A
      }, R))
    }))
  });
hH.muiSupportAuto = !0;
const t2 = hH,
  U1e = ["disableUnderline", "components", "componentsProps", "fullWidth", "inputComponent", "multiline", "slotProps", "slots", "type"],
  z1e = e => {
    const {
      classes: t,
      disableUnderline: n
    } = e, i = pt({
      root: ["root", !n && "underline"],
      input: ["input"]
    }, $pe, t);
    return K({}, t, i)
  },
  H1e = me(P5, {
    shouldForwardProp: e => $s(e) || e === "classes",
    name: "MuiInput",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [..._5(e, t), !n.disableUnderline && t.underline]
    }
  })(({
    theme: e,
    ownerState: t
  }) => {
    let r = e.palette.mode === "light" ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)";
    return e.vars && (r = `rgba(${e.vars.palette.common.onBackgroundChannel} / ${e.vars.opacity.inputUnderline})`), K({
      position: "relative"
    }, t.formControl && {
      "label + &": {
        marginTop: 16
      }
    }, !t.disableUnderline && {
      "&::after": {
        borderBottom: `2px solid ${(e.vars||e).palette[t.color].main}`,
        left: 0,
        bottom: 0,
        content: '""',
        position: "absolute",
        right: 0,
        transform: "scaleX(0)",
        transition: e.transitions.create("transform", {
          duration: e.transitions.duration.shorter,
          easing: e.transitions.easing.easeOut
        }),
        pointerEvents: "none"
      },
      [`&.${Cg.focused}:after`]: {
        transform: "scaleX(1) translateX(0)"
      },
      [`&.${Cg.error}`]: {
        "&::before, &::after": {
          borderBottomColor: (e.vars || e).palette.error.main
        }
      },
      "&::before": {
        borderBottom: `1px solid ${r}`,
        left: 0,
        bottom: 0,
        content: '"\\00a0"',
        position: "absolute",
        right: 0,
        transition: e.transitions.create("border-bottom-color", {
          duration: e.transitions.duration.shorter
        }),
        pointerEvents: "none"
      },
      [`&:hover:not(.${Cg.disabled}, .${Cg.error}):before`]: {
        borderBottom: `2px solid ${(e.vars||e).palette.text.primary}`,
        "@media (hover: none)": {
          borderBottom: `1px solid ${r}`
        }
      },
      [`&.${Cg.disabled}:before`]: {
        borderBottomStyle: "dotted"
      }
    })
  }),
  V1e = me(R5, {
    name: "MuiInput",
    slot: "Input",
    overridesResolver: I5
  })({}),
  pH = j.forwardRef(function (t, n) {
    var r, i, s, o;
    const a = xt({
        props: t,
        name: "MuiInput"
      }),
      {
        disableUnderline: c,
        components: l = {},
        componentsProps: u,
        fullWidth: f = !1,
        inputComponent: h = "input",
        multiline: g = !1,
        slotProps: y,
        slots: x = {},
        type: k = "text"
      } = a,
      _ = Ve(a, U1e),
      p = z1e(a),
      S = {
        root: {
          ownerState: {
            disableUnderline: c
          }
        }
      },
      I = y ?? u ? ks(y ?? u, S) : S,
      A = (r = (i = x.root) != null ? i : l.Root) != null ? r : H1e,
      w = (s = (o = x.input) != null ? o : l.Input) != null ? s : V1e;
    return C.jsx(gm, K({
      slots: {
        root: A,
        input: w
      },
      slotProps: I,
      fullWidth: f,
      inputComponent: h,
      multiline: g,
      ref: n,
      type: k
    }, _, {
      classes: p
    }))
  });
pH.muiName = "Input";
const W1e = pH;

function q1e(e) {
  return mt("MuiInputAdornment", e)
}
const G1e = gt("MuiInputAdornment", ["root", "filled", "standard", "outlined", "positionStart", "positionEnd", "disablePointerEvents", "hiddenLabel", "sizeSmall"]),
  QD = G1e;
var YD;
const K1e = ["children", "className", "component", "disablePointerEvents", "disableTypography", "position", "variant"],
  Q1e = (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, t[`position${qe(n.position)}`], n.disablePointerEvents === !0 && t.disablePointerEvents, t[n.variant]]
  },
  Y1e = e => {
    const {
      classes: t,
      disablePointerEvents: n,
      hiddenLabel: r,
      position: i,
      size: s,
      variant: o
    } = e, a = {
      root: ["root", n && "disablePointerEvents", i && `position${qe(i)}`, o, r && "hiddenLabel", s && `size${qe(s)}`]
    };
    return pt(a, q1e, t)
  },
  J1e = me("div", {
    name: "MuiInputAdornment",
    slot: "Root",
    overridesResolver: Q1e
  })(({
    theme: e,
    ownerState: t
  }) => K({
    display: "flex",
    height: "0.01em",
    maxHeight: "2em",
    alignItems: "center",
    whiteSpace: "nowrap",
    color: (e.vars || e).palette.action.active
  }, t.variant === "filled" && {
    [`&.${QD.positionStart}&:not(.${QD.hiddenLabel})`]: {
      marginTop: 16
    }
  }, t.position === "start" && {
    marginRight: 8
  }, t.position === "end" && {
    marginLeft: 8
  }, t.disablePointerEvents === !0 && {
    pointerEvents: "none"
  })),
  X1e = j.forwardRef(function (t, n) {
    const r = xt({
        props: t,
        name: "MuiInputAdornment"
      }),
      {
        children: i,
        className: s,
        component: o = "div",
        disablePointerEvents: a = !1,
        disableTypography: c = !1,
        position: l,
        variant: u
      } = r,
      f = Ve(r, K1e),
      h = mm() || {};
    let g = u;
    u && h.variant, h && !g && (g = h.variant);
    const y = K({}, r, {
        hiddenLabel: h.hiddenLabel,
        size: h.size,
        disablePointerEvents: a,
        position: l,
        variant: g
      }),
      x = Y1e(y);
    return C.jsx(k5.Provider, {
      value: null,
      children: C.jsx(J1e, K({
        as: o,
        ownerState: y,
        className: Ye(x.root, s),
        ref: n
      }, f, {
        children: typeof i == "string" && !c ? C.jsx(Ue, {
          color: "text.secondary",
          children: i
        }) : C.jsxs(j.Fragment, {
          children: [l === "start" ? YD || (YD = C.jsx("span", {
            className: "notranslate",
            children: "​"
          })) : null, i]
        })
      }))
    })
  }),
  YT = X1e;

function Z1e(e) {
  return mt("MuiLink", e)
}
const e2e = gt("MuiLink", ["root", "underlineNone", "underlineHover", "underlineAlways", "button", "focusVisible"]),
  t2e = e2e,
  mH = {
    primary: "primary.main",
    textPrimary: "text.primary",
    secondary: "secondary.main",
    textSecondary: "text.secondary",
    error: "error.main"
  },
  n2e = e => mH[e] || e,
  r2e = ({
    theme: e,
    ownerState: t
  }) => {
    const n = n2e(t.color),
      r = Tp(e, `palette.${n}`, !1) || t.color,
      i = Tp(e, `palette.${n}Channel`);
    return "vars" in e && i ? `rgba(${i} / 0.4)` : lr(r, .4)
  },
  i2e = ["className", "color", "component", "onBlur", "onFocus", "TypographyClasses", "underline", "variant", "sx"],
  s2e = e => {
    const {
      classes: t,
      component: n,
      focusVisible: r,
      underline: i
    } = e, s = {
      root: ["root", `underline${qe(i)}`, n === "button" && "button", r && "focusVisible"]
    };
    return pt(s, Z1e, t)
  },
  o2e = me(Ue, {
    name: "MuiLink",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, t[`underline${qe(n.underline)}`], n.component === "button" && t.button]
    }
  })(({
    theme: e,
    ownerState: t
  }) => K({}, t.underline === "none" && {
    textDecoration: "none"
  }, t.underline === "hover" && {
    textDecoration: "none",
    "&:hover": {
      textDecoration: "underline"
    }
  }, t.underline === "always" && K({
    textDecoration: "underline"
  }, t.color !== "inherit" && {
    textDecorationColor: r2e({
      theme: e,
      ownerState: t
    })
  }, {
    "&:hover": {
      textDecorationColor: "inherit"
    }
  }), t.component === "button" && {
    position: "relative",
    WebkitTapHighlightColor: "transparent",
    backgroundColor: "transparent",
    outline: 0,
    border: 0,
    margin: 0,
    borderRadius: 0,
    padding: 0,
    cursor: "pointer",
    userSelect: "none",
    verticalAlign: "middle",
    MozAppearance: "none",
    WebkitAppearance: "none",
    "&::-moz-focus-inner": {
      borderStyle: "none"
    },
    [`&.${t2e.focusVisible}`]: {
      outline: "auto"
    }
  })),
  a2e = j.forwardRef(function (t, n) {
    const r = xt({
        props: t,
        name: "MuiLink"
      }),
      {
        className: i,
        color: s = "primary",
        component: o = "a",
        onBlur: a,
        onFocus: c,
        TypographyClasses: l,
        underline: u = "always",
        variant: f = "inherit",
        sx: h
      } = r,
      g = Ve(r, i2e),
      {
        isFocusVisibleRef: y,
        onBlur: x,
        onFocus: k,
        ref: _
      } = Zx(),
      [p, v] = j.useState(!1),
      S = vr(n, _),
      I = D => {
        x(D), y.current === !1 && v(!1), a && a(D)
      },
      A = D => {
        k(D), y.current === !0 && v(!0), c && c(D)
      },
      w = K({}, r, {
        color: s,
        component: o,
        focusVisible: p,
        underline: u,
        variant: f
      }),
      E = s2e(w);
    return C.jsx(o2e, K({
      color: s,
      className: Ye(E.root, i),
      classes: l,
      component: o,
      onBlur: I,
      onFocus: A,
      ref: S,
      ownerState: w,
      variant: f,
      sx: [...Object.keys(mH).includes(s) ? [] : [{
        color: s
      }], ...Array.isArray(h) ? h : [h]]
    }, g))
  }),
  K2 = a2e,
  c2e = j.createContext({}),
  vc = c2e;

function l2e(e) {
  return mt("MuiList", e)
}
gt("MuiList", ["root", "padding", "dense", "subheader"]);
const u2e = ["children", "className", "component", "dense", "disablePadding", "subheader"],
  d2e = e => {
    const {
      classes: t,
      disablePadding: n,
      dense: r,
      subheader: i
    } = e;
    return pt({
      root: ["root", !n && "padding", r && "dense", i && "subheader"]
    }, l2e, t)
  },
  f2e = me("ul", {
    name: "MuiList",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, !n.disablePadding && t.padding, n.dense && t.dense, n.subheader && t.subheader]
    }
  })(({
    ownerState: e
  }) => K({
    listStyle: "none",
    margin: 0,
    padding: 0,
    position: "relative"
  }, !e.disablePadding && {
    paddingTop: 8,
    paddingBottom: 8
  }, e.subheader && {
    paddingTop: 0
  })),
  h2e = j.forwardRef(function (t, n) {
    const r = xt({
        props: t,
        name: "MuiList"
      }),
      {
        children: i,
        className: s,
        component: o = "ul",
        dense: a = !1,
        disablePadding: c = !1,
        subheader: l
      } = r,
      u = Ve(r, u2e),
      f = j.useMemo(() => ({
        dense: a
      }), [a]),
      h = K({}, r, {
        component: o,
        dense: a,
        disablePadding: c
      }),
      g = d2e(h);
    return C.jsx(vc.Provider, {
      value: f,
      children: C.jsxs(f2e, K({
        as: o,
        className: Ye(g.root, s),
        ref: n,
        ownerState: h
      }, u, {
        children: [l, i]
      }))
    })
  }),
  sh = h2e;

function p2e(e) {
  return mt("MuiListItem", e)
}
const m2e = gt("MuiListItem", ["root", "container", "focusVisible", "dense", "alignItemsFlexStart", "disabled", "divider", "gutters", "padding", "button", "secondaryAction", "selected"]),
  S0 = m2e;

function g2e(e) {
  return mt("MuiListItemButton", e)
}
const y2e = gt("MuiListItemButton", ["root", "focusVisible", "dense", "alignItemsFlexStart", "disabled", "divider", "gutters", "selected"]),
  C0 = y2e,
  v2e = ["alignItems", "autoFocus", "component", "children", "dense", "disableGutters", "divider", "focusVisibleClassName", "selected", "className"],
  b2e = (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.dense && t.dense, n.alignItems === "flex-start" && t.alignItemsFlexStart, n.divider && t.divider, !n.disableGutters && t.gutters]
  },
  w2e = e => {
    const {
      alignItems: t,
      classes: n,
      dense: r,
      disabled: i,
      disableGutters: s,
      divider: o,
      selected: a
    } = e, l = pt({
      root: ["root", r && "dense", !s && "gutters", o && "divider", i && "disabled", t === "flex-start" && "alignItemsFlexStart", a && "selected"]
    }, g2e, n);
    return K({}, n, l)
  },
  x2e = me(gu, {
    shouldForwardProp: e => $s(e) || e === "classes",
    name: "MuiListItemButton",
    slot: "Root",
    overridesResolver: b2e
  })(({
    theme: e,
    ownerState: t
  }) => K({
    display: "flex",
    flexGrow: 1,
    justifyContent: "flex-start",
    alignItems: "center",
    position: "relative",
    textDecoration: "none",
    minWidth: 0,
    boxSizing: "border-box",
    textAlign: "left",
    paddingTop: 8,
    paddingBottom: 8,
    transition: e.transitions.create("background-color", {
      duration: e.transitions.duration.shortest
    }),
    "&:hover": {
      textDecoration: "none",
      backgroundColor: (e.vars || e).palette.action.hover,
      "@media (hover: none)": {
        backgroundColor: "transparent"
      }
    },
    [`&.${C0.selected}`]: {
      backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / ${e.vars.palette.action.selectedOpacity})` : lr(e.palette.primary.main, e.palette.action.selectedOpacity),
      [`&.${C0.focusVisible}`]: {
        backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / calc(${e.vars.palette.action.selectedOpacity} + ${e.vars.palette.action.focusOpacity}))` : lr(e.palette.primary.main, e.palette.action.selectedOpacity + e.palette.action.focusOpacity)
      }
    },
    [`&.${C0.selected}:hover`]: {
      backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / calc(${e.vars.palette.action.selectedOpacity} + ${e.vars.palette.action.hoverOpacity}))` : lr(e.palette.primary.main, e.palette.action.selectedOpacity + e.palette.action.hoverOpacity),
      "@media (hover: none)": {
        backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / ${e.vars.palette.action.selectedOpacity})` : lr(e.palette.primary.main, e.palette.action.selectedOpacity)
      }
    },
    [`&.${C0.focusVisible}`]: {
      backgroundColor: (e.vars || e).palette.action.focus
    },
    [`&.${C0.disabled}`]: {
      opacity: (e.vars || e).palette.action.disabledOpacity
    }
  }, t.divider && {
    borderBottom: `1px solid ${(e.vars||e).palette.divider}`,
    backgroundClip: "padding-box"
  }, t.alignItems === "flex-start" && {
    alignItems: "flex-start"
  }, !t.disableGutters && {
    paddingLeft: 16,
    paddingRight: 16
  }, t.dense && {
    paddingTop: 4,
    paddingBottom: 4
  })),
  E2e = j.forwardRef(function (t, n) {
    const r = xt({
        props: t,
        name: "MuiListItemButton"
      }),
      {
        alignItems: i = "center",
        autoFocus: s = !1,
        component: o = "div",
        children: a,
        dense: c = !1,
        disableGutters: l = !1,
        divider: u = !1,
        focusVisibleClassName: f,
        selected: h = !1,
        className: g
      } = r,
      y = Ve(r, v2e),
      x = j.useContext(vc),
      k = j.useMemo(() => ({
        dense: c || x.dense || !1,
        alignItems: i,
        disableGutters: l
      }), [i, x.dense, c, l]),
      _ = j.useRef(null);
    Os(() => {
      s && _.current && _.current.focus()
    }, [s]);
    const p = K({}, r, {
        alignItems: i,
        dense: k.dense,
        disableGutters: l,
        divider: u,
        selected: h
      }),
      v = w2e(p),
      S = vr(_, n);
    return C.jsx(vc.Provider, {
      value: k,
      children: C.jsx(x2e, K({
        ref: S,
        href: y.href || y.to,
        component: (y.href || y.to) && o === "div" ? "button" : o,
        focusVisibleClassName: Ye(v.focusVisible, f),
        ownerState: p,
        className: Ye(v.root, g)
      }, y, {
        classes: v,
        children: a
      }))
    })
  }),
  gH = E2e;

function S2e(e) {
  return mt("MuiListItemSecondaryAction", e)
}
const C2e = gt("MuiListItemSecondaryAction", ["root", "disableGutters"]),
  yH = C2e,
  A2e = ["className"],
  T2e = e => {
    const {
      disableGutters: t,
      classes: n
    } = e;
    return pt({
      root: ["root", t && "disableGutters"]
    }, S2e, n)
  },
  k2e = me("div", {
    name: "MuiListItemSecondaryAction",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, n.disableGutters && t.disableGutters]
    }
  })(({
    ownerState: e
  }) => K({
    position: "absolute",
    right: 16,
    top: "50%",
    transform: "translateY(-50%)"
  }, e.disableGutters && {
    right: 0
  })),
  vH = j.forwardRef(function (t, n) {
    const r = xt({
        props: t,
        name: "MuiListItemSecondaryAction"
      }),
      {
        className: i
      } = r,
      s = Ve(r, A2e),
      o = j.useContext(vc),
      a = K({}, r, {
        disableGutters: o.disableGutters
      }),
      c = T2e(a);
    return C.jsx(k2e, K({
      className: Ye(c.root, i),
      ownerState: a,
      ref: n
    }, s))
  });
vH.muiName = "ListItemSecondaryAction";
const _2e = vH,
  I2e = ["className"],
  P2e = ["alignItems", "autoFocus", "button", "children", "className", "component", "components", "componentsProps", "ContainerComponent", "ContainerProps", "dense", "disabled", "disableGutters", "disablePadding", "divider", "focusVisibleClassName", "secondaryAction", "selected", "slotProps", "slots"],
  R2e = (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.dense && t.dense, n.alignItems === "flex-start" && t.alignItemsFlexStart, n.divider && t.divider, !n.disableGutters && t.gutters, !n.disablePadding && t.padding, n.button && t.button, n.hasSecondaryAction && t.secondaryAction]
  },
  O2e = e => {
    const {
      alignItems: t,
      button: n,
      classes: r,
      dense: i,
      disabled: s,
      disableGutters: o,
      disablePadding: a,
      divider: c,
      hasSecondaryAction: l,
      selected: u
    } = e;
    return pt({
      root: ["root", i && "dense", !o && "gutters", !a && "padding", c && "divider", s && "disabled", n && "button", t === "flex-start" && "alignItemsFlexStart", l && "secondaryAction", u && "selected"],
      container: ["container"]
    }, p2e, r)
  },
  D2e = me("div", {
    name: "MuiListItem",
    slot: "Root",
    overridesResolver: R2e
  })(({
    theme: e,
    ownerState: t
  }) => K({
    display: "flex",
    justifyContent: "flex-start",
    alignItems: "center",
    position: "relative",
    textDecoration: "none",
    width: "100%",
    boxSizing: "border-box",
    textAlign: "left"
  }, !t.disablePadding && K({
    paddingTop: 8,
    paddingBottom: 8
  }, t.dense && {
    paddingTop: 4,
    paddingBottom: 4
  }, !t.disableGutters && {
    paddingLeft: 16,
    paddingRight: 16
  }, !!t.secondaryAction && {
    paddingRight: 48
  }), !!t.secondaryAction && {
    [`& > .${C0.root}`]: {
      paddingRight: 48
    }
  }, {
    [`&.${S0.focusVisible}`]: {
      backgroundColor: (e.vars || e).palette.action.focus
    },
    [`&.${S0.selected}`]: {
      backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / ${e.vars.palette.action.selectedOpacity})` : lr(e.palette.primary.main, e.palette.action.selectedOpacity),
      [`&.${S0.focusVisible}`]: {
        backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / calc(${e.vars.palette.action.selectedOpacity} + ${e.vars.palette.action.focusOpacity}))` : lr(e.palette.primary.main, e.palette.action.selectedOpacity + e.palette.action.focusOpacity)
      }
    },
    [`&.${S0.disabled}`]: {
      opacity: (e.vars || e).palette.action.disabledOpacity
    }
  }, t.alignItems === "flex-start" && {
    alignItems: "flex-start"
  }, t.divider && {
    borderBottom: `1px solid ${(e.vars||e).palette.divider}`,
    backgroundClip: "padding-box"
  }, t.button && {
    transition: e.transitions.create("background-color", {
      duration: e.transitions.duration.shortest
    }),
    "&:hover": {
      textDecoration: "none",
      backgroundColor: (e.vars || e).palette.action.hover,
      "@media (hover: none)": {
        backgroundColor: "transparent"
      }
    },
    [`&.${S0.selected}:hover`]: {
      backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / calc(${e.vars.palette.action.selectedOpacity} + ${e.vars.palette.action.hoverOpacity}))` : lr(e.palette.primary.main, e.palette.action.selectedOpacity + e.palette.action.hoverOpacity),
      "@media (hover: none)": {
        backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / ${e.vars.palette.action.selectedOpacity})` : lr(e.palette.primary.main, e.palette.action.selectedOpacity)
      }
    }
  }, t.hasSecondaryAction && {
    paddingRight: 48
  })),
  N2e = me("li", {
    name: "MuiListItem",
    slot: "Container",
    overridesResolver: (e, t) => t.container
  })({
    position: "relative"
  }),
  M2e = j.forwardRef(function (t, n) {
    const r = xt({
        props: t,
        name: "MuiListItem"
      }),
      {
        alignItems: i = "center",
        autoFocus: s = !1,
        button: o = !1,
        children: a,
        className: c,
        component: l,
        components: u = {},
        componentsProps: f = {},
        ContainerComponent: h = "li",
        ContainerProps: {
          className: g
        } = {},
        dense: y = !1,
        disabled: x = !1,
        disableGutters: k = !1,
        disablePadding: _ = !1,
        divider: p = !1,
        focusVisibleClassName: v,
        secondaryAction: S,
        selected: I = !1,
        slotProps: A = {},
        slots: w = {}
      } = r,
      E = Ve(r.ContainerProps, I2e),
      D = Ve(r, P2e),
      $ = j.useContext(vc),
      V = j.useMemo(() => ({
        dense: y || $.dense || !1,
        alignItems: i,
        disableGutters: k
      }), [i, $.dense, y, k]),
      G = j.useRef(null);
    Os(() => {
      s && G.current && G.current.focus()
    }, [s]);
    const L = j.Children.toArray(a),
      b = L.length && g1(L[L.length - 1], ["ListItemSecondaryAction"]),
      T = K({}, r, {
        alignItems: i,
        autoFocus: s,
        button: o,
        dense: V.dense,
        disabled: x,
        disableGutters: k,
        disablePadding: _,
        divider: p,
        hasSecondaryAction: b,
        selected: I
      }),
      R = O2e(T),
      N = vr(G, n),
      O = w.root || u.Root || D2e,
      U = A.root || f.root || {},
      q = K({
        className: Ye(R.root, U.className, c),
        disabled: x
      }, D);
    let W = l || "li";
    return o && (q.component = l || "div", q.focusVisibleClassName = Ye(S0.focusVisible, v), W = gu), b ? (W = !q.component && !l ? "div" : W, h === "li" && (W === "li" ? W = "div" : q.component === "li" && (q.component = "div")), C.jsx(vc.Provider, {
      value: V,
      children: C.jsxs(N2e, K({
        as: h,
        className: Ye(R.container, g),
        ref: N,
        ownerState: T
      }, E, {
        children: [C.jsx(O, K({}, U, !_p(O) && {
          as: W,
          ownerState: K({}, T, U.ownerState)
        }, q, {
          children: L
        })), L.pop()]
      }))
    })) : C.jsx(vc.Provider, {
      value: V,
      children: C.jsxs(O, K({}, U, {
        as: W,
        ref: N
      }, !_p(O) && {
        ownerState: K({}, T, U.ownerState)
      }, q, {
        children: [L, S && C.jsx(_2e, {
          children: S
        })]
      }))
    })
  }),
  bH = M2e;

function $2e(e) {
  return mt("MuiListItemAvatar", e)
}
gt("MuiListItemAvatar", ["root", "alignItemsFlexStart"]);
const L2e = ["className"],
  B2e = e => {
    const {
      alignItems: t,
      classes: n
    } = e;
    return pt({
      root: ["root", t === "flex-start" && "alignItemsFlexStart"]
    }, $2e, n)
  },
  F2e = me("div", {
    name: "MuiListItemAvatar",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, n.alignItems === "flex-start" && t.alignItemsFlexStart]
    }
  })(({
    ownerState: e
  }) => K({
    minWidth: 56,
    flexShrink: 0
  }, e.alignItems === "flex-start" && {
    marginTop: 8
  })),
  j2e = j.forwardRef(function (t, n) {
    const r = xt({
        props: t,
        name: "MuiListItemAvatar"
      }),
      {
        className: i
      } = r,
      s = Ve(r, L2e),
      o = j.useContext(vc),
      a = K({}, r, {
        alignItems: o.alignItems
      }),
      c = B2e(a);
    return C.jsx(F2e, K({
      className: Ye(c.root, i),
      ownerState: a,
      ref: n
    }, s))
  }),
  ym = j2e,
  U2e = gt("MuiListItemIcon", ["root", "alignItemsFlexStart"]),
  XC = U2e;

function z2e(e) {
  return mt("MuiListItemText", e)
}
const H2e = gt("MuiListItemText", ["root", "multiline", "dense", "inset", "primary", "secondary"]),
  ru = H2e,
  V2e = ["children", "className", "disableTypography", "inset", "primary", "primaryTypographyProps", "secondary", "secondaryTypographyProps"],
  W2e = e => {
    const {
      classes: t,
      inset: n,
      primary: r,
      secondary: i,
      dense: s
    } = e;
    return pt({
      root: ["root", n && "inset", s && "dense", r && i && "multiline"],
      primary: ["primary"],
      secondary: ["secondary"]
    }, z2e, t)
  },
  q2e = me("div", {
    name: "MuiListItemText",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [{
        [`& .${ru.primary}`]: t.primary
      }, {
        [`& .${ru.secondary}`]: t.secondary
      }, t.root, n.inset && t.inset, n.primary && n.secondary && t.multiline, n.dense && t.dense]
    }
  })(({
    ownerState: e
  }) => K({
    flex: "1 1 auto",
    minWidth: 0,
    marginTop: 4,
    marginBottom: 4
  }, e.primary && e.secondary && {
    marginTop: 6,
    marginBottom: 6
  }, e.inset && {
    paddingLeft: 56
  })),
  G2e = j.forwardRef(function (t, n) {
    const r = xt({
        props: t,
        name: "MuiListItemText"
      }),
      {
        children: i,
        className: s,
        disableTypography: o = !1,
        inset: a = !1,
        primary: c,
        primaryTypographyProps: l,
        secondary: u,
        secondaryTypographyProps: f
      } = r,
      h = Ve(r, V2e),
      {
        dense: g
      } = j.useContext(vc);
    let y = c ?? i,
      x = u;
    const k = K({}, r, {
        disableTypography: o,
        inset: a,
        primary: !!y,
        secondary: !!x,
        dense: g
      }),
      _ = W2e(k);
    return y != null && y.type !== Ue && !o && (y = C.jsx(Ue, K({
      variant: g ? "body2" : "body1",
      className: _.primary,
      component: l != null && l.variant ? void 0 : "span",
      display: "block"
    }, l, {
      children: y
    }))), x != null && x.type !== Ue && !o && (x = C.jsx(Ue, K({
      variant: "body2",
      className: _.secondary,
      color: "text.secondary",
      display: "block"
    }, f, {
      children: x
    }))), C.jsxs(q2e, K({
      className: Ye(_.root, s),
      ownerState: k,
      ref: n
    }, h, {
      children: [y, x]
    }))
  }),
  Q2 = G2e,
  K2e = ["actions", "autoFocus", "autoFocusItem", "children", "className", "disabledItemsFocusable", "disableListWrap", "onKeyDown", "variant"];

function pS(e, t, n) {
  return e === t ? e.firstChild : t && t.nextElementSibling ? t.nextElementSibling : n ? null : e.firstChild
}

function JD(e, t, n) {
  return e === t ? n ? e.firstChild : e.lastChild : t && t.previousElementSibling ? t.previousElementSibling : n ? null : e.lastChild
}

function wH(e, t) {
  if (t === void 0) return !0;
  let n = e.innerText;
  return n === void 0 && (n = e.textContent), n = n.trim().toLowerCase(), n.length === 0 ? !1 : t.repeating ? n[0] === t.keys[0] : n.indexOf(t.keys.join("")) === 0
}

function Ag(e, t, n, r, i, s) {
  let o = !1,
    a = i(e, t, t ? n : !1);
  for (; a;) {
    if (a === e.firstChild) {
      if (o) return !1;
      o = !0
    }
    const c = r ? !1 : a.disabled || a.getAttribute("aria-disabled") === "true";
    if (!a.hasAttribute("tabindex") || !wH(a, s) || c) a = i(e, a, n);
    else return a.focus(), !0
  }
  return !1
}
const Q2e = j.forwardRef(function (t, n) {
    const {
      actions: r,
      autoFocus: i = !1,
      autoFocusItem: s = !1,
      children: o,
      className: a,
      disabledItemsFocusable: c = !1,
      disableListWrap: l = !1,
      onKeyDown: u,
      variant: f = "selectedMenu"
    } = t, h = Ve(t, K2e), g = j.useRef(null), y = j.useRef({
      keys: [],
      repeating: !0,
      previousKeyMatched: !0,
      lastTime: null
    });
    Os(() => {
      i && g.current.focus()
    }, [i]), j.useImperativeHandle(r, () => ({
      adjustStyleForScrollbar: (v, {
        direction: S
      }) => {
        const I = !g.current.style.width;
        if (v.clientHeight < g.current.clientHeight && I) {
          const A = `${OU(ji(v))}px`;
          g.current.style[S === "rtl" ? "paddingLeft" : "paddingRight"] = A, g.current.style.width = `calc(100% + ${A})`
        }
        return g.current
      }
    }), []);
    const x = v => {
        const S = g.current,
          I = v.key,
          A = ji(S).activeElement;
        if (I === "ArrowDown") v.preventDefault(), Ag(S, A, l, c, pS);
        else if (I === "ArrowUp") v.preventDefault(), Ag(S, A, l, c, JD);
        else if (I === "Home") v.preventDefault(), Ag(S, null, l, c, pS);
        else if (I === "End") v.preventDefault(), Ag(S, null, l, c, JD);
        else if (I.length === 1) {
          const w = y.current,
            E = I.toLowerCase(),
            D = performance.now();
          w.keys.length > 0 && (D - w.lastTime > 500 ? (w.keys = [], w.repeating = !0, w.previousKeyMatched = !0) : w.repeating && E !== w.keys[0] && (w.repeating = !1)), w.lastTime = D, w.keys.push(E);
          const $ = A && !w.repeating && wH(A, w);
          w.previousKeyMatched && ($ || Ag(S, A, !1, c, pS, w)) ? v.preventDefault() : w.previousKeyMatched = !1
        }
        u && u(v)
      },
      k = vr(g, n);
    let _ = -1;
    j.Children.forEach(o, (v, S) => {
      if (!j.isValidElement(v)) {
        _ === S && (_ += 1, _ >= o.length && (_ = -1));
        return
      }
      v.props.disabled || (f === "selectedMenu" && v.props.selected || _ === -1) && (_ = S), _ === S && (v.props.disabled || v.props.muiSkipListHighlight || v.type.muiSkipListHighlight) && (_ += 1, _ >= o.length && (_ = -1))
    });
    const p = j.Children.map(o, (v, S) => {
      if (S === _) {
        const I = {};
        return s && (I.autoFocus = !0), v.props.tabIndex === void 0 && f === "selectedMenu" && (I.tabIndex = 0), j.cloneElement(v, I)
      }
      return v
    });
    return C.jsx(sh, K({
      role: "menu",
      ref: k,
      className: a,
      onKeyDown: x,
      tabIndex: i ? 0 : -1
    }, h, {
      children: p
    }))
  }),
  Y2e = Q2e;

function J2e(e) {
  return mt("MuiPopover", e)
}
gt("MuiPopover", ["root", "paper"]);
const X2e = ["onEntering"],
  Z2e = ["action", "anchorEl", "anchorOrigin", "anchorPosition", "anchorReference", "children", "className", "container", "elevation", "marginThreshold", "open", "PaperProps", "slots", "slotProps", "transformOrigin", "TransitionComponent", "transitionDuration", "TransitionProps", "disableScrollLock"],
  eye = ["slotProps"];

function XD(e, t) {
  let n = 0;
  return typeof t == "number" ? n = t : t === "center" ? n = e.height / 2 : t === "bottom" && (n = e.height), n
}

function ZD(e, t) {
  let n = 0;
  return typeof t == "number" ? n = t : t === "center" ? n = e.width / 2 : t === "right" && (n = e.width), n
}

function eN(e) {
  return [e.horizontal, e.vertical].map(t => typeof t == "number" ? `${t}px` : t).join(" ")
}

function mS(e) {
  return typeof e == "function" ? e() : e
}
const tye = e => {
    const {
      classes: t
    } = e;
    return pt({
      root: ["root"],
      paper: ["paper"]
    }, J2e, t)
  },
  nye = me(QT, {
    name: "MuiPopover",
    slot: "Root",
    overridesResolver: (e, t) => t.root
  })({}),
  xH = me(z2, {
    name: "MuiPopover",
    slot: "Paper",
    overridesResolver: (e, t) => t.paper
  })({
    position: "absolute",
    overflowY: "auto",
    overflowX: "hidden",
    minWidth: 16,
    minHeight: 16,
    maxWidth: "calc(100% - 32px)",
    maxHeight: "calc(100% - 32px)",
    outline: 0
  }),
  rye = j.forwardRef(function (t, n) {
    var r, i, s;
    const o = xt({
        props: t,
        name: "MuiPopover"
      }),
      {
        action: a,
        anchorEl: c,
        anchorOrigin: l = {
          vertical: "top",
          horizontal: "left"
        },
        anchorPosition: u,
        anchorReference: f = "anchorEl",
        children: h,
        className: g,
        container: y,
        elevation: x = 8,
        marginThreshold: k = 16,
        open: _,
        PaperProps: p = {},
        slots: v,
        slotProps: S,
        transformOrigin: I = {
          vertical: "top",
          horizontal: "left"
        },
        TransitionComponent: A = t2,
        transitionDuration: w = "auto",
        TransitionProps: {
          onEntering: E
        } = {},
        disableScrollLock: D = !1
      } = o,
      $ = Ve(o.TransitionProps, X2e),
      V = Ve(o, Z2e),
      G = (r = S == null ? void 0 : S.paper) != null ? r : p,
      L = j.useRef(),
      b = vr(L, G.ref),
      T = K({}, o, {
        anchorOrigin: l,
        anchorReference: f,
        elevation: x,
        marginThreshold: k,
        externalPaperSlotProps: G,
        transformOrigin: I,
        TransitionComponent: A,
        transitionDuration: w,
        TransitionProps: $
      }),
      R = tye(T),
      N = j.useCallback(() => {
        if (f === "anchorPosition") return u;
        const ce = mS(c),
          ge = (ce && ce.nodeType === 1 ? ce : ji(L.current).body).getBoundingClientRect();
        return {
          top: ge.top + XD(ge, l.vertical),
          left: ge.left + ZD(ge, l.horizontal)
        }
      }, [c, l.horizontal, l.vertical, u, f]),
      O = j.useCallback(ce => ({
        vertical: XD(ce, I.vertical),
        horizontal: ZD(ce, I.horizontal)
      }), [I.horizontal, I.vertical]),
      U = j.useCallback(ce => {
        const ue = {
            width: ce.offsetWidth,
            height: ce.offsetHeight
          },
          ge = O(ue);
        if (f === "none") return {
          top: null,
          left: null,
          transformOrigin: eN(ge)
        };
        const et = N();
        let He = et.top - ge.vertical,
          se = et.left - ge.horizontal;
        const pe = He + ue.height,
          de = se + ue.width,
          we = _a(mS(c)),
          Ce = we.innerHeight - k,
          be = we.innerWidth - k;
        if (k !== null && He < k) {
          const Se = He - k;
          He -= Se, ge.vertical += Se
        } else if (k !== null && pe > Ce) {
          const Se = pe - Ce;
          He -= Se, ge.vertical += Se
        }
        if (k !== null && se < k) {
          const Se = se - k;
          se -= Se, ge.horizontal += Se
        } else if (de > be) {
          const Se = de - be;
          se -= Se, ge.horizontal += Se
        }
        return {
          top: `${Math.round(He)}px`,
          left: `${Math.round(se)}px`,
          transformOrigin: eN(ge)
        }
      }, [c, f, N, O, k]),
      [q, W] = j.useState(_),
      M = j.useCallback(() => {
        const ce = L.current;
        if (!ce) return;
        const ue = U(ce);
        ue.top !== null && (ce.style.top = ue.top), ue.left !== null && (ce.style.left = ue.left), ce.style.transformOrigin = ue.transformOrigin, W(!0)
      }, [U]);
    j.useEffect(() => (D && window.addEventListener("scroll", M), () => window.removeEventListener("scroll", M)), [c, D, M]);
    const Q = (ce, ue) => {
        E && E(ce, ue), M()
      },
      he = () => {
        W(!1)
      };
    j.useEffect(() => {
      _ && M()
    }), j.useImperativeHandle(a, () => _ ? {
      updatePosition: () => {
        M()
      }
    } : null, [_, M]), j.useEffect(() => {
      if (!_) return;
      const ce = um(() => {
          M()
        }),
        ue = _a(c);
      return ue.addEventListener("resize", ce), () => {
        ce.clear(), ue.removeEventListener("resize", ce)
      }
    }, [c, _, M]);
    let H = w;
    w === "auto" && !A.muiSupportAuto && (H = void 0);
    const ne = y || (c ? ji(mS(c)).body : void 0),
      X = (i = v == null ? void 0 : v.root) != null ? i : nye,
      Z = (s = v == null ? void 0 : v.paper) != null ? s : xH,
      te = zo({
        elementType: Z,
        externalSlotProps: K({}, G, {
          style: q ? G.style : K({}, G.style, {
            opacity: 0
          })
        }),
        additionalProps: {
          elevation: x,
          ref: b
        },
        ownerState: T,
        className: Ye(R.paper, G == null ? void 0 : G.className)
      }),
      F = zo({
        elementType: X,
        externalSlotProps: (S == null ? void 0 : S.root) || {},
        externalForwardedProps: V,
        additionalProps: {
          ref: n,
          slotProps: {
            backdrop: {
              invisible: !0
            }
          },
          container: ne,
          open: _
        },
        ownerState: T,
        className: Ye(R.root, g)
      }),
      {
        slotProps: J
      } = F,
      ie = Ve(F, eye);
    return C.jsx(X, K({}, ie, !_p(X) && {
      slotProps: J,
      disableScrollLock: D
    }, {
      children: C.jsx(A, K({
        appear: !0,
        in: _,
        onEntering: Q,
        onExited: he,
        timeout: H
      }, $, {
        children: C.jsx(Z, K({}, te, {
          children: h
        }))
      }))
    }))
  }),
  iye = rye;

function sye(e) {
  return mt("MuiMenu", e)
}
const oye = gt("MuiMenu", ["root", "paper", "list"]),
  tN = oye,
  aye = ["onEntering"],
  cye = ["autoFocus", "children", "className", "disableAutoFocusItem", "MenuListProps", "onClose", "open", "PaperProps", "PopoverClasses", "transitionDuration", "TransitionProps", "variant", "slots", "slotProps"],
  lye = {
    vertical: "top",
    horizontal: "right"
  },
  uye = {
    vertical: "top",
    horizontal: "left"
  },
  dye = e => {
    const {
      classes: t
    } = e;
    return pt({
      root: ["root"],
      paper: ["paper"],
      list: ["list"]
    }, sye, t)
  },
  fye = me(iye, {
    shouldForwardProp: e => $s(e) || e === "classes",
    name: "MuiMenu",
    slot: "Root",
    overridesResolver: (e, t) => t.root
  })({}),
  hye = me(xH, {
    name: "MuiMenu",
    slot: "Paper",
    overridesResolver: (e, t) => t.paper
  })({
    maxHeight: "calc(100% - 96px)",
    WebkitOverflowScrolling: "touch"
  }),
  pye = me(Y2e, {
    name: "MuiMenu",
    slot: "List",
    overridesResolver: (e, t) => t.list
  })({
    outline: 0
  }),
  mye = j.forwardRef(function (t, n) {
    var r, i;
    const s = xt({
        props: t,
        name: "MuiMenu"
      }),
      {
        autoFocus: o = !0,
        children: a,
        className: c,
        disableAutoFocusItem: l = !1,
        MenuListProps: u = {},
        onClose: f,
        open: h,
        PaperProps: g = {},
        PopoverClasses: y,
        transitionDuration: x = "auto",
        TransitionProps: {
          onEntering: k
        } = {},
        variant: _ = "selectedMenu",
        slots: p = {},
        slotProps: v = {}
      } = s,
      S = Ve(s.TransitionProps, aye),
      I = Ve(s, cye),
      A = U2(),
      w = K({}, s, {
        autoFocus: o,
        disableAutoFocusItem: l,
        MenuListProps: u,
        onEntering: k,
        PaperProps: g,
        transitionDuration: x,
        TransitionProps: S,
        variant: _
      }),
      E = dye(w),
      D = o && !l && h,
      $ = j.useRef(null),
      V = (O, U) => {
        $.current && $.current.adjustStyleForScrollbar(O, {
          direction: A ? "rtl" : "ltr"
        }), k && k(O, U)
      },
      G = O => {
        O.key === "Tab" && (O.preventDefault(), f && f(O, "tabKeyDown"))
      };
    let L = -1;
    j.Children.map(a, (O, U) => {
      j.isValidElement(O) && (O.props.disabled || (_ === "selectedMenu" && O.props.selected || L === -1) && (L = U))
    });
    const b = (r = p.paper) != null ? r : hye,
      T = (i = v.paper) != null ? i : g,
      R = zo({
        elementType: p.root,
        externalSlotProps: v.root,
        ownerState: w,
        className: [E.root, c]
      }),
      N = zo({
        elementType: b,
        externalSlotProps: T,
        ownerState: w,
        className: E.paper
      });
    return C.jsx(fye, K({
      onClose: f,
      anchorOrigin: {
        vertical: "bottom",
        horizontal: A ? "right" : "left"
      },
      transformOrigin: A ? lye : uye,
      slots: {
        paper: b,
        root: p.root
      },
      slotProps: {
        root: R,
        paper: N
      },
      open: h,
      ref: n,
      transitionDuration: x,
      TransitionProps: K({
        onEntering: V
      }, S),
      ownerState: w
    }, I, {
      classes: y,
      children: C.jsx(pye, K({
        onKeyDown: G,
        actions: $,
        autoFocus: o && (L === -1 || l),
        autoFocusItem: D,
        variant: _
      }, u, {
        className: Ye(E.list, u.className),
        children: a
      }))
    }))
  }),
  EH = mye;

function gye(e) {
  return mt("MuiMenuItem", e)
}
const yye = gt("MuiMenuItem", ["root", "focusVisible", "dense", "disabled", "divider", "gutters", "selected"]),
  A0 = yye,
  vye = ["autoFocus", "component", "dense", "divider", "disableGutters", "focusVisibleClassName", "role", "tabIndex", "className"],
  bye = (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.dense && t.dense, n.divider && t.divider, !n.disableGutters && t.gutters]
  },
  wye = e => {
    const {
      disabled: t,
      dense: n,
      divider: r,
      disableGutters: i,
      selected: s,
      classes: o
    } = e, c = pt({
      root: ["root", n && "dense", t && "disabled", !i && "gutters", r && "divider", s && "selected"]
    }, gye, o);
    return K({}, o, c)
  },
  xye = me(gu, {
    shouldForwardProp: e => $s(e) || e === "classes",
    name: "MuiMenuItem",
    slot: "Root",
    overridesResolver: bye
  })(({
    theme: e,
    ownerState: t
  }) => K({}, e.typography.body1, {
    display: "flex",
    justifyContent: "flex-start",
    alignItems: "center",
    position: "relative",
    textDecoration: "none",
    minHeight: 48,
    paddingTop: 6,
    paddingBottom: 6,
    boxSizing: "border-box",
    whiteSpace: "nowrap"
  }, !t.disableGutters && {
    paddingLeft: 16,
    paddingRight: 16
  }, t.divider && {
    borderBottom: `1px solid ${(e.vars||e).palette.divider}`,
    backgroundClip: "padding-box"
  }, {
    "&:hover": {
      textDecoration: "none",
      backgroundColor: (e.vars || e).palette.action.hover,
      "@media (hover: none)": {
        backgroundColor: "transparent"
      }
    },
    [`&.${A0.selected}`]: {
      backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / ${e.vars.palette.action.selectedOpacity})` : lr(e.palette.primary.main, e.palette.action.selectedOpacity),
      [`&.${A0.focusVisible}`]: {
        backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / calc(${e.vars.palette.action.selectedOpacity} + ${e.vars.palette.action.focusOpacity}))` : lr(e.palette.primary.main, e.palette.action.selectedOpacity + e.palette.action.focusOpacity)
      }
    },
    [`&.${A0.selected}:hover`]: {
      backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / calc(${e.vars.palette.action.selectedOpacity} + ${e.vars.palette.action.hoverOpacity}))` : lr(e.palette.primary.main, e.palette.action.selectedOpacity + e.palette.action.hoverOpacity),
      "@media (hover: none)": {
        backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / ${e.vars.palette.action.selectedOpacity})` : lr(e.palette.primary.main, e.palette.action.selectedOpacity)
      }
    },
    [`&.${A0.focusVisible}`]: {
      backgroundColor: (e.vars || e).palette.action.focus
    },
    [`&.${A0.disabled}`]: {
      opacity: (e.vars || e).palette.action.disabledOpacity
    },
    [`& + .${WD.root}`]: {
      marginTop: e.spacing(1),
      marginBottom: e.spacing(1)
    },
    [`& + .${WD.inset}`]: {
      marginLeft: 52
    },
    [`& .${ru.root}`]: {
      marginTop: 0,
      marginBottom: 0
    },
    [`& .${ru.inset}`]: {
      paddingLeft: 36
    },
    [`& .${XC.root}`]: {
      minWidth: 36
    }
  }, !t.dense && {
    [e.breakpoints.up("sm")]: {
      minHeight: "auto"
    }
  }, t.dense && K({
    minHeight: 32,
    paddingTop: 4,
    paddingBottom: 4
  }, e.typography.body2, {
    [`& .${XC.root} svg`]: {
      fontSize: "1.25rem"
    }
  }))),
  Eye = j.forwardRef(function (t, n) {
    const r = xt({
        props: t,
        name: "MuiMenuItem"
      }),
      {
        autoFocus: i = !1,
        component: s = "li",
        dense: o = !1,
        divider: a = !1,
        disableGutters: c = !1,
        focusVisibleClassName: l,
        role: u = "menuitem",
        tabIndex: f,
        className: h
      } = r,
      g = Ve(r, vye),
      y = j.useContext(vc),
      x = j.useMemo(() => ({
        dense: o || y.dense || !1,
        disableGutters: c
      }), [y.dense, o, c]),
      k = j.useRef(null);
    Os(() => {
      i && k.current && k.current.focus()
    }, [i]);
    const _ = K({}, r, {
        dense: x.dense,
        divider: a,
        disableGutters: c
      }),
      p = wye(r),
      v = vr(k, n);
    let S;
    return r.disabled || (S = f !== void 0 ? f : -1), C.jsx(vc.Provider, {
      value: x,
      children: C.jsx(xye, K({
        ref: v,
        role: u,
        tabIndex: S,
        component: s,
        focusVisibleClassName: Ye(p.focusVisible, l),
        className: Ye(p.root, h)
      }, g, {
        ownerState: _,
        classes: p
      }))
    })
  }),
  Vf = Eye;

function Sye(e) {
  return mt("MuiNativeSelect", e)
}
const Cye = gt("MuiNativeSelect", ["root", "select", "multiple", "filled", "outlined", "standard", "disabled", "icon", "iconOpen", "iconFilled", "iconOutlined", "iconStandard", "nativeInput", "error"]),
  JT = Cye,
  Aye = ["className", "disabled", "error", "IconComponent", "inputRef", "variant"],
  Tye = e => {
    const {
      classes: t,
      variant: n,
      disabled: r,
      multiple: i,
      open: s,
      error: o
    } = e, a = {
      select: ["select", n, r && "disabled", i && "multiple", o && "error"],
      icon: ["icon", `icon${qe(n)}`, s && "iconOpen", r && "disabled"]
    };
    return pt(a, Sye, t)
  },
  SH = ({
    ownerState: e,
    theme: t
  }) => K({
    MozAppearance: "none",
    WebkitAppearance: "none",
    userSelect: "none",
    borderRadius: 0,
    cursor: "pointer",
    "&:focus": K({}, t.vars ? {
      backgroundColor: `rgba(${t.vars.palette.common.onBackgroundChannel} / 0.05)`
    } : {
      backgroundColor: t.palette.mode === "light" ? "rgba(0, 0, 0, 0.05)" : "rgba(255, 255, 255, 0.05)"
    }, {
      borderRadius: 0
    }),
    "&::-ms-expand": {
      display: "none"
    },
    [`&.${JT.disabled}`]: {
      cursor: "default"
    },
    "&[multiple]": {
      height: "auto"
    },
    "&:not([multiple]) option, &:not([multiple]) optgroup": {
      backgroundColor: (t.vars || t).palette.background.paper
    },
    "&&&": {
      paddingRight: 24,
      minWidth: 16
    }
  }, e.variant === "filled" && {
    "&&&": {
      paddingRight: 32
    }
  }, e.variant === "outlined" && {
    borderRadius: (t.vars || t).shape.borderRadius,
    "&:focus": {
      borderRadius: (t.vars || t).shape.borderRadius
    },
    "&&&": {
      paddingRight: 32
    }
  }),
  kye = me("select", {
    name: "MuiNativeSelect",
    slot: "Select",
    shouldForwardProp: $s,
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.select, t[n.variant], n.error && t.error, {
        [`&.${JT.multiple}`]: t.multiple
      }]
    }
  })(SH),
  CH = ({
    ownerState: e,
    theme: t
  }) => K({
    position: "absolute",
    right: 0,
    top: "calc(50% - .5em)",
    pointerEvents: "none",
    color: (t.vars || t).palette.action.active,
    [`&.${JT.disabled}`]: {
      color: (t.vars || t).palette.action.disabled
    }
  }, e.open && {
    transform: "rotate(180deg)"
  }, e.variant === "filled" && {
    right: 7
  }, e.variant === "outlined" && {
    right: 7
  }),
  _ye = me("svg", {
    name: "MuiNativeSelect",
    slot: "Icon",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.icon, n.variant && t[`icon${qe(n.variant)}`], n.open && t.iconOpen]
    }
  })(CH),
  Iye = j.forwardRef(function (t, n) {
    const {
      className: r,
      disabled: i,
      error: s,
      IconComponent: o,
      inputRef: a,
      variant: c = "standard"
    } = t, l = Ve(t, Aye), u = K({}, t, {
      disabled: i,
      variant: c,
      error: s
    }), f = Tye(u);
    return C.jsxs(j.Fragment, {
      children: [C.jsx(kye, K({
        ownerState: u,
        className: Ye(f.select, r),
        disabled: i,
        ref: a || n
      }, l)), t.multiple ? null : C.jsx(_ye, {
        as: o,
        ownerState: u,
        className: f.icon
      })]
    })
  }),
  Pye = Iye;
var nN;
const Rye = ["children", "classes", "className", "label", "notched"],
  Oye = me("fieldset", {
    shouldForwardProp: $s
  })({
    textAlign: "left",
    position: "absolute",
    bottom: 0,
    right: 0,
    top: -5,
    left: 0,
    margin: 0,
    padding: "0 8px",
    pointerEvents: "none",
    borderRadius: "inherit",
    borderStyle: "solid",
    borderWidth: 1,
    overflow: "hidden",
    minWidth: "0%"
  }),
  Dye = me("legend", {
    shouldForwardProp: $s
  })(({
    ownerState: e,
    theme: t
  }) => K({
    float: "unset",
    width: "auto",
    overflow: "hidden"
  }, !e.withLabel && {
    padding: 0,
    lineHeight: "11px",
    transition: t.transitions.create("width", {
      duration: 150,
      easing: t.transitions.easing.easeOut
    })
  }, e.withLabel && K({
    display: "block",
    padding: 0,
    height: 11,
    fontSize: "0.75em",
    visibility: "hidden",
    maxWidth: .01,
    transition: t.transitions.create("max-width", {
      duration: 50,
      easing: t.transitions.easing.easeOut
    }),
    whiteSpace: "nowrap",
    "& > span": {
      paddingLeft: 5,
      paddingRight: 5,
      display: "inline-block",
      opacity: 0,
      visibility: "visible"
    }
  }, e.notched && {
    maxWidth: "100%",
    transition: t.transitions.create("max-width", {
      duration: 100,
      easing: t.transitions.easing.easeOut,
      delay: 50
    })
  })));

function Nye(e) {
  const {
    className: t,
    label: n,
    notched: r
  } = e, i = Ve(e, Rye), s = n != null && n !== "", o = K({}, e, {
    notched: r,
    withLabel: s
  });
  return C.jsx(Oye, K({
    "aria-hidden": !0,
    className: t,
    ownerState: o
  }, i, {
    children: C.jsx(Dye, {
      ownerState: o,
      children: s ? C.jsx("span", {
        children: n
      }) : nN || (nN = C.jsx("span", {
        className: "notranslate",
        children: "​"
      }))
    })
  }))
}
const Mye = ["components", "fullWidth", "inputComponent", "label", "multiline", "notched", "slots", "type"],
  $ye = e => {
    const {
      classes: t
    } = e, r = pt({
      root: ["root"],
      notchedOutline: ["notchedOutline"],
      input: ["input"]
    }, Bpe, t);
    return K({}, t, r)
  },
  Lye = me(P5, {
    shouldForwardProp: e => $s(e) || e === "classes",
    name: "MuiOutlinedInput",
    slot: "Root",
    overridesResolver: _5
  })(({
    theme: e,
    ownerState: t
  }) => {
    const n = e.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)";
    return K({
      position: "relative",
      borderRadius: (e.vars || e).shape.borderRadius,
      [`&:hover .${Hl.notchedOutline}`]: {
        borderColor: (e.vars || e).palette.text.primary
      },
      "@media (hover: none)": {
        [`&:hover .${Hl.notchedOutline}`]: {
          borderColor: e.vars ? `rgba(${e.vars.palette.common.onBackgroundChannel} / 0.23)` : n
        }
      },
      [`&.${Hl.focused} .${Hl.notchedOutline}`]: {
        borderColor: (e.vars || e).palette[t.color].main,
        borderWidth: 2
      },
      [`&.${Hl.error} .${Hl.notchedOutline}`]: {
        borderColor: (e.vars || e).palette.error.main
      },
      [`&.${Hl.disabled} .${Hl.notchedOutline}`]: {
        borderColor: (e.vars || e).palette.action.disabled
      }
    }, t.startAdornment && {
      paddingLeft: 14
    }, t.endAdornment && {
      paddingRight: 14
    }, t.multiline && K({
      padding: "16.5px 14px"
    }, t.size === "small" && {
      padding: "8.5px 14px"
    }))
  }),
  Bye = me(Nye, {
    name: "MuiOutlinedInput",
    slot: "NotchedOutline",
    overridesResolver: (e, t) => t.notchedOutline
  })(({
    theme: e
  }) => {
    const t = e.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)";
    return {
      borderColor: e.vars ? `rgba(${e.vars.palette.common.onBackgroundChannel} / 0.23)` : t
    }
  }),
  Fye = me(R5, {
    name: "MuiOutlinedInput",
    slot: "Input",
    overridesResolver: I5
  })(({
    theme: e,
    ownerState: t
  }) => K({
    padding: "16.5px 14px"
  }, !e.vars && {
    "&:-webkit-autofill": {
      WebkitBoxShadow: e.palette.mode === "light" ? null : "0 0 0 100px #266798 inset",
      WebkitTextFillColor: e.palette.mode === "light" ? null : "#fff",
      caretColor: e.palette.mode === "light" ? null : "#fff",
      borderRadius: "inherit"
    }
  }, e.vars && {
    "&:-webkit-autofill": {
      borderRadius: "inherit"
    },
    [e.getColorSchemeSelector("dark")]: {
      "&:-webkit-autofill": {
        WebkitBoxShadow: "0 0 0 100px #266798 inset",
        WebkitTextFillColor: "#fff",
        caretColor: "#fff"
      }
    }
  }, t.size === "small" && {
    padding: "8.5px 14px"
  }, t.multiline && {
    padding: 0
  }, t.startAdornment && {
    paddingLeft: 0
  }, t.endAdornment && {
    paddingRight: 0
  })),
  AH = j.forwardRef(function (t, n) {
    var r, i, s, o, a;
    const c = xt({
        props: t,
        name: "MuiOutlinedInput"
      }),
      {
        components: l = {},
        fullWidth: u = !1,
        inputComponent: f = "input",
        label: h,
        multiline: g = !1,
        notched: y,
        slots: x = {},
        type: k = "text"
      } = c,
      _ = Ve(c, Mye),
      p = $ye(c),
      v = mm(),
      S = T5({
        props: c,
        muiFormControl: v,
        states: ["color", "disabled", "error", "focused", "hiddenLabel", "size", "required"]
      }),
      I = K({}, c, {
        color: S.color || "primary",
        disabled: S.disabled,
        error: S.error,
        focused: S.focused,
        formControl: v,
        fullWidth: u,
        hiddenLabel: S.hiddenLabel,
        multiline: g,
        size: S.size,
        type: k
      }),
      A = (r = (i = x.root) != null ? i : l.Root) != null ? r : Lye,
      w = (s = (o = x.input) != null ? o : l.Input) != null ? s : Fye;
    return C.jsx(gm, K({
      slots: {
        root: A,
        input: w
      },
      renderSuffix: E => C.jsx(Bye, {
        ownerState: I,
        className: p.notchedOutline,
        label: h != null && h !== "" && S.required ? a || (a = C.jsxs(j.Fragment, {
          children: [h, " ", "*"]
        })) : h,
        notched: typeof y < "u" ? y : !!(E.startAdornment || E.filled || E.focused)
      }),
      fullWidth: u,
      inputComponent: f,
      multiline: g,
      ref: n,
      type: k
    }, _, {
      classes: K({}, p, {
        notchedOutline: null
      })
    }))
  });
AH.muiName = "Input";
const jye = AH;

function Uye(e) {
  return mt("MuiScopedCssBaseline", e)
}
gt("MuiScopedCssBaseline", ["root"]);
const zye = ["className", "component", "enableColorScheme"],
  Hye = e => {
    const {
      classes: t
    } = e;
    return pt({
      root: ["root"]
    }, Uye, t)
  },
  Vye = me("div", {
    name: "MuiScopedCssBaseline",
    slot: "Root",
    overridesResolver: (e, t) => t.root
  })(({
    theme: e,
    ownerState: t
  }) => {
    const n = {};
    return t.enableColorScheme && e.colorSchemes && Object.entries(e.colorSchemes).forEach(([r, i]) => {
      var s;
      n[`&${e.getColorSchemeSelector(r).replace(/\s*&/,"")}`] = {
        colorScheme: (s = i.palette) == null ? void 0 : s.mode
      }
    }), K({}, hge(e, t.enableColorScheme), pge(e), {
      "& *, & *::before, & *::after": {
        boxSizing: "inherit"
      },
      "& strong, & b": {
        fontWeight: e.typography.fontWeightBold
      }
    }, n)
  }),
  Wye = j.forwardRef(function (t, n) {
    const r = xt({
        props: t,
        name: "MuiScopedCssBaseline"
      }),
      {
        className: i,
        component: s = "div"
      } = r,
      o = Ve(r, zye),
      a = K({}, r, {
        component: s
      }),
      c = Hye(a);
    return C.jsx(Vye, K({
      as: s,
      className: Ye(c.root, i),
      ref: n,
      ownerState: a
    }, o))
  }),
  TH = Wye;

function qye(e) {
  return mt("MuiSelect", e)
}
const Gye = gt("MuiSelect", ["root", "select", "multiple", "filled", "outlined", "standard", "disabled", "focused", "icon", "iconOpen", "iconFilled", "iconOutlined", "iconStandard", "nativeInput", "error"]),
  T0 = Gye;
var rN;
const Kye = ["aria-describedby", "aria-label", "autoFocus", "autoWidth", "children", "className", "defaultOpen", "defaultValue", "disabled", "displayEmpty", "error", "IconComponent", "inputRef", "labelId", "MenuProps", "multiple", "name", "onBlur", "onChange", "onClose", "onFocus", "onOpen", "open", "readOnly", "renderValue", "SelectDisplayProps", "tabIndex", "type", "value", "variant"],
  Qye = me("div", {
    name: "MuiSelect",
    slot: "Select",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [{
        [`&.${T0.select}`]: t.select
      }, {
        [`&.${T0.select}`]: t[n.variant]
      }, {
        [`&.${T0.error}`]: t.error
      }, {
        [`&.${T0.multiple}`]: t.multiple
      }]
    }
  })(SH, {
    [`&.${T0.select}`]: {
      height: "auto",
      minHeight: "1.4375em",
      textOverflow: "ellipsis",
      whiteSpace: "nowrap",
      overflow: "hidden"
    }
  }),
  Yye = me("svg", {
    name: "MuiSelect",
    slot: "Icon",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.icon, n.variant && t[`icon${qe(n.variant)}`], n.open && t.iconOpen]
    }
  })(CH),
  Jye = me("input", {
    shouldForwardProp: e => Cz(e) && e !== "classes",
    name: "MuiSelect",
    slot: "NativeInput",
    overridesResolver: (e, t) => t.nativeInput
  })({
    bottom: 0,
    left: 0,
    position: "absolute",
    opacity: 0,
    pointerEvents: "none",
    width: "100%",
    boxSizing: "border-box"
  });

function iN(e, t) {
  return typeof t == "object" && t !== null ? e === t : String(e) === String(t)
}

function Xye(e) {
  return e == null || typeof e == "string" && !e.trim()
}
const Zye = e => {
    const {
      classes: t,
      variant: n,
      disabled: r,
      multiple: i,
      open: s,
      error: o
    } = e, a = {
      select: ["select", n, r && "disabled", i && "multiple", o && "error"],
      icon: ["icon", `icon${qe(n)}`, s && "iconOpen", r && "disabled"],
      nativeInput: ["nativeInput"]
    };
    return pt(a, qye, t)
  },
  eve = j.forwardRef(function (t, n) {
    var r;
    const {
      "aria-describedby": i,
      "aria-label": s,
      autoFocus: o,
      autoWidth: a,
      children: c,
      className: l,
      defaultOpen: u,
      defaultValue: f,
      disabled: h,
      displayEmpty: g,
      error: y = !1,
      IconComponent: x,
      inputRef: k,
      labelId: _,
      MenuProps: p = {},
      multiple: v,
      name: S,
      onBlur: I,
      onChange: A,
      onClose: w,
      onFocus: E,
      onOpen: D,
      open: $,
      readOnly: V,
      renderValue: G,
      SelectDisplayProps: L = {},
      tabIndex: b,
      value: T,
      variant: R = "standard"
    } = t, N = Ve(t, Kye), [O, U] = K1({
      controlled: T,
      default: f,
      name: "Select"
    }), [q, W] = K1({
      controlled: $,
      default: u,
      name: "Select"
    }), M = j.useRef(null), Q = j.useRef(null), [he, H] = j.useState(null), {
      current: ne
    } = j.useRef($ != null), [X, Z] = j.useState(), te = vr(n, k), F = j.useCallback(_e => {
      Q.current = _e, _e && H(_e)
    }, []), J = he == null ? void 0 : he.parentNode;
    j.useImperativeHandle(te, () => ({
      focus: () => {
        Q.current.focus()
      },
      node: M.current,
      value: O
    }), [O]), j.useEffect(() => {
      u && q && he && !ne && (Z(a ? null : J.clientWidth), Q.current.focus())
    }, [he, a]), j.useEffect(() => {
      o && Q.current.focus()
    }, [o]), j.useEffect(() => {
      if (!_) return;
      const _e = ji(Q.current).getElementById(_);
      if (_e) {
        const Ze = () => {
          getSelection().isCollapsed && Q.current.focus()
        };
        return _e.addEventListener("click", Ze), () => {
          _e.removeEventListener("click", Ze)
        }
      }
    }, [_]);
    const ie = (_e, Ze) => {
        _e ? D && D(Ze) : w && w(Ze), ne || (Z(a ? null : J.clientWidth), W(_e))
      },
      ce = _e => {
        _e.button === 0 && (_e.preventDefault(), Q.current.focus(), ie(!0, _e))
      },
      ue = _e => {
        ie(!1, _e)
      },
      ge = j.Children.toArray(c),
      et = _e => {
        const Ze = ge.find(Ee => Ee.props.value === _e.target.value);
        Ze !== void 0 && (U(Ze.props.value), A && A(_e, Ze))
      },
      He = _e => Ze => {
        let Ee;
        if (Ze.currentTarget.hasAttribute("tabindex")) {
          if (v) {
            Ee = Array.isArray(O) ? O.slice() : [];
            const Oe = O.indexOf(_e.props.value);
            Oe === -1 ? Ee.push(_e.props.value) : Ee.splice(Oe, 1)
          } else Ee = _e.props.value;
          if (_e.props.onClick && _e.props.onClick(Ze), O !== Ee && (U(Ee), A)) {
            const Oe = Ze.nativeEvent || Ze,
              yt = new Oe.constructor(Oe.type, Oe);
            Object.defineProperty(yt, "target", {
              writable: !0,
              value: {
                value: Ee,
                name: S
              }
            }), A(yt, _e)
          }
          v || ie(!1, Ze)
        }
      },
      se = _e => {
        V || [" ", "ArrowUp", "ArrowDown", "Enter"].indexOf(_e.key) !== -1 && (_e.preventDefault(), ie(!0, _e))
      },
      pe = he !== null && q,
      de = _e => {
        !pe && I && (Object.defineProperty(_e, "target", {
          writable: !0,
          value: {
            value: O,
            name: S
          }
        }), I(_e))
      };
    delete N["aria-invalid"];
    let we, Ce;
    const be = [];
    let Se = !1;
    (l3({
      value: O
    }) || g) && (G ? we = G(O) : Se = !0);
    const Fe = ge.map(_e => {
      if (!j.isValidElement(_e)) return null;
      let Ze;
      if (v) {
        if (!Array.isArray(O)) throw new Error(cu(2));
        Ze = O.some(Ee => iN(Ee, _e.props.value)), Ze && Se && be.push(_e.props.children)
      } else Ze = iN(O, _e.props.value), Ze && Se && (Ce = _e.props.children);
      return j.cloneElement(_e, {
        "aria-selected": Ze ? "true" : "false",
        onClick: He(_e),
        onKeyUp: Ee => {
          Ee.key === " " && Ee.preventDefault(), _e.props.onKeyUp && _e.props.onKeyUp(Ee)
        },
        role: "option",
        selected: Ze,
        value: void 0,
        "data-value": _e.props.value
      })
    });
    Se && (v ? be.length === 0 ? we = null : we = be.reduce((_e, Ze, Ee) => (_e.push(Ze), Ee < be.length - 1 && _e.push(", "), _e), []) : we = Ce);
    let Ne = X;
    !a && ne && he && (Ne = J.clientWidth);
    let Me;
    typeof b < "u" ? Me = b : Me = h ? null : 0;
    const We = L.id || (S ? `mui-component-select-${S}` : void 0),
      ke = K({}, t, {
        variant: R,
        value: O,
        open: pe,
        error: y
      }),
      ze = Zye(ke),
      ct = K({}, p.PaperProps, (r = p.slotProps) == null ? void 0 : r.paper),
      Xe = O2();
    return C.jsxs(j.Fragment, {
      children: [C.jsx(Qye, K({
        ref: F,
        tabIndex: Me,
        role: "combobox",
        "aria-controls": Xe,
        "aria-disabled": h ? "true" : void 0,
        "aria-expanded": pe ? "true" : "false",
        "aria-haspopup": "listbox",
        "aria-label": s,
        "aria-labelledby": [_, We].filter(Boolean).join(" ") || void 0,
        "aria-describedby": i,
        onKeyDown: se,
        onMouseDown: h || V ? null : ce,
        onBlur: de,
        onFocus: E
      }, L, {
        ownerState: ke,
        className: Ye(L.className, ze.select, l),
        id: We,
        children: Xye(we) ? rN || (rN = C.jsx("span", {
          className: "notranslate",
          children: "​"
        })) : we
      })), C.jsx(Jye, K({
        "aria-invalid": y,
        value: Array.isArray(O) ? O.join(",") : O,
        name: S,
        ref: M,
        "aria-hidden": !0,
        onChange: et,
        tabIndex: -1,
        disabled: h,
        className: ze.nativeInput,
        autoFocus: o,
        ownerState: ke
      }, N)), C.jsx(Yye, {
        as: x,
        className: ze.icon,
        ownerState: ke
      }), C.jsx(EH, K({
        id: `menu-${S||""}`,
        anchorEl: J,
        open: pe,
        onClose: ue,
        anchorOrigin: {
          vertical: "bottom",
          horizontal: "center"
        },
        transformOrigin: {
          vertical: "top",
          horizontal: "center"
        }
      }, p, {
        MenuListProps: K({
          "aria-labelledby": _,
          role: "listbox",
          "aria-multiselectable": v ? "true" : void 0,
          disableListWrap: !0,
          id: Xe
        }, p.MenuListProps),
        slotProps: K({}, p.slotProps, {
          paper: K({}, ct, {
            style: K({
              minWidth: Ne
            }, ct != null ? ct.style : null)
          })
        }),
        children: Fe
      }))]
    })
  }),
  tve = eve,
  nve = ["autoWidth", "children", "classes", "className", "defaultOpen", "displayEmpty", "IconComponent", "id", "input", "inputProps", "label", "labelId", "MenuProps", "multiple", "native", "onClose", "onOpen", "open", "renderValue", "SelectDisplayProps", "variant"],
  rve = ["root"],
  ive = e => {
    const {
      classes: t
    } = e;
    return t
  },
  XT = {
    name: "MuiSelect",
    overridesResolver: (e, t) => t.root,
    shouldForwardProp: e => $s(e) && e !== "variant",
    slot: "Root"
  },
  sve = me(W1e, XT)(""),
  ove = me(jye, XT)(""),
  ave = me(T1e, XT)(""),
  kH = j.forwardRef(function (t, n) {
    const r = xt({
        name: "MuiSelect",
        props: t
      }),
      {
        autoWidth: i = !1,
        children: s,
        classes: o = {},
        className: a,
        defaultOpen: c = !1,
        displayEmpty: l = !1,
        IconComponent: u = zpe,
        id: f,
        input: h,
        inputProps: g,
        label: y,
        labelId: x,
        MenuProps: k,
        multiple: _ = !1,
        native: p = !1,
        onClose: v,
        onOpen: S,
        open: I,
        renderValue: A,
        SelectDisplayProps: w,
        variant: E = "outlined"
      } = r,
      D = Ve(r, nve),
      $ = p ? Pye : tve,
      V = mm(),
      G = T5({
        props: r,
        muiFormControl: V,
        states: ["variant", "error"]
      }),
      L = G.variant || E,
      b = K({}, r, {
        variant: L,
        classes: o
      }),
      T = ive(b),
      R = Ve(T, rve),
      N = h || {
        standard: C.jsx(sve, {
          ownerState: b
        }),
        outlined: C.jsx(ove, {
          label: y,
          ownerState: b
        }),
        filled: C.jsx(ave, {
          ownerState: b
        })
      } [L],
      O = vr(n, N.ref);
    return C.jsx(j.Fragment, {
      children: j.cloneElement(N, K({
        inputComponent: $,
        inputProps: K({
          children: s,
          error: G.error,
          IconComponent: u,
          variant: L,
          type: void 0,
          multiple: _
        }, p ? {
          id: f
        } : {
          autoWidth: i,
          defaultOpen: c,
          displayEmpty: l,
          labelId: x,
          MenuProps: k,
          onClose: v,
          onOpen: S,
          open: I,
          renderValue: A,
          SelectDisplayProps: K({
            id: f
          }, w)
        }, g, {
          classes: g ? ks(R, g.classes) : R
        }, h ? h.props.inputProps : {})
      }, (_ && p || l) && L === "outlined" ? {
        notched: !0
      } : {}, {
        ref: O,
        className: Ye(N.props.className, a, T.root)
      }, !h && {
        variant: L
      }, D))
    })
  });
kH.muiName = "Select";
const cve = kH;

function lve(e) {
  return mt("MuiSkeleton", e)
}
gt("MuiSkeleton", ["root", "text", "rectangular", "rounded", "circular", "pulse", "wave", "withChildren", "fitContent", "heightAuto"]);
const uve = ["animation", "className", "component", "height", "style", "variant", "width"];
let d3 = e => e,
  sN, oN, aN, cN;
const dve = e => {
    const {
      classes: t,
      variant: n,
      animation: r,
      hasChildren: i,
      width: s,
      height: o
    } = e;
    return pt({
      root: ["root", n, r, i && "withChildren", i && !s && "fitContent", i && !o && "heightAuto"]
    }, lve, t)
  },
  fve = yl(sN || (sN = d3 `
  0% {
    opacity: 1;
  }

  50% {
    opacity: 0.4;
  }

  100% {
    opacity: 1;
  }
`)),
  hve = yl(oN || (oN = d3 `
  0% {
    transform: translateX(-100%);
  }

  50% {
    /* +0.5s of delay between each loop */
    transform: translateX(100%);
  }

  100% {
    transform: translateX(100%);
  }
`)),
  pve = me("span", {
    name: "MuiSkeleton",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, t[n.variant], n.animation !== !1 && t[n.animation], n.hasChildren && t.withChildren, n.hasChildren && !n.width && t.fitContent, n.hasChildren && !n.height && t.heightAuto]
    }
  })(({
    theme: e,
    ownerState: t
  }) => {
    const n = wfe(e.shape.borderRadius) || "px",
      r = xfe(e.shape.borderRadius);
    return K({
      display: "block",
      backgroundColor: e.vars ? e.vars.palette.Skeleton.bg : Vt(e.palette.text.primary, e.palette.mode === "light" ? .11 : .13),
      height: "1.2em"
    }, t.variant === "text" && {
      marginTop: 0,
      marginBottom: 0,
      height: "auto",
      transformOrigin: "0 55%",
      transform: "scale(1, 0.60)",
      borderRadius: `${r}${n}/${Math.round(r/.6*10)/10}${n}`,
      "&:empty:before": {
        content: '"\\00a0"'
      }
    }, t.variant === "circular" && {
      borderRadius: "50%"
    }, t.variant === "rounded" && {
      borderRadius: (e.vars || e).shape.borderRadius
    }, t.hasChildren && {
      "& > *": {
        visibility: "hidden"
      }
    }, t.hasChildren && !t.width && {
      maxWidth: "fit-content"
    }, t.hasChildren && !t.height && {
      height: "auto"
    })
  }, ({
    ownerState: e
  }) => e.animation === "pulse" && th(aN || (aN = d3 `
      animation: ${0} 2s ease-in-out 0.5s infinite;
    `), fve), ({
    ownerState: e,
    theme: t
  }) => e.animation === "wave" && th(cN || (cN = d3 `
      position: relative;
      overflow: hidden;

      /* Fix bug in Safari https://bugs.webkit.org/show_bug.cgi?id=68196 */
      -webkit-mask-image: -webkit-radial-gradient(white, black);

      &::after {
        animation: ${0} 2s linear 0.5s infinite;
        background: linear-gradient(
          90deg,
          transparent,
          ${0},
          transparent
        );
        content: '';
        position: absolute;
        transform: translateX(-100%); /* Avoid flash during server-side hydration */
        bottom: 0;
        left: 0;
        right: 0;
        top: 0;
      }
    `), hve, (t.vars || t).palette.action.hover)),
  mve = j.forwardRef(function (t, n) {
    const r = xt({
        props: t,
        name: "MuiSkeleton"
      }),
      {
        animation: i = "pulse",
        className: s,
        component: o = "span",
        height: a,
        style: c,
        variant: l = "text",
        width: u
      } = r,
      f = Ve(r, uve),
      h = K({}, r, {
        animation: i,
        component: o,
        variant: l,
        hasChildren: !!f.children
      }),
      g = dve(h);
    return C.jsx(pve, K({
      as: o,
      ref: n,
      className: Ye(g.root, s),
      ownerState: h
    }, f, {
      style: K({
        width: u,
        height: a
      }, c)
    }))
  }),
  gr = mve;

function gve(e) {
  return mt("MuiTooltip", e)
}
const yve = gt("MuiTooltip", ["popper", "popperInteractive", "popperArrow", "popperClose", "tooltip", "tooltipArrow", "touch", "tooltipPlacementLeft", "tooltipPlacementRight", "tooltipPlacementTop", "tooltipPlacementBottom", "arrow"]),
  ad = yve,
  vve = ["arrow", "children", "classes", "components", "componentsProps", "describeChild", "disableFocusListener", "disableHoverListener", "disableInteractive", "disableTouchListener", "enterDelay", "enterNextDelay", "enterTouchDelay", "followCursor", "id", "leaveDelay", "leaveTouchDelay", "onClose", "onOpen", "open", "placement", "PopperComponent", "PopperProps", "slotProps", "slots", "title", "TransitionComponent", "TransitionProps"];

function bve(e) {
  return Math.round(e * 1e5) / 1e5
}
const wve = e => {
    const {
      classes: t,
      disableInteractive: n,
      arrow: r,
      touch: i,
      placement: s
    } = e, o = {
      popper: ["popper", !n && "popperInteractive", r && "popperArrow"],
      tooltip: ["tooltip", r && "tooltipArrow", i && "touch", `tooltipPlacement${qe(s.split("-")[0])}`],
      arrow: ["arrow"]
    };
    return pt(o, gve, t)
  },
  xve = me(eH, {
    name: "MuiTooltip",
    slot: "Popper",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.popper, !n.disableInteractive && t.popperInteractive, n.arrow && t.popperArrow, !n.open && t.popperClose]
    }
  })(({
    theme: e,
    ownerState: t,
    open: n
  }) => K({
    zIndex: (e.vars || e).zIndex.tooltip,
    pointerEvents: "none"
  }, !t.disableInteractive && {
    pointerEvents: "auto"
  }, !n && {
    pointerEvents: "none"
  }, t.arrow && {
    [`&[data-popper-placement*="bottom"] .${ad.arrow}`]: {
      top: 0,
      marginTop: "-0.71em",
      "&::before": {
        transformOrigin: "0 100%"
      }
    },
    [`&[data-popper-placement*="top"] .${ad.arrow}`]: {
      bottom: 0,
      marginBottom: "-0.71em",
      "&::before": {
        transformOrigin: "100% 0"
      }
    },
    [`&[data-popper-placement*="right"] .${ad.arrow}`]: K({}, t.isRtl ? {
      right: 0,
      marginRight: "-0.71em"
    } : {
      left: 0,
      marginLeft: "-0.71em"
    }, {
      height: "1em",
      width: "0.71em",
      "&::before": {
        transformOrigin: "100% 100%"
      }
    }),
    [`&[data-popper-placement*="left"] .${ad.arrow}`]: K({}, t.isRtl ? {
      left: 0,
      marginLeft: "-0.71em"
    } : {
      right: 0,
      marginRight: "-0.71em"
    }, {
      height: "1em",
      width: "0.71em",
      "&::before": {
        transformOrigin: "0 0"
      }
    })
  })),
  Eve = me("div", {
    name: "MuiTooltip",
    slot: "Tooltip",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.tooltip, n.touch && t.touch, n.arrow && t.tooltipArrow, t[`tooltipPlacement${qe(n.placement.split("-")[0])}`]]
    }
  })(({
    theme: e,
    ownerState: t
  }) => K({
    backgroundColor: e.vars ? e.vars.palette.Tooltip.bg : lr(e.palette.grey[700], .92),
    borderRadius: (e.vars || e).shape.borderRadius,
    color: (e.vars || e).palette.common.white,
    fontFamily: e.typography.fontFamily,
    padding: "4px 8px",
    fontSize: e.typography.pxToRem(11),
    maxWidth: 300,
    margin: 2,
    wordWrap: "break-word",
    fontWeight: e.typography.fontWeightMedium
  }, t.arrow && {
    position: "relative",
    margin: 0
  }, t.touch && {
    padding: "8px 16px",
    fontSize: e.typography.pxToRem(14),
    lineHeight: `${bve(16/14)}em`,
    fontWeight: e.typography.fontWeightRegular
  }, {
    [`.${ad.popper}[data-popper-placement*="left"] &`]: K({
      transformOrigin: "right center"
    }, t.isRtl ? K({
      marginLeft: "14px"
    }, t.touch && {
      marginLeft: "24px"
    }) : K({
      marginRight: "14px"
    }, t.touch && {
      marginRight: "24px"
    })),
    [`.${ad.popper}[data-popper-placement*="right"] &`]: K({
      transformOrigin: "left center"
    }, t.isRtl ? K({
      marginRight: "14px"
    }, t.touch && {
      marginRight: "24px"
    }) : K({
      marginLeft: "14px"
    }, t.touch && {
      marginLeft: "24px"
    })),
    [`.${ad.popper}[data-popper-placement*="top"] &`]: K({
      transformOrigin: "center bottom",
      marginBottom: "14px"
    }, t.touch && {
      marginBottom: "24px"
    }),
    [`.${ad.popper}[data-popper-placement*="bottom"] &`]: K({
      transformOrigin: "center top",
      marginTop: "14px"
    }, t.touch && {
      marginTop: "24px"
    })
  })),
  Sve = me("span", {
    name: "MuiTooltip",
    slot: "Arrow",
    overridesResolver: (e, t) => t.arrow
  })(({
    theme: e
  }) => ({
    overflow: "hidden",
    position: "absolute",
    width: "1em",
    height: "0.71em",
    boxSizing: "border-box",
    color: e.vars ? e.vars.palette.Tooltip.bg : lr(e.palette.grey[700], .9),
    "&::before": {
      content: '""',
      margin: "auto",
      display: "block",
      width: "100%",
      height: "100%",
      backgroundColor: "currentColor",
      transform: "rotate(45deg)"
    }
  }));
let ub = !1;
const lN = new D2;
let Tg = {
  x: 0,
  y: 0
};

function db(e, t) {
  return (n, ...r) => {
    t && t(n, ...r), e(n, ...r)
  }
}
const Cve = j.forwardRef(function (t, n) {
    var r, i, s, o, a, c, l, u, f, h, g, y, x, k, _, p, v, S, I;
    const A = xt({
        props: t,
        name: "MuiTooltip"
      }),
      {
        arrow: w = !1,
        children: E,
        components: D = {},
        componentsProps: $ = {},
        describeChild: V = !1,
        disableFocusListener: G = !1,
        disableHoverListener: L = !1,
        disableInteractive: b = !1,
        disableTouchListener: T = !1,
        enterDelay: R = 100,
        enterNextDelay: N = 0,
        enterTouchDelay: O = 700,
        followCursor: U = !1,
        id: q,
        leaveDelay: W = 0,
        leaveTouchDelay: M = 1500,
        onClose: Q,
        onOpen: he,
        open: H,
        placement: ne = "bottom",
        PopperComponent: X,
        PopperProps: Z = {},
        slotProps: te = {},
        slots: F = {},
        title: J,
        TransitionComponent: ie = t2,
        TransitionProps: ce
      } = A,
      ue = Ve(A, vve),
      ge = j.isValidElement(E) ? E : C.jsx("span", {
        children: E
      }),
      et = vl(),
      He = U2(),
      [se, pe] = j.useState(),
      [de, we] = j.useState(null),
      Ce = j.useRef(!1),
      be = b || U,
      Se = Pf(),
      Fe = Pf(),
      Ne = Pf(),
      Me = Pf(),
      [We, ke] = K1({
        controlled: H,
        default: !1,
        name: "Tooltip",
        state: "open"
      });
    let ze = We;
    const ct = O2(q),
      Xe = j.useRef(),
      _e = Ea(() => {
        Xe.current !== void 0 && (document.body.style.WebkitUserSelect = Xe.current, Xe.current = void 0), Me.clear()
      });
    j.useEffect(() => _e, [_e]);
    const Ze = Ut => {
        lN.clear(), ub = !0, ke(!0), he && !ze && he(Ut)
      },
      Ee = Ea(Ut => {
        lN.start(800 + W, () => {
          ub = !1
        }), ke(!1), Q && ze && Q(Ut), Se.start(et.transitions.duration.shortest, () => {
          Ce.current = !1
        })
      }),
      Oe = Ut => {
        Ce.current && Ut.type !== "touchstart" || (se && se.removeAttribute("title"), Fe.clear(), Ne.clear(), R || ub && N ? Fe.start(ub ? N : R, () => {
          Ze(Ut)
        }) : Ze(Ut))
      },
      yt = Ut => {
        Fe.clear(), Ne.start(W, () => {
          Ee(Ut)
        })
      },
      {
        isFocusVisibleRef: tt,
        onBlur: dt,
        onFocus: xn,
        ref: Ht
      } = Zx(),
      [, en] = j.useState(!1),
      tn = Ut => {
        dt(Ut), tt.current === !1 && (en(!1), yt(Ut))
      },
      Et = Ut => {
        se || pe(Ut.currentTarget), xn(Ut), tt.current === !0 && (en(!0), Oe(Ut))
      },
      Ot = Ut => {
        Ce.current = !0;
        const or = ge.props;
        or.onTouchStart && or.onTouchStart(Ut)
      },
      kn = Ut => {
        Ot(Ut), Ne.clear(), Se.clear(), _e(), Xe.current = document.body.style.WebkitUserSelect, document.body.style.WebkitUserSelect = "none", Me.start(O, () => {
          document.body.style.WebkitUserSelect = Xe.current, Oe(Ut)
        })
      },
      Dt = Ut => {
        ge.props.onTouchEnd && ge.props.onTouchEnd(Ut), _e(), Ne.start(M, () => {
          Ee(Ut)
        })
      };
    j.useEffect(() => {
      if (!ze) return;

      function Ut(or) {
        (or.key === "Escape" || or.key === "Esc") && Ee(or)
      }
      return document.addEventListener("keydown", Ut), () => {
        document.removeEventListener("keydown", Ut)
      }
    }, [Ee, ze]);
    const Pt = vr(ge.ref, Ht, pe, n);
    !J && J !== 0 && (ze = !1);
    const _n = j.useRef(),
      zt = Ut => {
        const or = ge.props;
        or.onMouseMove && or.onMouseMove(Ut), Tg = {
          x: Ut.clientX,
          y: Ut.clientY
        }, _n.current && _n.current.update()
      },
      kt = {},
      In = typeof J == "string";
    V ? (kt.title = !ze && In && !L ? J : null, kt["aria-describedby"] = ze ? ct : null) : (kt["aria-label"] = In ? J : null, kt["aria-labelledby"] = ze && !In ? ct : null);
    const vt = K({}, kt, ue, ge.props, {
        className: Ye(ue.className, ge.props.className),
        onTouchStart: Ot,
        ref: Pt
      }, U ? {
        onMouseMove: zt
      } : {}),
      _t = {};
    T || (vt.onTouchStart = kn, vt.onTouchEnd = Dt), L || (vt.onMouseOver = db(Oe, vt.onMouseOver), vt.onMouseLeave = db(yt, vt.onMouseLeave), be || (_t.onMouseOver = Oe, _t.onMouseLeave = yt)), G || (vt.onFocus = db(Et, vt.onFocus), vt.onBlur = db(tn, vt.onBlur), be || (_t.onFocus = Et, _t.onBlur = tn));
    const Pn = j.useMemo(() => {
        var Ut;
        let or = [{
          name: "arrow",
          enabled: !!de,
          options: {
            element: de,
            padding: 4
          }
        }];
        return (Ut = Z.popperOptions) != null && Ut.modifiers && (or = or.concat(Z.popperOptions.modifiers)), K({}, Z.popperOptions, {
          modifiers: or
        })
      }, [de, Z]),
      wt = K({}, A, {
        isRtl: He,
        arrow: w,
        disableInteractive: be,
        placement: ne,
        PopperComponentProp: X,
        touch: Ce.current
      }),
      $t = wve(wt),
      Mn = (r = (i = F.popper) != null ? i : D.Popper) != null ? r : xve,
      Rn = (s = (o = (a = F.transition) != null ? a : D.Transition) != null ? o : ie) != null ? s : t2,
      On = (c = (l = F.tooltip) != null ? l : D.Tooltip) != null ? c : Eve,
      js = (u = (f = F.arrow) != null ? f : D.Arrow) != null ? u : Sve,
      cn = z0(Mn, K({}, Z, (h = te.popper) != null ? h : $.popper, {
        className: Ye($t.popper, Z == null ? void 0 : Z.className, (g = (y = te.popper) != null ? y : $.popper) == null ? void 0 : g.className)
      }), wt),
      $n = z0(Rn, K({}, ce, (x = te.transition) != null ? x : $.transition), wt),
      Us = z0(On, K({}, (k = te.tooltip) != null ? k : $.tooltip, {
        className: Ye($t.tooltip, (_ = (p = te.tooltip) != null ? p : $.tooltip) == null ? void 0 : _.className)
      }), wt),
      zs = z0(js, K({}, (v = te.arrow) != null ? v : $.arrow, {
        className: Ye($t.arrow, (S = (I = te.arrow) != null ? I : $.arrow) == null ? void 0 : S.className)
      }), wt);
    return C.jsxs(j.Fragment, {
      children: [j.cloneElement(ge, vt), C.jsx(Mn, K({
        as: X ?? eH,
        placement: ne,
        anchorEl: U ? {
          getBoundingClientRect: () => ({
            top: Tg.y,
            left: Tg.x,
            right: Tg.x,
            bottom: Tg.y,
            width: 0,
            height: 0
          })
        } : se,
        popperRef: _n,
        open: se ? ze : !1,
        id: ct,
        transition: !0
      }, _t, cn, {
        popperOptions: Pn,
        children: ({
          TransitionProps: Ut
        }) => C.jsx(Rn, K({
          timeout: et.transitions.duration.shorter
        }, Ut, $n, {
          children: C.jsxs(On, K({}, Us, {
            children: [J, w ? C.jsx(js, K({}, zs, {
              ref: we
            })) : null]
          }))
        }))
      }))]
    })
  }),
  ro = Cve,
  Ave = j.createContext({}),
  Y2 = Ave,
  Tve = j.createContext({}),
  M5 = Tve;

function kve(e) {
  return mt("MuiStep", e)
}
gt("MuiStep", ["root", "horizontal", "vertical", "alternativeLabel", "completed"]);
const _ve = ["active", "children", "className", "component", "completed", "disabled", "expanded", "index", "last"],
  Ive = e => {
    const {
      classes: t,
      orientation: n,
      alternativeLabel: r,
      completed: i
    } = e;
    return pt({
      root: ["root", n, r && "alternativeLabel", i && "completed"]
    }, kve, t)
  },
  Pve = me("div", {
    name: "MuiStep",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, t[n.orientation], n.alternativeLabel && t.alternativeLabel, n.completed && t.completed]
    }
  })(({
    ownerState: e
  }) => K({}, e.orientation === "horizontal" && {
    paddingLeft: 8,
    paddingRight: 8
  }, e.alternativeLabel && {
    flex: 1,
    position: "relative"
  })),
  Rve = j.forwardRef(function (t, n) {
    const r = xt({
        props: t,
        name: "MuiStep"
      }),
      {
        active: i,
        children: s,
        className: o,
        component: a = "div",
        completed: c,
        disabled: l,
        expanded: u = !1,
        index: f,
        last: h
      } = r,
      g = Ve(r, _ve),
      {
        activeStep: y,
        connector: x,
        alternativeLabel: k,
        orientation: _,
        nonLinear: p
      } = j.useContext(Y2);
    let [v = !1, S = !1, I = !1] = [i, c, l];
    y === f ? v = i !== void 0 ? i : !0 : !p && y > f ? S = c !== void 0 ? c : !0 : !p && y < f && (I = l !== void 0 ? l : !0);
    const A = j.useMemo(() => ({
        index: f,
        last: h,
        expanded: u,
        icon: f + 1,
        active: v,
        completed: S,
        disabled: I
      }), [f, h, u, v, S, I]),
      w = K({}, r, {
        active: v,
        orientation: _,
        alternativeLabel: k,
        completed: S,
        disabled: I,
        expanded: u,
        component: a
      }),
      E = Ive(w),
      D = C.jsxs(Pve, K({
        as: a,
        className: Ye(E.root, o),
        ref: n,
        ownerState: w
      }, g, {
        children: [x && k && f !== 0 ? x : null, s]
      }));
    return C.jsx(M5.Provider, {
      value: A,
      children: x && !k && f !== 0 ? C.jsxs(j.Fragment, {
        children: [x, D]
      }) : D
    })
  }),
  Ove = Rve,
  Dve = Bd(C.jsx("path", {
    d: "M12 0a12 12 0 1 0 0 24 12 12 0 0 0 0-24zm-2 17l-5-5 1.4-1.4 3.6 3.6 7.6-7.6L19 8l-9 9z"
  }), "CheckCircle"),
  Nve = Bd(C.jsx("path", {
    d: "M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z"
  }), "Warning");

function Mve(e) {
  return mt("MuiStepIcon", e)
}
const $ve = gt("MuiStepIcon", ["root", "active", "completed", "error", "text"]),
  gS = $ve;
var uN;
const Lve = ["active", "className", "completed", "error", "icon"],
  Bve = e => {
    const {
      classes: t,
      active: n,
      completed: r,
      error: i
    } = e;
    return pt({
      root: ["root", n && "active", r && "completed", i && "error"],
      text: ["text"]
    }, Mve, t)
  },
  yS = me(o3, {
    name: "MuiStepIcon",
    slot: "Root",
    overridesResolver: (e, t) => t.root
  })(({
    theme: e
  }) => ({
    display: "block",
    transition: e.transitions.create("color", {
      duration: e.transitions.duration.shortest
    }),
    color: (e.vars || e).palette.text.disabled,
    [`&.${gS.completed}`]: {
      color: (e.vars || e).palette.primary.main
    },
    [`&.${gS.active}`]: {
      color: (e.vars || e).palette.primary.main
    },
    [`&.${gS.error}`]: {
      color: (e.vars || e).palette.error.main
    }
  })),
  Fve = me("text", {
    name: "MuiStepIcon",
    slot: "Text",
    overridesResolver: (e, t) => t.text
  })(({
    theme: e
  }) => ({
    fill: (e.vars || e).palette.primary.contrastText,
    fontSize: e.typography.caption.fontSize,
    fontFamily: e.typography.fontFamily
  })),
  jve = j.forwardRef(function (t, n) {
    const r = xt({
        props: t,
        name: "MuiStepIcon"
      }),
      {
        active: i = !1,
        className: s,
        completed: o = !1,
        error: a = !1,
        icon: c
      } = r,
      l = Ve(r, Lve),
      u = K({}, r, {
        active: i,
        completed: o,
        error: a
      }),
      f = Bve(u);
    if (typeof c == "number" || typeof c == "string") {
      const h = Ye(s, f.root);
      return a ? C.jsx(yS, K({
        as: Nve,
        className: h,
        ref: n,
        ownerState: u
      }, l)) : o ? C.jsx(yS, K({
        as: Dve,
        className: h,
        ref: n,
        ownerState: u
      }, l)) : C.jsxs(yS, K({
        className: h,
        ref: n,
        ownerState: u
      }, l, {
        children: [uN || (uN = C.jsx("circle", {
          cx: "12",
          cy: "12",
          r: "12"
        })), C.jsx(Fve, {
          className: f.text,
          x: "12",
          y: "12",
          textAnchor: "middle",
          dominantBaseline: "central",
          ownerState: u,
          children: c
        })]
      }))
    }
    return c
  }),
  Uve = jve;

function zve(e) {
  return mt("MuiStepLabel", e)
}
const Hve = gt("MuiStepLabel", ["root", "horizontal", "vertical", "label", "active", "completed", "error", "disabled", "iconContainer", "alternativeLabel", "labelContainer"]),
  Yc = Hve,
  Vve = ["children", "className", "componentsProps", "error", "icon", "optional", "slotProps", "StepIconComponent", "StepIconProps"],
  Wve = e => {
    const {
      classes: t,
      orientation: n,
      active: r,
      completed: i,
      error: s,
      disabled: o,
      alternativeLabel: a
    } = e;
    return pt({
      root: ["root", n, s && "error", o && "disabled", a && "alternativeLabel"],
      label: ["label", r && "active", i && "completed", s && "error", o && "disabled", a && "alternativeLabel"],
      iconContainer: ["iconContainer", r && "active", i && "completed", s && "error", o && "disabled", a && "alternativeLabel"],
      labelContainer: ["labelContainer", a && "alternativeLabel"]
    }, zve, t)
  },
  qve = me("span", {
    name: "MuiStepLabel",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, t[n.orientation]]
    }
  })(({
    ownerState: e
  }) => K({
    display: "flex",
    alignItems: "center",
    [`&.${Yc.alternativeLabel}`]: {
      flexDirection: "column"
    },
    [`&.${Yc.disabled}`]: {
      cursor: "default"
    }
  }, e.orientation === "vertical" && {
    textAlign: "left",
    padding: "8px 0"
  })),
  Gve = me("span", {
    name: "MuiStepLabel",
    slot: "Label",
    overridesResolver: (e, t) => t.label
  })(({
    theme: e
  }) => K({}, e.typography.body2, {
    display: "block",
    transition: e.transitions.create("color", {
      duration: e.transitions.duration.shortest
    }),
    [`&.${Yc.active}`]: {
      color: (e.vars || e).palette.text.primary,
      fontWeight: 500
    },
    [`&.${Yc.completed}`]: {
      color: (e.vars || e).palette.text.primary,
      fontWeight: 500
    },
    [`&.${Yc.alternativeLabel}`]: {
      marginTop: 16
    },
    [`&.${Yc.error}`]: {
      color: (e.vars || e).palette.error.main
    }
  })),
  Kve = me("span", {
    name: "MuiStepLabel",
    slot: "IconContainer",
    overridesResolver: (e, t) => t.iconContainer
  })(() => ({
    flexShrink: 0,
    display: "flex",
    paddingRight: 8,
    [`&.${Yc.alternativeLabel}`]: {
      paddingRight: 0
    }
  })),
  Qve = me("span", {
    name: "MuiStepLabel",
    slot: "LabelContainer",
    overridesResolver: (e, t) => t.labelContainer
  })(({
    theme: e
  }) => ({
    width: "100%",
    color: (e.vars || e).palette.text.secondary,
    [`&.${Yc.alternativeLabel}`]: {
      textAlign: "center"
    }
  })),
  _H = j.forwardRef(function (t, n) {
    var r;
    const i = xt({
        props: t,
        name: "MuiStepLabel"
      }),
      {
        children: s,
        className: o,
        componentsProps: a = {},
        error: c = !1,
        icon: l,
        optional: u,
        slotProps: f = {},
        StepIconComponent: h,
        StepIconProps: g
      } = i,
      y = Ve(i, Vve),
      {
        alternativeLabel: x,
        orientation: k
      } = j.useContext(Y2),
      {
        active: _,
        disabled: p,
        completed: v,
        icon: S
      } = j.useContext(M5),
      I = l || S;
    let A = h;
    I && !A && (A = Uve);
    const w = K({}, i, {
        active: _,
        alternativeLabel: x,
        completed: v,
        disabled: p,
        error: c,
        orientation: k
      }),
      E = Wve(w),
      D = (r = f.label) != null ? r : a.label;
    return C.jsxs(qve, K({
      className: Ye(E.root, o),
      ref: n,
      ownerState: w
    }, y, {
      children: [I || A ? C.jsx(Kve, {
        className: E.iconContainer,
        ownerState: w,
        children: C.jsx(A, K({
          completed: v,
          active: _,
          error: c,
          icon: I
        }, g))
      }) : null, C.jsxs(Qve, {
        className: E.labelContainer,
        ownerState: w,
        children: [s ? C.jsx(Gve, K({
          ownerState: w
        }, D, {
          className: Ye(E.label, D == null ? void 0 : D.className),
          children: s
        })) : null, u]
      })]
    }))
  });
_H.muiName = "StepLabel";
const Yve = _H;

function Jve(e) {
  return mt("MuiStepConnector", e)
}
const Xve = gt("MuiStepConnector", ["root", "horizontal", "vertical", "alternativeLabel", "active", "completed", "disabled", "line", "lineHorizontal", "lineVertical"]),
  Zve = Xve,
  ebe = ["className"],
  tbe = e => {
    const {
      classes: t,
      orientation: n,
      alternativeLabel: r,
      active: i,
      completed: s,
      disabled: o
    } = e, a = {
      root: ["root", n, r && "alternativeLabel", i && "active", s && "completed", o && "disabled"],
      line: ["line", `line${qe(n)}`]
    };
    return pt(a, Jve, t)
  },
  nbe = me("div", {
    name: "MuiStepConnector",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, t[n.orientation], n.alternativeLabel && t.alternativeLabel, n.completed && t.completed]
    }
  })(({
    ownerState: e
  }) => K({
    flex: "1 1 auto"
  }, e.orientation === "vertical" && {
    marginLeft: 12
  }, e.alternativeLabel && {
    position: "absolute",
    top: 12,
    left: "calc(-50% + 20px)",
    right: "calc(50% + 20px)"
  })),
  rbe = me("span", {
    name: "MuiStepConnector",
    slot: "Line",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.line, t[`line${qe(n.orientation)}`]]
    }
  })(({
    ownerState: e,
    theme: t
  }) => {
    const n = t.palette.mode === "light" ? t.palette.grey[400] : t.palette.grey[600];
    return K({
      display: "block",
      borderColor: t.vars ? t.vars.palette.StepConnector.border : n
    }, e.orientation === "horizontal" && {
      borderTopStyle: "solid",
      borderTopWidth: 1
    }, e.orientation === "vertical" && {
      borderLeftStyle: "solid",
      borderLeftWidth: 1,
      minHeight: 24
    })
  }),
  ibe = j.forwardRef(function (t, n) {
    const r = xt({
        props: t,
        name: "MuiStepConnector"
      }),
      {
        className: i
      } = r,
      s = Ve(r, ebe),
      {
        alternativeLabel: o,
        orientation: a = "horizontal"
      } = j.useContext(Y2),
      {
        active: c,
        disabled: l,
        completed: u
      } = j.useContext(M5),
      f = K({}, r, {
        alternativeLabel: o,
        orientation: a,
        active: c,
        completed: u,
        disabled: l
      }),
      h = tbe(f);
    return C.jsx(nbe, K({
      className: Ye(h.root, i),
      ref: n,
      ownerState: f
    }, s, {
      children: C.jsx(rbe, {
        className: h.line,
        ownerState: f
      })
    }))
  }),
  IH = ibe;

function sbe(e) {
  return mt("MuiStepContent", e)
}
const obe = gt("MuiStepContent", ["root", "last", "transition"]),
  abe = obe,
  cbe = ["children", "className", "TransitionComponent", "transitionDuration", "TransitionProps"],
  lbe = e => {
    const {
      classes: t,
      last: n
    } = e;
    return pt({
      root: ["root", n && "last"],
      transition: ["transition"]
    }, sbe, t)
  },
  ube = me("div", {
    name: "MuiStepContent",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, n.last && t.last]
    }
  })(({
    ownerState: e,
    theme: t
  }) => K({
    marginLeft: 12,
    paddingLeft: 20,
    paddingRight: 8,
    borderLeft: t.vars ? `1px solid ${t.vars.palette.StepContent.border}` : `1px solid ${t.palette.mode==="light"?t.palette.grey[400]:t.palette.grey[600]}`
  }, e.last && {
    borderLeft: "none"
  })),
  dbe = me(fo, {
    name: "MuiStepContent",
    slot: "Transition",
    overridesResolver: (e, t) => t.transition
  })({}),
  fbe = j.forwardRef(function (t, n) {
    const r = xt({
        props: t,
        name: "MuiStepContent"
      }),
      {
        children: i,
        className: s,
        TransitionComponent: o = fo,
        transitionDuration: a = "auto",
        TransitionProps: c
      } = r,
      l = Ve(r, cbe);
    j.useContext(Y2);
    const {
      active: u,
      last: f,
      expanded: h
    } = j.useContext(M5), g = K({}, r, {
      last: f
    }), y = lbe(g);
    let x = a;
    return a === "auto" && !o.muiSupportAuto && (x = void 0), C.jsx(ube, K({
      className: Ye(y.root, s),
      ref: n,
      ownerState: g
    }, l, {
      children: C.jsx(dbe, K({
        as: o,
        in: u || h,
        className: y.transition,
        ownerState: g,
        timeout: x,
        unmountOnExit: !0
      }, c, {
        children: i
      }))
    }))
  }),
  hbe = fbe;

function pbe(e) {
  return mt("MuiStepper", e)
}
gt("MuiStepper", ["root", "horizontal", "vertical", "alternativeLabel"]);
const mbe = ["activeStep", "alternativeLabel", "children", "className", "component", "connector", "nonLinear", "orientation"],
  gbe = e => {
    const {
      orientation: t,
      alternativeLabel: n,
      classes: r
    } = e;
    return pt({
      root: ["root", t, n && "alternativeLabel"]
    }, pbe, r)
  },
  ybe = me("div", {
    name: "MuiStepper",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, t[n.orientation], n.alternativeLabel && t.alternativeLabel]
    }
  })(({
    ownerState: e
  }) => K({
    display: "flex"
  }, e.orientation === "horizontal" && {
    flexDirection: "row",
    alignItems: "center"
  }, e.orientation === "vertical" && {
    flexDirection: "column"
  }, e.alternativeLabel && {
    alignItems: "flex-start"
  })),
  vbe = C.jsx(IH, {}),
  bbe = j.forwardRef(function (t, n) {
    const r = xt({
        props: t,
        name: "MuiStepper"
      }),
      {
        activeStep: i = 0,
        alternativeLabel: s = !1,
        children: o,
        className: a,
        component: c = "div",
        connector: l = vbe,
        nonLinear: u = !1,
        orientation: f = "horizontal"
      } = r,
      h = Ve(r, mbe),
      g = K({}, r, {
        alternativeLabel: s,
        orientation: f,
        component: c
      }),
      y = gbe(g),
      x = j.Children.toArray(o).filter(Boolean),
      k = x.map((p, v) => j.cloneElement(p, K({
        index: v,
        last: v + 1 === x.length
      }, p.props))),
      _ = j.useMemo(() => ({
        activeStep: i,
        alternativeLabel: s,
        connector: l,
        nonLinear: u,
        orientation: f
      }), [i, s, l, u, f]);
    return C.jsx(Y2.Provider, {
      value: _,
      children: C.jsx(ybe, K({
        as: c,
        ownerState: g,
        className: Ye(y.root, a),
        ref: n
      }, h, {
        children: k
      }))
    })
  }),
  wbe = bbe;

function xbe(e) {
  return mt("MuiSwitch", e)
}
const Ebe = gt("MuiSwitch", ["root", "edgeStart", "edgeEnd", "switchBase", "colorPrimary", "colorSecondary", "sizeSmall", "sizeMedium", "checked", "disabled", "input", "thumb", "track"]),
  jn = Ebe,
  Sbe = ["className", "color", "edge", "size", "sx"],
  Cbe = $T(),
  Abe = e => {
    const {
      classes: t,
      edge: n,
      size: r,
      color: i,
      checked: s,
      disabled: o
    } = e, a = {
      root: ["root", n && `edge${qe(n)}`, `size${qe(r)}`],
      switchBase: ["switchBase", `color${qe(i)}`, s && "checked", o && "disabled"],
      thumb: ["thumb"],
      track: ["track"],
      input: ["input"]
    }, c = pt(a, xbe, t);
    return K({}, t, c)
  },
  Tbe = me("span", {
    name: "MuiSwitch",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, n.edge && t[`edge${qe(n.edge)}`], t[`size${qe(n.size)}`]]
    }
  })({
    display: "inline-flex",
    width: 34 + 12 * 2,
    height: 14 + 12 * 2,
    overflow: "hidden",
    padding: 12,
    boxSizing: "border-box",
    position: "relative",
    flexShrink: 0,
    zIndex: 0,
    verticalAlign: "middle",
    "@media print": {
      colorAdjust: "exact"
    },
    variants: [{
      props: {
        edge: "start"
      },
      style: {
        marginLeft: -8
      }
    }, {
      props: {
        edge: "end"
      },
      style: {
        marginRight: -8
      }
    }, {
      props: {
        size: "small"
      },
      style: {
        width: 40,
        height: 24,
        padding: 7,
        [`& .${jn.thumb}`]: {
          width: 16,
          height: 16
        },
        [`& .${jn.switchBase}`]: {
          padding: 4,
          [`&.${jn.checked}`]: {
            transform: "translateX(16px)"
          }
        }
      }
    }]
  }),
  kbe = me(tge, {
    name: "MuiSwitch",
    slot: "SwitchBase",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.switchBase, {
        [`& .${jn.input}`]: t.input
      }, n.color !== "default" && t[`color${qe(n.color)}`]]
    }
  })(({
    theme: e
  }) => ({
    position: "absolute",
    top: 0,
    left: 0,
    zIndex: 1,
    color: e.vars ? e.vars.palette.Switch.defaultColor : `${e.palette.mode==="light"?e.palette.common.white:e.palette.grey[300]}`,
    transition: e.transitions.create(["left", "transform"], {
      duration: e.transitions.duration.shortest
    }),
    [`&.${jn.checked}`]: {
      transform: "translateX(20px)"
    },
    [`&.${jn.disabled}`]: {
      color: e.vars ? e.vars.palette.Switch.defaultDisabledColor : `${e.palette.mode==="light"?e.palette.grey[100]:e.palette.grey[600]}`
    },
    [`&.${jn.checked} + .${jn.track}`]: {
      opacity: .5
    },
    [`&.${jn.disabled} + .${jn.track}`]: {
      opacity: e.vars ? e.vars.opacity.switchTrackDisabled : `${e.palette.mode==="light"?.12:.2}`
    },
    [`& .${jn.input}`]: {
      left: "-100%",
      width: "300%"
    }
  }), ({
    theme: e
  }) => ({
    "&:hover": {
      backgroundColor: e.vars ? `rgba(${e.vars.palette.action.activeChannel} / ${e.vars.palette.action.hoverOpacity})` : lr(e.palette.action.active, e.palette.action.hoverOpacity),
      "@media (hover: none)": {
        backgroundColor: "transparent"
      }
    },
    variants: [...Object.entries(e.palette).filter(([, t]) => t.main && t.light).map(([t]) => ({
      props: {
        color: t
      },
      style: {
        [`&.${jn.checked}`]: {
          color: (e.vars || e).palette[t].main,
          "&:hover": {
            backgroundColor: e.vars ? `rgba(${e.vars.palette[t].mainChannel} / ${e.vars.palette.action.hoverOpacity})` : lr(e.palette[t].main, e.palette.action.hoverOpacity),
            "@media (hover: none)": {
              backgroundColor: "transparent"
            }
          },
          [`&.${jn.disabled}`]: {
            color: e.vars ? e.vars.palette.Switch[`${t}DisabledColor`] : `${e.palette.mode==="light"?mz(e.palette[t].main,.62):pz(e.palette[t].main,.55)}`
          }
        },
        [`&.${jn.checked} + .${jn.track}`]: {
          backgroundColor: (e.vars || e).palette[t].main
        }
      }
    }))]
  })),
  _be = me("span", {
    name: "MuiSwitch",
    slot: "Track",
    overridesResolver: (e, t) => t.track
  })(({
    theme: e
  }) => ({
    height: "100%",
    width: "100%",
    borderRadius: 14 / 2,
    zIndex: -1,
    transition: e.transitions.create(["opacity", "background-color"], {
      duration: e.transitions.duration.shortest
    }),
    backgroundColor: e.vars ? e.vars.palette.common.onBackground : `${e.palette.mode==="light"?e.palette.common.black:e.palette.common.white}`,
    opacity: e.vars ? e.vars.opacity.switchTrack : `${e.palette.mode==="light"?.38:.3}`
  })),
  Ibe = me("span", {
    name: "MuiSwitch",
    slot: "Thumb",
    overridesResolver: (e, t) => t.thumb
  })(({
    theme: e
  }) => ({
    boxShadow: (e.vars || e).shadows[1],
    backgroundColor: "currentColor",
    width: 20,
    height: 20,
    borderRadius: "50%"
  })),
  Pbe = j.forwardRef(function (t, n) {
    const r = Cbe({
        props: t,
        name: "MuiSwitch"
      }),
      {
        className: i,
        color: s = "primary",
        edge: o = !1,
        size: a = "medium",
        sx: c
      } = r,
      l = Ve(r, Sbe),
      u = K({}, r, {
        color: s,
        edge: o,
        size: a
      }),
      f = Abe(u),
      h = C.jsx(Ibe, {
        className: f.thumb,
        ownerState: u
      });
    return C.jsxs(Tbe, {
      className: Ye(f.root, i),
      sx: c,
      ownerState: u,
      children: [C.jsx(kbe, K({
        type: "checkbox",
        icon: h,
        checkedIcon: h,
        ref: n,
        ownerState: u
      }, l, {
        classes: K({}, f, {
          root: f.switchBase
        })
      })), C.jsx(_be, {
        className: f.track,
        ownerState: u
      })]
    })
  }),
  Rbe = Pbe;

function Obe(e) {
  return mt("MuiTab", e)
}
const Dbe = gt("MuiTab", ["root", "labelIcon", "textColorInherit", "textColorPrimary", "textColorSecondary", "selected", "disabled", "fullWidth", "wrapped", "iconWrapper"]),
  Wl = Dbe,
  Nbe = ["className", "disabled", "disableFocusRipple", "fullWidth", "icon", "iconPosition", "indicator", "label", "onChange", "onClick", "onFocus", "selected", "selectionFollowsFocus", "textColor", "value", "wrapped"],
  Mbe = e => {
    const {
      classes: t,
      textColor: n,
      fullWidth: r,
      wrapped: i,
      icon: s,
      label: o,
      selected: a,
      disabled: c
    } = e, l = {
      root: ["root", s && o && "labelIcon", `textColor${qe(n)}`, r && "fullWidth", i && "wrapped", a && "selected", c && "disabled"],
      iconWrapper: ["iconWrapper"]
    };
    return pt(l, Obe, t)
  },
  $be = me(gu, {
    name: "MuiTab",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, n.label && n.icon && t.labelIcon, t[`textColor${qe(n.textColor)}`], n.fullWidth && t.fullWidth, n.wrapped && t.wrapped]
    }
  })(({
    theme: e,
    ownerState: t
  }) => K({}, e.typography.button, {
    maxWidth: 360,
    minWidth: 90,
    position: "relative",
    minHeight: 48,
    flexShrink: 0,
    padding: "12px 16px",
    overflow: "hidden",
    whiteSpace: "normal",
    textAlign: "center"
  }, t.label && {
    flexDirection: t.iconPosition === "top" || t.iconPosition === "bottom" ? "column" : "row"
  }, {
    lineHeight: 1.25
  }, t.icon && t.label && {
    minHeight: 72,
    paddingTop: 9,
    paddingBottom: 9,
    [`& > .${Wl.iconWrapper}`]: K({}, t.iconPosition === "top" && {
      marginBottom: 6
    }, t.iconPosition === "bottom" && {
      marginTop: 6
    }, t.iconPosition === "start" && {
      marginRight: e.spacing(1)
    }, t.iconPosition === "end" && {
      marginLeft: e.spacing(1)
    })
  }, t.textColor === "inherit" && {
    color: "inherit",
    opacity: .6,
    [`&.${Wl.selected}`]: {
      opacity: 1
    },
    [`&.${Wl.disabled}`]: {
      opacity: (e.vars || e).palette.action.disabledOpacity
    }
  }, t.textColor === "primary" && {
    color: (e.vars || e).palette.text.secondary,
    [`&.${Wl.selected}`]: {
      color: (e.vars || e).palette.primary.main
    },
    [`&.${Wl.disabled}`]: {
      color: (e.vars || e).palette.text.disabled
    }
  }, t.textColor === "secondary" && {
    color: (e.vars || e).palette.text.secondary,
    [`&.${Wl.selected}`]: {
      color: (e.vars || e).palette.secondary.main
    },
    [`&.${Wl.disabled}`]: {
      color: (e.vars || e).palette.text.disabled
    }
  }, t.fullWidth && {
    flexShrink: 1,
    flexGrow: 1,
    flexBasis: 0,
    maxWidth: "none"
  }, t.wrapped && {
    fontSize: e.typography.pxToRem(12)
  })),
  Lbe = j.forwardRef(function (t, n) {
    const r = xt({
        props: t,
        name: "MuiTab"
      }),
      {
        className: i,
        disabled: s = !1,
        disableFocusRipple: o = !1,
        fullWidth: a,
        icon: c,
        iconPosition: l = "top",
        indicator: u,
        label: f,
        onChange: h,
        onClick: g,
        onFocus: y,
        selected: x,
        selectionFollowsFocus: k,
        textColor: _ = "inherit",
        value: p,
        wrapped: v = !1
      } = r,
      S = Ve(r, Nbe),
      I = K({}, r, {
        disabled: s,
        disableFocusRipple: o,
        selected: x,
        icon: !!c,
        iconPosition: l,
        label: !!f,
        fullWidth: a,
        textColor: _,
        wrapped: v
      }),
      A = Mbe(I),
      w = c && f && j.isValidElement(c) ? j.cloneElement(c, {
        className: Ye(A.iconWrapper, c.props.className)
      }) : c,
      E = $ => {
        !x && h && h($, p), g && g($)
      },
      D = $ => {
        k && !x && h && h($, p), y && y($)
      };
    return C.jsxs($be, K({
      focusRipple: !o,
      className: Ye(A.root, i),
      ref: n,
      role: "tab",
      "aria-selected": x,
      disabled: s,
      onClick: E,
      onFocus: D,
      ownerState: I,
      tabIndex: x ? 0 : -1
    }, S, {
      children: [l === "top" || l === "start" ? C.jsxs(j.Fragment, {
        children: [w, f]
      }) : C.jsxs(j.Fragment, {
        children: [f, w]
      }), u]
    }))
  }),
  Bbe = Lbe,
  Fbe = Bd(C.jsx("path", {
    d: "M15.41 16.09l-4.58-4.59 4.58-4.59L14 5.5l-6 6 6 6z"
  }), "KeyboardArrowLeft"),
  jbe = Bd(C.jsx("path", {
    d: "M8.59 16.34l4.58-4.59-4.58-4.59L10 5.75l6 6-6 6z"
  }), "KeyboardArrowRight");

function Ube(e) {
  return (1 + Math.sin(Math.PI * e - Math.PI / 2)) / 2
}

function zbe(e, t, n, r = {}, i = () => {}) {
  const {
    ease: s = Ube,
    duration: o = 300
  } = r;
  let a = null;
  const c = t[e];
  let l = !1;
  const u = () => {
      l = !0
    },
    f = h => {
      if (l) {
        i(new Error("Animation cancelled"));
        return
      }
      a === null && (a = h);
      const g = Math.min(1, (h - a) / o);
      if (t[e] = s(g) * (n - c) + c, g >= 1) {
        requestAnimationFrame(() => {
          i(null)
        });
        return
      }
      requestAnimationFrame(f)
    };
  return c === n ? (i(new Error("Element already at target position")), u) : (requestAnimationFrame(f), u)
}
const Hbe = ["onChange"],
  Vbe = {
    width: 99,
    height: 99,
    position: "absolute",
    top: -9999,
    overflow: "scroll"
  };

function Wbe(e) {
  const {
    onChange: t
  } = e, n = Ve(e, Hbe), r = j.useRef(), i = j.useRef(null), s = () => {
    r.current = i.current.offsetHeight - i.current.clientHeight
  };
  return Os(() => {
    const o = um(() => {
        const c = r.current;
        s(), c !== r.current && t(r.current)
      }),
      a = _a(i.current);
    return a.addEventListener("resize", o), () => {
      o.clear(), a.removeEventListener("resize", o)
    }
  }, [t]), j.useEffect(() => {
    s(), t(r.current)
  }, [t]), C.jsx("div", K({
    style: Vbe,
    ref: i
  }, n))
}

function qbe(e) {
  return mt("MuiTabScrollButton", e)
}
const Gbe = gt("MuiTabScrollButton", ["root", "vertical", "horizontal", "disabled"]),
  Kbe = Gbe,
  Qbe = ["className", "slots", "slotProps", "direction", "orientation", "disabled"],
  Ybe = e => {
    const {
      classes: t,
      orientation: n,
      disabled: r
    } = e;
    return pt({
      root: ["root", n, r && "disabled"]
    }, qbe, t)
  },
  Jbe = me(gu, {
    name: "MuiTabScrollButton",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, n.orientation && t[n.orientation]]
    }
  })(({
    ownerState: e
  }) => K({
    width: 40,
    flexShrink: 0,
    opacity: .8,
    [`&.${Kbe.disabled}`]: {
      opacity: 0
    }
  }, e.orientation === "vertical" && {
    width: "100%",
    height: 40,
    "& svg": {
      transform: `rotate(${e.isRtl?-90:90}deg)`
    }
  })),
  Xbe = j.forwardRef(function (t, n) {
    var r, i;
    const s = xt({
        props: t,
        name: "MuiTabScrollButton"
      }),
      {
        className: o,
        slots: a = {},
        slotProps: c = {},
        direction: l
      } = s,
      u = Ve(s, Qbe),
      f = U2(),
      h = K({
        isRtl: f
      }, s),
      g = Ybe(h),
      y = (r = a.StartScrollButtonIcon) != null ? r : Fbe,
      x = (i = a.EndScrollButtonIcon) != null ? i : jbe,
      k = zo({
        elementType: y,
        externalSlotProps: c.startScrollButtonIcon,
        additionalProps: {
          fontSize: "small"
        },
        ownerState: h
      }),
      _ = zo({
        elementType: x,
        externalSlotProps: c.endScrollButtonIcon,
        additionalProps: {
          fontSize: "small"
        },
        ownerState: h
      });
    return C.jsx(Jbe, K({
      component: "div",
      className: Ye(g.root, o),
      ref: n,
      role: null,
      ownerState: h,
      tabIndex: null
    }, u, {
      children: l === "left" ? C.jsx(y, K({}, k)) : C.jsx(x, K({}, _))
    }))
  }),
  Zbe = Xbe;

function ewe(e) {
  return mt("MuiTabs", e)
}
const twe = gt("MuiTabs", ["root", "vertical", "flexContainer", "flexContainerVertical", "centered", "scroller", "fixed", "scrollableX", "scrollableY", "hideScrollbar", "scrollButtons", "scrollButtonsHideMobile", "indicator"]),
  up = twe,
  nwe = ["aria-label", "aria-labelledby", "action", "centered", "children", "className", "component", "allowScrollButtonsMobile", "indicatorColor", "onChange", "orientation", "ScrollButtonComponent", "scrollButtons", "selectionFollowsFocus", "slots", "slotProps", "TabIndicatorProps", "TabScrollButtonProps", "textColor", "value", "variant", "visibleScrollbar"],
  dN = (e, t) => e === t ? e.firstChild : t && t.nextElementSibling ? t.nextElementSibling : e.firstChild,
  fN = (e, t) => e === t ? e.lastChild : t && t.previousElementSibling ? t.previousElementSibling : e.lastChild,
  fb = (e, t, n) => {
    let r = !1,
      i = n(e, t);
    for (; i;) {
      if (i === e.firstChild) {
        if (r) return;
        r = !0
      }
      const s = i.disabled || i.getAttribute("aria-disabled") === "true";
      if (!i.hasAttribute("tabindex") || s) i = n(e, i);
      else {
        i.focus();
        return
      }
    }
  },
  rwe = e => {
    const {
      vertical: t,
      fixed: n,
      hideScrollbar: r,
      scrollableX: i,
      scrollableY: s,
      centered: o,
      scrollButtonsHideMobile: a,
      classes: c
    } = e;
    return pt({
      root: ["root", t && "vertical"],
      scroller: ["scroller", n && "fixed", r && "hideScrollbar", i && "scrollableX", s && "scrollableY"],
      flexContainer: ["flexContainer", t && "flexContainerVertical", o && "centered"],
      indicator: ["indicator"],
      scrollButtons: ["scrollButtons", a && "scrollButtonsHideMobile"],
      scrollableX: [i && "scrollableX"],
      hideScrollbar: [r && "hideScrollbar"]
    }, ewe, c)
  },
  iwe = me("div", {
    name: "MuiTabs",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [{
        [`& .${up.scrollButtons}`]: t.scrollButtons
      }, {
        [`& .${up.scrollButtons}`]: n.scrollButtonsHideMobile && t.scrollButtonsHideMobile
      }, t.root, n.vertical && t.vertical]
    }
  })(({
    ownerState: e,
    theme: t
  }) => K({
    overflow: "hidden",
    minHeight: 48,
    WebkitOverflowScrolling: "touch",
    display: "flex"
  }, e.vertical && {
    flexDirection: "column"
  }, e.scrollButtonsHideMobile && {
    [`& .${up.scrollButtons}`]: {
      [t.breakpoints.down("sm")]: {
        display: "none"
      }
    }
  })),
  swe = me("div", {
    name: "MuiTabs",
    slot: "Scroller",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.scroller, n.fixed && t.fixed, n.hideScrollbar && t.hideScrollbar, n.scrollableX && t.scrollableX, n.scrollableY && t.scrollableY]
    }
  })(({
    ownerState: e
  }) => K({
    position: "relative",
    display: "inline-block",
    flex: "1 1 auto",
    whiteSpace: "nowrap"
  }, e.fixed && {
    overflowX: "hidden",
    width: "100%"
  }, e.hideScrollbar && {
    scrollbarWidth: "none",
    "&::-webkit-scrollbar": {
      display: "none"
    }
  }, e.scrollableX && {
    overflowX: "auto",
    overflowY: "hidden"
  }, e.scrollableY && {
    overflowY: "auto",
    overflowX: "hidden"
  })),
  owe = me("div", {
    name: "MuiTabs",
    slot: "FlexContainer",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.flexContainer, n.vertical && t.flexContainerVertical, n.centered && t.centered]
    }
  })(({
    ownerState: e
  }) => K({
    display: "flex"
  }, e.vertical && {
    flexDirection: "column"
  }, e.centered && {
    justifyContent: "center"
  })),
  awe = me("span", {
    name: "MuiTabs",
    slot: "Indicator",
    overridesResolver: (e, t) => t.indicator
  })(({
    ownerState: e,
    theme: t
  }) => K({
    position: "absolute",
    height: 2,
    bottom: 0,
    width: "100%",
    transition: t.transitions.create()
  }, e.indicatorColor === "primary" && {
    backgroundColor: (t.vars || t).palette.primary.main
  }, e.indicatorColor === "secondary" && {
    backgroundColor: (t.vars || t).palette.secondary.main
  }, e.vertical && {
    height: "100%",
    width: 2,
    right: 0
  })),
  cwe = me(Wbe)({
    overflowX: "auto",
    overflowY: "hidden",
    scrollbarWidth: "none",
    "&::-webkit-scrollbar": {
      display: "none"
    }
  }),
  hN = {},
  lwe = j.forwardRef(function (t, n) {
    const r = xt({
        props: t,
        name: "MuiTabs"
      }),
      i = vl(),
      s = U2(),
      {
        "aria-label": o,
        "aria-labelledby": a,
        action: c,
        centered: l = !1,
        children: u,
        className: f,
        component: h = "div",
        allowScrollButtonsMobile: g = !1,
        indicatorColor: y = "primary",
        onChange: x,
        orientation: k = "horizontal",
        ScrollButtonComponent: _ = Zbe,
        scrollButtons: p = "auto",
        selectionFollowsFocus: v,
        slots: S = {},
        slotProps: I = {},
        TabIndicatorProps: A = {},
        TabScrollButtonProps: w = {},
        textColor: E = "primary",
        value: D,
        variant: $ = "standard",
        visibleScrollbar: V = !1
      } = r,
      G = Ve(r, nwe),
      L = $ === "scrollable",
      b = k === "vertical",
      T = b ? "scrollTop" : "scrollLeft",
      R = b ? "top" : "left",
      N = b ? "bottom" : "right",
      O = b ? "clientHeight" : "clientWidth",
      U = b ? "height" : "width",
      q = K({}, r, {
        component: h,
        allowScrollButtonsMobile: g,
        indicatorColor: y,
        orientation: k,
        vertical: b,
        scrollButtons: p,
        textColor: E,
        variant: $,
        visibleScrollbar: V,
        fixed: !L,
        hideScrollbar: L && !V,
        scrollableX: L && !b,
        scrollableY: L && b,
        centered: l && !L,
        scrollButtonsHideMobile: !g
      }),
      W = rwe(q),
      M = zo({
        elementType: S.StartScrollButtonIcon,
        externalSlotProps: I.startScrollButtonIcon,
        ownerState: q
      }),
      Q = zo({
        elementType: S.EndScrollButtonIcon,
        externalSlotProps: I.endScrollButtonIcon,
        ownerState: q
      }),
      [he, H] = j.useState(!1),
      [ne, X] = j.useState(hN),
      [Z, te] = j.useState(!1),
      [F, J] = j.useState(!1),
      [ie, ce] = j.useState(!1),
      [ue, ge] = j.useState({
        overflow: "hidden",
        scrollbarWidth: 0
      }),
      et = new Map,
      He = j.useRef(null),
      se = j.useRef(null),
      pe = () => {
        const Ee = He.current;
        let Oe;
        if (Ee) {
          const tt = Ee.getBoundingClientRect();
          Oe = {
            clientWidth: Ee.clientWidth,
            scrollLeft: Ee.scrollLeft,
            scrollTop: Ee.scrollTop,
            scrollLeftNormalized: Xae(Ee, s ? "rtl" : "ltr"),
            scrollWidth: Ee.scrollWidth,
            top: tt.top,
            bottom: tt.bottom,
            left: tt.left,
            right: tt.right
          }
        }
        let yt;
        if (Ee && D !== !1) {
          const tt = se.current.children;
          if (tt.length > 0) {
            const dt = tt[et.get(D)];
            yt = dt ? dt.getBoundingClientRect() : null
          }
        }
        return {
          tabsMeta: Oe,
          tabMeta: yt
        }
      },
      de = Ea(() => {
        const {
          tabsMeta: Ee,
          tabMeta: Oe
        } = pe();
        let yt = 0,
          tt;
        if (b) tt = "top", Oe && Ee && (yt = Oe.top - Ee.top + Ee.scrollTop);
        else if (tt = s ? "right" : "left", Oe && Ee) {
          const xn = s ? Ee.scrollLeftNormalized + Ee.clientWidth - Ee.scrollWidth : Ee.scrollLeft;
          yt = (s ? -1 : 1) * (Oe[tt] - Ee[tt] + xn)
        }
        const dt = {
          [tt]: yt,
          [U]: Oe ? Oe[U] : 0
        };
        if (isNaN(ne[tt]) || isNaN(ne[U])) X(dt);
        else {
          const xn = Math.abs(ne[tt] - dt[tt]),
            Ht = Math.abs(ne[U] - dt[U]);
          (xn >= 1 || Ht >= 1) && X(dt)
        }
      }),
      we = (Ee, {
        animation: Oe = !0
      } = {}) => {
        Oe ? zbe(T, He.current, Ee, {
          duration: i.transitions.duration.standard
        }) : He.current[T] = Ee
      },
      Ce = Ee => {
        let Oe = He.current[T];
        b ? Oe += Ee : (Oe += Ee * (s ? -1 : 1), Oe *= s && DU() === "reverse" ? -1 : 1), we(Oe)
      },
      be = () => {
        const Ee = He.current[O];
        let Oe = 0;
        const yt = Array.from(se.current.children);
        for (let tt = 0; tt < yt.length; tt += 1) {
          const dt = yt[tt];
          if (Oe + dt[O] > Ee) {
            tt === 0 && (Oe = Ee);
            break
          }
          Oe += dt[O]
        }
        return Oe
      },
      Se = () => {
        Ce(-1 * be())
      },
      Fe = () => {
        Ce(be())
      },
      Ne = j.useCallback(Ee => {
        ge({
          overflow: null,
          scrollbarWidth: Ee
        })
      }, []),
      Me = () => {
        const Ee = {};
        Ee.scrollbarSizeListener = L ? C.jsx(cwe, {
          onChange: Ne,
          className: Ye(W.scrollableX, W.hideScrollbar)
        }) : null;
        const yt = L && (p === "auto" && (Z || F) || p === !0);
        return Ee.scrollButtonStart = yt ? C.jsx(_, K({
          slots: {
            StartScrollButtonIcon: S.StartScrollButtonIcon
          },
          slotProps: {
            startScrollButtonIcon: M
          },
          orientation: k,
          direction: s ? "right" : "left",
          onClick: Se,
          disabled: !Z
        }, w, {
          className: Ye(W.scrollButtons, w.className)
        })) : null, Ee.scrollButtonEnd = yt ? C.jsx(_, K({
          slots: {
            EndScrollButtonIcon: S.EndScrollButtonIcon
          },
          slotProps: {
            endScrollButtonIcon: Q
          },
          orientation: k,
          direction: s ? "left" : "right",
          onClick: Fe,
          disabled: !F
        }, w, {
          className: Ye(W.scrollButtons, w.className)
        })) : null, Ee
      },
      We = Ea(Ee => {
        const {
          tabsMeta: Oe,
          tabMeta: yt
        } = pe();
        if (!(!yt || !Oe)) {
          if (yt[R] < Oe[R]) {
            const tt = Oe[T] + (yt[R] - Oe[R]);
            we(tt, {
              animation: Ee
            })
          } else if (yt[N] > Oe[N]) {
            const tt = Oe[T] + (yt[N] - Oe[N]);
            we(tt, {
              animation: Ee
            })
          }
        }
      }),
      ke = Ea(() => {
        L && p !== !1 && ce(!ie)
      });
    j.useEffect(() => {
      const Ee = um(() => {
        He.current && de()
      });
      let Oe;
      const yt = xn => {
          xn.forEach(Ht => {
            Ht.removedNodes.forEach(en => {
              var tn;
              (tn = Oe) == null || tn.unobserve(en)
            }), Ht.addedNodes.forEach(en => {
              var tn;
              (tn = Oe) == null || tn.observe(en)
            })
          }), Ee(), ke()
        },
        tt = _a(He.current);
      tt.addEventListener("resize", Ee);
      let dt;
      return typeof ResizeObserver < "u" && (Oe = new ResizeObserver(Ee), Array.from(se.current.children).forEach(xn => {
        Oe.observe(xn)
      })), typeof MutationObserver < "u" && (dt = new MutationObserver(yt), dt.observe(se.current, {
        childList: !0
      })), () => {
        var xn, Ht;
        Ee.clear(), tt.removeEventListener("resize", Ee), (xn = dt) == null || xn.disconnect(), (Ht = Oe) == null || Ht.disconnect()
      }
    }, [de, ke]), j.useEffect(() => {
      const Ee = Array.from(se.current.children),
        Oe = Ee.length;
      if (typeof IntersectionObserver < "u" && Oe > 0 && L && p !== !1) {
        const yt = Ee[0],
          tt = Ee[Oe - 1],
          dt = {
            root: He.current,
            threshold: .99
          },
          xn = Et => {
            te(!Et[0].isIntersecting)
          },
          Ht = new IntersectionObserver(xn, dt);
        Ht.observe(yt);
        const en = Et => {
            J(!Et[0].isIntersecting)
          },
          tn = new IntersectionObserver(en, dt);
        return tn.observe(tt), () => {
          Ht.disconnect(), tn.disconnect()
        }
      }
    }, [L, p, ie, u == null ? void 0 : u.length]), j.useEffect(() => {
      H(!0)
    }, []), j.useEffect(() => {
      de()
    }), j.useEffect(() => {
      We(hN !== ne)
    }, [We, ne]), j.useImperativeHandle(c, () => ({
      updateIndicator: de,
      updateScrollButtons: ke
    }), [de, ke]);
    const ze = C.jsx(awe, K({}, A, {
      className: Ye(W.indicator, A.className),
      ownerState: q,
      style: K({}, ne, A.style)
    }));
    let ct = 0;
    const Xe = j.Children.map(u, Ee => {
        if (!j.isValidElement(Ee)) return null;
        const Oe = Ee.props.value === void 0 ? ct : Ee.props.value;
        et.set(Oe, ct);
        const yt = Oe === D;
        return ct += 1, j.cloneElement(Ee, K({
          fullWidth: $ === "fullWidth",
          indicator: yt && !he && ze,
          selected: yt,
          selectionFollowsFocus: v,
          onChange: x,
          textColor: E,
          value: Oe
        }, ct === 1 && D === !1 && !Ee.props.tabIndex ? {
          tabIndex: 0
        } : {}))
      }),
      _e = Ee => {
        const Oe = se.current,
          yt = ji(Oe).activeElement;
        if (yt.getAttribute("role") !== "tab") return;
        let dt = k === "horizontal" ? "ArrowLeft" : "ArrowUp",
          xn = k === "horizontal" ? "ArrowRight" : "ArrowDown";
        switch (k === "horizontal" && s && (dt = "ArrowRight", xn = "ArrowLeft"), Ee.key) {
          case dt:
            Ee.preventDefault(), fb(Oe, yt, fN);
            break;
          case xn:
            Ee.preventDefault(), fb(Oe, yt, dN);
            break;
          case "Home":
            Ee.preventDefault(), fb(Oe, null, dN);
            break;
          case "End":
            Ee.preventDefault(), fb(Oe, null, fN);
            break
        }
      },
      Ze = Me();
    return C.jsxs(iwe, K({
      className: Ye(W.root, f),
      ownerState: q,
      ref: n,
      as: h
    }, G, {
      children: [Ze.scrollButtonStart, Ze.scrollbarSizeListener, C.jsxs(swe, {
        className: W.scroller,
        ownerState: q,
        style: {
          overflow: ue.overflow,
          [b ? `margin${s?"Left":"Right"}` : "marginBottom"]: V ? void 0 : -ue.scrollbarWidth
        },
        ref: He,
        children: [C.jsx(owe, {
          "aria-label": o,
          "aria-labelledby": a,
          "aria-orientation": k === "vertical" ? "vertical" : null,
          className: W.flexContainer,
          ownerState: q,
          onKeyDown: _e,
          ref: se,
          role: "tablist",
          children: Xe
        }), he && ze]
      }), Ze.scrollButtonEnd]
    }))
  }),
  uwe = lwe;

function dwe(e) {
  return mt("MuiToggleButton", e)
}
const fwe = gt("MuiToggleButton", ["root", "disabled", "selected", "standard", "primary", "secondary", "sizeSmall", "sizeMedium", "sizeLarge", "fullWidth"]),
  Of = fwe,
  PH = j.createContext({}),
  hwe = j.createContext(void 0),
  RH = hwe;

function pwe(e, t) {
  return t === void 0 || e === void 0 ? !1 : Array.isArray(t) ? t.indexOf(e) >= 0 : e === t
}
const mwe = ["value"],
  gwe = ["children", "className", "color", "disabled", "disableFocusRipple", "fullWidth", "onChange", "onClick", "selected", "size", "value"],
  ywe = e => {
    const {
      classes: t,
      fullWidth: n,
      selected: r,
      disabled: i,
      size: s,
      color: o
    } = e, a = {
      root: ["root", r && "selected", i && "disabled", n && "fullWidth", `size${qe(s)}`, o]
    };
    return pt(a, dwe, t)
  },
  vwe = me(gu, {
    name: "MuiToggleButton",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, t[`size${qe(n.size)}`]]
    }
  })(({
    theme: e,
    ownerState: t
  }) => {
    let n = t.color === "standard" ? e.palette.text.primary : e.palette[t.color].main,
      r;
    return e.vars && (n = t.color === "standard" ? e.vars.palette.text.primary : e.vars.palette[t.color].main, r = t.color === "standard" ? e.vars.palette.text.primaryChannel : e.vars.palette[t.color].mainChannel), K({}, e.typography.button, {
      borderRadius: (e.vars || e).shape.borderRadius,
      padding: 11,
      border: `1px solid ${(e.vars||e).palette.divider}`,
      color: (e.vars || e).palette.action.active
    }, t.fullWidth && {
      width: "100%"
    }, {
      [`&.${Of.disabled}`]: {
        color: (e.vars || e).palette.action.disabled,
        border: `1px solid ${(e.vars||e).palette.action.disabledBackground}`
      },
      "&:hover": {
        textDecoration: "none",
        backgroundColor: e.vars ? `rgba(${e.vars.palette.text.primaryChannel} / ${e.vars.palette.action.hoverOpacity})` : Vt(e.palette.text.primary, e.palette.action.hoverOpacity),
        "@media (hover: none)": {
          backgroundColor: "transparent"
        }
      },
      [`&.${Of.selected}`]: {
        color: n,
        backgroundColor: e.vars ? `rgba(${r} / ${e.vars.palette.action.selectedOpacity})` : Vt(n, e.palette.action.selectedOpacity),
        "&:hover": {
          backgroundColor: e.vars ? `rgba(${r} / calc(${e.vars.palette.action.selectedOpacity} + ${e.vars.palette.action.hoverOpacity}))` : Vt(n, e.palette.action.selectedOpacity + e.palette.action.hoverOpacity),
          "@media (hover: none)": {
            backgroundColor: e.vars ? `rgba(${r} / ${e.vars.palette.action.selectedOpacity})` : Vt(n, e.palette.action.selectedOpacity)
          }
        }
      }
    }, t.size === "small" && {
      padding: 7,
      fontSize: e.typography.pxToRem(13)
    }, t.size === "large" && {
      padding: 15,
      fontSize: e.typography.pxToRem(15)
    })
  }),
  bwe = j.forwardRef(function (t, n) {
    const r = j.useContext(PH),
      {
        value: i
      } = r,
      s = Ve(r, mwe),
      o = j.useContext(RH),
      a = N2(K({}, s, {
        selected: pwe(t.value, i)
      }), t),
      c = xt({
        props: a,
        name: "MuiToggleButton"
      }),
      {
        children: l,
        className: u,
        color: f = "standard",
        disabled: h = !1,
        disableFocusRipple: g = !1,
        fullWidth: y = !1,
        onChange: x,
        onClick: k,
        selected: _,
        size: p = "medium",
        value: v
      } = c,
      S = Ve(c, gwe),
      I = K({}, c, {
        color: f,
        disabled: h,
        disableFocusRipple: g,
        fullWidth: y,
        size: p
      }),
      A = ywe(I),
      w = D => {
        k && (k(D, v), D.defaultPrevented) || x && x(D, v)
      },
      E = o || "";
    return C.jsx(vwe, K({
      className: Ye(s.className, A.root, u, E),
      disabled: h,
      focusRipple: !g,
      ref: n,
      onClick: w,
      onChange: x,
      value: v,
      ownerState: I,
      "aria-pressed": _
    }, S, {
      children: l
    }))
  }),
  wwe = bwe;

function xwe(e) {
  return mt("MuiToggleButtonGroup", e)
}
const Ewe = gt("MuiToggleButtonGroup", ["root", "selected", "vertical", "disabled", "grouped", "groupedHorizontal", "groupedVertical", "fullWidth", "firstButton", "lastButton", "middleButton"]),
  xr = Ewe,
  Swe = ["children", "className", "color", "disabled", "exclusive", "fullWidth", "onChange", "orientation", "size", "value"],
  Cwe = e => {
    const {
      classes: t,
      orientation: n,
      fullWidth: r,
      disabled: i
    } = e, s = {
      root: ["root", n === "vertical" && "vertical", r && "fullWidth"],
      grouped: ["grouped", `grouped${qe(n)}`, i && "disabled"],
      firstButton: ["firstButton"],
      lastButton: ["lastButton"],
      middleButton: ["middleButton"]
    };
    return pt(s, xwe, t)
  },
  Awe = me("div", {
    name: "MuiToggleButtonGroup",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [{
        [`& .${xr.grouped}`]: t.grouped
      }, {
        [`& .${xr.grouped}`]: t[`grouped${qe(n.orientation)}`]
      }, {
        [`& .${xr.firstButton}`]: t.firstButton
      }, {
        [`& .${xr.lastButton}`]: t.lastButton
      }, {
        [`& .${xr.middleButton}`]: t.middleButton
      }, t.root, n.orientation === "vertical" && t.vertical, n.fullWidth && t.fullWidth]
    }
  })(({
    ownerState: e,
    theme: t
  }) => K({
    display: "inline-flex",
    borderRadius: (t.vars || t).shape.borderRadius
  }, e.orientation === "vertical" && {
    flexDirection: "column"
  }, e.fullWidth && {
    width: "100%"
  }, {
    [`& .${xr.grouped}`]: K({}, e.orientation === "horizontal" ? {
      [`&.${xr.selected} + .${xr.grouped}.${xr.selected}`]: {
        borderLeft: 0,
        marginLeft: 0
      }
    } : {
      [`&.${xr.selected} + .${xr.grouped}.${xr.selected}`]: {
        borderTop: 0,
        marginTop: 0
      }
    })
  }, e.orientation === "horizontal" ? {
    [`& .${xr.firstButton},& .${xr.middleButton}`]: {
      borderTopRightRadius: 0,
      borderBottomRightRadius: 0
    },
    [`& .${xr.lastButton},& .${xr.middleButton}`]: {
      marginLeft: -1,
      borderLeft: "1px solid transparent",
      borderTopLeftRadius: 0,
      borderBottomLeftRadius: 0
    }
  } : {
    [`& .${xr.firstButton},& .${xr.middleButton}`]: {
      borderBottomLeftRadius: 0,
      borderBottomRightRadius: 0
    },
    [`& .${xr.lastButton},& .${xr.middleButton}`]: {
      marginTop: -1,
      borderTop: "1px solid transparent",
      borderTopLeftRadius: 0,
      borderTopRightRadius: 0
    }
  }, e.orientation === "horizontal" ? {
    [`& .${xr.lastButton}.${Of.disabled},& .${xr.middleButton}.${Of.disabled}`]: {
      borderLeft: "1px solid transparent"
    }
  } : {
    [`& .${xr.lastButton}.${Of.disabled},& .${xr.middleButton}.${Of.disabled}`]: {
      borderTop: "1px solid transparent"
    }
  })),
  Twe = j.forwardRef(function (t, n) {
    const r = xt({
        props: t,
        name: "MuiToggleButtonGroup"
      }),
      {
        children: i,
        className: s,
        color: o = "standard",
        disabled: a = !1,
        exclusive: c = !1,
        fullWidth: l = !1,
        onChange: u,
        orientation: f = "horizontal",
        size: h = "medium",
        value: g
      } = r,
      y = Ve(r, Swe),
      x = K({}, r, {
        disabled: a,
        fullWidth: l,
        orientation: f,
        size: h
      }),
      k = Cwe(x),
      _ = j.useCallback((w, E) => {
        if (!u) return;
        const D = g && g.indexOf(E);
        let $;
        g && D >= 0 ? ($ = g.slice(), $.splice(D, 1)) : $ = g ? g.concat(E) : [E], u(w, $)
      }, [u, g]),
      p = j.useCallback((w, E) => {
        u && u(w, g === E ? null : E)
      }, [u, g]),
      v = j.useMemo(() => ({
        className: k.grouped,
        onChange: c ? p : _,
        value: g,
        size: h,
        fullWidth: l,
        color: o,
        disabled: a
      }), [k.grouped, c, p, _, g, h, l, o, a]),
      S = Zae(i),
      I = S.length,
      A = w => {
        const E = w === 0,
          D = w === I - 1;
        return E && D ? "" : E ? k.firstButton : D ? k.lastButton : k.middleButton
      };
    return C.jsx(Awe, K({
      role: "group",
      className: Ye(k.root, s),
      ref: n,
      ownerState: x
    }, y, {
      children: C.jsx(PH.Provider, {
        value: v,
        children: S.map((w, E) => C.jsx(RH.Provider, {
          value: A(E),
          children: w
        }, E))
      })
    }))
  }),
  kwe = Twe;
var _we = {
  area: !0,
  base: !0,
  br: !0,
  col: !0,
  embed: !0,
  hr: !0,
  img: !0,
  input: !0,
  link: !0,
  meta: !0,
  param: !0,
  source: !0,
  track: !0,
  wbr: !0
};
const Iwe = Vo(_we);
var Pwe = /\s([^'"/\s><]+?)[\s/>]|([^\s=]+)=\s?(".*?"|'.*?')/g;

function pN(e) {
  var t = {
      type: "tag",
      name: "",
      voidElement: !1,
      attrs: {},
      children: []
    },
    n = e.match(/<\/?([^\s]+?)[/\s>]/);
  if (n && (t.name = n[1], (Iwe[n[1]] || e.charAt(e.length - 2) === "/") && (t.voidElement = !0), t.name.startsWith("!--"))) {
    var r = e.indexOf("-->");
    return {
      type: "comment",
      comment: r !== -1 ? e.slice(4, r) : ""
    }
  }
  for (var i = new RegExp(Pwe), s = null;
    (s = i.exec(e)) !== null;)
    if (s[0].trim())
      if (s[1]) {
        var o = s[1].trim(),
          a = [o, ""];
        o.indexOf("=") > -1 && (a = o.split("=")), t.attrs[a[0]] = a[1], i.lastIndex--
      } else s[2] && (t.attrs[s[2]] = s[3].trim().substring(1, s[3].length - 1));
  return t
}
var Rwe = /<[a-zA-Z0-9\-\!\/](?:"[^"]*"|'[^']*'|[^'">])*>/g,
  Owe = /^\s*$/,
  Dwe = Object.create(null);

function OH(e, t) {
  switch (t.type) {
    case "text":
      return e + t.content;
    case "tag":
      return e += "<" + t.name + (t.attrs ? function (n) {
        var r = [];
        for (var i in n) r.push(i + '="' + n[i] + '"');
        return r.length ? " " + r.join(" ") : ""
      }(t.attrs) : "") + (t.voidElement ? "/>" : ">"), t.voidElement ? e : e + t.children.reduce(OH, "") + "</" + t.name + ">";
    case "comment":
      return e + "<!--" + t.comment + "-->"
  }
}
var Nwe = {
  parse: function (e, t) {
    t || (t = {}), t.components || (t.components = Dwe);
    var n, r = [],
      i = [],
      s = -1,
      o = !1;
    if (e.indexOf("<") !== 0) {
      var a = e.indexOf("<");
      r.push({
        type: "text",
        content: a === -1 ? e : e.substring(0, a)
      })
    }
    return e.replace(Rwe, function (c, l) {
      if (o) {
        if (c !== "</" + n.name + ">") return;
        o = !1
      }
      var u, f = c.charAt(1) !== "/",
        h = c.startsWith("<!--"),
        g = l + c.length,
        y = e.charAt(g);
      if (h) {
        var x = pN(c);
        return s < 0 ? (r.push(x), r) : ((u = i[s]).children.push(x), r)
      }
      if (f && (s++, (n = pN(c)).type === "tag" && t.components[n.name] && (n.type = "component", o = !0), n.voidElement || o || !y || y === "<" || n.children.push({
          type: "text",
          content: e.slice(g, e.indexOf("<", g))
        }), s === 0 && r.push(n), (u = i[s - 1]) && u.children.push(n), i[s] = n), (!f || n.voidElement) && (s > -1 && (n.voidElement || n.name === c.slice(2, -1)) && (s--, n = s === -1 ? r : i[s]), !o && y !== "<" && y)) {
        u = s === -1 ? r : i[s].children;
        var k = e.indexOf("<", g),
          _ = e.slice(g, k === -1 ? void 0 : k);
        Owe.test(_) && (_ = " "), (k > -1 && s + u.length >= 0 || _ !== " ") && u.push({
          type: "text",
          content: _
        })
      }
    }), r
  },
  stringify: function (e) {
    return e.reduce(function (t, n) {
      return t + OH("", n)
    }, "")
  }
};

function pw() {
  if (console && console.warn) {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
    typeof t[0] == "string" && (t[0] = `react-i18next:: ${t[0]}`), console.warn(...t)
  }
}
const mN = {};

function f3() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
  typeof t[0] == "string" && mN[t[0]] || (typeof t[0] == "string" && (mN[t[0]] = new Date), pw(...t))
}
const DH = (e, t) => () => {
  if (e.isInitialized) t();
  else {
    const n = () => {
      setTimeout(() => {
        e.off("initialized", n)
      }, 0), t()
    };
    e.on("initialized", n)
  }
};

function gN(e, t, n) {
  e.loadNamespaces(t, DH(e, n))
}

function yN(e, t, n, r) {
  typeof n == "string" && (n = [n]), n.forEach(i => {
    e.options.ns.indexOf(i) < 0 && e.options.ns.push(i)
  }), e.loadLanguages(t, DH(e, r))
}

function Mwe(e, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  const r = t.languages[0],
    i = t.options ? t.options.fallbackLng : !1,
    s = t.languages[t.languages.length - 1];
  if (r.toLowerCase() === "cimode") return !0;
  const o = (a, c) => {
    const l = t.services.backendConnector.state[`${a}|${c}`];
    return l === -1 || l === 2
  };
  return n.bindI18n && n.bindI18n.indexOf("languageChanging") > -1 && t.services.backendConnector.backend && t.isLanguageChangingTo && !o(t.isLanguageChangingTo, e) ? !1 : !!(t.hasResourceBundle(r, e) || !t.services.backendConnector.backend || t.options.resources && !t.options.partialBundledLanguages || o(r, e) && (!i || o(s, e)))
}

function $we(e, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  return !t.languages || !t.languages.length ? (f3("i18n.languages were undefined or empty", t.languages), !0) : t.options.ignoreJSONStructure !== void 0 ? t.hasLoadedNamespace(e, {
    lng: n.lng,
    precheck: (i, s) => {
      if (n.bindI18n && n.bindI18n.indexOf("languageChanging") > -1 && i.services.backendConnector.backend && i.isLanguageChangingTo && !s(i.isLanguageChangingTo, e)) return !1
    }
  }) : Mwe(e, t, n)
}
const Lwe = /&(?:amp|#38|lt|#60|gt|#62|apos|#39|quot|#34|nbsp|#160|copy|#169|reg|#174|hellip|#8230|#x2F|#47);/g,
  Bwe = {
    "&amp;": "&",
    "&#38;": "&",
    "&lt;": "<",
    "&#60;": "<",
    "&gt;": ">",
    "&#62;": ">",
    "&apos;": "'",
    "&#39;": "'",
    "&quot;": '"',
    "&#34;": '"',
    "&nbsp;": " ",
    "&#160;": " ",
    "&copy;": "©",
    "&#169;": "©",
    "&reg;": "®",
    "&#174;": "®",
    "&hellip;": "…",
    "&#8230;": "…",
    "&#x2F;": "/",
    "&#47;": "/"
  },
  Fwe = e => Bwe[e],
  jwe = e => e.replace(Lwe, Fwe);
let ZC = {
  bindI18n: "languageChanged",
  bindI18nStore: "",
  transEmptyNodeValue: "",
  transSupportBasicHtmlNodes: !0,
  transWrapTextNodes: "",
  transKeepBasicHtmlNodesFor: ["br", "strong", "i", "p"],
  useSuspense: !0,
  unescape: jwe
};

function Uwe() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  ZC = {
    ...ZC,
    ...e
  }
}

function NH() {
  return ZC
}
let MH;

function zwe(e) {
  MH = e
}

function ZT() {
  return MH
}

function vS(e, t) {
  if (!e) return !1;
  const n = e.props ? e.props.children : e.children;
  return t ? n.length > 0 : !!n
}

function bS(e) {
  if (!e) return [];
  const t = e.props ? e.props.children : e.children;
  return e.props && e.props.i18nIsDynamicList ? V0(t) : t
}

function Hwe(e) {
  return Object.prototype.toString.call(e) !== "[object Array]" ? !1 : e.every(t => j.isValidElement(t))
}

function V0(e) {
  return Array.isArray(e) ? e : [e]
}

function Vwe(e, t) {
  const n = {
    ...t
  };
  return n.props = Object.assign(e.props, t.props), n
}

function $H(e, t) {
  if (!e) return "";
  let n = "";
  const r = V0(e),
    i = t.transSupportBasicHtmlNodes && t.transKeepBasicHtmlNodesFor ? t.transKeepBasicHtmlNodesFor : [];
  return r.forEach((s, o) => {
    if (typeof s == "string") n += `${s}`;
    else if (j.isValidElement(s)) {
      const a = Object.keys(s.props).length,
        c = i.indexOf(s.type) > -1,
        l = s.props.children;
      if (!l && c && a === 0) n += `<${s.type}/>`;
      else if (!l && (!c || a !== 0)) n += `<${o}></${o}>`;
      else if (s.props.i18nIsDynamicList) n += `<${o}></${o}>`;
      else if (c && a === 1 && typeof l == "string") n += `<${s.type}>${l}</${s.type}>`;
      else {
        const u = $H(l, t);
        n += `<${o}>${u}</${o}>`
      }
    } else if (s === null) pw("Trans: the passed in value is invalid - seems you passed in a null child.");
    else if (typeof s == "object") {
      const {
        format: a,
        ...c
      } = s, l = Object.keys(c);
      if (l.length === 1) {
        const u = a ? `${l[0]}, ${a}` : l[0];
        n += `{{${u}}}`
      } else pw("react-i18next: the passed in object contained more than one variable - the object should look like {{ value, format }} where format is optional.", s)
    } else pw("Trans: the passed in value is invalid - seems you passed in a variable like {number} - please pass in variables for interpolation as full objects like {{number}}.", s)
  }), n
}

function Wwe(e, t, n, r, i, s) {
  if (t === "") return [];
  const o = r.transKeepBasicHtmlNodesFor || [],
    a = t && new RegExp(o.map(k => `<${k}`).join("|")).test(t);
  if (!e && !a && !s) return [t];
  const c = {};

  function l(k) {
    V0(k).forEach(p => {
      typeof p != "string" && (vS(p) ? l(bS(p)) : typeof p == "object" && !j.isValidElement(p) && Object.assign(c, p))
    })
  }
  l(e);
  const u = Nwe.parse(`<0>${t}</0>`),
    f = {
      ...c,
      ...i
    };

  function h(k, _, p) {
    const v = bS(k),
      S = y(v, _.children, p);
    return Hwe(v) && S.length === 0 || k.props && k.props.i18nIsDynamicList ? v : S
  }

  function g(k, _, p, v, S) {
    k.dummy ? (k.children = _, p.push(j.cloneElement(k, {
      key: v
    }, S ? void 0 : _))) : p.push(...j.Children.map([k], I => {
      const A = {
        ...I.props
      };
      return delete A.i18nIsDynamicList, Jt.createElement(I.type, K({}, A, {
        key: v,
        ref: I.ref
      }, S ? {} : {
        children: _
      }))
    }))
  }

  function y(k, _, p) {
    const v = V0(k);
    return V0(_).reduce((I, A, w) => {
      const E = A.children && A.children[0] && A.children[0].content && n.services.interpolator.interpolate(A.children[0].content, f, n.language);
      if (A.type === "tag") {
        let D = v[parseInt(A.name, 10)];
        p.length === 1 && !D && (D = p[0][A.name]), D || (D = {});
        const $ = Object.keys(A.attrs).length !== 0 ? Vwe({
            props: A.attrs
          }, D) : D,
          V = j.isValidElement($),
          G = V && vS(A, !0) && !A.voidElement,
          L = a && typeof $ == "object" && $.dummy && !V,
          b = typeof e == "object" && e !== null && Object.hasOwnProperty.call(e, A.name);
        if (typeof $ == "string") {
          const T = n.services.interpolator.interpolate($, f, n.language);
          I.push(T)
        } else if (vS($) || G) {
          const T = h($, A, p);
          g($, T, I, w)
        } else if (L) {
          const T = y(v, A.children, p);
          g($, T, I, w)
        } else if (Number.isNaN(parseFloat(A.name)))
          if (b) {
            const T = h($, A, p);
            g($, T, I, w, A.voidElement)
          } else if (r.transSupportBasicHtmlNodes && o.indexOf(A.name) > -1)
          if (A.voidElement) I.push(j.createElement(A.name, {
            key: `${A.name}-${w}`
          }));
          else {
            const T = y(v, A.children, p);
            I.push(j.createElement(A.name, {
              key: `${A.name}-${w}`
            }, T))
          }
        else if (A.voidElement) I.push(`<${A.name} />`);
        else {
          const T = y(v, A.children, p);
          I.push(`<${A.name}>${T}</${A.name}>`)
        } else if (typeof $ == "object" && !V) {
          const T = A.children[0] ? E : null;
          T && I.push(T)
        } else g($, E, I, w, A.children.length !== 1 || !E)
      } else if (A.type === "text") {
        const D = r.transWrapTextNodes,
          $ = s ? r.unescape(n.services.interpolator.interpolate(A.content, f, n.language)) : n.services.interpolator.interpolate(A.content, f, n.language);
        D ? I.push(j.createElement(D, {
          key: `${A.name}-${w}`
        }, $)) : I.push($)
      }
      return I
    }, [])
  }
  const x = y([{
    dummy: !0,
    children: e || []
  }], u, V0(e || []));
  return bS(x[0])
}

function qwe(e) {
  let {
    children: t,
    count: n,
    parent: r,
    i18nKey: i,
    context: s,
    tOptions: o = {},
    values: a,
    defaults: c,
    components: l,
    ns: u,
    i18n: f,
    t: h,
    shouldUnescape: g,
    ...y
  } = e;
  const x = f || ZT();
  if (!x) return f3("You will need to pass in an i18next instance by using i18nextReactModule"), t;
  const k = h || x.t.bind(x) || (G => G);
  s && (o.context = s);
  const _ = {
    ...NH(),
    ...x.options && x.options.react
  };
  let p = u || k.ns || x.options && x.options.defaultNS;
  p = typeof p == "string" ? [p] : p || ["translation"];
  const v = $H(t, _),
    S = c || v || _.transEmptyNodeValue || i,
    {
      hashTransKey: I
    } = _,
    A = i || (I ? I(v || S) : v || S);
  x.options && x.options.interpolation && x.options.interpolation.defaultVariables && (a = a && Object.keys(a).length > 0 ? {
    ...a,
    ...x.options.interpolation.defaultVariables
  } : {
    ...x.options.interpolation.defaultVariables
  });
  const w = a ? o.interpolation : {
      interpolation: {
        ...o.interpolation,
        prefix: "#$?",
        suffix: "?$#"
      }
    },
    E = {
      ...o,
      count: n,
      ...a,
      ...w,
      defaultValue: S,
      ns: p
    },
    D = A ? k(A, E) : S;
  l && Object.keys(l).forEach(G => {
    const L = l[G];
    if (typeof L.type == "function" || !L.props || !L.props.children || D.indexOf(`${G}/>`) < 0 && D.indexOf(`${G} />`) < 0) return;

    function b() {
      return Jt.createElement(Jt.Fragment, null, L)
    }
    l[G] = Jt.createElement(b, null)
  });
  const $ = Wwe(l || t, D, x, _, E, g),
    V = r !== void 0 ? r : _.defaultTransParent;
  return V ? j.createElement(V, y, $) : $
}
const Gwe = {
    type: "3rdParty",
    init(e) {
      Uwe(e.options.react), zwe(e)
    }
  },
  ek = j.createContext();
class Kwe {
  constructor() {
    this.usedNamespaces = {}
  }
  addUsedNamespaces(t) {
    t.forEach(n => {
      this.usedNamespaces[n] || (this.usedNamespaces[n] = !0)
    })
  }
  getUsedNamespaces() {
    return Object.keys(this.usedNamespaces)
  }
}

function tk(e) {
  let {
    children: t,
    count: n,
    parent: r,
    i18nKey: i,
    context: s,
    tOptions: o = {},
    values: a,
    defaults: c,
    components: l,
    ns: u,
    i18n: f,
    t: h,
    shouldUnescape: g,
    ...y
  } = e;
  const {
    i18n: x,
    defaultNS: k
  } = j.useContext(ek) || {}, _ = f || x || ZT(), p = h || _ && _.t.bind(_);
  return qwe({
    children: t,
    count: n,
    parent: r,
    i18nKey: i,
    context: s,
    tOptions: o,
    values: a,
    defaults: c,
    components: l,
    ns: u || p && p.ns || k || _ && _.options && _.options.defaultNS,
    i18n: _,
    t: h,
    shouldUnescape: g,
    ...y
  })
}
const Qwe = (e, t) => {
  const n = j.useRef();
  return j.useEffect(() => {
    n.current = t ? n.current : e
  }, [e, t]), n.current
};

function ft(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    i18n: n
  } = t, {
    i18n: r,
    defaultNS: i
  } = j.useContext(ek) || {}, s = n || r || ZT();
  if (s && !s.reportNamespaces && (s.reportNamespaces = new Kwe), !s) {
    f3("You will need to pass in an i18next instance by using initReactI18next");
    const v = (I, A) => typeof A == "string" ? A : A && typeof A == "object" && typeof A.defaultValue == "string" ? A.defaultValue : Array.isArray(I) ? I[I.length - 1] : I,
      S = [v, {}, !1];
    return S.t = v, S.i18n = {}, S.ready = !1, S
  }
  s.options.react && s.options.react.wait !== void 0 && f3("It seems you are still using the old wait option, you may migrate to the new useSuspense behaviour.");
  const o = {
      ...NH(),
      ...s.options.react,
      ...t
    },
    {
      useSuspense: a,
      keyPrefix: c
    } = o;
  let l = e || i || s.options && s.options.defaultNS;
  l = typeof l == "string" ? [l] : l || ["translation"], s.reportNamespaces.addUsedNamespaces && s.reportNamespaces.addUsedNamespaces(l);
  const u = (s.isInitialized || s.initializedStoreOnce) && l.every(v => $we(v, s, o));

  function f() {
    return s.getFixedT(t.lng || null, o.nsMode === "fallback" ? l : l[0], c)
  }
  const [h, g] = j.useState(f);
  let y = l.join();
  t.lng && (y = `${t.lng}${y}`);
  const x = Qwe(y),
    k = j.useRef(!0);
  j.useEffect(() => {
    const {
      bindI18n: v,
      bindI18nStore: S
    } = o;
    k.current = !0, !u && !a && (t.lng ? yN(s, t.lng, l, () => {
      k.current && g(f)
    }) : gN(s, l, () => {
      k.current && g(f)
    })), u && x && x !== y && k.current && g(f);

    function I() {
      k.current && g(f)
    }
    return v && s && s.on(v, I), S && s && s.store.on(S, I), () => {
      k.current = !1, v && s && v.split(" ").forEach(A => s.off(A, I)), S && s && S.split(" ").forEach(A => s.store.off(A, I))
    }
  }, [s, y]);
  const _ = j.useRef(!0);
  j.useEffect(() => {
    k.current && !_.current && g(f), _.current = !1
  }, [s, c]);
  const p = [h, s, u];
  if (p.t = h, p.i18n = s, p.ready = u, u || !u && !a) return p;
  throw new Promise(v => {
    t.lng ? yN(s, t.lng, l, () => v()) : gN(s, l, () => v())
  })
}

function Ywe(e) {
  let {
    i18n: t,
    defaultNS: n,
    children: r
  } = e;
  const i = j.useMemo(() => ({
    i18n: t,
    defaultNS: n
  }), [t, n]);
  return j.createElement(ek.Provider, {
    value: i
  }, r)
}
const Jwe = (e, t) => typeof e == "number" ? `${e}px` : typeof e == "string" && !e.includes("%") ? e : typeof t == "number" ? `${t}px` : typeof t == "string" && !t.includes("%") ? t : "392px",
  Xwe = me(ur, {
    shouldForwardProp: e => !["open", "drawerProps"].includes(e)
  })(({
    theme: e,
    open: t,
    drawerProps: n
  }) => ({
    background: e.palette.mode === "light" ? e.palette.common.black : e.palette.common.white,
    color: e.palette.mode === "light" ? e.palette.common.white : e.palette.common.black,
    alignItems: "center",
    borderRadius: `${e.shape.borderRadiusSecondary}px 0 0 ${e.shape.borderRadiusSecondary}px`,
    display: "flex",
    flexDirection: "column",
    justifyContent: "center",
    minHeight: 144,
    minWidth: 40,
    padding: e.spacing(1, 0, 1, 0),
    position: "absolute",
    right: 0,
    top: "calc(50% - 74px)",
    transform: `translate3d(calc(${t?Jwe(n==null?void 0:n.width,n==null?void 0:n.maxWidth):"0px"} * -1), 0, 0)`,
    transition: e.transitions.create(["transform"], {
      duration: t ? e.transitions.duration.enteringScreen : e.transitions.duration.leavingScreen,
      easing: t ? e.transitions.easing.easeOut : e.transitions.easing.sharp
    }),
    zIndex: 1500,
    "&:hover": {
      background: e.palette.mode === "light" ? e.palette.common.black : e.palette.common.white
    },
    svg: {
      color: e.palette.mode === "light" ? e.palette.common.white : e.palette.common.black
    }
  })),
  Zwe = me(Ue)(({
    theme: e
  }) => ({
    borderRadius: `0 ${e.shape.borderRadiusSecondary}px ${e.shape.borderRadiusSecondary}px 0`,
    background: e.palette.mode === "light" ? e.palette.common.black : e.palette.common.white,
    color: e.palette.mode === "light" ? e.palette.common.white : e.palette.common.black,
    cursor: "pointer",
    display: "flex",
    flexDirection: "row",
    padding: e.spacing(1),
    position: "relative",
    textTransform: "none",
    transform: "rotateZ(180deg)",
    writingMode: "vertical-rl"
  }));
me(_s)(() => ({
  position: "absolute",
  top: "12px",
  right: "26px",
  zIndex: 1,
  height: "40px",
  width: "40px",
  alignItems: "center",
  justifyContent: "center"
}));
const LH = j.createContext({}),
  e3e = () => j.useContext(LH);
class vm {
  constructor() {
    this.listeners = new Set, this.subscribe = this.subscribe.bind(this)
  }
  subscribe(t) {
    const n = {
      listener: t
    };
    return this.listeners.add(n), this.onSubscribe(), () => {
      this.listeners.delete(n), this.onUnsubscribe()
    }
  }
  hasListeners() {
    return this.listeners.size > 0
  }
  onSubscribe() {}
  onUnsubscribe() {}
}
const n2 = typeof window > "u" || "Deno" in window;

function ma() {}

function t3e(e, t) {
  return typeof e == "function" ? e(t) : e
}

function eA(e) {
  return typeof e == "number" && e >= 0 && e !== 1 / 0
}

function BH(e, t) {
  return Math.max(e + (t || 0) - Date.now(), 0)
}

function r1(e, t, n) {
  return J2(e) ? typeof t == "function" ? {
    ...n,
    queryKey: e,
    queryFn: t
  } : {
    ...t,
    queryKey: e
  } : e
}

function n3e(e, t, n) {
  return J2(e) ? typeof t == "function" ? {
    ...n,
    mutationKey: e,
    mutationFn: t
  } : {
    ...t,
    mutationKey: e
  } : typeof e == "function" ? {
    ...t,
    mutationFn: e
  } : {
    ...e
  }
}

function Zu(e, t, n) {
  return J2(e) ? [{
    ...t,
    queryKey: e
  }, n] : [e || {}, t]
}

function vN(e, t) {
  const {
    type: n = "all",
    exact: r,
    fetchStatus: i,
    predicate: s,
    queryKey: o,
    stale: a
  } = e;
  if (J2(o)) {
    if (r) {
      if (t.queryHash !== nk(o, t.options)) return !1
    } else if (!h3(t.queryKey, o)) return !1
  }
  if (n !== "all") {
    const c = t.isActive();
    if (n === "active" && !c || n === "inactive" && c) return !1
  }
  return !(typeof a == "boolean" && t.isStale() !== a || typeof i < "u" && i !== t.state.fetchStatus || s && !s(t))
}

function bN(e, t) {
  const {
    exact: n,
    fetching: r,
    predicate: i,
    mutationKey: s
  } = e;
  if (J2(s)) {
    if (!t.options.mutationKey) return !1;
    if (n) {
      if (Df(t.options.mutationKey) !== Df(s)) return !1
    } else if (!h3(t.options.mutationKey, s)) return !1
  }
  return !(typeof r == "boolean" && t.state.status === "loading" !== r || i && !i(t))
}

function nk(e, t) {
  return ((t == null ? void 0 : t.queryKeyHashFn) || Df)(e)
}

function Df(e) {
  return JSON.stringify(e, (t, n) => tA(n) ? Object.keys(n).sort().reduce((r, i) => (r[i] = n[i], r), {}) : n)
}

function h3(e, t) {
  return FH(e, t)
}

function FH(e, t) {
  return e === t ? !0 : typeof e != typeof t ? !1 : e && t && typeof e == "object" && typeof t == "object" ? !Object.keys(t).some(n => !FH(e[n], t[n])) : !1
}

function jH(e, t) {
  if (e === t) return e;
  const n = wN(e) && wN(t);
  if (n || tA(e) && tA(t)) {
    const r = n ? e.length : Object.keys(e).length,
      i = n ? t : Object.keys(t),
      s = i.length,
      o = n ? [] : {};
    let a = 0;
    for (let c = 0; c < s; c++) {
      const l = n ? c : i[c];
      o[l] = jH(e[l], t[l]), o[l] === e[l] && a++
    }
    return r === s && a === r ? e : o
  }
  return t
}

function p3(e, t) {
  if (e && !t || t && !e) return !1;
  for (const n in e)
    if (e[n] !== t[n]) return !1;
  return !0
}

function wN(e) {
  return Array.isArray(e) && e.length === Object.keys(e).length
}

function tA(e) {
  if (!xN(e)) return !1;
  const t = e.constructor;
  if (typeof t > "u") return !0;
  const n = t.prototype;
  return !(!xN(n) || !n.hasOwnProperty("isPrototypeOf"))
}

function xN(e) {
  return Object.prototype.toString.call(e) === "[object Object]"
}

function J2(e) {
  return Array.isArray(e)
}

function UH(e) {
  return new Promise(t => {
    setTimeout(t, e)
  })
}

function EN(e) {
  UH(0).then(e)
}

function r3e() {
  if (typeof AbortController == "function") return new AbortController
}

function nA(e, t, n) {
  return n.isDataEqual != null && n.isDataEqual(e, t) ? e : typeof n.structuralSharing == "function" ? n.structuralSharing(e, t) : n.structuralSharing !== !1 ? jH(e, t) : t
}
class i3e extends vm {
  constructor() {
    super(), this.setup = t => {
      if (!n2 && window.addEventListener) {
        const n = () => t();
        return window.addEventListener("visibilitychange", n, !1), window.addEventListener("focus", n, !1), () => {
          window.removeEventListener("visibilitychange", n), window.removeEventListener("focus", n)
        }
      }
    }
  }
  onSubscribe() {
    this.cleanup || this.setEventListener(this.setup)
  }
  onUnsubscribe() {
    if (!this.hasListeners()) {
      var t;
      (t = this.cleanup) == null || t.call(this), this.cleanup = void 0
    }
  }
  setEventListener(t) {
    var n;
    this.setup = t, (n = this.cleanup) == null || n.call(this), this.cleanup = t(r => {
      typeof r == "boolean" ? this.setFocused(r) : this.onFocus()
    })
  }
  setFocused(t) {
    this.focused !== t && (this.focused = t, this.onFocus())
  }
  onFocus() {
    this.listeners.forEach(({
      listener: t
    }) => {
      t()
    })
  }
  isFocused() {
    return typeof this.focused == "boolean" ? this.focused : typeof document > "u" ? !0 : [void 0, "visible", "prerender"].includes(document.visibilityState)
  }
}
const m3 = new i3e,
  SN = ["online", "offline"];
class s3e extends vm {
  constructor() {
    super(), this.setup = t => {
      if (!n2 && window.addEventListener) {
        const n = () => t();
        return SN.forEach(r => {
          window.addEventListener(r, n, !1)
        }), () => {
          SN.forEach(r => {
            window.removeEventListener(r, n)
          })
        }
      }
    }
  }
  onSubscribe() {
    this.cleanup || this.setEventListener(this.setup)
  }
  onUnsubscribe() {
    if (!this.hasListeners()) {
      var t;
      (t = this.cleanup) == null || t.call(this), this.cleanup = void 0
    }
  }
  setEventListener(t) {
    var n;
    this.setup = t, (n = this.cleanup) == null || n.call(this), this.cleanup = t(r => {
      typeof r == "boolean" ? this.setOnline(r) : this.onOnline()
    })
  }
  setOnline(t) {
    this.online !== t && (this.online = t, this.onOnline())
  }
  onOnline() {
    this.listeners.forEach(({
      listener: t
    }) => {
      t()
    })
  }
  isOnline() {
    return typeof this.online == "boolean" ? this.online : typeof navigator > "u" || typeof navigator.onLine > "u" ? !0 : navigator.onLine
  }
}
const g3 = new s3e;

function o3e(e) {
  return Math.min(1e3 * 2 ** e, 3e4)
}

function $5(e) {
  return (e ?? "online") === "online" ? g3.isOnline() : !0
}
class zH {
  constructor(t) {
    this.revert = t == null ? void 0 : t.revert, this.silent = t == null ? void 0 : t.silent
  }
}

function mw(e) {
  return e instanceof zH
}

function HH(e) {
  let t = !1,
    n = 0,
    r = !1,
    i, s, o;
  const a = new Promise((k, _) => {
      s = k, o = _
    }),
    c = k => {
      r || (g(new zH(k)), e.abort == null || e.abort())
    },
    l = () => {
      t = !0
    },
    u = () => {
      t = !1
    },
    f = () => !m3.isFocused() || e.networkMode !== "always" && !g3.isOnline(),
    h = k => {
      r || (r = !0, e.onSuccess == null || e.onSuccess(k), i == null || i(), s(k))
    },
    g = k => {
      r || (r = !0, e.onError == null || e.onError(k), i == null || i(), o(k))
    },
    y = () => new Promise(k => {
      i = _ => {
        const p = r || !f();
        return p && k(_), p
      }, e.onPause == null || e.onPause()
    }).then(() => {
      i = void 0, r || e.onContinue == null || e.onContinue()
    }),
    x = () => {
      if (r) return;
      let k;
      try {
        k = e.fn()
      } catch (_) {
        k = Promise.reject(_)
      }
      Promise.resolve(k).then(h).catch(_ => {
        var p, v;
        if (r) return;
        const S = (p = e.retry) != null ? p : 3,
          I = (v = e.retryDelay) != null ? v : o3e,
          A = typeof I == "function" ? I(n, _) : I,
          w = S === !0 || typeof S == "number" && n < S || typeof S == "function" && S(n, _);
        if (t || !w) {
          g(_);
          return
        }
        n++, e.onFail == null || e.onFail(n, _), UH(A).then(() => {
          if (f()) return y()
        }).then(() => {
          t ? g(_) : x()
        })
      })
    };
  return $5(e.networkMode) ? x() : y().then(x), {
    promise: a,
    cancel: c,
    continue: () => (i == null ? void 0 : i()) ? a : Promise.resolve(),
    cancelRetry: l,
    continueRetry: u
  }
}
const rk = console;

function a3e() {
  let e = [],
    t = 0,
    n = u => {
      u()
    },
    r = u => {
      u()
    };
  const i = u => {
      let f;
      t++;
      try {
        f = u()
      } finally {
        t--, t || a()
      }
      return f
    },
    s = u => {
      t ? e.push(u) : EN(() => {
        n(u)
      })
    },
    o = u => (...f) => {
      s(() => {
        u(...f)
      })
    },
    a = () => {
      const u = e;
      e = [], u.length && EN(() => {
        r(() => {
          u.forEach(f => {
            n(f)
          })
        })
      })
    };
  return {
    batch: i,
    batchCalls: o,
    schedule: s,
    setNotifyFunction: u => {
      n = u
    },
    setBatchNotifyFunction: u => {
      r = u
    }
  }
}
const Ur = a3e();
class VH {
  destroy() {
    this.clearGcTimeout()
  }
  scheduleGc() {
    this.clearGcTimeout(), eA(this.cacheTime) && (this.gcTimeout = setTimeout(() => {
      this.optionalRemove()
    }, this.cacheTime))
  }
  updateCacheTime(t) {
    this.cacheTime = Math.max(this.cacheTime || 0, t ?? (n2 ? 1 / 0 : 5 * 60 * 1e3))
  }
  clearGcTimeout() {
    this.gcTimeout && (clearTimeout(this.gcTimeout), this.gcTimeout = void 0)
  }
}
class c3e extends VH {
  constructor(t) {
    super(), this.abortSignalConsumed = !1, this.defaultOptions = t.defaultOptions, this.setOptions(t.options), this.observers = [], this.cache = t.cache, this.logger = t.logger || rk, this.queryKey = t.queryKey, this.queryHash = t.queryHash, this.initialState = t.state || l3e(this.options), this.state = this.initialState, this.scheduleGc()
  }
  get meta() {
    return this.options.meta
  }
  setOptions(t) {
    this.options = {
      ...this.defaultOptions,
      ...t
    }, this.updateCacheTime(this.options.cacheTime)
  }
  optionalRemove() {
    !this.observers.length && this.state.fetchStatus === "idle" && this.cache.remove(this)
  }
  setData(t, n) {
    const r = nA(this.state.data, t, this.options);
    return this.dispatch({
      data: r,
      type: "success",
      dataUpdatedAt: n == null ? void 0 : n.updatedAt,
      manual: n == null ? void 0 : n.manual
    }), r
  }
  setState(t, n) {
    this.dispatch({
      type: "setState",
      state: t,
      setStateOptions: n
    })
  }
  cancel(t) {
    var n;
    const r = this.promise;
    return (n = this.retryer) == null || n.cancel(t), r ? r.then(ma).catch(ma) : Promise.resolve()
  }
  destroy() {
    super.destroy(), this.cancel({
      silent: !0
    })
  }
  reset() {
    this.destroy(), this.setState(this.initialState)
  }
  isActive() {
    return this.observers.some(t => t.options.enabled !== !1)
  }
  isDisabled() {
    return this.getObserversCount() > 0 && !this.isActive()
  }
  isStale() {
    return this.state.isInvalidated || !this.state.dataUpdatedAt || this.observers.some(t => t.getCurrentResult().isStale)
  }
  isStaleByTime(t = 0) {
    return this.state.isInvalidated || !this.state.dataUpdatedAt || !BH(this.state.dataUpdatedAt, t)
  }
  onFocus() {
    var t;
    const n = this.observers.find(r => r.shouldFetchOnWindowFocus());
    n && n.refetch({
      cancelRefetch: !1
    }), (t = this.retryer) == null || t.continue()
  }
  onOnline() {
    var t;
    const n = this.observers.find(r => r.shouldFetchOnReconnect());
    n && n.refetch({
      cancelRefetch: !1
    }), (t = this.retryer) == null || t.continue()
  }
  addObserver(t) {
    this.observers.includes(t) || (this.observers.push(t), this.clearGcTimeout(), this.cache.notify({
      type: "observerAdded",
      query: this,
      observer: t
    }))
  }
  removeObserver(t) {
    this.observers.includes(t) && (this.observers = this.observers.filter(n => n !== t), this.observers.length || (this.retryer && (this.abortSignalConsumed ? this.retryer.cancel({
      revert: !0
    }) : this.retryer.cancelRetry()), this.scheduleGc()), this.cache.notify({
      type: "observerRemoved",
      query: this,
      observer: t
    }))
  }
  getObserversCount() {
    return this.observers.length
  }
  invalidate() {
    this.state.isInvalidated || this.dispatch({
      type: "invalidate"
    })
  }
  fetch(t, n) {
    var r, i;
    if (this.state.fetchStatus !== "idle") {
      if (this.state.dataUpdatedAt && n != null && n.cancelRefetch) this.cancel({
        silent: !0
      });
      else if (this.promise) {
        var s;
        return (s = this.retryer) == null || s.continueRetry(), this.promise
      }
    }
    if (t && this.setOptions(t), !this.options.queryFn) {
      const g = this.observers.find(y => y.options.queryFn);
      g && this.setOptions(g.options)
    }
    const o = r3e(),
      a = {
        queryKey: this.queryKey,
        pageParam: void 0,
        meta: this.meta
      },
      c = g => {
        Object.defineProperty(g, "signal", {
          enumerable: !0,
          get: () => {
            if (o) return this.abortSignalConsumed = !0, o.signal
          }
        })
      };
    c(a);
    const l = () => this.options.queryFn ? (this.abortSignalConsumed = !1, this.options.queryFn(a)) : Promise.reject("Missing queryFn for queryKey '" + this.options.queryHash + "'"),
      u = {
        fetchOptions: n,
        options: this.options,
        queryKey: this.queryKey,
        state: this.state,
        fetchFn: l
      };
    if (c(u), (r = this.options.behavior) == null || r.onFetch(u), this.revertState = this.state, this.state.fetchStatus === "idle" || this.state.fetchMeta !== ((i = u.fetchOptions) == null ? void 0 : i.meta)) {
      var f;
      this.dispatch({
        type: "fetch",
        meta: (f = u.fetchOptions) == null ? void 0 : f.meta
      })
    }
    const h = g => {
      if (mw(g) && g.silent || this.dispatch({
          type: "error",
          error: g
        }), !mw(g)) {
        var y, x, k, _;
        (y = (x = this.cache.config).onError) == null || y.call(x, g, this), (k = (_ = this.cache.config).onSettled) == null || k.call(_, this.state.data, g, this)
      }
      this.isFetchingOptimistic || this.scheduleGc(), this.isFetchingOptimistic = !1
    };
    return this.retryer = HH({
      fn: u.fetchFn,
      abort: o == null ? void 0 : o.abort.bind(o),
      onSuccess: g => {
        var y, x, k, _;
        if (typeof g > "u") {
          h(new Error(this.queryHash + " data is undefined"));
          return
        }
        this.setData(g), (y = (x = this.cache.config).onSuccess) == null || y.call(x, g, this), (k = (_ = this.cache.config).onSettled) == null || k.call(_, g, this.state.error, this), this.isFetchingOptimistic || this.scheduleGc(), this.isFetchingOptimistic = !1
      },
      onError: h,
      onFail: (g, y) => {
        this.dispatch({
          type: "failed",
          failureCount: g,
          error: y
        })
      },
      onPause: () => {
        this.dispatch({
          type: "pause"
        })
      },
      onContinue: () => {
        this.dispatch({
          type: "continue"
        })
      },
      retry: u.options.retry,
      retryDelay: u.options.retryDelay,
      networkMode: u.options.networkMode
    }), this.promise = this.retryer.promise, this.promise
  }
  dispatch(t) {
    const n = r => {
      var i, s;
      switch (t.type) {
        case "failed":
          return {
            ...r, fetchFailureCount: t.failureCount, fetchFailureReason: t.error
          };
        case "pause":
          return {
            ...r, fetchStatus: "paused"
          };
        case "continue":
          return {
            ...r, fetchStatus: "fetching"
          };
        case "fetch":
          return {
            ...r, fetchFailureCount: 0, fetchFailureReason: null, fetchMeta: (i = t.meta) != null ? i : null, fetchStatus: $5(this.options.networkMode) ? "fetching" : "paused", ...!r.dataUpdatedAt && {
              error: null,
              status: "loading"
            }
          };
        case "success":
          return {
            ...r, data: t.data, dataUpdateCount: r.dataUpdateCount + 1, dataUpdatedAt: (s = t.dataUpdatedAt) != null ? s : Date.now(), error: null, isInvalidated: !1, status: "success", ...!t.manual && {
              fetchStatus: "idle",
              fetchFailureCount: 0,
              fetchFailureReason: null
            }
          };
        case "error":
          const o = t.error;
          return mw(o) && o.revert && this.revertState ? {
            ...this.revertState,
            fetchStatus: "idle"
          } : {
            ...r,
            error: o,
            errorUpdateCount: r.errorUpdateCount + 1,
            errorUpdatedAt: Date.now(),
            fetchFailureCount: r.fetchFailureCount + 1,
            fetchFailureReason: o,
            fetchStatus: "idle",
            status: "error"
          };
        case "invalidate":
          return {
            ...r, isInvalidated: !0
          };
        case "setState":
          return {
            ...r, ...t.state
          }
      }
    };
    this.state = n(this.state), Ur.batch(() => {
      this.observers.forEach(r => {
        r.onQueryUpdate(t)
      }), this.cache.notify({
        query: this,
        type: "updated",
        action: t
      })
    })
  }
}

function l3e(e) {
  const t = typeof e.initialData == "function" ? e.initialData() : e.initialData,
    n = typeof t < "u",
    r = n ? typeof e.initialDataUpdatedAt == "function" ? e.initialDataUpdatedAt() : e.initialDataUpdatedAt : 0;
  return {
    data: t,
    dataUpdateCount: 0,
    dataUpdatedAt: n ? r ?? Date.now() : 0,
    error: null,
    errorUpdateCount: 0,
    errorUpdatedAt: 0,
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchMeta: null,
    isInvalidated: !1,
    status: n ? "success" : "loading",
    fetchStatus: "idle"
  }
}
class u3e extends vm {
  constructor(t) {
    super(), this.config = t || {}, this.queries = [], this.queriesMap = {}
  }
  build(t, n, r) {
    var i;
    const s = n.queryKey,
      o = (i = n.queryHash) != null ? i : nk(s, n);
    let a = this.get(o);
    return a || (a = new c3e({
      cache: this,
      logger: t.getLogger(),
      queryKey: s,
      queryHash: o,
      options: t.defaultQueryOptions(n),
      state: r,
      defaultOptions: t.getQueryDefaults(s)
    }), this.add(a)), a
  }
  add(t) {
    this.queriesMap[t.queryHash] || (this.queriesMap[t.queryHash] = t, this.queries.push(t), this.notify({
      type: "added",
      query: t
    }))
  }
  remove(t) {
    const n = this.queriesMap[t.queryHash];
    n && (t.destroy(), this.queries = this.queries.filter(r => r !== t), n === t && delete this.queriesMap[t.queryHash], this.notify({
      type: "removed",
      query: t
    }))
  }
  clear() {
    Ur.batch(() => {
      this.queries.forEach(t => {
        this.remove(t)
      })
    })
  }
  get(t) {
    return this.queriesMap[t]
  }
  getAll() {
    return this.queries
  }
  find(t, n) {
    const [r] = Zu(t, n);
    return typeof r.exact > "u" && (r.exact = !0), this.queries.find(i => vN(r, i))
  }
  findAll(t, n) {
    const [r] = Zu(t, n);
    return Object.keys(r).length > 0 ? this.queries.filter(i => vN(r, i)) : this.queries
  }
  notify(t) {
    Ur.batch(() => {
      this.listeners.forEach(({
        listener: n
      }) => {
        n(t)
      })
    })
  }
  onFocus() {
    Ur.batch(() => {
      this.queries.forEach(t => {
        t.onFocus()
      })
    })
  }
  onOnline() {
    Ur.batch(() => {
      this.queries.forEach(t => {
        t.onOnline()
      })
    })
  }
}
class d3e extends VH {
  constructor(t) {
    super(), this.defaultOptions = t.defaultOptions, this.mutationId = t.mutationId, this.mutationCache = t.mutationCache, this.logger = t.logger || rk, this.observers = [], this.state = t.state || WH(), this.setOptions(t.options), this.scheduleGc()
  }
  setOptions(t) {
    this.options = {
      ...this.defaultOptions,
      ...t
    }, this.updateCacheTime(this.options.cacheTime)
  }
  get meta() {
    return this.options.meta
  }
  setState(t) {
    this.dispatch({
      type: "setState",
      state: t
    })
  }
  addObserver(t) {
    this.observers.includes(t) || (this.observers.push(t), this.clearGcTimeout(), this.mutationCache.notify({
      type: "observerAdded",
      mutation: this,
      observer: t
    }))
  }
  removeObserver(t) {
    this.observers = this.observers.filter(n => n !== t), this.scheduleGc(), this.mutationCache.notify({
      type: "observerRemoved",
      mutation: this,
      observer: t
    })
  }
  optionalRemove() {
    this.observers.length || (this.state.status === "loading" ? this.scheduleGc() : this.mutationCache.remove(this))
  }
  continue () {
    var t, n;
    return (t = (n = this.retryer) == null ? void 0 : n.continue()) != null ? t : this.execute()
  }
  async execute() {
    const t = () => {
        var w;
        return this.retryer = HH({
          fn: () => this.options.mutationFn ? this.options.mutationFn(this.state.variables) : Promise.reject("No mutationFn found"),
          onFail: (E, D) => {
            this.dispatch({
              type: "failed",
              failureCount: E,
              error: D
            })
          },
          onPause: () => {
            this.dispatch({
              type: "pause"
            })
          },
          onContinue: () => {
            this.dispatch({
              type: "continue"
            })
          },
          retry: (w = this.options.retry) != null ? w : 0,
          retryDelay: this.options.retryDelay,
          networkMode: this.options.networkMode
        }), this.retryer.promise
      },
      n = this.state.status === "loading";
    try {
      var r, i, s, o, a, c, l, u;
      if (!n) {
        var f, h, g, y;
        this.dispatch({
          type: "loading",
          variables: this.options.variables
        }), await ((f = (h = this.mutationCache.config).onMutate) == null ? void 0 : f.call(h, this.state.variables, this));
        const E = await ((g = (y = this.options).onMutate) == null ? void 0 : g.call(y, this.state.variables));
        E !== this.state.context && this.dispatch({
          type: "loading",
          context: E,
          variables: this.state.variables
        })
      }
      const w = await t();
      return await ((r = (i = this.mutationCache.config).onSuccess) == null ? void 0 : r.call(i, w, this.state.variables, this.state.context, this)), await ((s = (o = this.options).onSuccess) == null ? void 0 : s.call(o, w, this.state.variables, this.state.context)), await ((a = (c = this.mutationCache.config).onSettled) == null ? void 0 : a.call(c, w, null, this.state.variables, this.state.context, this)), await ((l = (u = this.options).onSettled) == null ? void 0 : l.call(u, w, null, this.state.variables, this.state.context)), this.dispatch({
        type: "success",
        data: w
      }), w
    } catch (w) {
      try {
        var x, k, _, p, v, S, I, A;
        throw await ((x = (k = this.mutationCache.config).onError) == null ? void 0 : x.call(k, w, this.state.variables, this.state.context, this)), await ((_ = (p = this.options).onError) == null ? void 0 : _.call(p, w, this.state.variables, this.state.context)), await ((v = (S = this.mutationCache.config).onSettled) == null ? void 0 : v.call(S, void 0, w, this.state.variables, this.state.context, this)), await ((I = (A = this.options).onSettled) == null ? void 0 : I.call(A, void 0, w, this.state.variables, this.state.context)), w
      } finally {
        this.dispatch({
          type: "error",
          error: w
        })
      }
    }
  }
  dispatch(t) {
    const n = r => {
      switch (t.type) {
        case "failed":
          return {
            ...r, failureCount: t.failureCount, failureReason: t.error
          };
        case "pause":
          return {
            ...r, isPaused: !0
          };
        case "continue":
          return {
            ...r, isPaused: !1
          };
        case "loading":
          return {
            ...r, context: t.context, data: void 0, failureCount: 0, failureReason: null, error: null, isPaused: !$5(this.options.networkMode), status: "loading", variables: t.variables
          };
        case "success":
          return {
            ...r, data: t.data, failureCount: 0, failureReason: null, error: null, status: "success", isPaused: !1
          };
        case "error":
          return {
            ...r, data: void 0, error: t.error, failureCount: r.failureCount + 1, failureReason: t.error, isPaused: !1, status: "error"
          };
        case "setState":
          return {
            ...r, ...t.state
          }
      }
    };
    this.state = n(this.state), Ur.batch(() => {
      this.observers.forEach(r => {
        r.onMutationUpdate(t)
      }), this.mutationCache.notify({
        mutation: this,
        type: "updated",
        action: t
      })
    })
  }
}

function WH() {
  return {
    context: void 0,
    data: void 0,
    error: null,
    failureCount: 0,
    failureReason: null,
    isPaused: !1,
    status: "idle",
    variables: void 0
  }
}
class f3e extends vm {
  constructor(t) {
    super(), this.config = t || {}, this.mutations = [], this.mutationId = 0
  }
  build(t, n, r) {
    const i = new d3e({
      mutationCache: this,
      logger: t.getLogger(),
      mutationId: ++this.mutationId,
      options: t.defaultMutationOptions(n),
      state: r,
      defaultOptions: n.mutationKey ? t.getMutationDefaults(n.mutationKey) : void 0
    });
    return this.add(i), i
  }
  add(t) {
    this.mutations.push(t), this.notify({
      type: "added",
      mutation: t
    })
  }
  remove(t) {
    this.mutations = this.mutations.filter(n => n !== t), this.notify({
      type: "removed",
      mutation: t
    })
  }
  clear() {
    Ur.batch(() => {
      this.mutations.forEach(t => {
        this.remove(t)
      })
    })
  }
  getAll() {
    return this.mutations
  }
  find(t) {
    return typeof t.exact > "u" && (t.exact = !0), this.mutations.find(n => bN(t, n))
  }
  findAll(t) {
    return this.mutations.filter(n => bN(t, n))
  }
  notify(t) {
    Ur.batch(() => {
      this.listeners.forEach(({
        listener: n
      }) => {
        n(t)
      })
    })
  }
  resumePausedMutations() {
    var t;
    return this.resuming = ((t = this.resuming) != null ? t : Promise.resolve()).then(() => {
      const n = this.mutations.filter(r => r.state.isPaused);
      return Ur.batch(() => n.reduce((r, i) => r.then(() => i.continue().catch(ma)), Promise.resolve()))
    }).then(() => {
      this.resuming = void 0
    }), this.resuming
  }
}

function h3e() {
  return {
    onFetch: e => {
      e.fetchFn = () => {
        var t, n, r, i, s, o;
        const a = (t = e.fetchOptions) == null || (n = t.meta) == null ? void 0 : n.refetchPage,
          c = (r = e.fetchOptions) == null || (i = r.meta) == null ? void 0 : i.fetchMore,
          l = c == null ? void 0 : c.pageParam,
          u = (c == null ? void 0 : c.direction) === "forward",
          f = (c == null ? void 0 : c.direction) === "backward",
          h = ((s = e.state.data) == null ? void 0 : s.pages) || [],
          g = ((o = e.state.data) == null ? void 0 : o.pageParams) || [];
        let y = g,
          x = !1;
        const k = A => {
            Object.defineProperty(A, "signal", {
              enumerable: !0,
              get: () => {
                var w;
                if ((w = e.signal) != null && w.aborted) x = !0;
                else {
                  var E;
                  (E = e.signal) == null || E.addEventListener("abort", () => {
                    x = !0
                  })
                }
                return e.signal
              }
            })
          },
          _ = e.options.queryFn || (() => Promise.reject("Missing queryFn for queryKey '" + e.options.queryHash + "'")),
          p = (A, w, E, D) => (y = D ? [w, ...y] : [...y, w], D ? [E, ...A] : [...A, E]),
          v = (A, w, E, D) => {
            if (x) return Promise.reject("Cancelled");
            if (typeof E > "u" && !w && A.length) return Promise.resolve(A);
            const $ = {
              queryKey: e.queryKey,
              pageParam: E,
              meta: e.options.meta
            };
            k($);
            const V = _($);
            return Promise.resolve(V).then(L => p(A, E, L, D))
          };
        let S;
        if (!h.length) S = v([]);
        else if (u) {
          const A = typeof l < "u",
            w = A ? l : CN(e.options, h);
          S = v(h, A, w)
        } else if (f) {
          const A = typeof l < "u",
            w = A ? l : p3e(e.options, h);
          S = v(h, A, w, !0)
        } else {
          y = [];
          const A = typeof e.options.getNextPageParam > "u";
          S = (a && h[0] ? a(h[0], 0, h) : !0) ? v([], A, g[0]) : Promise.resolve(p([], g[0], h[0]));
          for (let E = 1; E < h.length; E++) S = S.then(D => {
            if (a && h[E] ? a(h[E], E, h) : !0) {
              const V = A ? g[E] : CN(e.options, D);
              return v(D, A, V)
            }
            return Promise.resolve(p(D, g[E], h[E]))
          })
        }
        return S.then(A => ({
          pages: A,
          pageParams: y
        }))
      }
    }
  }
}

function CN(e, t) {
  return e.getNextPageParam == null ? void 0 : e.getNextPageParam(t[t.length - 1], t)
}

function p3e(e, t) {
  return e.getPreviousPageParam == null ? void 0 : e.getPreviousPageParam(t[0], t)
}
class m3e {
  constructor(t = {}) {
    this.queryCache = t.queryCache || new u3e, this.mutationCache = t.mutationCache || new f3e, this.logger = t.logger || rk, this.defaultOptions = t.defaultOptions || {}, this.queryDefaults = [], this.mutationDefaults = [], this.mountCount = 0
  }
  mount() {
    this.mountCount++, this.mountCount === 1 && (this.unsubscribeFocus = m3.subscribe(() => {
      m3.isFocused() && (this.resumePausedMutations(), this.queryCache.onFocus())
    }), this.unsubscribeOnline = g3.subscribe(() => {
      g3.isOnline() && (this.resumePausedMutations(), this.queryCache.onOnline())
    }))
  }
  unmount() {
    var t, n;
    this.mountCount--, this.mountCount === 0 && ((t = this.unsubscribeFocus) == null || t.call(this), this.unsubscribeFocus = void 0, (n = this.unsubscribeOnline) == null || n.call(this), this.unsubscribeOnline = void 0)
  }
  isFetching(t, n) {
    const [r] = Zu(t, n);
    return r.fetchStatus = "fetching", this.queryCache.findAll(r).length
  }
  isMutating(t) {
    return this.mutationCache.findAll({
      ...t,
      fetching: !0
    }).length
  }
  getQueryData(t, n) {
    var r;
    return (r = this.queryCache.find(t, n)) == null ? void 0 : r.state.data
  }
  ensureQueryData(t, n, r) {
    const i = r1(t, n, r),
      s = this.getQueryData(i.queryKey);
    return s ? Promise.resolve(s) : this.fetchQuery(i)
  }
  getQueriesData(t) {
    return this.getQueryCache().findAll(t).map(({
      queryKey: n,
      state: r
    }) => {
      const i = r.data;
      return [n, i]
    })
  }
  setQueryData(t, n, r) {
    const i = this.queryCache.find(t),
      s = i == null ? void 0 : i.state.data,
      o = t3e(n, s);
    if (typeof o > "u") return;
    const a = r1(t),
      c = this.defaultQueryOptions(a);
    return this.queryCache.build(this, c).setData(o, {
      ...r,
      manual: !0
    })
  }
  setQueriesData(t, n, r) {
    return Ur.batch(() => this.getQueryCache().findAll(t).map(({
      queryKey: i
    }) => [i, this.setQueryData(i, n, r)]))
  }
  getQueryState(t, n) {
    var r;
    return (r = this.queryCache.find(t, n)) == null ? void 0 : r.state
  }
  removeQueries(t, n) {
    const [r] = Zu(t, n), i = this.queryCache;
    Ur.batch(() => {
      i.findAll(r).forEach(s => {
        i.remove(s)
      })
    })
  }
  resetQueries(t, n, r) {
    const [i, s] = Zu(t, n, r), o = this.queryCache, a = {
      type: "active",
      ...i
    };
    return Ur.batch(() => (o.findAll(i).forEach(c => {
      c.reset()
    }), this.refetchQueries(a, s)))
  }
  cancelQueries(t, n, r) {
    const [i, s = {}] = Zu(t, n, r);
    typeof s.revert > "u" && (s.revert = !0);
    const o = Ur.batch(() => this.queryCache.findAll(i).map(a => a.cancel(s)));
    return Promise.all(o).then(ma).catch(ma)
  }
  invalidateQueries(t, n, r) {
    const [i, s] = Zu(t, n, r);
    return Ur.batch(() => {
      var o, a;
      if (this.queryCache.findAll(i).forEach(l => {
          l.invalidate()
        }), i.refetchType === "none") return Promise.resolve();
      const c = {
        ...i,
        type: (o = (a = i.refetchType) != null ? a : i.type) != null ? o : "active"
      };
      return this.refetchQueries(c, s)
    })
  }
  refetchQueries(t, n, r) {
    const [i, s] = Zu(t, n, r), o = Ur.batch(() => this.queryCache.findAll(i).filter(c => !c.isDisabled()).map(c => {
      var l;
      return c.fetch(void 0, {
        ...s,
        cancelRefetch: (l = s == null ? void 0 : s.cancelRefetch) != null ? l : !0,
        meta: {
          refetchPage: i.refetchPage
        }
      })
    }));
    let a = Promise.all(o).then(ma);
    return s != null && s.throwOnError || (a = a.catch(ma)), a
  }
  fetchQuery(t, n, r) {
    const i = r1(t, n, r),
      s = this.defaultQueryOptions(i);
    typeof s.retry > "u" && (s.retry = !1);
    const o = this.queryCache.build(this, s);
    return o.isStaleByTime(s.staleTime) ? o.fetch(s) : Promise.resolve(o.state.data)
  }
  prefetchQuery(t, n, r) {
    return this.fetchQuery(t, n, r).then(ma).catch(ma)
  }
  fetchInfiniteQuery(t, n, r) {
    const i = r1(t, n, r);
    return i.behavior = h3e(), this.fetchQuery(i)
  }
  prefetchInfiniteQuery(t, n, r) {
    return this.fetchInfiniteQuery(t, n, r).then(ma).catch(ma)
  }
  resumePausedMutations() {
    return this.mutationCache.resumePausedMutations()
  }
  getQueryCache() {
    return this.queryCache
  }
  getMutationCache() {
    return this.mutationCache
  }
  getLogger() {
    return this.logger
  }
  getDefaultOptions() {
    return this.defaultOptions
  }
  setDefaultOptions(t) {
    this.defaultOptions = t
  }
  setQueryDefaults(t, n) {
    const r = this.queryDefaults.find(i => Df(t) === Df(i.queryKey));
    r ? r.defaultOptions = n : this.queryDefaults.push({
      queryKey: t,
      defaultOptions: n
    })
  }
  getQueryDefaults(t) {
    if (!t) return;
    const n = this.queryDefaults.find(r => h3(t, r.queryKey));
    return n == null ? void 0 : n.defaultOptions
  }
  setMutationDefaults(t, n) {
    const r = this.mutationDefaults.find(i => Df(t) === Df(i.mutationKey));
    r ? r.defaultOptions = n : this.mutationDefaults.push({
      mutationKey: t,
      defaultOptions: n
    })
  }
  getMutationDefaults(t) {
    if (!t) return;
    const n = this.mutationDefaults.find(r => h3(t, r.mutationKey));
    return n == null ? void 0 : n.defaultOptions
  }
  defaultQueryOptions(t) {
    if (t != null && t._defaulted) return t;
    const n = {
      ...this.defaultOptions.queries,
      ...this.getQueryDefaults(t == null ? void 0 : t.queryKey),
      ...t,
      _defaulted: !0
    };
    return !n.queryHash && n.queryKey && (n.queryHash = nk(n.queryKey, n)), typeof n.refetchOnReconnect > "u" && (n.refetchOnReconnect = n.networkMode !== "always"), typeof n.useErrorBoundary > "u" && (n.useErrorBoundary = !!n.suspense), n
  }
  defaultMutationOptions(t) {
    return t != null && t._defaulted ? t : {
      ...this.defaultOptions.mutations,
      ...this.getMutationDefaults(t == null ? void 0 : t.mutationKey),
      ...t,
      _defaulted: !0
    }
  }
  clear() {
    this.queryCache.clear(), this.mutationCache.clear()
  }
}
class g3e extends vm {
  constructor(t, n) {
    super(), this.client = t, this.options = n, this.trackedProps = new Set, this.selectError = null, this.bindMethods(), this.setOptions(n)
  }
  bindMethods() {
    this.remove = this.remove.bind(this), this.refetch = this.refetch.bind(this)
  }
  onSubscribe() {
    this.listeners.size === 1 && (this.currentQuery.addObserver(this), AN(this.currentQuery, this.options) && this.executeFetch(), this.updateTimers())
  }
  onUnsubscribe() {
    this.hasListeners() || this.destroy()
  }
  shouldFetchOnReconnect() {
    return rA(this.currentQuery, this.options, this.options.refetchOnReconnect)
  }
  shouldFetchOnWindowFocus() {
    return rA(this.currentQuery, this.options, this.options.refetchOnWindowFocus)
  }
  destroy() {
    this.listeners = new Set, this.clearStaleTimeout(), this.clearRefetchInterval(), this.currentQuery.removeObserver(this)
  }
  setOptions(t, n) {
    const r = this.options,
      i = this.currentQuery;
    if (this.options = this.client.defaultQueryOptions(t), p3(r, this.options) || this.client.getQueryCache().notify({
        type: "observerOptionsUpdated",
        query: this.currentQuery,
        observer: this
      }), typeof this.options.enabled < "u" && typeof this.options.enabled != "boolean") throw new Error("Expected enabled to be a boolean");
    this.options.queryKey || (this.options.queryKey = r.queryKey), this.updateQuery();
    const s = this.hasListeners();
    s && TN(this.currentQuery, i, this.options, r) && this.executeFetch(), this.updateResult(n), s && (this.currentQuery !== i || this.options.enabled !== r.enabled || this.options.staleTime !== r.staleTime) && this.updateStaleTimeout();
    const o = this.computeRefetchInterval();
    s && (this.currentQuery !== i || this.options.enabled !== r.enabled || o !== this.currentRefetchInterval) && this.updateRefetchInterval(o)
  }
  getOptimisticResult(t) {
    const n = this.client.getQueryCache().build(this.client, t),
      r = this.createResult(n, t);
    return v3e(this, r, t) && (this.currentResult = r, this.currentResultOptions = this.options, this.currentResultState = this.currentQuery.state), r
  }
  getCurrentResult() {
    return this.currentResult
  }
  trackResult(t) {
    const n = {};
    return Object.keys(t).forEach(r => {
      Object.defineProperty(n, r, {
        configurable: !1,
        enumerable: !0,
        get: () => (this.trackedProps.add(r), t[r])
      })
    }), n
  }
  getCurrentQuery() {
    return this.currentQuery
  }
  remove() {
    this.client.getQueryCache().remove(this.currentQuery)
  }
  refetch({
    refetchPage: t,
    ...n
  } = {}) {
    return this.fetch({
      ...n,
      meta: {
        refetchPage: t
      }
    })
  }
  fetchOptimistic(t) {
    const n = this.client.defaultQueryOptions(t),
      r = this.client.getQueryCache().build(this.client, n);
    return r.isFetchingOptimistic = !0, r.fetch().then(() => this.createResult(r, n))
  }
  fetch(t) {
    var n;
    return this.executeFetch({
      ...t,
      cancelRefetch: (n = t.cancelRefetch) != null ? n : !0
    }).then(() => (this.updateResult(), this.currentResult))
  }
  executeFetch(t) {
    this.updateQuery();
    let n = this.currentQuery.fetch(this.options, t);
    return t != null && t.throwOnError || (n = n.catch(ma)), n
  }
  updateStaleTimeout() {
    if (this.clearStaleTimeout(), n2 || this.currentResult.isStale || !eA(this.options.staleTime)) return;
    const n = BH(this.currentResult.dataUpdatedAt, this.options.staleTime) + 1;
    this.staleTimeoutId = setTimeout(() => {
      this.currentResult.isStale || this.updateResult()
    }, n)
  }
  computeRefetchInterval() {
    var t;
    return typeof this.options.refetchInterval == "function" ? this.options.refetchInterval(this.currentResult.data, this.currentQuery) : (t = this.options.refetchInterval) != null ? t : !1
  }
  updateRefetchInterval(t) {
    this.clearRefetchInterval(), this.currentRefetchInterval = t, !(n2 || this.options.enabled === !1 || !eA(this.currentRefetchInterval) || this.currentRefetchInterval === 0) && (this.refetchIntervalId = setInterval(() => {
      (this.options.refetchIntervalInBackground || m3.isFocused()) && this.executeFetch()
    }, this.currentRefetchInterval))
  }
  updateTimers() {
    this.updateStaleTimeout(), this.updateRefetchInterval(this.computeRefetchInterval())
  }
  clearStaleTimeout() {
    this.staleTimeoutId && (clearTimeout(this.staleTimeoutId), this.staleTimeoutId = void 0)
  }
  clearRefetchInterval() {
    this.refetchIntervalId && (clearInterval(this.refetchIntervalId), this.refetchIntervalId = void 0)
  }
  createResult(t, n) {
    const r = this.currentQuery,
      i = this.options,
      s = this.currentResult,
      o = this.currentResultState,
      a = this.currentResultOptions,
      c = t !== r,
      l = c ? t.state : this.currentQueryInitialState,
      u = c ? this.currentResult : this.previousQueryResult,
      {
        state: f
      } = t;
    let {
      dataUpdatedAt: h,
      error: g,
      errorUpdatedAt: y,
      fetchStatus: x,
      status: k
    } = f, _ = !1, p = !1, v;
    if (n._optimisticResults) {
      const E = this.hasListeners(),
        D = !E && AN(t, n),
        $ = E && TN(t, r, n, i);
      (D || $) && (x = $5(t.options.networkMode) ? "fetching" : "paused", h || (k = "loading")), n._optimisticResults === "isRestoring" && (x = "idle")
    }
    if (n.keepPreviousData && !f.dataUpdatedAt && u != null && u.isSuccess && k !== "error") v = u.data, h = u.dataUpdatedAt, k = u.status, _ = !0;
    else if (n.select && typeof f.data < "u")
      if (s && f.data === (o == null ? void 0 : o.data) && n.select === this.selectFn) v = this.selectResult;
      else try {
        this.selectFn = n.select, v = n.select(f.data), v = nA(s == null ? void 0 : s.data, v, n), this.selectResult = v, this.selectError = null
      } catch (E) {
        this.selectError = E
      } else v = f.data;
    if (typeof n.placeholderData < "u" && typeof v > "u" && k === "loading") {
      let E;
      if (s != null && s.isPlaceholderData && n.placeholderData === (a == null ? void 0 : a.placeholderData)) E = s.data;
      else if (E = typeof n.placeholderData == "function" ? n.placeholderData() : n.placeholderData, n.select && typeof E < "u") try {
        E = n.select(E), this.selectError = null
      } catch (D) {
        this.selectError = D
      }
      typeof E < "u" && (k = "success", v = nA(s == null ? void 0 : s.data, E, n), p = !0)
    }
    this.selectError && (g = this.selectError, v = this.selectResult, y = Date.now(), k = "error");
    const S = x === "fetching",
      I = k === "loading",
      A = k === "error";
    return {
      status: k,
      fetchStatus: x,
      isLoading: I,
      isSuccess: k === "success",
      isError: A,
      isInitialLoading: I && S,
      data: v,
      dataUpdatedAt: h,
      error: g,
      errorUpdatedAt: y,
      failureCount: f.fetchFailureCount,
      failureReason: f.fetchFailureReason,
      errorUpdateCount: f.errorUpdateCount,
      isFetched: f.dataUpdateCount > 0 || f.errorUpdateCount > 0,
      isFetchedAfterMount: f.dataUpdateCount > l.dataUpdateCount || f.errorUpdateCount > l.errorUpdateCount,
      isFetching: S,
      isRefetching: S && !I,
      isLoadingError: A && f.dataUpdatedAt === 0,
      isPaused: x === "paused",
      isPlaceholderData: p,
      isPreviousData: _,
      isRefetchError: A && f.dataUpdatedAt !== 0,
      isStale: ik(t, n),
      refetch: this.refetch,
      remove: this.remove
    }
  }
  updateResult(t) {
    const n = this.currentResult,
      r = this.createResult(this.currentQuery, this.options);
    if (this.currentResultState = this.currentQuery.state, this.currentResultOptions = this.options, p3(r, n)) return;
    this.currentResult = r;
    const i = {
        cache: !0
      },
      s = () => {
        if (!n) return !0;
        const {
          notifyOnChangeProps: o
        } = this.options, a = typeof o == "function" ? o() : o;
        if (a === "all" || !a && !this.trackedProps.size) return !0;
        const c = new Set(a ?? this.trackedProps);
        return this.options.useErrorBoundary && c.add("error"), Object.keys(this.currentResult).some(l => {
          const u = l;
          return this.currentResult[u] !== n[u] && c.has(u)
        })
      };
    (t == null ? void 0 : t.listeners) !== !1 && s() && (i.listeners = !0), this.notify({
      ...i,
      ...t
    })
  }
  updateQuery() {
    const t = this.client.getQueryCache().build(this.client, this.options);
    if (t === this.currentQuery) return;
    const n = this.currentQuery;
    this.currentQuery = t, this.currentQueryInitialState = t.state, this.previousQueryResult = this.currentResult, this.hasListeners() && (n == null || n.removeObserver(this), t.addObserver(this))
  }
  onQueryUpdate(t) {
    const n = {};
    t.type === "success" ? n.onSuccess = !t.manual : t.type === "error" && !mw(t.error) && (n.onError = !0), this.updateResult(n), this.hasListeners() && this.updateTimers()
  }
  notify(t) {
    Ur.batch(() => {
      if (t.onSuccess) {
        var n, r, i, s;
        (n = (r = this.options).onSuccess) == null || n.call(r, this.currentResult.data), (i = (s = this.options).onSettled) == null || i.call(s, this.currentResult.data, null)
      } else if (t.onError) {
        var o, a, c, l;
        (o = (a = this.options).onError) == null || o.call(a, this.currentResult.error), (c = (l = this.options).onSettled) == null || c.call(l, void 0, this.currentResult.error)
      }
      t.listeners && this.listeners.forEach(({
        listener: u
      }) => {
        u(this.currentResult)
      }), t.cache && this.client.getQueryCache().notify({
        query: this.currentQuery,
        type: "observerResultsUpdated"
      })
    })
  }
}

function y3e(e, t) {
  return t.enabled !== !1 && !e.state.dataUpdatedAt && !(e.state.status === "error" && t.retryOnMount === !1)
}

function AN(e, t) {
  return y3e(e, t) || e.state.dataUpdatedAt > 0 && rA(e, t, t.refetchOnMount)
}

function rA(e, t, n) {
  if (t.enabled !== !1) {
    const r = typeof n == "function" ? n(e) : n;
    return r === "always" || r !== !1 && ik(e, t)
  }
  return !1
}

function TN(e, t, n, r) {
  return n.enabled !== !1 && (e !== t || r.enabled === !1) && (!n.suspense || e.state.status !== "error") && ik(e, n)
}

function ik(e, t) {
  return e.isStaleByTime(t.staleTime)
}

function v3e(e, t, n) {
  return n.keepPreviousData ? !1 : n.placeholderData !== void 0 ? t.isPlaceholderData : !p3(e.getCurrentResult(), t)
}
let b3e = class extends vm {
  constructor(t, n) {
    super(), this.client = t, this.setOptions(n), this.bindMethods(), this.updateResult()
  }
  bindMethods() {
    this.mutate = this.mutate.bind(this), this.reset = this.reset.bind(this)
  }
  setOptions(t) {
    var n;
    const r = this.options;
    this.options = this.client.defaultMutationOptions(t), p3(r, this.options) || this.client.getMutationCache().notify({
      type: "observerOptionsUpdated",
      mutation: this.currentMutation,
      observer: this
    }), (n = this.currentMutation) == null || n.setOptions(this.options)
  }
  onUnsubscribe() {
    if (!this.hasListeners()) {
      var t;
      (t = this.currentMutation) == null || t.removeObserver(this)
    }
  }
  onMutationUpdate(t) {
    this.updateResult();
    const n = {
      listeners: !0
    };
    t.type === "success" ? n.onSuccess = !0 : t.type === "error" && (n.onError = !0), this.notify(n)
  }
  getCurrentResult() {
    return this.currentResult
  }
  reset() {
    this.currentMutation = void 0, this.updateResult(), this.notify({
      listeners: !0
    })
  }
  mutate(t, n) {
    return this.mutateOptions = n, this.currentMutation && this.currentMutation.removeObserver(this), this.currentMutation = this.client.getMutationCache().build(this.client, {
      ...this.options,
      variables: typeof t < "u" ? t : this.options.variables
    }), this.currentMutation.addObserver(this), this.currentMutation.execute()
  }
  updateResult() {
    const t = this.currentMutation ? this.currentMutation.state : WH(),
      n = {
        ...t,
        isLoading: t.status === "loading",
        isSuccess: t.status === "success",
        isError: t.status === "error",
        isIdle: t.status === "idle",
        mutate: this.mutate,
        reset: this.reset
      };
    this.currentResult = n
  }
  notify(t) {
    Ur.batch(() => {
      if (this.mutateOptions && this.hasListeners()) {
        if (t.onSuccess) {
          var n, r, i, s;
          (n = (r = this.mutateOptions).onSuccess) == null || n.call(r, this.currentResult.data, this.currentResult.variables, this.currentResult.context), (i = (s = this.mutateOptions).onSettled) == null || i.call(s, this.currentResult.data, null, this.currentResult.variables, this.currentResult.context)
        } else if (t.onError) {
          var o, a, c, l;
          (o = (a = this.mutateOptions).onError) == null || o.call(a, this.currentResult.error, this.currentResult.variables, this.currentResult.context), (c = (l = this.mutateOptions).onSettled) == null || c.call(l, void 0, this.currentResult.error, this.currentResult.variables, this.currentResult.context)
        }
      }
      t.listeners && this.listeners.forEach(({
        listener: u
      }) => {
        u(this.currentResult)
      })
    })
  }
};
var qH = {
    exports: {}
  },
  GH = {};
/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Dp = j;

function w3e(e, t) {
  return e === t && (e !== 0 || 1 / e === 1 / t) || e !== e && t !== t
}
var x3e = typeof Object.is == "function" ? Object.is : w3e,
  E3e = Dp.useState,
  S3e = Dp.useEffect,
  C3e = Dp.useLayoutEffect,
  A3e = Dp.useDebugValue;

function T3e(e, t) {
  var n = t(),
    r = E3e({
      inst: {
        value: n,
        getSnapshot: t
      }
    }),
    i = r[0].inst,
    s = r[1];
  return C3e(function () {
    i.value = n, i.getSnapshot = t, wS(i) && s({
      inst: i
    })
  }, [e, n, t]), S3e(function () {
    return wS(i) && s({
      inst: i
    }), e(function () {
      wS(i) && s({
        inst: i
      })
    })
  }, [e]), A3e(n), n
}

function wS(e) {
  var t = e.getSnapshot;
  e = e.value;
  try {
    var n = t();
    return !x3e(e, n)
  } catch {
    return !0
  }
}

function k3e(e, t) {
  return t()
}
var _3e = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? k3e : T3e;
GH.useSyncExternalStore = Dp.useSyncExternalStore !== void 0 ? Dp.useSyncExternalStore : _3e;
qH.exports = GH;
var KH = qH.exports;
const QH = KH.useSyncExternalStore,
  kN = j.createContext(void 0),
  YH = j.createContext(!1);

function JH(e, t) {
  return e || (t && typeof window < "u" ? (window.ReactQueryClientContext || (window.ReactQueryClientContext = kN), window.ReactQueryClientContext) : kN)
}
const bm = ({
    context: e
  } = {}) => {
    const t = j.useContext(JH(e, j.useContext(YH)));
    if (!t) throw new Error("No QueryClient set, use QueryClientProvider to set one");
    return t
  },
  I3e = ({
    client: e,
    children: t,
    context: n,
    contextSharing: r = !1
  }) => {
    j.useEffect(() => (e.mount(), () => {
      e.unmount()
    }), [e]);
    const i = JH(n, r);
    return j.createElement(YH.Provider, {
      value: !n && r
    }, j.createElement(i.Provider, {
      value: e
    }, t))
  },
  XH = j.createContext(!1),
  P3e = () => j.useContext(XH);
XH.Provider;

function R3e() {
  let e = !1;
  return {
    clearReset: () => {
      e = !1
    },
    reset: () => {
      e = !0
    },
    isReset: () => e
  }
}
const O3e = j.createContext(R3e()),
  D3e = () => j.useContext(O3e);

function ZH(e, t) {
  return typeof e == "function" ? e(...t) : !!e
}
const N3e = (e, t) => {
    (e.suspense || e.useErrorBoundary) && (t.isReset() || (e.retryOnMount = !1))
  },
  M3e = e => {
    j.useEffect(() => {
      e.clearReset()
    }, [e])
  },
  $3e = ({
    result: e,
    errorResetBoundary: t,
    useErrorBoundary: n,
    query: r
  }) => e.isError && !t.isReset() && !e.isFetching && ZH(n, [e.error, r]),
  L3e = e => {
    e.suspense && typeof e.staleTime != "number" && (e.staleTime = 1e3)
  },
  B3e = (e, t) => e.isLoading && e.isFetching && !t,
  F3e = (e, t, n) => (e == null ? void 0 : e.suspense) && B3e(t, n),
  j3e = (e, t, n) => t.fetchOptimistic(e).then(({
    data: r
  }) => {
    e.onSuccess == null || e.onSuccess(r), e.onSettled == null || e.onSettled(r, null)
  }).catch(r => {
    n.clearReset(), e.onError == null || e.onError(r), e.onSettled == null || e.onSettled(void 0, r)
  });

function U3e(e, t) {
  const n = bm({
      context: e.context
    }),
    r = P3e(),
    i = D3e(),
    s = n.defaultQueryOptions(e);
  s._optimisticResults = r ? "isRestoring" : "optimistic", s.onError && (s.onError = Ur.batchCalls(s.onError)), s.onSuccess && (s.onSuccess = Ur.batchCalls(s.onSuccess)), s.onSettled && (s.onSettled = Ur.batchCalls(s.onSettled)), L3e(s), N3e(s, i), M3e(i);
  const [o] = j.useState(() => new t(n, s)), a = o.getOptimisticResult(s);
  if (QH(j.useCallback(c => {
      const l = r ? () => {} : o.subscribe(Ur.batchCalls(c));
      return o.updateResult(), l
    }, [o, r]), () => o.getCurrentResult(), () => o.getCurrentResult()), j.useEffect(() => {
      o.setOptions(s, {
        listeners: !1
      })
    }, [s, o]), F3e(s, a, r)) throw j3e(s, o, i);
  if ($3e({
      result: a,
      errorResetBoundary: i,
      useErrorBoundary: s.useErrorBoundary,
      query: o.getCurrentQuery()
    })) throw a.error;
  return s.notifyOnChangeProps ? a : o.trackResult(a)
}

function wl(e, t, n) {
  const r = r1(e, t, n);
  return U3e(r, g3e)
}

function _N(e, t, n) {
  const r = n3e(e, t, n),
    i = bm({
      context: r.context
    }),
    [s] = j.useState(() => new b3e(i, r));
  j.useEffect(() => {
    s.setOptions(r)
  }, [s, r]);
  const o = QH(j.useCallback(c => s.subscribe(Ur.batchCalls(c)), [s]), () => s.getCurrentResult(), () => s.getCurrentResult()),
    a = j.useCallback((c, l) => {
      s.mutate(c, l).catch(z3e)
    }, [s]);
  if (o.error && ZH(s.options.useErrorBoundary, [o.error])) throw o.error;
  return {
    ...o,
    mutate: a,
    mutateAsync: o.mutate
  }
}

function z3e() {}
/**
 * @remix-run/router v1.15.3
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function y3() {
  return y3 = Object.assign ? Object.assign.bind() : function (e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
    }
    return e
  }, y3.apply(this, arguments)
}
var cd;
(function (e) {
  e.Pop = "POP", e.Push = "PUSH", e.Replace = "REPLACE"
})(cd || (cd = {}));

function H3e(e) {
  e === void 0 && (e = {});
  let {
    initialEntries: t = ["/"],
    initialIndex: n,
    v5Compat: r = !1
  } = e, i;
  i = t.map((g, y) => u(g, typeof g == "string" ? null : g.state, y === 0 ? "default" : void 0));
  let s = c(n ?? i.length - 1),
    o = cd.Pop,
    a = null;

  function c(g) {
    return Math.min(Math.max(g, 0), i.length - 1)
  }

  function l() {
    return i[s]
  }

  function u(g, y, x) {
    y === void 0 && (y = null);
    let k = W3e(i ? l().pathname : "/", g, y, x);
    return sk(k.pathname.charAt(0) === "/", "relative pathnames are not supported in memory history: " + JSON.stringify(g)), k
  }

  function f(g) {
    return typeof g == "string" ? g : q3e(g)
  }
  return {
    get index() {
      return s
    },
    get action() {
      return o
    },
    get location() {
      return l()
    },
    createHref: f,
    createURL(g) {
      return new URL(f(g), "http://localhost")
    },
    encodeLocation(g) {
      let y = typeof g == "string" ? Ch(g) : g;
      return {
        pathname: y.pathname || "",
        search: y.search || "",
        hash: y.hash || ""
      }
    },
    push(g, y) {
      o = cd.Push;
      let x = u(g, y);
      s += 1, i.splice(s, i.length, x), r && a && a({
        action: o,
        location: x,
        delta: 1
      })
    },
    replace(g, y) {
      o = cd.Replace;
      let x = u(g, y);
      i[s] = x, r && a && a({
        action: o,
        location: x,
        delta: 0
      })
    },
    go(g) {
      o = cd.Pop;
      let y = c(s + g),
        x = i[y];
      s = y, a && a({
        action: o,
        location: x,
        delta: g
      })
    },
    listen(g) {
      return a = g, () => {
        a = null
      }
    }
  }
}

function Ai(e, t) {
  if (e === !1 || e === null || typeof e > "u") throw new Error(t)
}

function sk(e, t) {
  if (!e) {
    typeof console < "u" && console.warn(t);
    try {
      throw new Error(t)
    } catch {}
  }
}

function V3e() {
  return Math.random().toString(36).substr(2, 8)
}

function W3e(e, t, n, r) {
  return n === void 0 && (n = null), y3({
    pathname: typeof e == "string" ? e : e.pathname,
    search: "",
    hash: ""
  }, typeof t == "string" ? Ch(t) : t, {
    state: n,
    key: t && t.key || r || V3e()
  })
}

function q3e(e) {
  let {
    pathname: t = "/",
    search: n = "",
    hash: r = ""
  } = e;
  return n && n !== "?" && (t += n.charAt(0) === "?" ? n : "?" + n), r && r !== "#" && (t += r.charAt(0) === "#" ? r : "#" + r), t
}

function Ch(e) {
  let t = {};
  if (e) {
    let n = e.indexOf("#");
    n >= 0 && (t.hash = e.substr(n), e = e.substr(0, n));
    let r = e.indexOf("?");
    r >= 0 && (t.search = e.substr(r), e = e.substr(0, r)), e && (t.pathname = e)
  }
  return t
}
var IN;
(function (e) {
  e.data = "data", e.deferred = "deferred", e.redirect = "redirect", e.error = "error"
})(IN || (IN = {}));

function G3e(e, t, n) {
  n === void 0 && (n = "/");
  let r = typeof t == "string" ? Ch(t) : t,
    i = nV(r.pathname || "/", n);
  if (i == null) return null;
  let s = eV(e);
  K3e(s);
  let o = null;
  for (let a = 0; o == null && a < s.length; ++a) {
    let c = oxe(i);
    o = rxe(s[a], c)
  }
  return o
}

function eV(e, t, n, r) {
  t === void 0 && (t = []), n === void 0 && (n = []), r === void 0 && (r = "");
  let i = (s, o, a) => {
    let c = {
      relativePath: a === void 0 ? s.path || "" : a,
      caseSensitive: s.caseSensitive === !0,
      childrenIndex: o,
      route: s
    };
    c.relativePath.startsWith("/") && (Ai(c.relativePath.startsWith(r), 'Absolute route path "' + c.relativePath + '" nested under path ' + ('"' + r + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes."), c.relativePath = c.relativePath.slice(r.length));
    let l = Wf([r, c.relativePath]),
      u = n.concat(c);
    s.children && s.children.length > 0 && (Ai(s.index !== !0, "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + l + '".')), eV(s.children, t, u, l)), !(s.path == null && !s.index) && t.push({
      path: l,
      score: txe(l, s.index),
      routesMeta: u
    })
  };
  return e.forEach((s, o) => {
    var a;
    if (s.path === "" || !((a = s.path) != null && a.includes("?"))) i(s, o);
    else
      for (let c of tV(s.path)) i(s, o, c)
  }), t
}

function tV(e) {
  let t = e.split("/");
  if (t.length === 0) return [];
  let [n, ...r] = t, i = n.endsWith("?"), s = n.replace(/\?$/, "");
  if (r.length === 0) return i ? [s, ""] : [s];
  let o = tV(r.join("/")),
    a = [];
  return a.push(...o.map(c => c === "" ? s : [s, c].join("/"))), i && a.push(...o), a.map(c => e.startsWith("/") && c === "" ? "/" : c)
}

function K3e(e) {
  e.sort((t, n) => t.score !== n.score ? n.score - t.score : nxe(t.routesMeta.map(r => r.childrenIndex), n.routesMeta.map(r => r.childrenIndex)))
}
const Q3e = /^:[\w-]+$/,
  Y3e = 3,
  J3e = 2,
  X3e = 1,
  Z3e = 10,
  exe = -2,
  PN = e => e === "*";

function txe(e, t) {
  let n = e.split("/"),
    r = n.length;
  return n.some(PN) && (r += exe), t && (r += J3e), n.filter(i => !PN(i)).reduce((i, s) => i + (Q3e.test(s) ? Y3e : s === "" ? X3e : Z3e), r)
}

function nxe(e, t) {
  return e.length === t.length && e.slice(0, -1).every((r, i) => r === t[i]) ? e[e.length - 1] - t[t.length - 1] : 0
}

function rxe(e, t) {
  let {
    routesMeta: n
  } = e, r = {}, i = "/", s = [];
  for (let o = 0; o < n.length; ++o) {
    let a = n[o],
      c = o === n.length - 1,
      l = i === "/" ? t : t.slice(i.length) || "/",
      u = ixe({
        path: a.relativePath,
        caseSensitive: a.caseSensitive,
        end: c
      }, l);
    if (!u) return null;
    Object.assign(r, u.params);
    let f = a.route;
    s.push({
      params: r,
      pathname: Wf([i, u.pathname]),
      pathnameBase: fxe(Wf([i, u.pathnameBase])),
      route: f
    }), u.pathnameBase !== "/" && (i = Wf([i, u.pathnameBase]))
  }
  return s
}

function ixe(e, t) {
  typeof e == "string" && (e = {
    path: e,
    caseSensitive: !1,
    end: !0
  });
  let [n, r] = sxe(e.path, e.caseSensitive, e.end), i = t.match(n);
  if (!i) return null;
  let s = i[0],
    o = s.replace(/(.)\/+$/, "$1"),
    a = i.slice(1);
  return {
    params: r.reduce((l, u, f) => {
      let {
        paramName: h,
        isOptional: g
      } = u;
      if (h === "*") {
        let x = a[f] || "";
        o = s.slice(0, s.length - x.length).replace(/(.)\/+$/, "$1")
      }
      const y = a[f];
      return g && !y ? l[h] = void 0 : l[h] = (y || "").replace(/%2F/g, "/"), l
    }, {}),
    pathname: s,
    pathnameBase: o,
    pattern: e
  }
}

function sxe(e, t, n) {
  t === void 0 && (t = !1), n === void 0 && (n = !0), sk(e === "*" || !e.endsWith("*") || e.endsWith("/*"), 'Route path "' + e + '" will be treated as if it were ' + ('"' + e.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + e.replace(/\*$/, "/*") + '".'));
  let r = [],
    i = "^" + e.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, (o, a, c) => (r.push({
      paramName: a,
      isOptional: c != null
    }), c ? "/?([^\\/]+)?" : "/([^\\/]+)"));
  return e.endsWith("*") ? (r.push({
    paramName: "*"
  }), i += e === "*" || e === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : n ? i += "\\/*$" : e !== "" && e !== "/" && (i += "(?:(?=\\/|$))"), [new RegExp(i, t ? void 0 : "i"), r]
}

function oxe(e) {
  try {
    return e.split("/").map(t => decodeURIComponent(t).replace(/\//g, "%2F")).join("/")
  } catch (t) {
    return sk(!1, 'The URL path "' + e + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + t + ").")), e
  }
}

function nV(e, t) {
  if (t === "/") return e;
  if (!e.toLowerCase().startsWith(t.toLowerCase())) return null;
  let n = t.endsWith("/") ? t.length - 1 : t.length,
    r = e.charAt(n);
  return r && r !== "/" ? null : e.slice(n) || "/"
}

function axe(e, t) {
  t === void 0 && (t = "/");
  let {
    pathname: n,
    search: r = "",
    hash: i = ""
  } = typeof e == "string" ? Ch(e) : e;
  return {
    pathname: n ? n.startsWith("/") ? n : cxe(n, t) : t,
    search: hxe(r),
    hash: pxe(i)
  }
}

function cxe(e, t) {
  let n = t.replace(/\/+$/, "").split("/");
  return e.split("/").forEach(i => {
    i === ".." ? n.length > 1 && n.pop() : i !== "." && n.push(i)
  }), n.length > 1 ? n.join("/") : "/"
}

function xS(e, t, n, r) {
  return "Cannot include a '" + e + "' character in a manually specified " + ("`to." + t + "` field [" + JSON.stringify(r) + "].  Please separate it out to the ") + ("`to." + n + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.'
}

function lxe(e) {
  return e.filter((t, n) => n === 0 || t.route.path && t.route.path.length > 0)
}

function uxe(e, t) {
  let n = lxe(e);
  return t ? n.map((r, i) => i === e.length - 1 ? r.pathname : r.pathnameBase) : n.map(r => r.pathnameBase)
}

function dxe(e, t, n, r) {
  r === void 0 && (r = !1);
  let i;
  typeof e == "string" ? i = Ch(e) : (i = y3({}, e), Ai(!i.pathname || !i.pathname.includes("?"), xS("?", "pathname", "search", i)), Ai(!i.pathname || !i.pathname.includes("#"), xS("#", "pathname", "hash", i)), Ai(!i.search || !i.search.includes("#"), xS("#", "search", "hash", i)));
  let s = e === "" || i.pathname === "",
    o = s ? "/" : i.pathname,
    a;
  if (o == null) a = n;
  else {
    let f = t.length - 1;
    if (!r && o.startsWith("..")) {
      let h = o.split("/");
      for (; h[0] === "..";) h.shift(), f -= 1;
      i.pathname = h.join("/")
    }
    a = f >= 0 ? t[f] : "/"
  }
  let c = axe(i, a),
    l = o && o !== "/" && o.endsWith("/"),
    u = (s || o === ".") && n.endsWith("/");
  return !c.pathname.endsWith("/") && (l || u) && (c.pathname += "/"), c
}
const Wf = e => e.join("/").replace(/\/\/+/g, "/"),
  fxe = e => e.replace(/\/+$/, "").replace(/^\/*/, "/"),
  hxe = e => !e || e === "?" ? "" : e.startsWith("?") ? e : "?" + e,
  pxe = e => !e || e === "#" ? "" : e.startsWith("#") ? e : "#" + e;

function mxe(e) {
  return e != null && typeof e.status == "number" && typeof e.statusText == "string" && typeof e.internal == "boolean" && "data" in e
}
const rV = ["post", "put", "patch", "delete"];
new Set(rV);
const gxe = ["get", ...rV];
new Set(gxe);
/**
 * React Router v6.22.3
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function r2() {
  return r2 = Object.assign ? Object.assign.bind() : function (e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
    }
    return e
  }, r2.apply(this, arguments)
}
const ok = j.createContext(null),
  yxe = j.createContext(null),
  L5 = j.createContext(null),
  B5 = j.createContext(null),
  wm = j.createContext({
    outlet: null,
    matches: [],
    isDataRoute: !1
  }),
  iV = j.createContext(null);

function X2() {
  return j.useContext(B5) != null
}

function yu() {
  return X2() || Ai(!1), j.useContext(B5).location
}

function sV(e) {
  j.useContext(L5).static || j.useLayoutEffect(e)
}

function Ba() {
  let {
    isDataRoute: e
  } = j.useContext(wm);
  return e ? Ixe() : vxe()
}

function vxe() {
  X2() || Ai(!1);
  let e = j.useContext(ok),
    {
      basename: t,
      future: n,
      navigator: r
    } = j.useContext(L5),
    {
      matches: i
    } = j.useContext(wm),
    {
      pathname: s
    } = yu(),
    o = JSON.stringify(uxe(i, n.v7_relativeSplatPath)),
    a = j.useRef(!1);
  return sV(() => {
    a.current = !0
  }), j.useCallback(function (l, u) {
    if (u === void 0 && (u = {}), !a.current) return;
    if (typeof l == "number") {
      r.go(l);
      return
    }
    let f = dxe(l, JSON.parse(o), s, u.relative === "path");
    e == null && t !== "/" && (f.pathname = f.pathname === "/" ? t : Wf([t, f.pathname])), (u.replace ? r.replace : r.push)(f, u.state, u)
  }, [t, r, o, s, e])
}

function ak(e, t) {
  return bxe(e, t)
}

function bxe(e, t, n, r) {
  X2() || Ai(!1);
  let {
    navigator: i
  } = j.useContext(L5), {
    matches: s
  } = j.useContext(wm), o = s[s.length - 1], a = o ? o.params : {};
  o && o.pathname;
  let c = o ? o.pathnameBase : "/";
  o && o.route;
  let l = yu(),
    u;
  if (t) {
    var f;
    let k = typeof t == "string" ? Ch(t) : t;
    c === "/" || (f = k.pathname) != null && f.startsWith(c) || Ai(!1), u = k
  } else u = l;
  let h = u.pathname || "/",
    g = h;
  if (c !== "/") {
    let k = c.replace(/^\//, "").split("/");
    g = "/" + h.replace(/^\//, "").split("/").slice(k.length).join("/")
  }
  let y = G3e(e, {
      pathname: g
    }),
    x = Cxe(y && y.map(k => Object.assign({}, k, {
      params: Object.assign({}, a, k.params),
      pathname: Wf([c, i.encodeLocation ? i.encodeLocation(k.pathname).pathname : k.pathname]),
      pathnameBase: k.pathnameBase === "/" ? c : Wf([c, i.encodeLocation ? i.encodeLocation(k.pathnameBase).pathname : k.pathnameBase])
    })), s, n, r);
  return t && x ? j.createElement(B5.Provider, {
    value: {
      location: r2({
        pathname: "/",
        search: "",
        hash: "",
        state: null,
        key: "default"
      }, u),
      navigationType: cd.Pop
    }
  }, x) : x
}

function wxe() {
  let e = _xe(),
    t = mxe(e) ? e.status + " " + e.statusText : e instanceof Error ? e.message : JSON.stringify(e),
    n = e instanceof Error ? e.stack : null,
    i = {
      padding: "0.5rem",
      backgroundColor: "rgba(200,200,200, 0.5)"
    };
  return j.createElement(j.Fragment, null, j.createElement("h2", null, "Unexpected Application Error!"), j.createElement("h3", {
    style: {
      fontStyle: "italic"
    }
  }, t), n ? j.createElement("pre", {
    style: i
  }, n) : null, null)
}
const xxe = j.createElement(wxe, null);
class Exe extends j.Component {
  constructor(t) {
    super(t), this.state = {
      location: t.location,
      revalidation: t.revalidation,
      error: t.error
    }
  }
  static getDerivedStateFromError(t) {
    return {
      error: t
    }
  }
  static getDerivedStateFromProps(t, n) {
    return n.location !== t.location || n.revalidation !== "idle" && t.revalidation === "idle" ? {
      error: t.error,
      location: t.location,
      revalidation: t.revalidation
    } : {
      error: t.error !== void 0 ? t.error : n.error,
      location: n.location,
      revalidation: t.revalidation || n.revalidation
    }
  }
  componentDidCatch(t, n) {
    console.error("React Router caught the following error during render", t, n)
  }
  render() {
    return this.state.error !== void 0 ? j.createElement(wm.Provider, {
      value: this.props.routeContext
    }, j.createElement(iV.Provider, {
      value: this.state.error,
      children: this.props.component
    })) : this.props.children
  }
}

function Sxe(e) {
  let {
    routeContext: t,
    match: n,
    children: r
  } = e, i = j.useContext(ok);
  return i && i.static && i.staticContext && (n.route.errorElement || n.route.ErrorBoundary) && (i.staticContext._deepestRenderedBoundaryId = n.route.id), j.createElement(wm.Provider, {
    value: t
  }, r)
}

function Cxe(e, t, n, r) {
  var i;
  if (t === void 0 && (t = []), n === void 0 && (n = null), r === void 0 && (r = null), e == null) {
    var s;
    if ((s = n) != null && s.errors) e = n.matches;
    else return null
  }
  let o = e,
    a = (i = n) == null ? void 0 : i.errors;
  if (a != null) {
    let u = o.findIndex(f => f.route.id && (a == null ? void 0 : a[f.route.id]));
    u >= 0 || Ai(!1), o = o.slice(0, Math.min(o.length, u + 1))
  }
  let c = !1,
    l = -1;
  if (n && r && r.v7_partialHydration)
    for (let u = 0; u < o.length; u++) {
      let f = o[u];
      if ((f.route.HydrateFallback || f.route.hydrateFallbackElement) && (l = u), f.route.id) {
        let {
          loaderData: h,
          errors: g
        } = n, y = f.route.loader && h[f.route.id] === void 0 && (!g || g[f.route.id] === void 0);
        if (f.route.lazy || y) {
          c = !0, l >= 0 ? o = o.slice(0, l + 1) : o = [o[0]];
          break
        }
      }
    }
  return o.reduceRight((u, f, h) => {
    let g, y = !1,
      x = null,
      k = null;
    n && (g = a && f.route.id ? a[f.route.id] : void 0, x = f.route.errorElement || xxe, c && (l < 0 && h === 0 ? (Pxe("route-fallback", !1), y = !0, k = null) : l === h && (y = !0, k = f.route.hydrateFallbackElement || null)));
    let _ = t.concat(o.slice(0, h + 1)),
      p = () => {
        let v;
        return g ? v = x : y ? v = k : f.route.Component ? v = j.createElement(f.route.Component, null) : f.route.element ? v = f.route.element : v = u, j.createElement(Sxe, {
          match: f,
          routeContext: {
            outlet: u,
            matches: _,
            isDataRoute: n != null
          },
          children: v
        })
      };
    return n && (f.route.ErrorBoundary || f.route.errorElement || h === 0) ? j.createElement(Exe, {
      location: n.location,
      revalidation: n.revalidation,
      component: x,
      error: g,
      children: p(),
      routeContext: {
        outlet: null,
        matches: _,
        isDataRoute: !0
      }
    }) : p()
  }, null)
}
var oV = function (e) {
    return e.UseBlocker = "useBlocker", e.UseRevalidator = "useRevalidator", e.UseNavigateStable = "useNavigate", e
  }(oV || {}),
  v3 = function (e) {
    return e.UseBlocker = "useBlocker", e.UseLoaderData = "useLoaderData", e.UseActionData = "useActionData", e.UseRouteError = "useRouteError", e.UseNavigation = "useNavigation", e.UseRouteLoaderData = "useRouteLoaderData", e.UseMatches = "useMatches", e.UseRevalidator = "useRevalidator", e.UseNavigateStable = "useNavigate", e.UseRouteId = "useRouteId", e
  }(v3 || {});

function Axe(e) {
  let t = j.useContext(ok);
  return t || Ai(!1), t
}

function Txe(e) {
  let t = j.useContext(yxe);
  return t || Ai(!1), t
}

function kxe(e) {
  let t = j.useContext(wm);
  return t || Ai(!1), t
}

function aV(e) {
  let t = kxe(),
    n = t.matches[t.matches.length - 1];
  return n.route.id || Ai(!1), n.route.id
}

function _xe() {
  var e;
  let t = j.useContext(iV),
    n = Txe(v3.UseRouteError),
    r = aV(v3.UseRouteError);
  return t !== void 0 ? t : (e = n.errors) == null ? void 0 : e[r]
}

function Ixe() {
  let {
    router: e
  } = Axe(oV.UseNavigateStable), t = aV(v3.UseNavigateStable), n = j.useRef(!1);
  return sV(() => {
    n.current = !0
  }), j.useCallback(function (i, s) {
    s === void 0 && (s = {}), n.current && (typeof i == "number" ? e.navigate(i) : e.navigate(i, r2({
      fromRouteId: t
    }, s)))
  }, [e, t])
}
const RN = {};

function Pxe(e, t, n) {
  !t && !RN[e] && (RN[e] = !0)
}
const Rxe = "startTransition",
  ON = Rw[Rxe];

function Oxe(e) {
  let {
    basename: t,
    children: n,
    initialEntries: r,
    initialIndex: i,
    future: s
  } = e, o = j.useRef();
  o.current == null && (o.current = H3e({
    initialEntries: r,
    initialIndex: i,
    v5Compat: !0
  }));
  let a = o.current,
    [c, l] = j.useState({
      action: a.action,
      location: a.location
    }),
    {
      v7_startTransition: u
    } = s || {},
    f = j.useCallback(h => {
      u && ON ? ON(() => l(h)) : l(h)
    }, [l, u]);
  return j.useLayoutEffect(() => a.listen(f), [a, f]), j.createElement(Dxe, {
    basename: t,
    children: n,
    location: c.location,
    navigationType: c.action,
    navigator: a,
    future: s
  })
}

function iA(e) {
  Ai(!1)
}

function Dxe(e) {
  let {
    basename: t = "/",
    children: n = null,
    location: r,
    navigationType: i = cd.Pop,
    navigator: s,
    static: o = !1,
    future: a
  } = e;
  X2() && Ai(!1);
  let c = t.replace(/^\/*/, "/"),
    l = j.useMemo(() => ({
      basename: c,
      navigator: s,
      static: o,
      future: r2({
        v7_relativeSplatPath: !1
      }, a)
    }), [c, a, s, o]);
  typeof r == "string" && (r = Ch(r));
  let {
    pathname: u = "/",
    search: f = "",
    hash: h = "",
    state: g = null,
    key: y = "default"
  } = r, x = j.useMemo(() => {
    let k = nV(u, c);
    return k == null ? null : {
      location: {
        pathname: k,
        search: f,
        hash: h,
        state: g,
        key: y
      },
      navigationType: i
    }
  }, [c, u, f, h, g, y, i]);
  return x == null ? null : j.createElement(L5.Provider, {
    value: l
  }, j.createElement(B5.Provider, {
    children: n,
    value: x
  }))
}

function Nxe(e) {
  let {
    children: t,
    location: n
  } = e;
  return ak(sA(t), n)
}
new Promise(() => {});

function sA(e, t) {
  t === void 0 && (t = []);
  let n = [];
  return j.Children.forEach(e, (r, i) => {
    if (!j.isValidElement(r)) return;
    let s = [...t, i];
    if (r.type === j.Fragment) {
      n.push.apply(n, sA(r.props.children, s));
      return
    }
    r.type !== iA && Ai(!1), !r.props.index || !r.props.children || Ai(!1);
    let o = {
      id: r.props.id || s.join("-"),
      caseSensitive: r.props.caseSensitive,
      element: r.props.element,
      Component: r.props.Component,
      index: r.props.index,
      path: r.props.path,
      loader: r.props.loader,
      action: r.props.action,
      errorElement: r.props.errorElement,
      ErrorBoundary: r.props.ErrorBoundary,
      hasErrorBoundary: r.props.ErrorBoundary != null || r.props.errorElement != null,
      shouldRevalidate: r.props.shouldRevalidate,
      handle: r.props.handle,
      lazy: r.props.lazy
    };
    r.props.children && (o.children = sA(r.props.children, s)), n.push(o)
  }), n
}
const Mxe = new m3e({
  defaultOptions: {
    queries: {
      enabled: !0,
      staleTime: 36e5,
      cacheTime: 1 / 0,
      refetchInterval: !1,
      refetchIntervalInBackground: !1,
      refetchOnWindowFocus: !0,
      refetchOnReconnect: !0,
      refetchOnMount: !0,
      retryOnMount: !0,
      onError: e => {}
    },
    mutations: {
      onError: e => {}
    }
  }
});
var Z2 = e => e.type === "checkbox",
  W0 = e => e instanceof Date,
  Es = e => e == null;
const cV = e => typeof e == "object";
var hi = e => !Es(e) && !Array.isArray(e) && cV(e) && !W0(e),
  lV = e => hi(e) && e.target ? Z2(e.target) ? e.target.checked : e.target.value : e,
  $xe = e => e.substring(0, e.search(/\.\d+(\.|$)/)) || e,
  uV = (e, t) => e.has($xe(t)),
  Lxe = e => {
    const t = e.constructor && e.constructor.prototype;
    return hi(t) && t.hasOwnProperty("isPrototypeOf")
  },
  ck = typeof window < "u" && typeof window.HTMLElement < "u" && typeof document < "u";

function Xs(e) {
  let t;
  const n = Array.isArray(e);
  if (e instanceof Date) t = new Date(e);
  else if (e instanceof Set) t = new Set(e);
  else if (!(ck && (e instanceof Blob || e instanceof FileList)) && (n || hi(e)))
    if (t = n ? [] : {}, !n && !Lxe(e)) t = e;
    else
      for (const r in e) e.hasOwnProperty(r) && (t[r] = Xs(e[r]));
  else return e;
  return t
}
var ey = e => Array.isArray(e) ? e.filter(Boolean) : [],
  jr = e => e === void 0,
  nt = (e, t, n) => {
    if (!t || !hi(e)) return n;
    const r = ey(t.split(/[,[\].]+?/)).reduce((i, s) => Es(i) ? i : i[s], e);
    return jr(r) || r === e ? jr(e[t]) ? n : e[t] : r
  },
  cc = e => typeof e == "boolean";
const b3 = {
    BLUR: "blur",
    FOCUS_OUT: "focusout",
    CHANGE: "change"
  },
  uc = {
    onBlur: "onBlur",
    onChange: "onChange",
    onSubmit: "onSubmit",
    onTouched: "onTouched",
    all: "all"
  },
  Nl = {
    max: "max",
    min: "min",
    maxLength: "maxLength",
    minLength: "minLength",
    pattern: "pattern",
    required: "required",
    validate: "validate"
  },
  dV = Jt.createContext(null),
  Ls = () => Jt.useContext(dV),
  Bxe = e => {
    const {
      children: t,
      ...n
    } = e;
    return Jt.createElement(dV.Provider, {
      value: n
    }, t)
  };
var fV = (e, t, n, r = !0) => {
    const i = {
      defaultValues: t._defaultValues
    };
    for (const s in e) Object.defineProperty(i, s, {
      get: () => {
        const o = s;
        return t._proxyFormState[o] !== uc.all && (t._proxyFormState[o] = !r || uc.all), n && (n[o] = !0), e[o]
      }
    });
    return i
  },
  ko = e => hi(e) && !Object.keys(e).length,
  hV = (e, t, n, r) => {
    n(e);
    const {
      name: i,
      ...s
    } = e;
    return ko(s) || Object.keys(s).length >= Object.keys(t).length || Object.keys(s).find(o => t[o] === (!r || uc.all))
  },
  gw = e => Array.isArray(e) ? e : [e],
  pV = (e, t, n) => !e || !t || e === t || gw(e).some(r => r && (n ? r === t : r.startsWith(t) || t.startsWith(r)));

function lk(e) {
  const t = Jt.useRef(e);
  t.current = e, Jt.useEffect(() => {
    const n = !e.disabled && t.current.subject && t.current.subject.subscribe({
      next: t.current.next
    });
    return () => {
      n && n.unsubscribe()
    }
  }, [e.disabled])
}

function xm(e) {
  const t = Ls(),
    {
      control: n = t.control,
      disabled: r,
      name: i,
      exact: s
    } = e || {},
    [o, a] = Jt.useState(n._formState),
    c = Jt.useRef(!0),
    l = Jt.useRef({
      isDirty: !1,
      isLoading: !1,
      dirtyFields: !1,
      touchedFields: !1,
      validatingFields: !1,
      isValidating: !1,
      isValid: !1,
      errors: !1
    }),
    u = Jt.useRef(i);
  return u.current = i, lk({
    disabled: r,
    next: f => c.current && pV(u.current, f.name, s) && hV(f, l.current, n._updateFormState) && a({
      ...n._formState,
      ...f
    }),
    subject: n._subjects.state
  }), Jt.useEffect(() => (c.current = !0, l.current.isValid && n._updateValid(!0), () => {
    c.current = !1
  }), [n]), fV(o, n, l.current, !1)
}
var Jc = e => typeof e == "string",
  mV = (e, t, n, r, i) => Jc(e) ? (r && t.watch.add(e), nt(n, e, i)) : Array.isArray(e) ? e.map(s => (r && t.watch.add(s), nt(n, s))) : (r && (t.watchAll = !0), n);

function ds(e) {
  const t = Ls(),
    {
      control: n = t.control,
      name: r,
      defaultValue: i,
      disabled: s,
      exact: o
    } = e || {},
    a = Jt.useRef(r);
  a.current = r, lk({
    disabled: s,
    subject: n._subjects.values,
    next: u => {
      pV(a.current, u.name, o) && l(Xs(mV(a.current, n._names, u.values || n._formValues, !1, i)))
    }
  });
  const [c, l] = Jt.useState(n._getWatch(r, i));
  return Jt.useEffect(() => n._removeUnmounted()), c
}
var uk = e => /^\w*$/.test(e),
  gV = e => ey(e.replace(/["|']|\]/g, "").split(/\.|\[/)),
  ir = (e, t, n) => {
    let r = -1;
    const i = uk(t) ? [t] : gV(t),
      s = i.length,
      o = s - 1;
    for (; ++r < s;) {
      const a = i[r];
      let c = n;
      if (r !== o) {
        const l = e[a];
        c = hi(l) || Array.isArray(l) ? l : isNaN(+i[r + 1]) ? {} : []
      }
      e[a] = c, e = e[a]
    }
    return e
  };

function F5(e) {
  const t = Ls(),
    {
      name: n,
      disabled: r,
      control: i = t.control,
      shouldUnregister: s
    } = e,
    o = uV(i._names.array, n),
    a = ds({
      control: i,
      name: n,
      defaultValue: nt(i._formValues, n, nt(i._defaultValues, n, e.defaultValue)),
      exact: !0
    }),
    c = xm({
      control: i,
      name: n
    }),
    l = Jt.useRef(i.register(n, {
      ...e.rules,
      value: a,
      ...cc(e.disabled) ? {
        disabled: e.disabled
      } : {}
    }));
  return Jt.useEffect(() => {
    const u = i._options.shouldUnregister || s,
      f = (h, g) => {
        const y = nt(i._fields, h);
        y && (y._f.mount = g)
      };
    if (f(n, !0), u) {
      const h = Xs(nt(i._options.defaultValues, n));
      ir(i._defaultValues, n, h), jr(nt(i._formValues, n)) && ir(i._formValues, n, h)
    }
    return () => {
      (o ? u && !i._state.action : u) ? i.unregister(n): f(n, !1)
    }
  }, [n, i, o, s]), Jt.useEffect(() => {
    nt(i._fields, n) && i._updateDisabledField({
      disabled: r,
      fields: i._fields,
      name: n,
      value: nt(i._fields, n)._f.value
    })
  }, [r, n, i]), {
    field: {
      name: n,
      value: a,
      ...cc(r) || c.disabled ? {
        disabled: c.disabled || r
      } : {},
      onChange: Jt.useCallback(u => l.current.onChange({
        target: {
          value: lV(u),
          name: n
        },
        type: b3.CHANGE
      }), [n]),
      onBlur: Jt.useCallback(() => l.current.onBlur({
        target: {
          value: nt(i._formValues, n),
          name: n
        },
        type: b3.BLUR
      }), [n, i]),
      ref: u => {
        const f = nt(i._fields, n);
        f && u && (f._f.ref = {
          focus: () => u.focus(),
          select: () => u.select(),
          setCustomValidity: h => u.setCustomValidity(h),
          reportValidity: () => u.reportValidity()
        })
      }
    },
    formState: c,
    fieldState: Object.defineProperties({}, {
      invalid: {
        enumerable: !0,
        get: () => !!nt(c.errors, n)
      },
      isDirty: {
        enumerable: !0,
        get: () => !!nt(c.dirtyFields, n)
      },
      isTouched: {
        enumerable: !0,
        get: () => !!nt(c.touchedFields, n)
      },
      isValidating: {
        enumerable: !0,
        get: () => !!nt(c.validatingFields, n)
      },
      error: {
        enumerable: !0,
        get: () => nt(c.errors, n)
      }
    })
  }
}
var Fxe = (e, t, n, r, i) => t ? {
    ...n[e],
    types: {
      ...n[e] && n[e].types ? n[e].types : {},
      [r]: i || !0
    }
  } : {},
  DN = e => ({
    isOnSubmit: !e || e === uc.onSubmit,
    isOnBlur: e === uc.onBlur,
    isOnChange: e === uc.onChange,
    isOnAll: e === uc.all,
    isOnTouch: e === uc.onTouched
  }),
  NN = (e, t, n) => !n && (t.watchAll || t.watch.has(e) || [...t.watch].some(r => e.startsWith(r) && /^\.\w+/.test(e.slice(r.length))));
const x1 = (e, t, n, r) => {
  for (const i of n || Object.keys(e)) {
    const s = nt(e, i);
    if (s) {
      const {
        _f: o,
        ...a
      } = s;
      if (o) {
        if (o.refs && o.refs[0] && t(o.refs[0], i) && !r) break;
        if (o.ref && t(o.ref, o.name) && !r) break;
        x1(a, t)
      } else hi(a) && x1(a, t)
    }
  }
};
var jxe = (e, t, n) => {
    const r = ey(nt(e, n));
    return ir(r, "root", t[n]), ir(e, n, r), e
  },
  dk = e => e.type === "file",
  ld = e => typeof e == "function",
  w3 = e => {
    if (!ck) return !1;
    const t = e ? e.ownerDocument : 0;
    return e instanceof(t && t.defaultView ? t.defaultView.HTMLElement : HTMLElement)
  },
  yw = e => Jc(e),
  fk = e => e.type === "radio",
  x3 = e => e instanceof RegExp;
const MN = {
    value: !1,
    isValid: !1
  },
  $N = {
    value: !0,
    isValid: !0
  };
var yV = e => {
  if (Array.isArray(e)) {
    if (e.length > 1) {
      const t = e.filter(n => n && n.checked && !n.disabled).map(n => n.value);
      return {
        value: t,
        isValid: !!t.length
      }
    }
    return e[0].checked && !e[0].disabled ? e[0].attributes && !jr(e[0].attributes.value) ? jr(e[0].value) || e[0].value === "" ? $N : {
      value: e[0].value,
      isValid: !0
    } : $N : MN
  }
  return MN
};
const LN = {
  isValid: !1,
  value: null
};
var vV = e => Array.isArray(e) ? e.reduce((t, n) => n && n.checked && !n.disabled ? {
  isValid: !0,
  value: n.value
} : t, LN) : LN;

function BN(e, t, n = "validate") {
  if (yw(e) || Array.isArray(e) && e.every(yw) || cc(e) && !e) return {
    type: n,
    message: yw(e) ? e : "",
    ref: t
  }
}
var p0 = e => hi(e) && !x3(e) ? e : {
    value: e,
    message: ""
  },
  FN = async (e, t, n, r, i) => {
    const {
      ref: s,
      refs: o,
      required: a,
      maxLength: c,
      minLength: l,
      min: u,
      max: f,
      pattern: h,
      validate: g,
      name: y,
      valueAsNumber: x,
      mount: k,
      disabled: _
    } = e._f, p = nt(t, y);
    if (!k || _) return {};
    const v = o ? o[0] : s,
      S = G => {
        r && v.reportValidity && (v.setCustomValidity(cc(G) ? "" : G || ""), v.reportValidity())
      },
      I = {},
      A = fk(s),
      w = Z2(s),
      E = A || w,
      D = (x || dk(s)) && jr(s.value) && jr(p) || w3(s) && s.value === "" || p === "" || Array.isArray(p) && !p.length,
      $ = Fxe.bind(null, y, n, I),
      V = (G, L, b, T = Nl.maxLength, R = Nl.minLength) => {
        const N = G ? L : b;
        I[y] = {
          type: G ? T : R,
          message: N,
          ref: s,
          ...$(G ? T : R, N)
        }
      };
    if (i ? !Array.isArray(p) || !p.length : a && (!E && (D || Es(p)) || cc(p) && !p || w && !yV(o).isValid || A && !vV(o).isValid)) {
      const {
        value: G,
        message: L
      } = yw(a) ? {
        value: !!a,
        message: a
      } : p0(a);
      if (G && (I[y] = {
          type: Nl.required,
          message: L,
          ref: v,
          ...$(Nl.required, L)
        }, !n)) return S(L), I
    }
    if (!D && (!Es(u) || !Es(f))) {
      let G, L;
      const b = p0(f),
        T = p0(u);
      if (!Es(p) && !isNaN(p)) {
        const R = s.valueAsNumber || p && +p;
        Es(b.value) || (G = R > b.value), Es(T.value) || (L = R < T.value)
      } else {
        const R = s.valueAsDate || new Date(p),
          N = q => new Date(new Date().toDateString() + " " + q),
          O = s.type == "time",
          U = s.type == "week";
        Jc(b.value) && p && (G = O ? N(p) > N(b.value) : U ? p > b.value : R > new Date(b.value)), Jc(T.value) && p && (L = O ? N(p) < N(T.value) : U ? p < T.value : R < new Date(T.value))
      }
      if ((G || L) && (V(!!G, b.message, T.message, Nl.max, Nl.min), !n)) return S(I[y].message), I
    }
    if ((c || l) && !D && (Jc(p) || i && Array.isArray(p))) {
      const G = p0(c),
        L = p0(l),
        b = !Es(G.value) && p.length > +G.value,
        T = !Es(L.value) && p.length < +L.value;
      if ((b || T) && (V(b, G.message, L.message), !n)) return S(I[y].message), I
    }
    if (h && !D && Jc(p)) {
      const {
        value: G,
        message: L
      } = p0(h);
      if (x3(G) && !p.match(G) && (I[y] = {
          type: Nl.pattern,
          message: L,
          ref: s,
          ...$(Nl.pattern, L)
        }, !n)) return S(L), I
    }
    if (g) {
      if (ld(g)) {
        const G = await g(p, t),
          L = BN(G, v);
        if (L && (I[y] = {
            ...L,
            ...$(Nl.validate, L.message)
          }, !n)) return S(L.message), I
      } else if (hi(g)) {
        let G = {};
        for (const L in g) {
          if (!ko(G) && !n) break;
          const b = BN(await g[L](p, t), v, L);
          b && (G = {
            ...b,
            ...$(L, b.message)
          }, S(b.message), n && (I[y] = G))
        }
        if (!ko(G) && (I[y] = {
            ref: v,
            ...G
          }, !n)) return I
      }
    }
    return S(!0), I
  };

function Uxe(e, t) {
  const n = t.slice(0, -1).length;
  let r = 0;
  for (; r < n;) e = jr(e) ? r++ : e[t[r++]];
  return e
}

function zxe(e) {
  for (const t in e)
    if (e.hasOwnProperty(t) && !jr(e[t])) return !1;
  return !0
}

function li(e, t) {
  const n = Array.isArray(t) ? t : uk(t) ? [t] : gV(t),
    r = n.length === 1 ? e : Uxe(e, n),
    i = n.length - 1,
    s = n[i];
  return r && delete r[s], i !== 0 && (hi(r) && ko(r) || Array.isArray(r) && zxe(r)) && li(e, n.slice(0, -1)), e
}
var ES = () => {
    let e = [];
    return {
      get observers() {
        return e
      },
      next: i => {
        for (const s of e) s.next && s.next(i)
      },
      subscribe: i => (e.push(i), {
        unsubscribe: () => {
          e = e.filter(s => s !== i)
        }
      }),
      unsubscribe: () => {
        e = []
      }
    }
  },
  E3 = e => Es(e) || !cV(e);

function Nf(e, t) {
  if (E3(e) || E3(t)) return e === t;
  if (W0(e) && W0(t)) return e.getTime() === t.getTime();
  const n = Object.keys(e),
    r = Object.keys(t);
  if (n.length !== r.length) return !1;
  for (const i of n) {
    const s = e[i];
    if (!r.includes(i)) return !1;
    if (i !== "ref") {
      const o = t[i];
      if (W0(s) && W0(o) || hi(s) && hi(o) || Array.isArray(s) && Array.isArray(o) ? !Nf(s, o) : s !== o) return !1
    }
  }
  return !0
}
var bV = e => e.type === "select-multiple",
  Hxe = e => fk(e) || Z2(e),
  SS = e => w3(e) && e.isConnected,
  wV = e => {
    for (const t in e)
      if (ld(e[t])) return !0;
    return !1
  };

function S3(e, t = {}) {
  const n = Array.isArray(e);
  if (hi(e) || n)
    for (const r in e) Array.isArray(e[r]) || hi(e[r]) && !wV(e[r]) ? (t[r] = Array.isArray(e[r]) ? [] : {}, S3(e[r], t[r])) : Es(e[r]) || (t[r] = !0);
  return t
}

function xV(e, t, n) {
  const r = Array.isArray(e);
  if (hi(e) || r)
    for (const i in e) Array.isArray(e[i]) || hi(e[i]) && !wV(e[i]) ? jr(t) || E3(n[i]) ? n[i] = Array.isArray(e[i]) ? S3(e[i], []) : {
      ...S3(e[i])
    } : xV(e[i], Es(t) ? {} : t[i], n[i]) : n[i] = !Nf(e[i], t[i]);
  return n
}
var hb = (e, t) => xV(e, t, S3(t)),
  EV = (e, {
    valueAsNumber: t,
    valueAsDate: n,
    setValueAs: r
  }) => jr(e) ? e : t ? e === "" ? NaN : e && +e : n && Jc(e) ? new Date(e) : r ? r(e) : e;

function CS(e) {
  const t = e.ref;
  if (!(e.refs ? e.refs.every(n => n.disabled) : t.disabled)) return dk(t) ? t.files : fk(t) ? vV(e.refs).value : bV(t) ? [...t.selectedOptions].map(({
    value: n
  }) => n) : Z2(t) ? yV(e.refs).value : EV(jr(t.value) ? e.ref.value : t.value, e)
}
var Vxe = (e, t, n, r) => {
    const i = {};
    for (const s of e) {
      const o = nt(t, s);
      o && ir(i, s, o._f)
    }
    return {
      criteriaMode: n,
      names: [...e],
      fields: i,
      shouldUseNativeValidation: r
    }
  },
  kg = e => jr(e) ? e : x3(e) ? e.source : hi(e) ? x3(e.value) ? e.value.source : e.value : e,
  Wxe = e => e.mount && (e.required || e.min || e.max || e.maxLength || e.minLength || e.pattern || e.validate);

function jN(e, t, n) {
  const r = nt(e, n);
  if (r || uk(n)) return {
    error: r,
    name: n
  };
  const i = n.split(".");
  for (; i.length;) {
    const s = i.join("."),
      o = nt(t, s),
      a = nt(e, s);
    if (o && !Array.isArray(o) && n !== s) return {
      name: n
    };
    if (a && a.type) return {
      name: s,
      error: a
    };
    i.pop()
  }
  return {
    name: n
  }
}
var qxe = (e, t, n, r, i) => i.isOnAll ? !1 : !n && i.isOnTouch ? !(t || e) : (n ? r.isOnBlur : i.isOnBlur) ? !e : (n ? r.isOnChange : i.isOnChange) ? e : !0,
  Gxe = (e, t) => !ey(nt(e, t)).length && li(e, t);
const Kxe = {
  mode: uc.onSubmit,
  reValidateMode: uc.onChange,
  shouldFocusError: !0
};

function Qxe(e = {}) {
  let t = {
      ...Kxe,
      ...e
    },
    n = {
      submitCount: 0,
      isDirty: !1,
      isLoading: ld(t.defaultValues),
      isValidating: !1,
      isSubmitted: !1,
      isSubmitting: !1,
      isSubmitSuccessful: !1,
      isValid: !1,
      touchedFields: {},
      dirtyFields: {},
      validatingFields: {},
      errors: t.errors || {},
      disabled: t.disabled || !1
    },
    r = {},
    i = hi(t.defaultValues) || hi(t.values) ? Xs(t.defaultValues || t.values) || {} : {},
    s = t.shouldUnregister ? {} : Xs(i),
    o = {
      action: !1,
      mount: !1,
      watch: !1
    },
    a = {
      mount: new Set,
      unMount: new Set,
      array: new Set,
      watch: new Set
    },
    c, l = 0;
  const u = {
      isDirty: !1,
      dirtyFields: !1,
      validatingFields: !1,
      touchedFields: !1,
      isValidating: !1,
      isValid: !1,
      errors: !1
    },
    f = {
      values: ES(),
      array: ES(),
      state: ES()
    },
    h = DN(t.mode),
    g = DN(t.reValidateMode),
    y = t.criteriaMode === uc.all,
    x = se => pe => {
      clearTimeout(l), l = setTimeout(se, pe)
    },
    k = async se => {
      if (u.isValid || se) {
        const pe = t.resolver ? ko((await E()).errors) : await $(r, !0);
        pe !== n.isValid && f.state.next({
          isValid: pe
        })
      }
    }, _ = (se, pe) => {
      (u.isValidating || u.validatingFields) && ((se || Array.from(a.mount)).forEach(de => {
        de && (pe ? ir(n.validatingFields, de, pe) : li(n.validatingFields, de))
      }), f.state.next({
        validatingFields: n.validatingFields,
        isValidating: !ko(n.validatingFields)
      }))
    }, p = (se, pe = [], de, we, Ce = !0, be = !0) => {
      if (we && de) {
        if (o.action = !0, be && Array.isArray(nt(r, se))) {
          const Se = de(nt(r, se), we.argA, we.argB);
          Ce && ir(r, se, Se)
        }
        if (be && Array.isArray(nt(n.errors, se))) {
          const Se = de(nt(n.errors, se), we.argA, we.argB);
          Ce && ir(n.errors, se, Se), Gxe(n.errors, se)
        }
        if (u.touchedFields && be && Array.isArray(nt(n.touchedFields, se))) {
          const Se = de(nt(n.touchedFields, se), we.argA, we.argB);
          Ce && ir(n.touchedFields, se, Se)
        }
        u.dirtyFields && (n.dirtyFields = hb(i, s)), f.state.next({
          name: se,
          isDirty: G(se, pe),
          dirtyFields: n.dirtyFields,
          errors: n.errors,
          isValid: n.isValid
        })
      } else ir(s, se, pe)
    }, v = (se, pe) => {
      ir(n.errors, se, pe), f.state.next({
        errors: n.errors
      })
    }, S = se => {
      n.errors = se, f.state.next({
        errors: n.errors,
        isValid: !1
      })
    }, I = (se, pe, de, we) => {
      const Ce = nt(r, se);
      if (Ce) {
        const be = nt(s, se, jr(de) ? nt(i, se) : de);
        jr(be) || we && we.defaultChecked || pe ? ir(s, se, pe ? be : CS(Ce._f)) : T(se, be), o.mount && k()
      }
    }, A = (se, pe, de, we, Ce) => {
      let be = !1,
        Se = !1;
      const Fe = {
          name: se
        },
        Ne = !!(nt(r, se) && nt(r, se)._f.disabled);
      if (!de || we) {
        u.isDirty && (Se = n.isDirty, n.isDirty = Fe.isDirty = G(), be = Se !== Fe.isDirty);
        const Me = Ne || Nf(nt(i, se), pe);
        Se = !!(!Ne && nt(n.dirtyFields, se)), Me || Ne ? li(n.dirtyFields, se) : ir(n.dirtyFields, se, !0), Fe.dirtyFields = n.dirtyFields, be = be || u.dirtyFields && Se !== !Me
      }
      if (de) {
        const Me = nt(n.touchedFields, se);
        Me || (ir(n.touchedFields, se, de), Fe.touchedFields = n.touchedFields, be = be || u.touchedFields && Me !== de)
      }
      return be && Ce && f.state.next(Fe), be ? Fe : {}
    }, w = (se, pe, de, we) => {
      const Ce = nt(n.errors, se),
        be = u.isValid && cc(pe) && n.isValid !== pe;
      if (e.delayError && de ? (c = x(() => v(se, de)), c(e.delayError)) : (clearTimeout(l), c = null, de ? ir(n.errors, se, de) : li(n.errors, se)), (de ? !Nf(Ce, de) : Ce) || !ko(we) || be) {
        const Se = {
          ...we,
          ...be && cc(pe) ? {
            isValid: pe
          } : {},
          errors: n.errors,
          name: se
        };
        n = {
          ...n,
          ...Se
        }, f.state.next(Se)
      }
    }, E = async se => {
      _(se, !0);
      const pe = await t.resolver(s, t.context, Vxe(se || a.mount, r, t.criteriaMode, t.shouldUseNativeValidation));
      return _(se), pe
    }, D = async se => {
      const {
        errors: pe
      } = await E(se);
      if (se)
        for (const de of se) {
          const we = nt(pe, de);
          we ? ir(n.errors, de, we) : li(n.errors, de)
        } else n.errors = pe;
      return pe
    }, $ = async (se, pe, de = {
      valid: !0
    }) => {
      for (const we in se) {
        const Ce = se[we];
        if (Ce) {
          const {
            _f: be,
            ...Se
          } = Ce;
          if (be) {
            const Fe = a.array.has(be.name);
            _([we], !0);
            const Ne = await FN(Ce, s, y, t.shouldUseNativeValidation && !pe, Fe);
            if (_([we]), Ne[be.name] && (de.valid = !1, pe)) break;
            !pe && (nt(Ne, be.name) ? Fe ? jxe(n.errors, Ne, be.name) : ir(n.errors, be.name, Ne[be.name]) : li(n.errors, be.name))
          }
          Se && await $(Se, pe, de)
        }
      }
      return de.valid
    }, V = () => {
      for (const se of a.unMount) {
        const pe = nt(r, se);
        pe && (pe._f.refs ? pe._f.refs.every(de => !SS(de)) : !SS(pe._f.ref)) && ne(se)
      }
      a.unMount = new Set
    }, G = (se, pe) => (se && pe && ir(s, se, pe), !Nf(W(), i)), L = (se, pe, de) => mV(se, a, {
      ...o.mount ? s : jr(pe) ? i : Jc(se) ? {
        [se]: pe
      } : pe
    }, de, pe), b = se => ey(nt(o.mount ? s : i, se, e.shouldUnregister ? nt(i, se, []) : [])), T = (se, pe, de = {}) => {
      const we = nt(r, se);
      let Ce = pe;
      if (we) {
        const be = we._f;
        be && (!be.disabled && ir(s, se, EV(pe, be)), Ce = w3(be.ref) && Es(pe) ? "" : pe, bV(be.ref) ? [...be.ref.options].forEach(Se => Se.selected = Ce.includes(Se.value)) : be.refs ? Z2(be.ref) ? be.refs.length > 1 ? be.refs.forEach(Se => (!Se.defaultChecked || !Se.disabled) && (Se.checked = Array.isArray(Ce) ? !!Ce.find(Fe => Fe === Se.value) : Ce === Se.value)) : be.refs[0] && (be.refs[0].checked = !!Ce) : be.refs.forEach(Se => Se.checked = Se.value === Ce) : dk(be.ref) ? be.ref.value = "" : (be.ref.value = Ce, be.ref.type || f.values.next({
          name: se,
          values: {
            ...s
          }
        })))
      }(de.shouldDirty || de.shouldTouch) && A(se, Ce, de.shouldTouch, de.shouldDirty, !0), de.shouldValidate && q(se)
    }, R = (se, pe, de) => {
      for (const we in pe) {
        const Ce = pe[we],
          be = `${se}.${we}`,
          Se = nt(r, be);
        (a.array.has(se) || !E3(Ce) || Se && !Se._f) && !W0(Ce) ? R(be, Ce, de) : T(be, Ce, de)
      }
    }, N = (se, pe, de = {}) => {
      const we = nt(r, se),
        Ce = a.array.has(se),
        be = Xs(pe);
      ir(s, se, be), Ce ? (f.array.next({
        name: se,
        values: {
          ...s
        }
      }), (u.isDirty || u.dirtyFields) && de.shouldDirty && f.state.next({
        name: se,
        dirtyFields: hb(i, s),
        isDirty: G(se, be)
      })) : we && !we._f && !Es(be) ? R(se, be, de) : T(se, be, de), NN(se, a) && f.state.next({
        ...n
      }), f.values.next({
        name: o.mount ? se : void 0,
        values: {
          ...s
        }
      })
    }, O = async se => {
      const pe = se.target;
      let de = pe.name,
        we = !0;
      const Ce = nt(r, de),
        be = () => pe.type ? CS(Ce._f) : lV(se),
        Se = Fe => {
          we = Number.isNaN(Fe) || Fe === nt(s, de, Fe)
        };
      if (Ce) {
        let Fe, Ne;
        const Me = be(),
          We = se.type === b3.BLUR || se.type === b3.FOCUS_OUT,
          ke = !Wxe(Ce._f) && !t.resolver && !nt(n.errors, de) && !Ce._f.deps || qxe(We, nt(n.touchedFields, de), n.isSubmitted, g, h),
          ze = NN(de, a, We);
        ir(s, de, Me), We ? (Ce._f.onBlur && Ce._f.onBlur(se), c && c(0)) : Ce._f.onChange && Ce._f.onChange(se);
        const ct = A(de, Me, We, !1),
          Xe = !ko(ct) || ze;
        if (!We && f.values.next({
            name: de,
            type: se.type,
            values: {
              ...s
            }
          }), ke) return u.isValid && k(), Xe && f.state.next({
          name: de,
          ...ze ? {} : ct
        });
        if (!We && ze && f.state.next({
            ...n
          }), t.resolver) {
          const {
            errors: _e
          } = await E([de]);
          if (Se(Me), we) {
            const Ze = jN(n.errors, r, de),
              Ee = jN(_e, r, Ze.name || de);
            Fe = Ee.error, de = Ee.name, Ne = ko(_e)
          }
        } else _([de], !0), Fe = (await FN(Ce, s, y, t.shouldUseNativeValidation))[de], _([de]), Se(Me), we && (Fe ? Ne = !1 : u.isValid && (Ne = await $(r, !0)));
        we && (Ce._f.deps && q(Ce._f.deps), w(de, Ne, Fe, ct))
      }
    }, U = (se, pe) => {
      if (nt(n.errors, pe) && se.focus) return se.focus(), 1
    }, q = async (se, pe = {}) => {
      let de, we;
      const Ce = gw(se);
      if (t.resolver) {
        const be = await D(jr(se) ? se : Ce);
        de = ko(be), we = se ? !Ce.some(Se => nt(be, Se)) : de
      } else se ? (we = (await Promise.all(Ce.map(async be => {
        const Se = nt(r, be);
        return await $(Se && Se._f ? {
          [be]: Se
        } : Se)
      }))).every(Boolean), !(!we && !n.isValid) && k()) : we = de = await $(r);
      return f.state.next({
        ...!Jc(se) || u.isValid && de !== n.isValid ? {} : {
          name: se
        },
        ...t.resolver || !se ? {
          isValid: de
        } : {},
        errors: n.errors
      }), pe.shouldFocus && !we && x1(r, U, se ? Ce : a.mount), we
    }, W = se => {
      const pe = {
        ...i,
        ...o.mount ? s : {}
      };
      return jr(se) ? pe : Jc(se) ? nt(pe, se) : se.map(de => nt(pe, de))
    }, M = (se, pe) => ({
      invalid: !!nt((pe || n).errors, se),
      isDirty: !!nt((pe || n).dirtyFields, se),
      isTouched: !!nt((pe || n).touchedFields, se),
      isValidating: !!nt((pe || n).validatingFields, se),
      error: nt((pe || n).errors, se)
    }), Q = se => {
      se && gw(se).forEach(pe => li(n.errors, pe)), f.state.next({
        errors: se ? n.errors : {}
      })
    }, he = (se, pe, de) => {
      const we = (nt(r, se, {
        _f: {}
      })._f || {}).ref;
      ir(n.errors, se, {
        ...pe,
        ref: we
      }), f.state.next({
        name: se,
        errors: n.errors,
        isValid: !1
      }), de && de.shouldFocus && we && we.focus && we.focus()
    }, H = (se, pe) => ld(se) ? f.values.subscribe({
      next: de => se(L(void 0, pe), de)
    }) : L(se, pe, !0), ne = (se, pe = {}) => {
      for (const de of se ? gw(se) : a.mount) a.mount.delete(de), a.array.delete(de), pe.keepValue || (li(r, de), li(s, de)), !pe.keepError && li(n.errors, de), !pe.keepDirty && li(n.dirtyFields, de), !pe.keepTouched && li(n.touchedFields, de), !pe.keepIsValidating && li(n.validatingFields, de), !t.shouldUnregister && !pe.keepDefaultValue && li(i, de);
      f.values.next({
        values: {
          ...s
        }
      }), f.state.next({
        ...n,
        ...pe.keepDirty ? {
          isDirty: G()
        } : {}
      }), !pe.keepIsValid && k()
    }, X = ({
      disabled: se,
      name: pe,
      field: de,
      fields: we,
      value: Ce
    }) => {
      if (cc(se)) {
        const be = se ? void 0 : jr(Ce) ? CS(de ? de._f : nt(we, pe)._f) : Ce;
        ir(s, pe, be), A(pe, be, !1, !1, !0)
      }
    }, Z = (se, pe = {}) => {
      let de = nt(r, se);
      const we = cc(pe.disabled);
      return ir(r, se, {
        ...de || {},
        _f: {
          ...de && de._f ? de._f : {
            ref: {
              name: se
            }
          },
          name: se,
          mount: !0,
          ...pe
        }
      }), a.mount.add(se), de ? X({
        field: de,
        disabled: pe.disabled,
        name: se,
        value: pe.value
      }) : I(se, !0, pe.value), {
        ...we ? {
          disabled: pe.disabled
        } : {},
        ...t.progressive ? {
          required: !!pe.required,
          min: kg(pe.min),
          max: kg(pe.max),
          minLength: kg(pe.minLength),
          maxLength: kg(pe.maxLength),
          pattern: kg(pe.pattern)
        } : {},
        name: se,
        onChange: O,
        onBlur: O,
        ref: Ce => {
          if (Ce) {
            Z(se, pe), de = nt(r, se);
            const be = jr(Ce.value) && Ce.querySelectorAll && Ce.querySelectorAll("input,select,textarea")[0] || Ce,
              Se = Hxe(be),
              Fe = de._f.refs || [];
            if (Se ? Fe.find(Ne => Ne === be) : be === de._f.ref) return;
            ir(r, se, {
              _f: {
                ...de._f,
                ...Se ? {
                  refs: [...Fe.filter(SS), be, ...Array.isArray(nt(i, se)) ? [{}] : []],
                  ref: {
                    type: be.type,
                    name: se
                  }
                } : {
                  ref: be
                }
              }
            }), I(se, !1, void 0, be)
          } else de = nt(r, se, {}), de._f && (de._f.mount = !1), (t.shouldUnregister || pe.shouldUnregister) && !(uV(a.array, se) && o.action) && a.unMount.add(se)
        }
      }
    }, te = () => t.shouldFocusError && x1(r, U, a.mount), F = se => {
      cc(se) && (f.state.next({
        disabled: se
      }), x1(r, (pe, de) => {
        let we = se;
        const Ce = nt(r, de);
        Ce && cc(Ce._f.disabled) && (we || (we = Ce._f.disabled)), pe.disabled = we
      }, 0, !1))
    }, J = (se, pe) => async de => {
      let we;
      de && (de.preventDefault && de.preventDefault(), de.persist && de.persist());
      let Ce = Xs(s);
      if (f.state.next({
          isSubmitting: !0
        }), t.resolver) {
        const {
          errors: be,
          values: Se
        } = await E();
        n.errors = be, Ce = Se
      } else await $(r);
      if (li(n.errors, "root"), ko(n.errors)) {
        f.state.next({
          errors: {}
        });
        try {
          await se(Ce, de)
        } catch (be) {
          we = be
        }
      } else pe && await pe({
        ...n.errors
      }, de), te(), setTimeout(te);
      if (f.state.next({
          isSubmitted: !0,
          isSubmitting: !1,
          isSubmitSuccessful: ko(n.errors) && !we,
          submitCount: n.submitCount + 1,
          errors: n.errors
        }), we) throw we
    }, ie = (se, pe = {}) => {
      nt(r, se) && (jr(pe.defaultValue) ? N(se, Xs(nt(i, se))) : (N(se, pe.defaultValue), ir(i, se, Xs(pe.defaultValue))), pe.keepTouched || li(n.touchedFields, se), pe.keepDirty || (li(n.dirtyFields, se), n.isDirty = pe.defaultValue ? G(se, Xs(nt(i, se))) : G()), pe.keepError || (li(n.errors, se), u.isValid && k()), f.state.next({
        ...n
      }))
    }, ce = (se, pe = {}) => {
      const de = se ? Xs(se) : i,
        we = Xs(de),
        Ce = ko(se),
        be = Ce ? i : we;
      if (pe.keepDefaultValues || (i = de), !pe.keepValues) {
        if (pe.keepDirtyValues)
          for (const Se of a.mount) nt(n.dirtyFields, Se) ? ir(be, Se, nt(s, Se)) : N(Se, nt(be, Se));
        else {
          if (ck && jr(se))
            for (const Se of a.mount) {
              const Fe = nt(r, Se);
              if (Fe && Fe._f) {
                const Ne = Array.isArray(Fe._f.refs) ? Fe._f.refs[0] : Fe._f.ref;
                if (w3(Ne)) {
                  const Me = Ne.closest("form");
                  if (Me) {
                    Me.reset();
                    break
                  }
                }
              }
            }
          r = {}
        }
        s = e.shouldUnregister ? pe.keepDefaultValues ? Xs(i) : {} : Xs(be), f.array.next({
          values: {
            ...be
          }
        }), f.values.next({
          values: {
            ...be
          }
        })
      }
      a = {
        mount: pe.keepDirtyValues ? a.mount : new Set,
        unMount: new Set,
        array: new Set,
        watch: new Set,
        watchAll: !1,
        focus: ""
      }, o.mount = !u.isValid || !!pe.keepIsValid || !!pe.keepDirtyValues, o.watch = !!e.shouldUnregister, f.state.next({
        submitCount: pe.keepSubmitCount ? n.submitCount : 0,
        isDirty: Ce ? !1 : pe.keepDirty ? n.isDirty : !!(pe.keepDefaultValues && !Nf(se, i)),
        isSubmitted: pe.keepIsSubmitted ? n.isSubmitted : !1,
        dirtyFields: Ce ? [] : pe.keepDirtyValues ? pe.keepDefaultValues && s ? hb(i, s) : n.dirtyFields : pe.keepDefaultValues && se ? hb(i, se) : {},
        touchedFields: pe.keepTouched ? n.touchedFields : {},
        errors: pe.keepErrors ? n.errors : {},
        isSubmitSuccessful: pe.keepIsSubmitSuccessful ? n.isSubmitSuccessful : !1,
        isSubmitting: !1
      })
    }, ue = (se, pe) => ce(ld(se) ? se(s) : se, pe);
  return {
    control: {
      register: Z,
      unregister: ne,
      getFieldState: M,
      handleSubmit: J,
      setError: he,
      _executeSchema: E,
      _getWatch: L,
      _getDirty: G,
      _updateValid: k,
      _removeUnmounted: V,
      _updateFieldArray: p,
      _updateDisabledField: X,
      _getFieldArray: b,
      _reset: ce,
      _resetDefaultValues: () => ld(t.defaultValues) && t.defaultValues().then(se => {
        ue(se, t.resetOptions), f.state.next({
          isLoading: !1
        })
      }),
      _updateFormState: se => {
        n = {
          ...n,
          ...se
        }
      },
      _disableForm: F,
      _subjects: f,
      _proxyFormState: u,
      _setErrors: S,
      get _fields() {
        return r
      },
      get _formValues() {
        return s
      },
      get _state() {
        return o
      },
      set _state(se) {
        o = se
      },
      get _defaultValues() {
        return i
      },
      get _names() {
        return a
      },
      set _names(se) {
        a = se
      },
      get _formState() {
        return n
      },
      set _formState(se) {
        n = se
      },
      get _options() {
        return t
      },
      set _options(se) {
        t = {
          ...t,
          ...se
        }
      }
    },
    trigger: q,
    register: Z,
    handleSubmit: J,
    watch: H,
    setValue: N,
    getValues: W,
    reset: ue,
    resetField: ie,
    clearErrors: Q,
    unregister: ne,
    setError: he,
    setFocus: (se, pe = {}) => {
      const de = nt(r, se),
        we = de && de._f;
      if (we) {
        const Ce = we.refs ? we.refs[0] : we.ref;
        Ce.focus && (Ce.focus(), pe.shouldSelect && Ce.select())
      }
    },
    getFieldState: M
  }
}

function Yxe(e = {}) {
  const t = Jt.useRef(),
    n = Jt.useRef(),
    [r, i] = Jt.useState({
      isDirty: !1,
      isValidating: !1,
      isLoading: ld(e.defaultValues),
      isSubmitted: !1,
      isSubmitting: !1,
      isSubmitSuccessful: !1,
      isValid: !1,
      submitCount: 0,
      dirtyFields: {},
      touchedFields: {},
      validatingFields: {},
      errors: e.errors || {},
      disabled: e.disabled || !1,
      defaultValues: ld(e.defaultValues) ? void 0 : e.defaultValues
    });
  t.current || (t.current = {
    ...Qxe(e),
    formState: r
  });
  const s = t.current.control;
  return s._options = e, lk({
    subject: s._subjects.state,
    next: o => {
      hV(o, s._proxyFormState, s._updateFormState, !0) && i({
        ...s._formState
      })
    }
  }), Jt.useEffect(() => s._disableForm(e.disabled), [s, e.disabled]), Jt.useEffect(() => {
    if (s._proxyFormState.isDirty) {
      const o = s._getDirty();
      o !== r.isDirty && s._subjects.state.next({
        isDirty: o
      })
    }
  }, [s, r.isDirty]), Jt.useEffect(() => {
    e.values && !Nf(e.values, n.current) ? (s._reset(e.values, s._options.resetOptions), n.current = e.values, i(o => ({
      ...o
    }))) : s._resetDefaultValues()
  }, [e.values, s]), Jt.useEffect(() => {
    e.errors && s._setErrors(e.errors)
  }, [e.errors, s]), Jt.useEffect(() => {
    s._state.mount || (s._updateValid(), s._state.mount = !0), s._state.watch && (s._state.watch = !1, s._subjects.state.next({
      ...s._formState
    })), s._removeUnmounted()
  }), Jt.useEffect(() => {
    e.shouldUnregister && s._subjects.values.next({
      values: s._getWatch()
    })
  }, [e.shouldUnregister, s]), t.current.formState = fV(r, s), t.current
}
const Np = (e, t) => {
  var n, r;
  return (n = t == null ? void 0 : t.allow) != null && n.length ? t.allow.includes(e) : !((r = t == null ? void 0 : t.deny) != null && r.includes(e))
};
var ae;
(function (e) {
  e.ETH = "ETH", e.MATIC = "MATIC", e.BNB = "BNB", e.DAI = "DAI", e.FTM = "FTM", e.OKT = "OKT", e.AVAX = "AVAX", e.HT = "HT", e.ONE = "ONE", e.FSN = "FSN", e.MOVR = "MOVR", e.EXP = "EXP", e.TCH = "TCH", e.UBQ = "UBQ", e.META = "META", e.DIODE = "DIODE", e.CELO = "CELO", e.FUSE = "FUSE", e.TLOS = "TLOS", e.CRO = "CRO", e.SHIB = "SHIB", e.L1 = "L1", e.RBTC = "RBTC", e.TBG = "TBG", e.VLX = "VLX", e.GLMR = "GLMR", e.METIS = "METIS", e.SOL = "SOL", e.EVM = "EVM", e.USDT = "USDT", e.USDC = "USDC", e.cbtUSDC = "cbtUSDC", e.cbtUSDT = "cbtUSDT", e.cbtWUSDT = "cbtWUSDT", e.cbtWUSDC = "cbtWUSDC", e.cbtCELR = "cbtCELR", e.BUSD = "BUSD", e.USDCe = "USDCe", e.TEST = "TEST", e.KAL = "KAL", e.SDIODE = "SDIODE", e.SPARK = "SPARK", e.TRBTC = "TRBTC", e.CXTT = "CXTT", e.sgMETIS = "sgMETIS", e.sgWOO = "sgWOO", e.sgUSDT = "sgUSDT", e.sgBUSD = "sgBUSD", e.sgUSDC = "sgUSDC", e.WBTC = "WBTC", e.WETH = "WETH", e.SUSHI = "SUSHI", e.DODO = "DODO", e.MCB = "MCB", e.CELR = "CELR", e.IF = "IF"
})(ae || (ae = {}));
var It;
(function (e) {
  e.ETH = "eth", e.POL = "pol", e.BSC = "bsc", e.DAI = "dai", e.OKT = "okt", e.FTM = "ftm", e.AVA = "ava", e.ARB = "arb", e.HEC = "hec", e.OPT = "opt", e.ONE = "one", e.FSN = "fsn", e.MOR = "mor", e.EXP = "exp", e.TCH = "tch", e.UBQ = "ubq", e.MET = "met", e.DIO = "dio", e.CEL = "cel", e.FUS = "fus", e.TLO = "tlo", e.CRO = "cro", e.BOB = "bob", e.SHI = "shi", e.GL1 = "gl1", e.RSK = "rsk", e.TBW = "tbw", e.VEL = "vel", e.MOO = "moo", e.MAM = "mam", e.AUR = "aur", e.TER = "ter", e.OAS = "oas", e.SOL = "sol", e.EVM = "evm", e.ARN = "arn", e.ERA = "era", e.PZE = "pze", e.LNA = "lna", e.BAS = "bas", e.GOR = "gor", e.METT = "mett", e.DIOT = "diot", e.MUM = "mum", e.ARBG = "arbg", e.OPTG = "optg", e.BSCT = "bsct", e.HECT = "hect", e.ONET = "onet", e.FUST = "fust", e.TLOT = "tlot", e.RSKT = "rskt", e.SOLT = "solt", e.OAST = "oast", e.TERT = "tert", e.AVAT = "avat", e.EVMT = "evmt", e.MORT = "mort", e.FTMT = "ftmt", e.LNAT = "lnat"
})(It || (It = {}));
var B;
(function (e) {
  e[e.ETH = 1] = "ETH", e[e.POL = 137] = "POL", e[e.BSC = 56] = "BSC", e[e.DAI = 100] = "DAI", e[e.OKT = 66] = "OKT", e[e.FTM = 250] = "FTM", e[e.AVA = 43114] = "AVA", e[e.ARB = 42161] = "ARB", e[e.HEC = 128] = "HEC", e[e.OPT = 10] = "OPT", e[e.ONE = 16666e5] = "ONE", e[e.FSN = 32659] = "FSN", e[e.MOR = 1285] = "MOR", e[e.EXP = 2] = "EXP", e[e.TCH = 7] = "TCH", e[e.UBQ = 8] = "UBQ", e[e.MET = 11] = "MET", e[e.DIO = 15] = "DIO", e[e.CEL = 42220] = "CEL", e[e.FUS = 122] = "FUS", e[e.TLO = 40] = "TLO", e[e.CRO = 25] = "CRO", e[e.BOB = 288] = "BOB", e[e.SHI = 27] = "SHI", e[e.GL1 = 29] = "GL1", e[e.RSK = 30] = "RSK", e[e.TBW = 35] = "TBW", e[e.VEL = 106] = "VEL", e[e.MOO = 1284] = "MOO", e[e.MAM = 1088] = "MAM", e[e.AUR = 1313161554] = "AUR", e[e.SOL = 0x416edef1601be] = "SOL", e[e.TER = 0x41feef8a540be] = "TER", e[e.OAS = 0x65d650afb73e] = "OAS", e[e.EVM = 9001] = "EVM", e[e.ARN = 42170] = "ARN", e[e.ERA = 324] = "ERA", e[e.PZE = 1101] = "PZE", e[e.LNA = 59144] = "LNA", e[e.BAS = 8453] = "BAS", e[e.GOR = 5] = "GOR", e[e.METT = 12] = "METT", e[e.DIOT = 13] = "DIOT", e[e.MUM = 80001] = "MUM", e[e.ARBG = 421613] = "ARBG", e[e.OPTG = 420] = "OPTG", e[e.BSCT = 97] = "BSCT", e[e.HECT = 256] = "HECT", e[e.ONET = 16667e5] = "ONET", e[e.FUST = 123] = "FUST", e[e.TLOT = 41] = "TLOT", e[e.RSKT = 31] = "RSKT", e[e.SOLT = 0x416edef16f133] = "SOLT", e[e.TERT = 0x41feef8a63033] = "TERT", e[e.OAST = 0x3fa5f26e682ff] = "OAST", e[e.AVAT = 43113] = "AVAT", e[e.EVMT = 9e3] = "EVMT", e[e.MORT = 1287] = "MORT", e[e.FTMT = 4002] = "FTMT", e[e.LNAT = 59140] = "LNAT"
})(B || (B = {}));
var Qs;
(function (e) {
  e.connext = "connext", e.hop = "hop", e.multichain = "multichain", e.cbridge = "cbridge", e.hyphen = "hyphen", e.polygon = "polygon", e.arbitrum = "arbitrum", e.avalanche = "avalanche", e.optimism = "optimism", e.across = "across", e.portal = "portal", e.stargate = "stargate"
})(Qs || (Qs = {}));
Qs.connext, Qs.hop, Qs.multichain, Qs.cbridge, Qs.hyphen, Qs.polygon, Qs.arbitrum, Qs.avalanche, Qs.optimism, Qs.across, Qs.portal, Qs.stargate;
var At;
(function (e) {
  e.EVM = "EVM", e.SVM = "SVM"
})(At || (At = {}));
const Ft = {
  [B.ETH]: "0xcA11bde05977b3631167028862bE2a173976CA11",
  [B.POL]: "0xcA11bde05977b3631167028862bE2a173976CA11",
  [B.BSC]: "0xcA11bde05977b3631167028862bE2a173976CA11",
  [B.DAI]: "0xcA11bde05977b3631167028862bE2a173976CA11",
  [B.OKT]: "0xcA11bde05977b3631167028862bE2a173976CA11",
  [B.FTM]: "0xcA11bde05977b3631167028862bE2a173976CA11",
  [B.AVA]: "0xcA11bde05977b3631167028862bE2a173976CA11",
  [B.ARB]: "0xcA11bde05977b3631167028862bE2a173976CA11",
  [B.HEC]: "0xcA11bde05977b3631167028862bE2a173976CA11",
  [B.OPT]: "0xcA11bde05977b3631167028862bE2a173976CA11",
  [B.ONE]: "0xcA11bde05977b3631167028862bE2a173976CA11",
  [B.FSN]: "0x0769fd68dFb93167989C6f7254cd0D766Fb2841F",
  [B.MOR]: "0xcA11bde05977b3631167028862bE2a173976CA11",
  [B.CEL]: "0xcA11bde05977b3631167028862bE2a173976CA11",
  [B.FUS]: "0xcA11bde05977b3631167028862bE2a173976CA11",
  [B.CRO]: "0xcA11bde05977b3631167028862bE2a173976CA11",
  [B.BOB]: "0xcA11bde05977b3631167028862bE2a173976CA11",
  [B.MOO]: "0xcA11bde05977b3631167028862bE2a173976CA11",
  [B.MAM]: "0xcA11bde05977b3631167028862bE2a173976CA11",
  [B.AUR]: "0xcA11bde05977b3631167028862bE2a173976CA11",
  [B.EVM]: "0xcA11bde05977b3631167028862bE2a173976CA11",
  [B.MET]: "0xcA11bde05977b3631167028862bE2a173976CA11",
  [B.RSK]: "0xcA11bde05977b3631167028862bE2a173976CA11",
  [B.VEL]: "0x6ede559F2Bd951777470595761672091CCD21Ac6",
  [B.PZE]: "0xcA11bde05977b3631167028862bE2a173976CA11",
  [B.ERA]: "0xF9cda624FBC7e059355ce98a31693d299FACd963",
  [B.LNA]: "0xcA11bde05977b3631167028862bE2a173976CA11",
  [B.ARN]: "0xcA11bde05977b3631167028862bE2a173976CA11",
  [B.BAS]: "0xcA11bde05977b3631167028862bE2a173976CA11",
  [B.GOR]: "0xcA11bde05977b3631167028862bE2a173976CA11",
  [B.MUM]: "0xcA11bde05977b3631167028862bE2a173976CA11",
  [B.BSCT]: "0xcA11bde05977b3631167028862bE2a173976CA11",
  [B.ONET]: "0xdDCbf776dF3dE60163066A5ddDF2277cB445E0F3",
  [B.AVAT]: "0xcA11bde05977b3631167028862bE2a173976CA11",
  [B.OPTG]: "0xcA11bde05977b3631167028862bE2a173976CA11",
  [B.EVMT]: "0xcA11bde05977b3631167028862bE2a173976CA11",
  [B.MORT]: "0xcA11bde05977b3631167028862bE2a173976CA11",
  [B.FTMT]: "0xcA11bde05977b3631167028862bE2a173976CA11",
  [B.RSKT]: "0xcA11bde05977b3631167028862bE2a173976CA11",
  [B.ARBG]: "0xcA11bde05977b3631167028862bE2a173976CA11",
  [B.LNAT]: "0xcA11bde05977b3631167028862bE2a173976CA11"
};
var hk = {
  exports: {}
};
const Jxe = {},
  Xxe = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: Jxe
  }, Symbol.toStringTag, {
    value: "Module"
  })),
  SV = Ds(Xxe);
hk.exports;
(function (e) {
  (function (t, n) {
    function r(L, b) {
      if (!L) throw new Error(b || "Assertion failed")
    }

    function i(L, b) {
      L.super_ = b;
      var T = function () {};
      T.prototype = b.prototype, L.prototype = new T, L.prototype.constructor = L
    }

    function s(L, b, T) {
      if (s.isBN(L)) return L;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, L !== null && ((b === "le" || b === "be") && (T = b, b = 10), this._init(L || 0, b || 10, T || "be"))
    }
    typeof t == "object" ? t.exports = s : n.BN = s, s.BN = s, s.wordSize = 26;
    var o;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? o = window.Buffer : o = SV.Buffer
    } catch {}
    s.isBN = function (b) {
      return b instanceof s ? !0 : b !== null && typeof b == "object" && b.constructor.wordSize === s.wordSize && Array.isArray(b.words)
    }, s.max = function (b, T) {
      return b.cmp(T) > 0 ? b : T
    }, s.min = function (b, T) {
      return b.cmp(T) < 0 ? b : T
    }, s.prototype._init = function (b, T, R) {
      if (typeof b == "number") return this._initNumber(b, T, R);
      if (typeof b == "object") return this._initArray(b, T, R);
      T === "hex" && (T = 16), r(T === (T | 0) && T >= 2 && T <= 36), b = b.toString().replace(/\s+/g, "");
      var N = 0;
      b[0] === "-" && (N++, this.negative = 1), N < b.length && (T === 16 ? this._parseHex(b, N, R) : (this._parseBase(b, T, N), R === "le" && this._initArray(this.toArray(), T, R)))
    }, s.prototype._initNumber = function (b, T, R) {
      b < 0 && (this.negative = 1, b = -b), b < 67108864 ? (this.words = [b & 67108863], this.length = 1) : b < 4503599627370496 ? (this.words = [b & 67108863, b / 67108864 & 67108863], this.length = 2) : (r(b < 9007199254740992), this.words = [b & 67108863, b / 67108864 & 67108863, 1], this.length = 3), R === "le" && this._initArray(this.toArray(), T, R)
    }, s.prototype._initArray = function (b, T, R) {
      if (r(typeof b.length == "number"), b.length <= 0) return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(b.length / 3), this.words = new Array(this.length);
      for (var N = 0; N < this.length; N++) this.words[N] = 0;
      var O, U, q = 0;
      if (R === "be")
        for (N = b.length - 1, O = 0; N >= 0; N -= 3) U = b[N] | b[N - 1] << 8 | b[N - 2] << 16, this.words[O] |= U << q & 67108863, this.words[O + 1] = U >>> 26 - q & 67108863, q += 24, q >= 26 && (q -= 26, O++);
      else if (R === "le")
        for (N = 0, O = 0; N < b.length; N += 3) U = b[N] | b[N + 1] << 8 | b[N + 2] << 16, this.words[O] |= U << q & 67108863, this.words[O + 1] = U >>> 26 - q & 67108863, q += 24, q >= 26 && (q -= 26, O++);
      return this._strip()
    };

    function a(L, b) {
      var T = L.charCodeAt(b);
      if (T >= 48 && T <= 57) return T - 48;
      if (T >= 65 && T <= 70) return T - 55;
      if (T >= 97 && T <= 102) return T - 87;
      r(!1, "Invalid character in " + L)
    }

    function c(L, b, T) {
      var R = a(L, T);
      return T - 1 >= b && (R |= a(L, T - 1) << 4), R
    }
    s.prototype._parseHex = function (b, T, R) {
      this.length = Math.ceil((b.length - T) / 6), this.words = new Array(this.length);
      for (var N = 0; N < this.length; N++) this.words[N] = 0;
      var O = 0,
        U = 0,
        q;
      if (R === "be")
        for (N = b.length - 1; N >= T; N -= 2) q = c(b, T, N) << O, this.words[U] |= q & 67108863, O >= 18 ? (O -= 18, U += 1, this.words[U] |= q >>> 26) : O += 8;
      else {
        var W = b.length - T;
        for (N = W % 2 === 0 ? T + 1 : T; N < b.length; N += 2) q = c(b, T, N) << O, this.words[U] |= q & 67108863, O >= 18 ? (O -= 18, U += 1, this.words[U] |= q >>> 26) : O += 8
      }
      this._strip()
    };

    function l(L, b, T, R) {
      for (var N = 0, O = 0, U = Math.min(L.length, T), q = b; q < U; q++) {
        var W = L.charCodeAt(q) - 48;
        N *= R, W >= 49 ? O = W - 49 + 10 : W >= 17 ? O = W - 17 + 10 : O = W, r(W >= 0 && O < R, "Invalid character"), N += O
      }
      return N
    }
    s.prototype._parseBase = function (b, T, R) {
      this.words = [0], this.length = 1;
      for (var N = 0, O = 1; O <= 67108863; O *= T) N++;
      N--, O = O / T | 0;
      for (var U = b.length - R, q = U % N, W = Math.min(U, U - q) + R, M = 0, Q = R; Q < W; Q += N) M = l(b, Q, Q + N, T), this.imuln(O), this.words[0] + M < 67108864 ? this.words[0] += M : this._iaddn(M);
      if (q !== 0) {
        var he = 1;
        for (M = l(b, Q, b.length, T), Q = 0; Q < q; Q++) he *= T;
        this.imuln(he), this.words[0] + M < 67108864 ? this.words[0] += M : this._iaddn(M)
      }
      this._strip()
    }, s.prototype.copy = function (b) {
      b.words = new Array(this.length);
      for (var T = 0; T < this.length; T++) b.words[T] = this.words[T];
      b.length = this.length, b.negative = this.negative, b.red = this.red
    };

    function u(L, b) {
      L.words = b.words, L.length = b.length, L.negative = b.negative, L.red = b.red
    }
    if (s.prototype._move = function (b) {
        u(b, this)
      }, s.prototype.clone = function () {
        var b = new s(null);
        return this.copy(b), b
      }, s.prototype._expand = function (b) {
        for (; this.length < b;) this.words[this.length++] = 0;
        return this
      }, s.prototype._strip = function () {
        for (; this.length > 1 && this.words[this.length - 1] === 0;) this.length--;
        return this._normSign()
      }, s.prototype._normSign = function () {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this
      }, typeof Symbol < "u" && typeof Symbol.for == "function") try {
      s.prototype[Symbol.for("nodejs.util.inspect.custom")] = f
    } catch {
      s.prototype.inspect = f
    } else s.prototype.inspect = f;

    function f() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">"
    }
    var h = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"],
      g = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5],
      y = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
    s.prototype.toString = function (b, T) {
      b = b || 10, T = T | 0 || 1;
      var R;
      if (b === 16 || b === "hex") {
        R = "";
        for (var N = 0, O = 0, U = 0; U < this.length; U++) {
          var q = this.words[U],
            W = ((q << N | O) & 16777215).toString(16);
          O = q >>> 24 - N & 16777215, N += 2, N >= 26 && (N -= 26, U--), O !== 0 || U !== this.length - 1 ? R = h[6 - W.length] + W + R : R = W + R
        }
        for (O !== 0 && (R = O.toString(16) + R); R.length % T !== 0;) R = "0" + R;
        return this.negative !== 0 && (R = "-" + R), R
      }
      if (b === (b | 0) && b >= 2 && b <= 36) {
        var M = g[b],
          Q = y[b];
        R = "";
        var he = this.clone();
        for (he.negative = 0; !he.isZero();) {
          var H = he.modrn(Q).toString(b);
          he = he.idivn(Q), he.isZero() ? R = H + R : R = h[M - H.length] + H + R
        }
        for (this.isZero() && (R = "0" + R); R.length % T !== 0;) R = "0" + R;
        return this.negative !== 0 && (R = "-" + R), R
      }
      r(!1, "Base should be between 2 and 36")
    }, s.prototype.toNumber = function () {
      var b = this.words[0];
      return this.length === 2 ? b += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? b += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -b : b
    }, s.prototype.toJSON = function () {
      return this.toString(16, 2)
    }, o && (s.prototype.toBuffer = function (b, T) {
      return this.toArrayLike(o, b, T)
    }), s.prototype.toArray = function (b, T) {
      return this.toArrayLike(Array, b, T)
    };
    var x = function (b, T) {
      return b.allocUnsafe ? b.allocUnsafe(T) : new b(T)
    };
    s.prototype.toArrayLike = function (b, T, R) {
      this._strip();
      var N = this.byteLength(),
        O = R || Math.max(1, N);
      r(N <= O, "byte array longer than desired length"), r(O > 0, "Requested array length <= 0");
      var U = x(b, O),
        q = T === "le" ? "LE" : "BE";
      return this["_toArrayLike" + q](U, N), U
    }, s.prototype._toArrayLikeLE = function (b, T) {
      for (var R = 0, N = 0, O = 0, U = 0; O < this.length; O++) {
        var q = this.words[O] << U | N;
        b[R++] = q & 255, R < b.length && (b[R++] = q >> 8 & 255), R < b.length && (b[R++] = q >> 16 & 255), U === 6 ? (R < b.length && (b[R++] = q >> 24 & 255), N = 0, U = 0) : (N = q >>> 24, U += 2)
      }
      if (R < b.length)
        for (b[R++] = N; R < b.length;) b[R++] = 0
    }, s.prototype._toArrayLikeBE = function (b, T) {
      for (var R = b.length - 1, N = 0, O = 0, U = 0; O < this.length; O++) {
        var q = this.words[O] << U | N;
        b[R--] = q & 255, R >= 0 && (b[R--] = q >> 8 & 255), R >= 0 && (b[R--] = q >> 16 & 255), U === 6 ? (R >= 0 && (b[R--] = q >> 24 & 255), N = 0, U = 0) : (N = q >>> 24, U += 2)
      }
      if (R >= 0)
        for (b[R--] = N; R >= 0;) b[R--] = 0
    }, Math.clz32 ? s.prototype._countBits = function (b) {
      return 32 - Math.clz32(b)
    } : s.prototype._countBits = function (b) {
      var T = b,
        R = 0;
      return T >= 4096 && (R += 13, T >>>= 13), T >= 64 && (R += 7, T >>>= 7), T >= 8 && (R += 4, T >>>= 4), T >= 2 && (R += 2, T >>>= 2), R + T
    }, s.prototype._zeroBits = function (b) {
      if (b === 0) return 26;
      var T = b,
        R = 0;
      return T & 8191 || (R += 13, T >>>= 13), T & 127 || (R += 7, T >>>= 7), T & 15 || (R += 4, T >>>= 4), T & 3 || (R += 2, T >>>= 2), T & 1 || R++, R
    }, s.prototype.bitLength = function () {
      var b = this.words[this.length - 1],
        T = this._countBits(b);
      return (this.length - 1) * 26 + T
    };

    function k(L) {
      for (var b = new Array(L.bitLength()), T = 0; T < b.length; T++) {
        var R = T / 26 | 0,
          N = T % 26;
        b[T] = L.words[R] >>> N & 1
      }
      return b
    }
    s.prototype.zeroBits = function () {
      if (this.isZero()) return 0;
      for (var b = 0, T = 0; T < this.length; T++) {
        var R = this._zeroBits(this.words[T]);
        if (b += R, R !== 26) break
      }
      return b
    }, s.prototype.byteLength = function () {
      return Math.ceil(this.bitLength() / 8)
    }, s.prototype.toTwos = function (b) {
      return this.negative !== 0 ? this.abs().inotn(b).iaddn(1) : this.clone()
    }, s.prototype.fromTwos = function (b) {
      return this.testn(b - 1) ? this.notn(b).iaddn(1).ineg() : this.clone()
    }, s.prototype.isNeg = function () {
      return this.negative !== 0
    }, s.prototype.neg = function () {
      return this.clone().ineg()
    }, s.prototype.ineg = function () {
      return this.isZero() || (this.negative ^= 1), this
    }, s.prototype.iuor = function (b) {
      for (; this.length < b.length;) this.words[this.length++] = 0;
      for (var T = 0; T < b.length; T++) this.words[T] = this.words[T] | b.words[T];
      return this._strip()
    }, s.prototype.ior = function (b) {
      return r((this.negative | b.negative) === 0), this.iuor(b)
    }, s.prototype.or = function (b) {
      return this.length > b.length ? this.clone().ior(b) : b.clone().ior(this)
    }, s.prototype.uor = function (b) {
      return this.length > b.length ? this.clone().iuor(b) : b.clone().iuor(this)
    }, s.prototype.iuand = function (b) {
      var T;
      this.length > b.length ? T = b : T = this;
      for (var R = 0; R < T.length; R++) this.words[R] = this.words[R] & b.words[R];
      return this.length = T.length, this._strip()
    }, s.prototype.iand = function (b) {
      return r((this.negative | b.negative) === 0), this.iuand(b)
    }, s.prototype.and = function (b) {
      return this.length > b.length ? this.clone().iand(b) : b.clone().iand(this)
    }, s.prototype.uand = function (b) {
      return this.length > b.length ? this.clone().iuand(b) : b.clone().iuand(this)
    }, s.prototype.iuxor = function (b) {
      var T, R;
      this.length > b.length ? (T = this, R = b) : (T = b, R = this);
      for (var N = 0; N < R.length; N++) this.words[N] = T.words[N] ^ R.words[N];
      if (this !== T)
        for (; N < T.length; N++) this.words[N] = T.words[N];
      return this.length = T.length, this._strip()
    }, s.prototype.ixor = function (b) {
      return r((this.negative | b.negative) === 0), this.iuxor(b)
    }, s.prototype.xor = function (b) {
      return this.length > b.length ? this.clone().ixor(b) : b.clone().ixor(this)
    }, s.prototype.uxor = function (b) {
      return this.length > b.length ? this.clone().iuxor(b) : b.clone().iuxor(this)
    }, s.prototype.inotn = function (b) {
      r(typeof b == "number" && b >= 0);
      var T = Math.ceil(b / 26) | 0,
        R = b % 26;
      this._expand(T), R > 0 && T--;
      for (var N = 0; N < T; N++) this.words[N] = ~this.words[N] & 67108863;
      return R > 0 && (this.words[N] = ~this.words[N] & 67108863 >> 26 - R), this._strip()
    }, s.prototype.notn = function (b) {
      return this.clone().inotn(b)
    }, s.prototype.setn = function (b, T) {
      r(typeof b == "number" && b >= 0);
      var R = b / 26 | 0,
        N = b % 26;
      return this._expand(R + 1), T ? this.words[R] = this.words[R] | 1 << N : this.words[R] = this.words[R] & ~(1 << N), this._strip()
    }, s.prototype.iadd = function (b) {
      var T;
      if (this.negative !== 0 && b.negative === 0) return this.negative = 0, T = this.isub(b), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && b.negative !== 0) return b.negative = 0, T = this.isub(b), b.negative = 1, T._normSign();
      var R, N;
      this.length > b.length ? (R = this, N = b) : (R = b, N = this);
      for (var O = 0, U = 0; U < N.length; U++) T = (R.words[U] | 0) + (N.words[U] | 0) + O, this.words[U] = T & 67108863, O = T >>> 26;
      for (; O !== 0 && U < R.length; U++) T = (R.words[U] | 0) + O, this.words[U] = T & 67108863, O = T >>> 26;
      if (this.length = R.length, O !== 0) this.words[this.length] = O, this.length++;
      else if (R !== this)
        for (; U < R.length; U++) this.words[U] = R.words[U];
      return this
    }, s.prototype.add = function (b) {
      var T;
      return b.negative !== 0 && this.negative === 0 ? (b.negative = 0, T = this.sub(b), b.negative ^= 1, T) : b.negative === 0 && this.negative !== 0 ? (this.negative = 0, T = b.sub(this), this.negative = 1, T) : this.length > b.length ? this.clone().iadd(b) : b.clone().iadd(this)
    }, s.prototype.isub = function (b) {
      if (b.negative !== 0) {
        b.negative = 0;
        var T = this.iadd(b);
        return b.negative = 1, T._normSign()
      } else if (this.negative !== 0) return this.negative = 0, this.iadd(b), this.negative = 1, this._normSign();
      var R = this.cmp(b);
      if (R === 0) return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var N, O;
      R > 0 ? (N = this, O = b) : (N = b, O = this);
      for (var U = 0, q = 0; q < O.length; q++) T = (N.words[q] | 0) - (O.words[q] | 0) + U, U = T >> 26, this.words[q] = T & 67108863;
      for (; U !== 0 && q < N.length; q++) T = (N.words[q] | 0) + U, U = T >> 26, this.words[q] = T & 67108863;
      if (U === 0 && q < N.length && N !== this)
        for (; q < N.length; q++) this.words[q] = N.words[q];
      return this.length = Math.max(this.length, q), N !== this && (this.negative = 1), this._strip()
    }, s.prototype.sub = function (b) {
      return this.clone().isub(b)
    };

    function _(L, b, T) {
      T.negative = b.negative ^ L.negative;
      var R = L.length + b.length | 0;
      T.length = R, R = R - 1 | 0;
      var N = L.words[0] | 0,
        O = b.words[0] | 0,
        U = N * O,
        q = U & 67108863,
        W = U / 67108864 | 0;
      T.words[0] = q;
      for (var M = 1; M < R; M++) {
        for (var Q = W >>> 26, he = W & 67108863, H = Math.min(M, b.length - 1), ne = Math.max(0, M - L.length + 1); ne <= H; ne++) {
          var X = M - ne | 0;
          N = L.words[X] | 0, O = b.words[ne] | 0, U = N * O + he, Q += U / 67108864 | 0, he = U & 67108863
        }
        T.words[M] = he | 0, W = Q | 0
      }
      return W !== 0 ? T.words[M] = W | 0 : T.length--, T._strip()
    }
    var p = function (b, T, R) {
      var N = b.words,
        O = T.words,
        U = R.words,
        q = 0,
        W, M, Q, he = N[0] | 0,
        H = he & 8191,
        ne = he >>> 13,
        X = N[1] | 0,
        Z = X & 8191,
        te = X >>> 13,
        F = N[2] | 0,
        J = F & 8191,
        ie = F >>> 13,
        ce = N[3] | 0,
        ue = ce & 8191,
        ge = ce >>> 13,
        et = N[4] | 0,
        He = et & 8191,
        se = et >>> 13,
        pe = N[5] | 0,
        de = pe & 8191,
        we = pe >>> 13,
        Ce = N[6] | 0,
        be = Ce & 8191,
        Se = Ce >>> 13,
        Fe = N[7] | 0,
        Ne = Fe & 8191,
        Me = Fe >>> 13,
        We = N[8] | 0,
        ke = We & 8191,
        ze = We >>> 13,
        ct = N[9] | 0,
        Xe = ct & 8191,
        _e = ct >>> 13,
        Ze = O[0] | 0,
        Ee = Ze & 8191,
        Oe = Ze >>> 13,
        yt = O[1] | 0,
        tt = yt & 8191,
        dt = yt >>> 13,
        xn = O[2] | 0,
        Ht = xn & 8191,
        en = xn >>> 13,
        tn = O[3] | 0,
        Et = tn & 8191,
        Ot = tn >>> 13,
        kn = O[4] | 0,
        Dt = kn & 8191,
        Pt = kn >>> 13,
        _n = O[5] | 0,
        zt = _n & 8191,
        kt = _n >>> 13,
        In = O[6] | 0,
        vt = In & 8191,
        _t = In >>> 13,
        Pn = O[7] | 0,
        wt = Pn & 8191,
        $t = Pn >>> 13,
        Mn = O[8] | 0,
        Rn = Mn & 8191,
        On = Mn >>> 13,
        js = O[9] | 0,
        cn = js & 8191,
        $n = js >>> 13;
      R.negative = b.negative ^ T.negative, R.length = 19, W = Math.imul(H, Ee), M = Math.imul(H, Oe), M = M + Math.imul(ne, Ee) | 0, Q = Math.imul(ne, Oe);
      var Us = (q + W | 0) + ((M & 8191) << 13) | 0;
      q = (Q + (M >>> 13) | 0) + (Us >>> 26) | 0, Us &= 67108863, W = Math.imul(Z, Ee), M = Math.imul(Z, Oe), M = M + Math.imul(te, Ee) | 0, Q = Math.imul(te, Oe), W = W + Math.imul(H, tt) | 0, M = M + Math.imul(H, dt) | 0, M = M + Math.imul(ne, tt) | 0, Q = Q + Math.imul(ne, dt) | 0;
      var zs = (q + W | 0) + ((M & 8191) << 13) | 0;
      q = (Q + (M >>> 13) | 0) + (zs >>> 26) | 0, zs &= 67108863, W = Math.imul(J, Ee), M = Math.imul(J, Oe), M = M + Math.imul(ie, Ee) | 0, Q = Math.imul(ie, Oe), W = W + Math.imul(Z, tt) | 0, M = M + Math.imul(Z, dt) | 0, M = M + Math.imul(te, tt) | 0, Q = Q + Math.imul(te, dt) | 0, W = W + Math.imul(H, Ht) | 0, M = M + Math.imul(H, en) | 0, M = M + Math.imul(ne, Ht) | 0, Q = Q + Math.imul(ne, en) | 0;
      var Ut = (q + W | 0) + ((M & 8191) << 13) | 0;
      q = (Q + (M >>> 13) | 0) + (Ut >>> 26) | 0, Ut &= 67108863, W = Math.imul(ue, Ee), M = Math.imul(ue, Oe), M = M + Math.imul(ge, Ee) | 0, Q = Math.imul(ge, Oe), W = W + Math.imul(J, tt) | 0, M = M + Math.imul(J, dt) | 0, M = M + Math.imul(ie, tt) | 0, Q = Q + Math.imul(ie, dt) | 0, W = W + Math.imul(Z, Ht) | 0, M = M + Math.imul(Z, en) | 0, M = M + Math.imul(te, Ht) | 0, Q = Q + Math.imul(te, en) | 0, W = W + Math.imul(H, Et) | 0, M = M + Math.imul(H, Ot) | 0, M = M + Math.imul(ne, Et) | 0, Q = Q + Math.imul(ne, Ot) | 0;
      var or = (q + W | 0) + ((M & 8191) << 13) | 0;
      q = (Q + (M >>> 13) | 0) + (or >>> 26) | 0, or &= 67108863, W = Math.imul(He, Ee), M = Math.imul(He, Oe), M = M + Math.imul(se, Ee) | 0, Q = Math.imul(se, Oe), W = W + Math.imul(ue, tt) | 0, M = M + Math.imul(ue, dt) | 0, M = M + Math.imul(ge, tt) | 0, Q = Q + Math.imul(ge, dt) | 0, W = W + Math.imul(J, Ht) | 0, M = M + Math.imul(J, en) | 0, M = M + Math.imul(ie, Ht) | 0, Q = Q + Math.imul(ie, en) | 0, W = W + Math.imul(Z, Et) | 0, M = M + Math.imul(Z, Ot) | 0, M = M + Math.imul(te, Et) | 0, Q = Q + Math.imul(te, Ot) | 0, W = W + Math.imul(H, Dt) | 0, M = M + Math.imul(H, Pt) | 0, M = M + Math.imul(ne, Dt) | 0, Q = Q + Math.imul(ne, Pt) | 0;
      var pi = (q + W | 0) + ((M & 8191) << 13) | 0;
      q = (Q + (M >>> 13) | 0) + (pi >>> 26) | 0, pi &= 67108863, W = Math.imul(de, Ee), M = Math.imul(de, Oe), M = M + Math.imul(we, Ee) | 0, Q = Math.imul(we, Oe), W = W + Math.imul(He, tt) | 0, M = M + Math.imul(He, dt) | 0, M = M + Math.imul(se, tt) | 0, Q = Q + Math.imul(se, dt) | 0, W = W + Math.imul(ue, Ht) | 0, M = M + Math.imul(ue, en) | 0, M = M + Math.imul(ge, Ht) | 0, Q = Q + Math.imul(ge, en) | 0, W = W + Math.imul(J, Et) | 0, M = M + Math.imul(J, Ot) | 0, M = M + Math.imul(ie, Et) | 0, Q = Q + Math.imul(ie, Ot) | 0, W = W + Math.imul(Z, Dt) | 0, M = M + Math.imul(Z, Pt) | 0, M = M + Math.imul(te, Dt) | 0, Q = Q + Math.imul(te, Pt) | 0, W = W + Math.imul(H, zt) | 0, M = M + Math.imul(H, kt) | 0, M = M + Math.imul(ne, zt) | 0, Q = Q + Math.imul(ne, kt) | 0;
      var _c = (q + W | 0) + ((M & 8191) << 13) | 0;
      q = (Q + (M >>> 13) | 0) + (_c >>> 26) | 0, _c &= 67108863, W = Math.imul(be, Ee), M = Math.imul(be, Oe), M = M + Math.imul(Se, Ee) | 0, Q = Math.imul(Se, Oe), W = W + Math.imul(de, tt) | 0, M = M + Math.imul(de, dt) | 0, M = M + Math.imul(we, tt) | 0, Q = Q + Math.imul(we, dt) | 0, W = W + Math.imul(He, Ht) | 0, M = M + Math.imul(He, en) | 0, M = M + Math.imul(se, Ht) | 0, Q = Q + Math.imul(se, en) | 0, W = W + Math.imul(ue, Et) | 0, M = M + Math.imul(ue, Ot) | 0, M = M + Math.imul(ge, Et) | 0, Q = Q + Math.imul(ge, Ot) | 0, W = W + Math.imul(J, Dt) | 0, M = M + Math.imul(J, Pt) | 0, M = M + Math.imul(ie, Dt) | 0, Q = Q + Math.imul(ie, Pt) | 0, W = W + Math.imul(Z, zt) | 0, M = M + Math.imul(Z, kt) | 0, M = M + Math.imul(te, zt) | 0, Q = Q + Math.imul(te, kt) | 0, W = W + Math.imul(H, vt) | 0, M = M + Math.imul(H, _t) | 0, M = M + Math.imul(ne, vt) | 0, Q = Q + Math.imul(ne, _t) | 0;
      var qd = (q + W | 0) + ((M & 8191) << 13) | 0;
      q = (Q + (M >>> 13) | 0) + (qd >>> 26) | 0, qd &= 67108863, W = Math.imul(Ne, Ee), M = Math.imul(Ne, Oe), M = M + Math.imul(Me, Ee) | 0, Q = Math.imul(Me, Oe), W = W + Math.imul(be, tt) | 0, M = M + Math.imul(be, dt) | 0, M = M + Math.imul(Se, tt) | 0, Q = Q + Math.imul(Se, dt) | 0, W = W + Math.imul(de, Ht) | 0, M = M + Math.imul(de, en) | 0, M = M + Math.imul(we, Ht) | 0, Q = Q + Math.imul(we, en) | 0, W = W + Math.imul(He, Et) | 0, M = M + Math.imul(He, Ot) | 0, M = M + Math.imul(se, Et) | 0, Q = Q + Math.imul(se, Ot) | 0, W = W + Math.imul(ue, Dt) | 0, M = M + Math.imul(ue, Pt) | 0, M = M + Math.imul(ge, Dt) | 0, Q = Q + Math.imul(ge, Pt) | 0, W = W + Math.imul(J, zt) | 0, M = M + Math.imul(J, kt) | 0, M = M + Math.imul(ie, zt) | 0, Q = Q + Math.imul(ie, kt) | 0, W = W + Math.imul(Z, vt) | 0, M = M + Math.imul(Z, _t) | 0, M = M + Math.imul(te, vt) | 0, Q = Q + Math.imul(te, _t) | 0, W = W + Math.imul(H, wt) | 0, M = M + Math.imul(H, $t) | 0, M = M + Math.imul(ne, wt) | 0, Q = Q + Math.imul(ne, $t) | 0;
      var Ic = (q + W | 0) + ((M & 8191) << 13) | 0;
      q = (Q + (M >>> 13) | 0) + (Ic >>> 26) | 0, Ic &= 67108863, W = Math.imul(ke, Ee), M = Math.imul(ke, Oe), M = M + Math.imul(ze, Ee) | 0, Q = Math.imul(ze, Oe), W = W + Math.imul(Ne, tt) | 0, M = M + Math.imul(Ne, dt) | 0, M = M + Math.imul(Me, tt) | 0, Q = Q + Math.imul(Me, dt) | 0, W = W + Math.imul(be, Ht) | 0, M = M + Math.imul(be, en) | 0, M = M + Math.imul(Se, Ht) | 0, Q = Q + Math.imul(Se, en) | 0, W = W + Math.imul(de, Et) | 0, M = M + Math.imul(de, Ot) | 0, M = M + Math.imul(we, Et) | 0, Q = Q + Math.imul(we, Ot) | 0, W = W + Math.imul(He, Dt) | 0, M = M + Math.imul(He, Pt) | 0, M = M + Math.imul(se, Dt) | 0, Q = Q + Math.imul(se, Pt) | 0, W = W + Math.imul(ue, zt) | 0, M = M + Math.imul(ue, kt) | 0, M = M + Math.imul(ge, zt) | 0, Q = Q + Math.imul(ge, kt) | 0, W = W + Math.imul(J, vt) | 0, M = M + Math.imul(J, _t) | 0, M = M + Math.imul(ie, vt) | 0, Q = Q + Math.imul(ie, _t) | 0, W = W + Math.imul(Z, wt) | 0, M = M + Math.imul(Z, $t) | 0, M = M + Math.imul(te, wt) | 0, Q = Q + Math.imul(te, $t) | 0, W = W + Math.imul(H, Rn) | 0, M = M + Math.imul(H, On) | 0, M = M + Math.imul(ne, Rn) | 0, Q = Q + Math.imul(ne, On) | 0;
      var Gd = (q + W | 0) + ((M & 8191) << 13) | 0;
      q = (Q + (M >>> 13) | 0) + (Gd >>> 26) | 0, Gd &= 67108863, W = Math.imul(Xe, Ee), M = Math.imul(Xe, Oe), M = M + Math.imul(_e, Ee) | 0, Q = Math.imul(_e, Oe), W = W + Math.imul(ke, tt) | 0, M = M + Math.imul(ke, dt) | 0, M = M + Math.imul(ze, tt) | 0, Q = Q + Math.imul(ze, dt) | 0, W = W + Math.imul(Ne, Ht) | 0, M = M + Math.imul(Ne, en) | 0, M = M + Math.imul(Me, Ht) | 0, Q = Q + Math.imul(Me, en) | 0, W = W + Math.imul(be, Et) | 0, M = M + Math.imul(be, Ot) | 0, M = M + Math.imul(Se, Et) | 0, Q = Q + Math.imul(Se, Ot) | 0, W = W + Math.imul(de, Dt) | 0, M = M + Math.imul(de, Pt) | 0, M = M + Math.imul(we, Dt) | 0, Q = Q + Math.imul(we, Pt) | 0, W = W + Math.imul(He, zt) | 0, M = M + Math.imul(He, kt) | 0, M = M + Math.imul(se, zt) | 0, Q = Q + Math.imul(se, kt) | 0, W = W + Math.imul(ue, vt) | 0, M = M + Math.imul(ue, _t) | 0, M = M + Math.imul(ge, vt) | 0, Q = Q + Math.imul(ge, _t) | 0, W = W + Math.imul(J, wt) | 0, M = M + Math.imul(J, $t) | 0, M = M + Math.imul(ie, wt) | 0, Q = Q + Math.imul(ie, $t) | 0, W = W + Math.imul(Z, Rn) | 0, M = M + Math.imul(Z, On) | 0, M = M + Math.imul(te, Rn) | 0, Q = Q + Math.imul(te, On) | 0, W = W + Math.imul(H, cn) | 0, M = M + Math.imul(H, $n) | 0, M = M + Math.imul(ne, cn) | 0, Q = Q + Math.imul(ne, $n) | 0;
      var Kd = (q + W | 0) + ((M & 8191) << 13) | 0;
      q = (Q + (M >>> 13) | 0) + (Kd >>> 26) | 0, Kd &= 67108863, W = Math.imul(Xe, tt), M = Math.imul(Xe, dt), M = M + Math.imul(_e, tt) | 0, Q = Math.imul(_e, dt), W = W + Math.imul(ke, Ht) | 0, M = M + Math.imul(ke, en) | 0, M = M + Math.imul(ze, Ht) | 0, Q = Q + Math.imul(ze, en) | 0, W = W + Math.imul(Ne, Et) | 0, M = M + Math.imul(Ne, Ot) | 0, M = M + Math.imul(Me, Et) | 0, Q = Q + Math.imul(Me, Ot) | 0, W = W + Math.imul(be, Dt) | 0, M = M + Math.imul(be, Pt) | 0, M = M + Math.imul(Se, Dt) | 0, Q = Q + Math.imul(Se, Pt) | 0, W = W + Math.imul(de, zt) | 0, M = M + Math.imul(de, kt) | 0, M = M + Math.imul(we, zt) | 0, Q = Q + Math.imul(we, kt) | 0, W = W + Math.imul(He, vt) | 0, M = M + Math.imul(He, _t) | 0, M = M + Math.imul(se, vt) | 0, Q = Q + Math.imul(se, _t) | 0, W = W + Math.imul(ue, wt) | 0, M = M + Math.imul(ue, $t) | 0, M = M + Math.imul(ge, wt) | 0, Q = Q + Math.imul(ge, $t) | 0, W = W + Math.imul(J, Rn) | 0, M = M + Math.imul(J, On) | 0, M = M + Math.imul(ie, Rn) | 0, Q = Q + Math.imul(ie, On) | 0, W = W + Math.imul(Z, cn) | 0, M = M + Math.imul(Z, $n) | 0, M = M + Math.imul(te, cn) | 0, Q = Q + Math.imul(te, $n) | 0;
      var Pc = (q + W | 0) + ((M & 8191) << 13) | 0;
      q = (Q + (M >>> 13) | 0) + (Pc >>> 26) | 0, Pc &= 67108863, W = Math.imul(Xe, Ht), M = Math.imul(Xe, en), M = M + Math.imul(_e, Ht) | 0, Q = Math.imul(_e, en), W = W + Math.imul(ke, Et) | 0, M = M + Math.imul(ke, Ot) | 0, M = M + Math.imul(ze, Et) | 0, Q = Q + Math.imul(ze, Ot) | 0, W = W + Math.imul(Ne, Dt) | 0, M = M + Math.imul(Ne, Pt) | 0, M = M + Math.imul(Me, Dt) | 0, Q = Q + Math.imul(Me, Pt) | 0, W = W + Math.imul(be, zt) | 0, M = M + Math.imul(be, kt) | 0, M = M + Math.imul(Se, zt) | 0, Q = Q + Math.imul(Se, kt) | 0, W = W + Math.imul(de, vt) | 0, M = M + Math.imul(de, _t) | 0, M = M + Math.imul(we, vt) | 0, Q = Q + Math.imul(we, _t) | 0, W = W + Math.imul(He, wt) | 0, M = M + Math.imul(He, $t) | 0, M = M + Math.imul(se, wt) | 0, Q = Q + Math.imul(se, $t) | 0, W = W + Math.imul(ue, Rn) | 0, M = M + Math.imul(ue, On) | 0, M = M + Math.imul(ge, Rn) | 0, Q = Q + Math.imul(ge, On) | 0, W = W + Math.imul(J, cn) | 0, M = M + Math.imul(J, $n) | 0, M = M + Math.imul(ie, cn) | 0, Q = Q + Math.imul(ie, $n) | 0;
      var _u = (q + W | 0) + ((M & 8191) << 13) | 0;
      q = (Q + (M >>> 13) | 0) + (_u >>> 26) | 0, _u &= 67108863, W = Math.imul(Xe, Et), M = Math.imul(Xe, Ot), M = M + Math.imul(_e, Et) | 0, Q = Math.imul(_e, Ot), W = W + Math.imul(ke, Dt) | 0, M = M + Math.imul(ke, Pt) | 0, M = M + Math.imul(ze, Dt) | 0, Q = Q + Math.imul(ze, Pt) | 0, W = W + Math.imul(Ne, zt) | 0, M = M + Math.imul(Ne, kt) | 0, M = M + Math.imul(Me, zt) | 0, Q = Q + Math.imul(Me, kt) | 0, W = W + Math.imul(be, vt) | 0, M = M + Math.imul(be, _t) | 0, M = M + Math.imul(Se, vt) | 0, Q = Q + Math.imul(Se, _t) | 0, W = W + Math.imul(de, wt) | 0, M = M + Math.imul(de, $t) | 0, M = M + Math.imul(we, wt) | 0, Q = Q + Math.imul(we, $t) | 0, W = W + Math.imul(He, Rn) | 0, M = M + Math.imul(He, On) | 0, M = M + Math.imul(se, Rn) | 0, Q = Q + Math.imul(se, On) | 0, W = W + Math.imul(ue, cn) | 0, M = M + Math.imul(ue, $n) | 0, M = M + Math.imul(ge, cn) | 0, Q = Q + Math.imul(ge, $n) | 0;
      var Iu = (q + W | 0) + ((M & 8191) << 13) | 0;
      q = (Q + (M >>> 13) | 0) + (Iu >>> 26) | 0, Iu &= 67108863, W = Math.imul(Xe, Dt), M = Math.imul(Xe, Pt), M = M + Math.imul(_e, Dt) | 0, Q = Math.imul(_e, Pt), W = W + Math.imul(ke, zt) | 0, M = M + Math.imul(ke, kt) | 0, M = M + Math.imul(ze, zt) | 0, Q = Q + Math.imul(ze, kt) | 0, W = W + Math.imul(Ne, vt) | 0, M = M + Math.imul(Ne, _t) | 0, M = M + Math.imul(Me, vt) | 0, Q = Q + Math.imul(Me, _t) | 0, W = W + Math.imul(be, wt) | 0, M = M + Math.imul(be, $t) | 0, M = M + Math.imul(Se, wt) | 0, Q = Q + Math.imul(Se, $t) | 0, W = W + Math.imul(de, Rn) | 0, M = M + Math.imul(de, On) | 0, M = M + Math.imul(we, Rn) | 0, Q = Q + Math.imul(we, On) | 0, W = W + Math.imul(He, cn) | 0, M = M + Math.imul(He, $n) | 0, M = M + Math.imul(se, cn) | 0, Q = Q + Math.imul(se, $n) | 0;
      var ps = (q + W | 0) + ((M & 8191) << 13) | 0;
      q = (Q + (M >>> 13) | 0) + (ps >>> 26) | 0, ps &= 67108863, W = Math.imul(Xe, zt), M = Math.imul(Xe, kt), M = M + Math.imul(_e, zt) | 0, Q = Math.imul(_e, kt), W = W + Math.imul(ke, vt) | 0, M = M + Math.imul(ke, _t) | 0, M = M + Math.imul(ze, vt) | 0, Q = Q + Math.imul(ze, _t) | 0, W = W + Math.imul(Ne, wt) | 0, M = M + Math.imul(Ne, $t) | 0, M = M + Math.imul(Me, wt) | 0, Q = Q + Math.imul(Me, $t) | 0, W = W + Math.imul(be, Rn) | 0, M = M + Math.imul(be, On) | 0, M = M + Math.imul(Se, Rn) | 0, Q = Q + Math.imul(Se, On) | 0, W = W + Math.imul(de, cn) | 0, M = M + Math.imul(de, $n) | 0, M = M + Math.imul(we, cn) | 0, Q = Q + Math.imul(we, $n) | 0;
      var Qd = (q + W | 0) + ((M & 8191) << 13) | 0;
      q = (Q + (M >>> 13) | 0) + (Qd >>> 26) | 0, Qd &= 67108863, W = Math.imul(Xe, vt), M = Math.imul(Xe, _t), M = M + Math.imul(_e, vt) | 0, Q = Math.imul(_e, _t), W = W + Math.imul(ke, wt) | 0, M = M + Math.imul(ke, $t) | 0, M = M + Math.imul(ze, wt) | 0, Q = Q + Math.imul(ze, $t) | 0, W = W + Math.imul(Ne, Rn) | 0, M = M + Math.imul(Ne, On) | 0, M = M + Math.imul(Me, Rn) | 0, Q = Q + Math.imul(Me, On) | 0, W = W + Math.imul(be, cn) | 0, M = M + Math.imul(be, $n) | 0, M = M + Math.imul(Se, cn) | 0, Q = Q + Math.imul(Se, $n) | 0;
      var Yd = (q + W | 0) + ((M & 8191) << 13) | 0;
      q = (Q + (M >>> 13) | 0) + (Yd >>> 26) | 0, Yd &= 67108863, W = Math.imul(Xe, wt), M = Math.imul(Xe, $t), M = M + Math.imul(_e, wt) | 0, Q = Math.imul(_e, $t), W = W + Math.imul(ke, Rn) | 0, M = M + Math.imul(ke, On) | 0, M = M + Math.imul(ze, Rn) | 0, Q = Q + Math.imul(ze, On) | 0, W = W + Math.imul(Ne, cn) | 0, M = M + Math.imul(Ne, $n) | 0, M = M + Math.imul(Me, cn) | 0, Q = Q + Math.imul(Me, $n) | 0;
      var Jd = (q + W | 0) + ((M & 8191) << 13) | 0;
      q = (Q + (M >>> 13) | 0) + (Jd >>> 26) | 0, Jd &= 67108863, W = Math.imul(Xe, Rn), M = Math.imul(Xe, On), M = M + Math.imul(_e, Rn) | 0, Q = Math.imul(_e, On), W = W + Math.imul(ke, cn) | 0, M = M + Math.imul(ke, $n) | 0, M = M + Math.imul(ze, cn) | 0, Q = Q + Math.imul(ze, $n) | 0;
      var Xd = (q + W | 0) + ((M & 8191) << 13) | 0;
      q = (Q + (M >>> 13) | 0) + (Xd >>> 26) | 0, Xd &= 67108863, W = Math.imul(Xe, cn), M = Math.imul(Xe, $n), M = M + Math.imul(_e, cn) | 0, Q = Math.imul(_e, $n);
      var Pu = (q + W | 0) + ((M & 8191) << 13) | 0;
      return q = (Q + (M >>> 13) | 0) + (Pu >>> 26) | 0, Pu &= 67108863, U[0] = Us, U[1] = zs, U[2] = Ut, U[3] = or, U[4] = pi, U[5] = _c, U[6] = qd, U[7] = Ic, U[8] = Gd, U[9] = Kd, U[10] = Pc, U[11] = _u, U[12] = Iu, U[13] = ps, U[14] = Qd, U[15] = Yd, U[16] = Jd, U[17] = Xd, U[18] = Pu, q !== 0 && (U[19] = q, R.length++), R
    };
    Math.imul || (p = _);

    function v(L, b, T) {
      T.negative = b.negative ^ L.negative, T.length = L.length + b.length;
      for (var R = 0, N = 0, O = 0; O < T.length - 1; O++) {
        var U = N;
        N = 0;
        for (var q = R & 67108863, W = Math.min(O, b.length - 1), M = Math.max(0, O - L.length + 1); M <= W; M++) {
          var Q = O - M,
            he = L.words[Q] | 0,
            H = b.words[M] | 0,
            ne = he * H,
            X = ne & 67108863;
          U = U + (ne / 67108864 | 0) | 0, X = X + q | 0, q = X & 67108863, U = U + (X >>> 26) | 0, N += U >>> 26, U &= 67108863
        }
        T.words[O] = q, R = U, U = N
      }
      return R !== 0 ? T.words[O] = R : T.length--, T._strip()
    }

    function S(L, b, T) {
      return v(L, b, T)
    }
    s.prototype.mulTo = function (b, T) {
      var R, N = this.length + b.length;
      return this.length === 10 && b.length === 10 ? R = p(this, b, T) : N < 63 ? R = _(this, b, T) : N < 1024 ? R = v(this, b, T) : R = S(this, b, T), R
    }, s.prototype.mul = function (b) {
      var T = new s(null);
      return T.words = new Array(this.length + b.length), this.mulTo(b, T)
    }, s.prototype.mulf = function (b) {
      var T = new s(null);
      return T.words = new Array(this.length + b.length), S(this, b, T)
    }, s.prototype.imul = function (b) {
      return this.clone().mulTo(b, this)
    }, s.prototype.imuln = function (b) {
      var T = b < 0;
      T && (b = -b), r(typeof b == "number"), r(b < 67108864);
      for (var R = 0, N = 0; N < this.length; N++) {
        var O = (this.words[N] | 0) * b,
          U = (O & 67108863) + (R & 67108863);
        R >>= 26, R += O / 67108864 | 0, R += U >>> 26, this.words[N] = U & 67108863
      }
      return R !== 0 && (this.words[N] = R, this.length++), T ? this.ineg() : this
    }, s.prototype.muln = function (b) {
      return this.clone().imuln(b)
    }, s.prototype.sqr = function () {
      return this.mul(this)
    }, s.prototype.isqr = function () {
      return this.imul(this.clone())
    }, s.prototype.pow = function (b) {
      var T = k(b);
      if (T.length === 0) return new s(1);
      for (var R = this, N = 0; N < T.length && T[N] === 0; N++, R = R.sqr());
      if (++N < T.length)
        for (var O = R.sqr(); N < T.length; N++, O = O.sqr()) T[N] !== 0 && (R = R.mul(O));
      return R
    }, s.prototype.iushln = function (b) {
      r(typeof b == "number" && b >= 0);
      var T = b % 26,
        R = (b - T) / 26,
        N = 67108863 >>> 26 - T << 26 - T,
        O;
      if (T !== 0) {
        var U = 0;
        for (O = 0; O < this.length; O++) {
          var q = this.words[O] & N,
            W = (this.words[O] | 0) - q << T;
          this.words[O] = W | U, U = q >>> 26 - T
        }
        U && (this.words[O] = U, this.length++)
      }
      if (R !== 0) {
        for (O = this.length - 1; O >= 0; O--) this.words[O + R] = this.words[O];
        for (O = 0; O < R; O++) this.words[O] = 0;
        this.length += R
      }
      return this._strip()
    }, s.prototype.ishln = function (b) {
      return r(this.negative === 0), this.iushln(b)
    }, s.prototype.iushrn = function (b, T, R) {
      r(typeof b == "number" && b >= 0);
      var N;
      T ? N = (T - T % 26) / 26 : N = 0;
      var O = b % 26,
        U = Math.min((b - O) / 26, this.length),
        q = 67108863 ^ 67108863 >>> O << O,
        W = R;
      if (N -= U, N = Math.max(0, N), W) {
        for (var M = 0; M < U; M++) W.words[M] = this.words[M];
        W.length = U
      }
      if (U !== 0)
        if (this.length > U)
          for (this.length -= U, M = 0; M < this.length; M++) this.words[M] = this.words[M + U];
        else this.words[0] = 0, this.length = 1;
      var Q = 0;
      for (M = this.length - 1; M >= 0 && (Q !== 0 || M >= N); M--) {
        var he = this.words[M] | 0;
        this.words[M] = Q << 26 - O | he >>> O, Q = he & q
      }
      return W && Q !== 0 && (W.words[W.length++] = Q), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip()
    }, s.prototype.ishrn = function (b, T, R) {
      return r(this.negative === 0), this.iushrn(b, T, R)
    }, s.prototype.shln = function (b) {
      return this.clone().ishln(b)
    }, s.prototype.ushln = function (b) {
      return this.clone().iushln(b)
    }, s.prototype.shrn = function (b) {
      return this.clone().ishrn(b)
    }, s.prototype.ushrn = function (b) {
      return this.clone().iushrn(b)
    }, s.prototype.testn = function (b) {
      r(typeof b == "number" && b >= 0);
      var T = b % 26,
        R = (b - T) / 26,
        N = 1 << T;
      if (this.length <= R) return !1;
      var O = this.words[R];
      return !!(O & N)
    }, s.prototype.imaskn = function (b) {
      r(typeof b == "number" && b >= 0);
      var T = b % 26,
        R = (b - T) / 26;
      if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= R) return this;
      if (T !== 0 && R++, this.length = Math.min(R, this.length), T !== 0) {
        var N = 67108863 ^ 67108863 >>> T << T;
        this.words[this.length - 1] &= N
      }
      return this._strip()
    }, s.prototype.maskn = function (b) {
      return this.clone().imaskn(b)
    }, s.prototype.iaddn = function (b) {
      return r(typeof b == "number"), r(b < 67108864), b < 0 ? this.isubn(-b) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= b ? (this.words[0] = b - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(b), this.negative = 1, this) : this._iaddn(b)
    }, s.prototype._iaddn = function (b) {
      this.words[0] += b;
      for (var T = 0; T < this.length && this.words[T] >= 67108864; T++) this.words[T] -= 67108864, T === this.length - 1 ? this.words[T + 1] = 1 : this.words[T + 1]++;
      return this.length = Math.max(this.length, T + 1), this
    }, s.prototype.isubn = function (b) {
      if (r(typeof b == "number"), r(b < 67108864), b < 0) return this.iaddn(-b);
      if (this.negative !== 0) return this.negative = 0, this.iaddn(b), this.negative = 1, this;
      if (this.words[0] -= b, this.length === 1 && this.words[0] < 0) this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var T = 0; T < this.length && this.words[T] < 0; T++) this.words[T] += 67108864, this.words[T + 1] -= 1;
      return this._strip()
    }, s.prototype.addn = function (b) {
      return this.clone().iaddn(b)
    }, s.prototype.subn = function (b) {
      return this.clone().isubn(b)
    }, s.prototype.iabs = function () {
      return this.negative = 0, this
    }, s.prototype.abs = function () {
      return this.clone().iabs()
    }, s.prototype._ishlnsubmul = function (b, T, R) {
      var N = b.length + R,
        O;
      this._expand(N);
      var U, q = 0;
      for (O = 0; O < b.length; O++) {
        U = (this.words[O + R] | 0) + q;
        var W = (b.words[O] | 0) * T;
        U -= W & 67108863, q = (U >> 26) - (W / 67108864 | 0), this.words[O + R] = U & 67108863
      }
      for (; O < this.length - R; O++) U = (this.words[O + R] | 0) + q, q = U >> 26, this.words[O + R] = U & 67108863;
      if (q === 0) return this._strip();
      for (r(q === -1), q = 0, O = 0; O < this.length; O++) U = -(this.words[O] | 0) + q, q = U >> 26, this.words[O] = U & 67108863;
      return this.negative = 1, this._strip()
    }, s.prototype._wordDiv = function (b, T) {
      var R = this.length - b.length,
        N = this.clone(),
        O = b,
        U = O.words[O.length - 1] | 0,
        q = this._countBits(U);
      R = 26 - q, R !== 0 && (O = O.ushln(R), N.iushln(R), U = O.words[O.length - 1] | 0);
      var W = N.length - O.length,
        M;
      if (T !== "mod") {
        M = new s(null), M.length = W + 1, M.words = new Array(M.length);
        for (var Q = 0; Q < M.length; Q++) M.words[Q] = 0
      }
      var he = N.clone()._ishlnsubmul(O, 1, W);
      he.negative === 0 && (N = he, M && (M.words[W] = 1));
      for (var H = W - 1; H >= 0; H--) {
        var ne = (N.words[O.length + H] | 0) * 67108864 + (N.words[O.length + H - 1] | 0);
        for (ne = Math.min(ne / U | 0, 67108863), N._ishlnsubmul(O, ne, H); N.negative !== 0;) ne--, N.negative = 0, N._ishlnsubmul(O, 1, H), N.isZero() || (N.negative ^= 1);
        M && (M.words[H] = ne)
      }
      return M && M._strip(), N._strip(), T !== "div" && R !== 0 && N.iushrn(R), {
        div: M || null,
        mod: N
      }
    }, s.prototype.divmod = function (b, T, R) {
      if (r(!b.isZero()), this.isZero()) return {
        div: new s(0),
        mod: new s(0)
      };
      var N, O, U;
      return this.negative !== 0 && b.negative === 0 ? (U = this.neg().divmod(b, T), T !== "mod" && (N = U.div.neg()), T !== "div" && (O = U.mod.neg(), R && O.negative !== 0 && O.iadd(b)), {
        div: N,
        mod: O
      }) : this.negative === 0 && b.negative !== 0 ? (U = this.divmod(b.neg(), T), T !== "mod" && (N = U.div.neg()), {
        div: N,
        mod: U.mod
      }) : this.negative & b.negative ? (U = this.neg().divmod(b.neg(), T), T !== "div" && (O = U.mod.neg(), R && O.negative !== 0 && O.isub(b)), {
        div: U.div,
        mod: O
      }) : b.length > this.length || this.cmp(b) < 0 ? {
        div: new s(0),
        mod: this
      } : b.length === 1 ? T === "div" ? {
        div: this.divn(b.words[0]),
        mod: null
      } : T === "mod" ? {
        div: null,
        mod: new s(this.modrn(b.words[0]))
      } : {
        div: this.divn(b.words[0]),
        mod: new s(this.modrn(b.words[0]))
      } : this._wordDiv(b, T)
    }, s.prototype.div = function (b) {
      return this.divmod(b, "div", !1).div
    }, s.prototype.mod = function (b) {
      return this.divmod(b, "mod", !1).mod
    }, s.prototype.umod = function (b) {
      return this.divmod(b, "mod", !0).mod
    }, s.prototype.divRound = function (b) {
      var T = this.divmod(b);
      if (T.mod.isZero()) return T.div;
      var R = T.div.negative !== 0 ? T.mod.isub(b) : T.mod,
        N = b.ushrn(1),
        O = b.andln(1),
        U = R.cmp(N);
      return U < 0 || O === 1 && U === 0 ? T.div : T.div.negative !== 0 ? T.div.isubn(1) : T.div.iaddn(1)
    }, s.prototype.modrn = function (b) {
      var T = b < 0;
      T && (b = -b), r(b <= 67108863);
      for (var R = (1 << 26) % b, N = 0, O = this.length - 1; O >= 0; O--) N = (R * N + (this.words[O] | 0)) % b;
      return T ? -N : N
    }, s.prototype.modn = function (b) {
      return this.modrn(b)
    }, s.prototype.idivn = function (b) {
      var T = b < 0;
      T && (b = -b), r(b <= 67108863);
      for (var R = 0, N = this.length - 1; N >= 0; N--) {
        var O = (this.words[N] | 0) + R * 67108864;
        this.words[N] = O / b | 0, R = O % b
      }
      return this._strip(), T ? this.ineg() : this
    }, s.prototype.divn = function (b) {
      return this.clone().idivn(b)
    }, s.prototype.egcd = function (b) {
      r(b.negative === 0), r(!b.isZero());
      var T = this,
        R = b.clone();
      T.negative !== 0 ? T = T.umod(b) : T = T.clone();
      for (var N = new s(1), O = new s(0), U = new s(0), q = new s(1), W = 0; T.isEven() && R.isEven();) T.iushrn(1), R.iushrn(1), ++W;
      for (var M = R.clone(), Q = T.clone(); !T.isZero();) {
        for (var he = 0, H = 1; !(T.words[0] & H) && he < 26; ++he, H <<= 1);
        if (he > 0)
          for (T.iushrn(he); he-- > 0;)(N.isOdd() || O.isOdd()) && (N.iadd(M), O.isub(Q)), N.iushrn(1), O.iushrn(1);
        for (var ne = 0, X = 1; !(R.words[0] & X) && ne < 26; ++ne, X <<= 1);
        if (ne > 0)
          for (R.iushrn(ne); ne-- > 0;)(U.isOdd() || q.isOdd()) && (U.iadd(M), q.isub(Q)), U.iushrn(1), q.iushrn(1);
        T.cmp(R) >= 0 ? (T.isub(R), N.isub(U), O.isub(q)) : (R.isub(T), U.isub(N), q.isub(O))
      }
      return {
        a: U,
        b: q,
        gcd: R.iushln(W)
      }
    }, s.prototype._invmp = function (b) {
      r(b.negative === 0), r(!b.isZero());
      var T = this,
        R = b.clone();
      T.negative !== 0 ? T = T.umod(b) : T = T.clone();
      for (var N = new s(1), O = new s(0), U = R.clone(); T.cmpn(1) > 0 && R.cmpn(1) > 0;) {
        for (var q = 0, W = 1; !(T.words[0] & W) && q < 26; ++q, W <<= 1);
        if (q > 0)
          for (T.iushrn(q); q-- > 0;) N.isOdd() && N.iadd(U), N.iushrn(1);
        for (var M = 0, Q = 1; !(R.words[0] & Q) && M < 26; ++M, Q <<= 1);
        if (M > 0)
          for (R.iushrn(M); M-- > 0;) O.isOdd() && O.iadd(U), O.iushrn(1);
        T.cmp(R) >= 0 ? (T.isub(R), N.isub(O)) : (R.isub(T), O.isub(N))
      }
      var he;
      return T.cmpn(1) === 0 ? he = N : he = O, he.cmpn(0) < 0 && he.iadd(b), he
    }, s.prototype.gcd = function (b) {
      if (this.isZero()) return b.abs();
      if (b.isZero()) return this.abs();
      var T = this.clone(),
        R = b.clone();
      T.negative = 0, R.negative = 0;
      for (var N = 0; T.isEven() && R.isEven(); N++) T.iushrn(1), R.iushrn(1);
      do {
        for (; T.isEven();) T.iushrn(1);
        for (; R.isEven();) R.iushrn(1);
        var O = T.cmp(R);
        if (O < 0) {
          var U = T;
          T = R, R = U
        } else if (O === 0 || R.cmpn(1) === 0) break;
        T.isub(R)
      } while (!0);
      return R.iushln(N)
    }, s.prototype.invm = function (b) {
      return this.egcd(b).a.umod(b)
    }, s.prototype.isEven = function () {
      return (this.words[0] & 1) === 0
    }, s.prototype.isOdd = function () {
      return (this.words[0] & 1) === 1
    }, s.prototype.andln = function (b) {
      return this.words[0] & b
    }, s.prototype.bincn = function (b) {
      r(typeof b == "number");
      var T = b % 26,
        R = (b - T) / 26,
        N = 1 << T;
      if (this.length <= R) return this._expand(R + 1), this.words[R] |= N, this;
      for (var O = N, U = R; O !== 0 && U < this.length; U++) {
        var q = this.words[U] | 0;
        q += O, O = q >>> 26, q &= 67108863, this.words[U] = q
      }
      return O !== 0 && (this.words[U] = O, this.length++), this
    }, s.prototype.isZero = function () {
      return this.length === 1 && this.words[0] === 0
    }, s.prototype.cmpn = function (b) {
      var T = b < 0;
      if (this.negative !== 0 && !T) return -1;
      if (this.negative === 0 && T) return 1;
      this._strip();
      var R;
      if (this.length > 1) R = 1;
      else {
        T && (b = -b), r(b <= 67108863, "Number is too big");
        var N = this.words[0] | 0;
        R = N === b ? 0 : N < b ? -1 : 1
      }
      return this.negative !== 0 ? -R | 0 : R
    }, s.prototype.cmp = function (b) {
      if (this.negative !== 0 && b.negative === 0) return -1;
      if (this.negative === 0 && b.negative !== 0) return 1;
      var T = this.ucmp(b);
      return this.negative !== 0 ? -T | 0 : T
    }, s.prototype.ucmp = function (b) {
      if (this.length > b.length) return 1;
      if (this.length < b.length) return -1;
      for (var T = 0, R = this.length - 1; R >= 0; R--) {
        var N = this.words[R] | 0,
          O = b.words[R] | 0;
        if (N !== O) {
          N < O ? T = -1 : N > O && (T = 1);
          break
        }
      }
      return T
    }, s.prototype.gtn = function (b) {
      return this.cmpn(b) === 1
    }, s.prototype.gt = function (b) {
      return this.cmp(b) === 1
    }, s.prototype.gten = function (b) {
      return this.cmpn(b) >= 0
    }, s.prototype.gte = function (b) {
      return this.cmp(b) >= 0
    }, s.prototype.ltn = function (b) {
      return this.cmpn(b) === -1
    }, s.prototype.lt = function (b) {
      return this.cmp(b) === -1
    }, s.prototype.lten = function (b) {
      return this.cmpn(b) <= 0
    }, s.prototype.lte = function (b) {
      return this.cmp(b) <= 0
    }, s.prototype.eqn = function (b) {
      return this.cmpn(b) === 0
    }, s.prototype.eq = function (b) {
      return this.cmp(b) === 0
    }, s.red = function (b) {
      return new V(b)
    }, s.prototype.toRed = function (b) {
      return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), b.convertTo(this)._forceRed(b)
    }, s.prototype.fromRed = function () {
      return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this)
    }, s.prototype._forceRed = function (b) {
      return this.red = b, this
    }, s.prototype.forceRed = function (b) {
      return r(!this.red, "Already a number in reduction context"), this._forceRed(b)
    }, s.prototype.redAdd = function (b) {
      return r(this.red, "redAdd works only with red numbers"), this.red.add(this, b)
    }, s.prototype.redIAdd = function (b) {
      return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, b)
    }, s.prototype.redSub = function (b) {
      return r(this.red, "redSub works only with red numbers"), this.red.sub(this, b)
    }, s.prototype.redISub = function (b) {
      return r(this.red, "redISub works only with red numbers"), this.red.isub(this, b)
    }, s.prototype.redShl = function (b) {
      return r(this.red, "redShl works only with red numbers"), this.red.shl(this, b)
    }, s.prototype.redMul = function (b) {
      return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, b), this.red.mul(this, b)
    }, s.prototype.redIMul = function (b) {
      return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, b), this.red.imul(this, b)
    }, s.prototype.redSqr = function () {
      return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this)
    }, s.prototype.redISqr = function () {
      return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this)
    }, s.prototype.redSqrt = function () {
      return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this)
    }, s.prototype.redInvm = function () {
      return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this)
    }, s.prototype.redNeg = function () {
      return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this)
    }, s.prototype.redPow = function (b) {
      return r(this.red && !b.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, b)
    };
    var I = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };

    function A(L, b) {
      this.name = L, this.p = new s(b, 16), this.n = this.p.bitLength(), this.k = new s(1).iushln(this.n).isub(this.p), this.tmp = this._tmp()
    }
    A.prototype._tmp = function () {
      var b = new s(null);
      return b.words = new Array(Math.ceil(this.n / 13)), b
    }, A.prototype.ireduce = function (b) {
      var T = b,
        R;
      do this.split(T, this.tmp), T = this.imulK(T), T = T.iadd(this.tmp), R = T.bitLength(); while (R > this.n);
      var N = R < this.n ? -1 : T.ucmp(this.p);
      return N === 0 ? (T.words[0] = 0, T.length = 1) : N > 0 ? T.isub(this.p) : T.strip !== void 0 ? T.strip() : T._strip(), T
    }, A.prototype.split = function (b, T) {
      b.iushrn(this.n, 0, T)
    }, A.prototype.imulK = function (b) {
      return b.imul(this.k)
    };

    function w() {
      A.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f")
    }
    i(w, A), w.prototype.split = function (b, T) {
      for (var R = 4194303, N = Math.min(b.length, 9), O = 0; O < N; O++) T.words[O] = b.words[O];
      if (T.length = N, b.length <= 9) {
        b.words[0] = 0, b.length = 1;
        return
      }
      var U = b.words[9];
      for (T.words[T.length++] = U & R, O = 10; O < b.length; O++) {
        var q = b.words[O] | 0;
        b.words[O - 10] = (q & R) << 4 | U >>> 22, U = q
      }
      U >>>= 22, b.words[O - 10] = U, U === 0 && b.length > 10 ? b.length -= 10 : b.length -= 9
    }, w.prototype.imulK = function (b) {
      b.words[b.length] = 0, b.words[b.length + 1] = 0, b.length += 2;
      for (var T = 0, R = 0; R < b.length; R++) {
        var N = b.words[R] | 0;
        T += N * 977, b.words[R] = T & 67108863, T = N * 64 + (T / 67108864 | 0)
      }
      return b.words[b.length - 1] === 0 && (b.length--, b.words[b.length - 1] === 0 && b.length--), b
    };

    function E() {
      A.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001")
    }
    i(E, A);

    function D() {
      A.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff")
    }
    i(D, A);

    function $() {
      A.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed")
    }
    i($, A), $.prototype.imulK = function (b) {
      for (var T = 0, R = 0; R < b.length; R++) {
        var N = (b.words[R] | 0) * 19 + T,
          O = N & 67108863;
        N >>>= 26, b.words[R] = O, T = N
      }
      return T !== 0 && (b.words[b.length++] = T), b
    }, s._prime = function (b) {
      if (I[b]) return I[b];
      var T;
      if (b === "k256") T = new w;
      else if (b === "p224") T = new E;
      else if (b === "p192") T = new D;
      else if (b === "p25519") T = new $;
      else throw new Error("Unknown prime " + b);
      return I[b] = T, T
    };

    function V(L) {
      if (typeof L == "string") {
        var b = s._prime(L);
        this.m = b.p, this.prime = b
      } else r(L.gtn(1), "modulus must be greater than 1"), this.m = L, this.prime = null
    }
    V.prototype._verify1 = function (b) {
      r(b.negative === 0, "red works only with positives"), r(b.red, "red works only with red numbers")
    }, V.prototype._verify2 = function (b, T) {
      r((b.negative | T.negative) === 0, "red works only with positives"), r(b.red && b.red === T.red, "red works only with red numbers")
    }, V.prototype.imod = function (b) {
      return this.prime ? this.prime.ireduce(b)._forceRed(this) : (u(b, b.umod(this.m)._forceRed(this)), b)
    }, V.prototype.neg = function (b) {
      return b.isZero() ? b.clone() : this.m.sub(b)._forceRed(this)
    }, V.prototype.add = function (b, T) {
      this._verify2(b, T);
      var R = b.add(T);
      return R.cmp(this.m) >= 0 && R.isub(this.m), R._forceRed(this)
    }, V.prototype.iadd = function (b, T) {
      this._verify2(b, T);
      var R = b.iadd(T);
      return R.cmp(this.m) >= 0 && R.isub(this.m), R
    }, V.prototype.sub = function (b, T) {
      this._verify2(b, T);
      var R = b.sub(T);
      return R.cmpn(0) < 0 && R.iadd(this.m), R._forceRed(this)
    }, V.prototype.isub = function (b, T) {
      this._verify2(b, T);
      var R = b.isub(T);
      return R.cmpn(0) < 0 && R.iadd(this.m), R
    }, V.prototype.shl = function (b, T) {
      return this._verify1(b), this.imod(b.ushln(T))
    }, V.prototype.imul = function (b, T) {
      return this._verify2(b, T), this.imod(b.imul(T))
    }, V.prototype.mul = function (b, T) {
      return this._verify2(b, T), this.imod(b.mul(T))
    }, V.prototype.isqr = function (b) {
      return this.imul(b, b.clone())
    }, V.prototype.sqr = function (b) {
      return this.mul(b, b)
    }, V.prototype.sqrt = function (b) {
      if (b.isZero()) return b.clone();
      var T = this.m.andln(3);
      if (r(T % 2 === 1), T === 3) {
        var R = this.m.add(new s(1)).iushrn(2);
        return this.pow(b, R)
      }
      for (var N = this.m.subn(1), O = 0; !N.isZero() && N.andln(1) === 0;) O++, N.iushrn(1);
      r(!N.isZero());
      var U = new s(1).toRed(this),
        q = U.redNeg(),
        W = this.m.subn(1).iushrn(1),
        M = this.m.bitLength();
      for (M = new s(2 * M * M).toRed(this); this.pow(M, W).cmp(q) !== 0;) M.redIAdd(q);
      for (var Q = this.pow(M, N), he = this.pow(b, N.addn(1).iushrn(1)), H = this.pow(b, N), ne = O; H.cmp(U) !== 0;) {
        for (var X = H, Z = 0; X.cmp(U) !== 0; Z++) X = X.redSqr();
        r(Z < ne);
        var te = this.pow(Q, new s(1).iushln(ne - Z - 1));
        he = he.redMul(te), Q = te.redSqr(), H = H.redMul(Q), ne = Z
      }
      return he
    }, V.prototype.invm = function (b) {
      var T = b._invmp(this.m);
      return T.negative !== 0 ? (T.negative = 0, this.imod(T).redNeg()) : this.imod(T)
    }, V.prototype.pow = function (b, T) {
      if (T.isZero()) return new s(1).toRed(this);
      if (T.cmpn(1) === 0) return b.clone();
      var R = 4,
        N = new Array(1 << R);
      N[0] = new s(1).toRed(this), N[1] = b;
      for (var O = 2; O < N.length; O++) N[O] = this.mul(N[O - 1], b);
      var U = N[0],
        q = 0,
        W = 0,
        M = T.bitLength() % 26;
      for (M === 0 && (M = 26), O = T.length - 1; O >= 0; O--) {
        for (var Q = T.words[O], he = M - 1; he >= 0; he--) {
          var H = Q >> he & 1;
          if (U !== N[0] && (U = this.sqr(U)), H === 0 && q === 0) {
            W = 0;
            continue
          }
          q <<= 1, q |= H, W++, !(W !== R && (O !== 0 || he !== 0)) && (U = this.mul(U, N[q]), W = 0, q = 0)
        }
        M = 26
      }
      return U
    }, V.prototype.convertTo = function (b) {
      var T = b.umod(this.m);
      return T === b ? T.clone() : T
    }, V.prototype.convertFrom = function (b) {
      var T = b.clone();
      return T.red = null, T
    }, s.mont = function (b) {
      return new G(b)
    };

    function G(L) {
      V.call(this, L), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new s(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv)
    }
    i(G, V), G.prototype.convertTo = function (b) {
      return this.imod(b.ushln(this.shift))
    }, G.prototype.convertFrom = function (b) {
      var T = this.imod(b.mul(this.rinv));
      return T.red = null, T
    }, G.prototype.imul = function (b, T) {
      if (b.isZero() || T.isZero()) return b.words[0] = 0, b.length = 1, b;
      var R = b.imul(T),
        N = R.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
        O = R.isub(N).iushrn(this.shift),
        U = O;
      return O.cmp(this.m) >= 0 ? U = O.isub(this.m) : O.cmpn(0) < 0 && (U = O.iadd(this.m)), U._forceRed(this)
    }, G.prototype.mul = function (b, T) {
      if (b.isZero() || T.isZero()) return new s(0)._forceRed(this);
      var R = b.mul(T),
        N = R.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
        O = R.isub(N).iushrn(this.shift),
        U = O;
      return O.cmp(this.m) >= 0 ? U = O.isub(this.m) : O.cmpn(0) < 0 && (U = O.iadd(this.m)), U._forceRed(this)
    }, G.prototype.invm = function (b) {
      var T = this.imod(b._invmp(this.m).mul(this.r2));
      return T._forceRed(this)
    }
  })(e, rn)
})(hk);
var Zxe = hk.exports;
const Xt = Vo(Zxe),
  e5e = "logger/5.7.0";
let UN = !1,
  zN = !1;
const vw = {
  debug: 1,
  default: 2,
  info: 2,
  warning: 3,
  error: 4,
  off: 5
};
let HN = vw.default,
  AS = null;

function t5e() {
  try {
    const e = [];
    if (["NFD", "NFC", "NFKD", "NFKC"].forEach(t => {
        try {
          if ("test".normalize(t) !== "test") throw new Error("bad normalize")
        } catch {
          e.push(t)
        }
      }), e.length) throw new Error("missing " + e.join(", "));
    if ("é".normalize("NFD") !== "é") throw new Error("broken implementation")
  } catch (e) {
    return e.message
  }
  return null
}
const VN = t5e();
var oA;
(function (e) {
  e.DEBUG = "DEBUG", e.INFO = "INFO", e.WARNING = "WARNING", e.ERROR = "ERROR", e.OFF = "OFF"
})(oA || (oA = {}));
var ic;
(function (e) {
  e.UNKNOWN_ERROR = "UNKNOWN_ERROR", e.NOT_IMPLEMENTED = "NOT_IMPLEMENTED", e.UNSUPPORTED_OPERATION = "UNSUPPORTED_OPERATION", e.NETWORK_ERROR = "NETWORK_ERROR", e.SERVER_ERROR = "SERVER_ERROR", e.TIMEOUT = "TIMEOUT", e.BUFFER_OVERRUN = "BUFFER_OVERRUN", e.NUMERIC_FAULT = "NUMERIC_FAULT", e.MISSING_NEW = "MISSING_NEW", e.INVALID_ARGUMENT = "INVALID_ARGUMENT", e.MISSING_ARGUMENT = "MISSING_ARGUMENT", e.UNEXPECTED_ARGUMENT = "UNEXPECTED_ARGUMENT", e.CALL_EXCEPTION = "CALL_EXCEPTION", e.INSUFFICIENT_FUNDS = "INSUFFICIENT_FUNDS", e.NONCE_EXPIRED = "NONCE_EXPIRED", e.REPLACEMENT_UNDERPRICED = "REPLACEMENT_UNDERPRICED", e.UNPREDICTABLE_GAS_LIMIT = "UNPREDICTABLE_GAS_LIMIT", e.TRANSACTION_REPLACED = "TRANSACTION_REPLACED", e.ACTION_REJECTED = "ACTION_REJECTED"
})(ic || (ic = {}));
const WN = "0123456789abcdef";
let Ae = class ci {
  constructor(t) {
    Object.defineProperty(this, "version", {
      enumerable: !0,
      value: t,
      writable: !1
    })
  }
  _log(t, n) {
    const r = t.toLowerCase();
    vw[r] == null && this.throwArgumentError("invalid log level name", "logLevel", t), !(HN > vw[r]) && console.log.apply(console, n)
  }
  debug(...t) {
    this._log(ci.levels.DEBUG, t)
  }
  info(...t) {
    this._log(ci.levels.INFO, t)
  }
  warn(...t) {
    this._log(ci.levels.WARNING, t)
  }
  makeError(t, n, r) {
    if (zN) return this.makeError("censored error", n, {});
    n || (n = ci.errors.UNKNOWN_ERROR), r || (r = {});
    const i = [];
    Object.keys(r).forEach(c => {
      const l = r[c];
      try {
        if (l instanceof Uint8Array) {
          let u = "";
          for (let f = 0; f < l.length; f++) u += WN[l[f] >> 4], u += WN[l[f] & 15];
          i.push(c + "=Uint8Array(0x" + u + ")")
        } else i.push(c + "=" + JSON.stringify(l))
      } catch {
        i.push(c + "=" + JSON.stringify(r[c].toString()))
      }
    }), i.push(`code=${n}`), i.push(`version=${this.version}`);
    const s = t;
    let o = "";
    switch (n) {
      case ic.NUMERIC_FAULT: {
        o = "NUMERIC_FAULT";
        const c = t;
        switch (c) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            o += "-" + c;
            break;
          case "negative-power":
          case "negative-width":
            o += "-unsupported";
            break;
          case "unbound-bitwise-result":
            o += "-unbound-result";
            break
        }
        break
      }
      case ic.CALL_EXCEPTION:
      case ic.INSUFFICIENT_FUNDS:
      case ic.MISSING_NEW:
      case ic.NONCE_EXPIRED:
      case ic.REPLACEMENT_UNDERPRICED:
      case ic.TRANSACTION_REPLACED:
      case ic.UNPREDICTABLE_GAS_LIMIT:
        o = n;
        break
    }
    o && (t += " [ See: https://links.ethers.org/v5-errors-" + o + " ]"), i.length && (t += " (" + i.join(", ") + ")");
    const a = new Error(t);
    return a.reason = s, a.code = n, Object.keys(r).forEach(function (c) {
      a[c] = r[c]
    }), a
  }
  throwError(t, n, r) {
    throw this.makeError(t, n, r)
  }
  throwArgumentError(t, n, r) {
    return this.throwError(t, ci.errors.INVALID_ARGUMENT, {
      argument: n,
      value: r
    })
  }
  assert(t, n, r, i) {
    t || this.throwError(n, r, i)
  }
  assertArgument(t, n, r, i) {
    t || this.throwArgumentError(n, r, i)
  }
  checkNormalize(t) {
    VN && this.throwError("platform missing String.prototype.normalize", ci.errors.UNSUPPORTED_OPERATION, {
      operation: "String.prototype.normalize",
      form: VN
    })
  }
  checkSafeUint53(t, n) {
    typeof t == "number" && (n == null && (n = "value not safe"), (t < 0 || t >= 9007199254740991) && this.throwError(n, ci.errors.NUMERIC_FAULT, {
      operation: "checkSafeInteger",
      fault: "out-of-safe-range",
      value: t
    }), t % 1 && this.throwError(n, ci.errors.NUMERIC_FAULT, {
      operation: "checkSafeInteger",
      fault: "non-integer",
      value: t
    }))
  }
  checkArgumentCount(t, n, r) {
    r ? r = ": " + r : r = "", t < n && this.throwError("missing argument" + r, ci.errors.MISSING_ARGUMENT, {
      count: t,
      expectedCount: n
    }), t > n && this.throwError("too many arguments" + r, ci.errors.UNEXPECTED_ARGUMENT, {
      count: t,
      expectedCount: n
    })
  }
  checkNew(t, n) {
    (t === Object || t == null) && this.throwError("missing new", ci.errors.MISSING_NEW, {
      name: n.name
    })
  }
  checkAbstract(t, n) {
    t === n ? this.throwError("cannot instantiate abstract class " + JSON.stringify(n.name) + " directly; use a sub-class", ci.errors.UNSUPPORTED_OPERATION, {
      name: t.name,
      operation: "new"
    }) : (t === Object || t == null) && this.throwError("missing new", ci.errors.MISSING_NEW, {
      name: n.name
    })
  }
  static globalLogger() {
    return AS || (AS = new ci(e5e)), AS
  }
  static setCensorship(t, n) {
    if (!t && n && this.globalLogger().throwError("cannot permanently disable censorship", ci.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      }), UN) {
      if (!t) return;
      this.globalLogger().throwError("error censorship permanent", ci.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      })
    }
    zN = !!t, UN = !!n
  }
  static setLogLevel(t) {
    const n = vw[t.toLowerCase()];
    if (n == null) {
      ci.globalLogger().warn("invalid log level - " + t);
      return
    }
    HN = n
  }
  static from(t) {
    return new ci(t)
  }
};
Ae.errors = ic;
Ae.levels = oA;
const n5e = "bytes/5.7.0",
  Lr = new Ae(n5e);

function CV(e) {
  return !!e.toHexString
}

function dp(e) {
  return e.slice || (e.slice = function () {
    const t = Array.prototype.slice.call(arguments);
    return dp(new Uint8Array(Array.prototype.slice.apply(e, t)))
  }), e
}

function pk(e) {
  return pn(e) && !(e.length % 2) || j5(e)
}

function qN(e) {
  return typeof e == "number" && e == e && e % 1 === 0
}

function j5(e) {
  if (e == null) return !1;
  if (e.constructor === Uint8Array) return !0;
  if (typeof e == "string" || !qN(e.length) || e.length < 0) return !1;
  for (let t = 0; t < e.length; t++) {
    const n = e[t];
    if (!qN(n) || n < 0 || n >= 256) return !1
  }
  return !0
}

function jt(e, t) {
  if (t || (t = {}), typeof e == "number") {
    Lr.checkSafeUint53(e, "invalid arrayify value");
    const n = [];
    for (; e;) n.unshift(e & 255), e = parseInt(String(e / 256));
    return n.length === 0 && n.push(0), dp(new Uint8Array(n))
  }
  if (t.allowMissingPrefix && typeof e == "string" && e.substring(0, 2) !== "0x" && (e = "0x" + e), CV(e) && (e = e.toHexString()), pn(e)) {
    let n = e.substring(2);
    n.length % 2 && (t.hexPad === "left" ? n = "0" + n : t.hexPad === "right" ? n += "0" : Lr.throwArgumentError("hex data is odd-length", "value", e));
    const r = [];
    for (let i = 0; i < n.length; i += 2) r.push(parseInt(n.substring(i, i + 2), 16));
    return dp(new Uint8Array(r))
  }
  return j5(e) ? dp(new Uint8Array(e)) : Lr.throwArgumentError("invalid arrayify value", "value", e)
}

function Bo(e) {
  const t = e.map(i => jt(i)),
    n = t.reduce((i, s) => i + s.length, 0),
    r = new Uint8Array(n);
  return t.reduce((i, s) => (r.set(s, i), i + s.length), 0), dp(r)
}

function Mp(e) {
  let t = jt(e);
  if (t.length === 0) return t;
  let n = 0;
  for (; n < t.length && t[n] === 0;) n++;
  return n && (t = t.slice(n)), t
}

function r5e(e, t) {
  e = jt(e), e.length > t && Lr.throwArgumentError("value out of range", "value", arguments[0]);
  const n = new Uint8Array(t);
  return n.set(e, t - e.length), dp(n)
}

function pn(e, t) {
  return !(typeof e != "string" || !e.match(/^0x[0-9A-Fa-f]*$/) || t && e.length !== 2 + 2 * t)
}
const TS = "0123456789abcdef";

function St(e, t) {
  if (t || (t = {}), typeof e == "number") {
    Lr.checkSafeUint53(e, "invalid hexlify value");
    let n = "";
    for (; e;) n = TS[e & 15] + n, e = Math.floor(e / 16);
    return n.length ? (n.length % 2 && (n = "0" + n), "0x" + n) : "0x00"
  }
  if (typeof e == "bigint") return e = e.toString(16), e.length % 2 ? "0x0" + e : "0x" + e;
  if (t.allowMissingPrefix && typeof e == "string" && e.substring(0, 2) !== "0x" && (e = "0x" + e), CV(e)) return e.toHexString();
  if (pn(e)) return e.length % 2 && (t.hexPad === "left" ? e = "0x0" + e.substring(2) : t.hexPad === "right" ? e += "0" : Lr.throwArgumentError("hex data is odd-length", "value", e)), e.toLowerCase();
  if (j5(e)) {
    let n = "0x";
    for (let r = 0; r < e.length; r++) {
      let i = e[r];
      n += TS[(i & 240) >> 4] + TS[i & 15]
    }
    return n
  }
  return Lr.throwArgumentError("invalid hexlify value", "value", e)
}

function oh(e) {
  if (typeof e != "string") e = St(e);
  else if (!pn(e) || e.length % 2) return null;
  return (e.length - 2) / 2
}

function rs(e, t, n) {
  return typeof e != "string" ? e = St(e) : (!pn(e) || e.length % 2) && Lr.throwArgumentError("invalid hexData", "value", e), t = 2 + 2 * t, n != null ? "0x" + e.substring(t, 2 + 2 * n) : "0x" + e.substring(t)
}

function to(e) {
  let t = "0x";
  return e.forEach(n => {
    t += St(n).substring(2)
  }), t
}

function mk(e) {
  const t = i5e(St(e, {
    hexPad: "left"
  }));
  return t === "0x" ? "0x0" : t
}

function i5e(e) {
  typeof e != "string" && (e = St(e)), pn(e) || Lr.throwArgumentError("invalid hex string", "value", e), e = e.substring(2);
  let t = 0;
  for (; t < e.length && e[t] === "0";) t++;
  return "0x" + e.substring(t)
}

function zr(e, t) {
  for (typeof e != "string" ? e = St(e) : pn(e) || Lr.throwArgumentError("invalid hex string", "value", e), e.length > 2 * t + 2 && Lr.throwArgumentError("value out of range", "value", arguments[1]); e.length < 2 * t + 2;) e = "0x0" + e.substring(2);
  return e
}

function U5(e) {
  const t = {
    r: "0x",
    s: "0x",
    _vs: "0x",
    recoveryParam: 0,
    v: 0,
    yParityAndS: "0x",
    compact: "0x"
  };
  if (pk(e)) {
    let n = jt(e);
    n.length === 64 ? (t.v = 27 + (n[32] >> 7), n[32] &= 127, t.r = St(n.slice(0, 32)), t.s = St(n.slice(32, 64))) : n.length === 65 ? (t.r = St(n.slice(0, 32)), t.s = St(n.slice(32, 64)), t.v = n[64]) : Lr.throwArgumentError("invalid signature string", "signature", e), t.v < 27 && (t.v === 0 || t.v === 1 ? t.v += 27 : Lr.throwArgumentError("signature invalid v byte", "signature", e)), t.recoveryParam = 1 - t.v % 2, t.recoveryParam && (n[32] |= 128), t._vs = St(n.slice(32, 64))
  } else {
    if (t.r = e.r, t.s = e.s, t.v = e.v, t.recoveryParam = e.recoveryParam, t._vs = e._vs, t._vs != null) {
      const i = r5e(jt(t._vs), 32);
      t._vs = St(i);
      const s = i[0] >= 128 ? 1 : 0;
      t.recoveryParam == null ? t.recoveryParam = s : t.recoveryParam !== s && Lr.throwArgumentError("signature recoveryParam mismatch _vs", "signature", e), i[0] &= 127;
      const o = St(i);
      t.s == null ? t.s = o : t.s !== o && Lr.throwArgumentError("signature v mismatch _vs", "signature", e)
    }
    if (t.recoveryParam == null) t.v == null ? Lr.throwArgumentError("signature missing v and recoveryParam", "signature", e) : t.v === 0 || t.v === 1 ? t.recoveryParam = t.v : t.recoveryParam = 1 - t.v % 2;
    else if (t.v == null) t.v = 27 + t.recoveryParam;
    else {
      const i = t.v === 0 || t.v === 1 ? t.v : 1 - t.v % 2;
      t.recoveryParam !== i && Lr.throwArgumentError("signature recoveryParam mismatch v", "signature", e)
    }
    t.r == null || !pn(t.r) ? Lr.throwArgumentError("signature missing or invalid r", "signature", e) : t.r = zr(t.r, 32), t.s == null || !pn(t.s) ? Lr.throwArgumentError("signature missing or invalid s", "signature", e) : t.s = zr(t.s, 32);
    const n = jt(t.s);
    n[0] >= 128 && Lr.throwArgumentError("signature s out of range", "signature", e), t.recoveryParam && (n[0] |= 128);
    const r = St(n);
    t._vs && (pn(t._vs) || Lr.throwArgumentError("signature invalid _vs", "signature", e), t._vs = zr(t._vs, 32)), t._vs == null ? t._vs = r : t._vs !== r && Lr.throwArgumentError("signature _vs mismatch v and s", "signature", e)
  }
  return t.yParityAndS = t._vs, t.compact = t.r + t.yParityAndS.substring(2), t
}
const s5e = "bignumber/5.7.0";
var C3 = Xt.BN;
const ql = new Ae(s5e),
  kS = {},
  GN = 9007199254740991;
let KN = !1,
  st = class ec {
    constructor(t, n) {
      t !== kS && ql.throwError("cannot call constructor directly; use BigNumber.from", Ae.errors.UNSUPPORTED_OPERATION, {
        operation: "new (BigNumber)"
      }), this._hex = n, this._isBigNumber = !0, Object.freeze(this)
    }
    fromTwos(t) {
      return Ks(gn(this).fromTwos(t))
    }
    toTwos(t) {
      return Ks(gn(this).toTwos(t))
    }
    abs() {
      return this._hex[0] === "-" ? ec.from(this._hex.substring(1)) : this
    }
    add(t) {
      return Ks(gn(this).add(gn(t)))
    }
    sub(t) {
      return Ks(gn(this).sub(gn(t)))
    }
    div(t) {
      return ec.from(t).isZero() && ia("division-by-zero", "div"), Ks(gn(this).div(gn(t)))
    }
    mul(t) {
      return Ks(gn(this).mul(gn(t)))
    }
    mod(t) {
      const n = gn(t);
      return n.isNeg() && ia("division-by-zero", "mod"), Ks(gn(this).umod(n))
    }
    pow(t) {
      const n = gn(t);
      return n.isNeg() && ia("negative-power", "pow"), Ks(gn(this).pow(n))
    }
    and(t) {
      const n = gn(t);
      return (this.isNegative() || n.isNeg()) && ia("unbound-bitwise-result", "and"), Ks(gn(this).and(n))
    }
    or(t) {
      const n = gn(t);
      return (this.isNegative() || n.isNeg()) && ia("unbound-bitwise-result", "or"), Ks(gn(this).or(n))
    }
    xor(t) {
      const n = gn(t);
      return (this.isNegative() || n.isNeg()) && ia("unbound-bitwise-result", "xor"), Ks(gn(this).xor(n))
    }
    mask(t) {
      return (this.isNegative() || t < 0) && ia("negative-width", "mask"), Ks(gn(this).maskn(t))
    }
    shl(t) {
      return (this.isNegative() || t < 0) && ia("negative-width", "shl"), Ks(gn(this).shln(t))
    }
    shr(t) {
      return (this.isNegative() || t < 0) && ia("negative-width", "shr"), Ks(gn(this).shrn(t))
    }
    eq(t) {
      return gn(this).eq(gn(t))
    }
    lt(t) {
      return gn(this).lt(gn(t))
    }
    lte(t) {
      return gn(this).lte(gn(t))
    }
    gt(t) {
      return gn(this).gt(gn(t))
    }
    gte(t) {
      return gn(this).gte(gn(t))
    }
    isNegative() {
      return this._hex[0] === "-"
    }
    isZero() {
      return gn(this).isZero()
    }
    toNumber() {
      try {
        return gn(this).toNumber()
      } catch {
        ia("overflow", "toNumber", this.toString())
      }
      return null
    }
    toBigInt() {
      try {
        return BigInt(this.toString())
      } catch {}
      return ql.throwError("this platform does not support BigInt", Ae.errors.UNSUPPORTED_OPERATION, {
        value: this.toString()
      })
    }
    toString() {
      return arguments.length > 0 && (arguments[0] === 10 ? KN || (KN = !0, ql.warn("BigNumber.toString does not accept any parameters; base-10 is assumed")) : arguments[0] === 16 ? ql.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", Ae.errors.UNEXPECTED_ARGUMENT, {}) : ql.throwError("BigNumber.toString does not accept parameters", Ae.errors.UNEXPECTED_ARGUMENT, {})), gn(this).toString(10)
    }
    toHexString() {
      return this._hex
    }
    toJSON(t) {
      return {
        type: "BigNumber",
        hex: this.toHexString()
      }
    }
    static from(t) {
      if (t instanceof ec) return t;
      if (typeof t == "string") return t.match(/^-?0x[0-9a-f]+$/i) ? new ec(kS, i2(t)) : t.match(/^-?[0-9]+$/) ? new ec(kS, i2(new C3(t))) : ql.throwArgumentError("invalid BigNumber string", "value", t);
      if (typeof t == "number") return t % 1 && ia("underflow", "BigNumber.from", t), (t >= GN || t <= -GN) && ia("overflow", "BigNumber.from", t), ec.from(String(t));
      const n = t;
      if (typeof n == "bigint") return ec.from(n.toString());
      if (j5(n)) return ec.from(St(n));
      if (n)
        if (n.toHexString) {
          const r = n.toHexString();
          if (typeof r == "string") return ec.from(r)
        } else {
          let r = n._hex;
          if (r == null && n.type === "BigNumber" && (r = n.hex), typeof r == "string" && (pn(r) || r[0] === "-" && pn(r.substring(1)))) return ec.from(r)
        } return ql.throwArgumentError("invalid BigNumber value", "value", t)
    }
    static isBigNumber(t) {
      return !!(t && t._isBigNumber)
    }
  };

function i2(e) {
  if (typeof e != "string") return i2(e.toString(16));
  if (e[0] === "-") return e = e.substring(1), e[0] === "-" && ql.throwArgumentError("invalid hex", "value", e), e = i2(e), e === "0x00" ? e : "-" + e;
  if (e.substring(0, 2) !== "0x" && (e = "0x" + e), e === "0x") return "0x00";
  for (e.length % 2 && (e = "0x0" + e.substring(2)); e.length > 4 && e.substring(0, 4) === "0x00";) e = "0x" + e.substring(4);
  return e
}

function Ks(e) {
  return st.from(i2(e))
}

function gn(e) {
  const t = st.from(e).toHexString();
  return t[0] === "-" ? new C3("-" + t.substring(3), 16) : new C3(t.substring(2), 16)
}

function ia(e, t, n) {
  const r = {
    fault: e,
    operation: t
  };
  return n != null && (r.value = n), ql.throwError(e, Ae.errors.NUMERIC_FAULT, r)
}

function o5e(e) {
  return new C3(e, 36).toString(16)
}
const a5e = "properties/5.7.0";
var c5e = function (e, t, n, r) {
  function i(s) {
    return s instanceof n ? s : new n(function (o) {
      o(s)
    })
  }
  return new(n || (n = Promise))(function (s, o) {
    function a(u) {
      try {
        l(r.next(u))
      } catch (f) {
        o(f)
      }
    }

    function c(u) {
      try {
        l(r.throw(u))
      } catch (f) {
        o(f)
      }
    }

    function l(u) {
      u.done ? s(u.value) : i(u.value).then(a, c)
    }
    l((r = r.apply(e, t || [])).next())
  })
};
const A3 = new Ae(a5e);

function Ge(e, t, n) {
  Object.defineProperty(e, t, {
    enumerable: !0,
    value: n,
    writable: !1
  })
}

function Xc(e, t) {
  for (let n = 0; n < 32; n++) {
    if (e[t]) return e[t];
    if (!e.prototype || typeof e.prototype != "object") break;
    e = Object.getPrototypeOf(e.prototype).constructor
  }
  return null
}

function ei(e) {
  return c5e(this, void 0, void 0, function* () {
    const t = Object.keys(e).map(r => {
      const i = e[r];
      return Promise.resolve(i).then(s => ({
        key: r,
        value: s
      }))
    });
    return (yield Promise.all(t)).reduce((r, i) => (r[i.key] = i.value, r), {})
  })
}

function l5e(e, t) {
  (!e || typeof e != "object") && A3.throwArgumentError("invalid object", "object", e), Object.keys(e).forEach(n => {
    t[n] || A3.throwArgumentError("invalid object key - " + n, "transaction:" + n, e)
  })
}

function Cr(e) {
  const t = {};
  for (const n in e) t[n] = e[n];
  return t
}
const u5e = {
  bigint: !0,
  boolean: !0,
  function: !0,
  number: !0,
  string: !0
};

function AV(e) {
  if (e == null || u5e[typeof e]) return !0;
  if (Array.isArray(e) || typeof e == "object") {
    if (!Object.isFrozen(e)) return !1;
    const t = Object.keys(e);
    for (let n = 0; n < t.length; n++) {
      let r = null;
      try {
        r = e[t[n]]
      } catch {
        continue
      }
      if (!AV(r)) return !1
    }
    return !0
  }
  return A3.throwArgumentError(`Cannot deepCopy ${typeof e}`, "object", e)
}

function d5e(e) {
  if (AV(e)) return e;
  if (Array.isArray(e)) return Object.freeze(e.map(t => Aa(t)));
  if (typeof e == "object") {
    const t = {};
    for (const n in e) {
      const r = e[n];
      r !== void 0 && Ge(t, n, Aa(r))
    }
    return t
  }
  return A3.throwArgumentError(`Cannot deepCopy ${typeof e}`, "object", e)
}

function Aa(e) {
  return d5e(e)
}
class ty {
  constructor(t) {
    for (const n in t) this[n] = Aa(t[n])
  }
}
const ny = "abi/5.7.0",
  Cn = new Ae(ny),
  ah = {};
let QN = {
    calldata: !0,
    memory: !0,
    storage: !0
  },
  f5e = {
    calldata: !0,
    memory: !0
  };

function pb(e, t) {
  if (e === "bytes" || e === "string") {
    if (QN[t]) return !0
  } else if (e === "address") {
    if (t === "payable") return !0
  } else if ((e.indexOf("[") >= 0 || e === "tuple") && f5e[t]) return !0;
  return (QN[t] || t === "payable") && Cn.throwArgumentError("invalid modifier", "name", t), !1
}

function h5e(e, t) {
  let n = e;

  function r(a) {
    Cn.throwArgumentError(`unexpected character at position ${a}`, "param", e)
  }
  e = e.replace(/\s/g, " ");

  function i(a) {
    let c = {
      type: "",
      name: "",
      parent: a,
      state: {
        allowType: !0
      }
    };
    return t && (c.indexed = !1), c
  }
  let s = {
      type: "",
      name: "",
      state: {
        allowType: !0
      }
    },
    o = s;
  for (let a = 0; a < e.length; a++) {
    let c = e[a];
    switch (c) {
      case "(":
        o.state.allowType && o.type === "" ? o.type = "tuple" : o.state.allowParams || r(a), o.state.allowType = !1, o.type = k0(o.type), o.components = [i(o)], o = o.components[0];
        break;
      case ")":
        delete o.state, o.name === "indexed" && (t || r(a), o.indexed = !0, o.name = ""), pb(o.type, o.name) && (o.name = ""), o.type = k0(o.type);
        let l = o;
        o = o.parent, o || r(a), delete l.parent, o.state.allowParams = !1, o.state.allowName = !0, o.state.allowArray = !0;
        break;
      case ",":
        delete o.state, o.name === "indexed" && (t || r(a), o.indexed = !0, o.name = ""), pb(o.type, o.name) && (o.name = ""), o.type = k0(o.type);
        let u = i(o.parent);
        o.parent.components.push(u), delete o.parent, o = u;
        break;
      case " ":
        o.state.allowType && o.type !== "" && (o.type = k0(o.type), delete o.state.allowType, o.state.allowName = !0, o.state.allowParams = !0), o.state.allowName && o.name !== "" && (o.name === "indexed" ? (t || r(a), o.indexed && r(a), o.indexed = !0, o.name = "") : pb(o.type, o.name) ? o.name = "" : o.state.allowName = !1);
        break;
      case "[":
        o.state.allowArray || r(a), o.type += c, o.state.allowArray = !1, o.state.allowName = !1, o.state.readArray = !0;
        break;
      case "]":
        o.state.readArray || r(a), o.type += c, o.state.readArray = !1, o.state.allowArray = !0, o.state.allowName = !0;
        break;
      default:
        o.state.allowType ? (o.type += c, o.state.allowParams = !0, o.state.allowArray = !0) : o.state.allowName ? (o.name += c, delete o.state.allowArray) : o.state.readArray ? o.type += c : r(a)
    }
  }
  return o.parent && Cn.throwArgumentError("unexpected eof", "param", e), delete s.state, o.name === "indexed" ? (t || r(n.length - 7), o.indexed && r(n.length - 7), o.indexed = !0, o.name = "") : pb(o.type, o.name) && (o.name = ""), s.type = k0(s.type), s
}

function bw(e, t) {
  for (let n in t) Ge(e, n, t[n])
}
const Nn = Object.freeze({
    sighash: "sighash",
    minimal: "minimal",
    full: "full",
    json: "json"
  }),
  p5e = new RegExp(/^(.*)\[([0-9]*)\]$/);
class wi {
  constructor(t, n) {
    t !== ah && Cn.throwError("use fromString", Ae.errors.UNSUPPORTED_OPERATION, {
      operation: "new ParamType()"
    }), bw(this, n);
    let r = this.type.match(p5e);
    r ? bw(this, {
      arrayLength: parseInt(r[2] || "-1"),
      arrayChildren: wi.fromObject({
        type: r[1],
        components: this.components
      }),
      baseType: "array"
    }) : bw(this, {
      arrayLength: null,
      arrayChildren: null,
      baseType: this.components != null ? "tuple" : this.type
    }), this._isParamType = !0, Object.freeze(this)
  }
  format(t) {
    if (t || (t = Nn.sighash), Nn[t] || Cn.throwArgumentError("invalid format type", "format", t), t === Nn.json) {
      let r = {
        type: this.baseType === "tuple" ? "tuple" : this.type,
        name: this.name || void 0
      };
      return typeof this.indexed == "boolean" && (r.indexed = this.indexed), this.components && (r.components = this.components.map(i => JSON.parse(i.format(t)))), JSON.stringify(r)
    }
    let n = "";
    return this.baseType === "array" ? (n += this.arrayChildren.format(t), n += "[" + (this.arrayLength < 0 ? "" : String(this.arrayLength)) + "]") : this.baseType === "tuple" ? (t !== Nn.sighash && (n += this.type), n += "(" + this.components.map(r => r.format(t)).join(t === Nn.full ? ", " : ",") + ")") : n += this.type, t !== Nn.sighash && (this.indexed === !0 && (n += " indexed"), t === Nn.full && this.name && (n += " " + this.name)), n
  }
  static from(t, n) {
    return typeof t == "string" ? wi.fromString(t, n) : wi.fromObject(t)
  }
  static fromObject(t) {
    return wi.isParamType(t) ? t : new wi(ah, {
      name: t.name || null,
      type: k0(t.type),
      indexed: t.indexed == null ? null : !!t.indexed,
      components: t.components ? t.components.map(wi.fromObject) : null
    })
  }
  static fromString(t, n) {
    function r(i) {
      return wi.fromObject({
        name: i.name,
        type: i.type,
        indexed: i.indexed,
        components: i.components
      })
    }
    return r(h5e(t, !!n))
  }
  static isParamType(t) {
    return !!(t != null && t._isParamType)
  }
}

function s2(e, t) {
  return g5e(e).map(n => wi.fromString(n, t))
}
class tu {
  constructor(t, n) {
    t !== ah && Cn.throwError("use a static from method", Ae.errors.UNSUPPORTED_OPERATION, {
      operation: "new Fragment()"
    }), bw(this, n), this._isFragment = !0, Object.freeze(this)
  }
  static from(t) {
    return tu.isFragment(t) ? t : typeof t == "string" ? tu.fromString(t) : tu.fromObject(t)
  }
  static fromObject(t) {
    if (tu.isFragment(t)) return t;
    switch (t.type) {
      case "function":
        return Qc.fromObject(t);
      case "event":
        return Xl.fromObject(t);
      case "constructor":
        return Kc.fromObject(t);
      case "error":
        return id.fromObject(t);
      case "fallback":
      case "receive":
        return null
    }
    return Cn.throwArgumentError("invalid fragment object", "value", t)
  }
  static fromString(t) {
    return t = t.replace(/\s/g, " "), t = t.replace(/\(/g, " (").replace(/\)/g, ") ").replace(/\s+/g, " "), t = t.trim(), t.split(" ")[0] === "event" ? Xl.fromString(t.substring(5).trim()) : t.split(" ")[0] === "function" ? Qc.fromString(t.substring(8).trim()) : t.split("(")[0].trim() === "constructor" ? Kc.fromString(t.trim()) : t.split(" ")[0] === "error" ? id.fromString(t.substring(5).trim()) : Cn.throwArgumentError("unsupported fragment", "value", t)
  }
  static isFragment(t) {
    return !!(t && t._isFragment)
  }
}
class Xl extends tu {
  format(t) {
    if (t || (t = Nn.sighash), Nn[t] || Cn.throwArgumentError("invalid format type", "format", t), t === Nn.json) return JSON.stringify({
      type: "event",
      anonymous: this.anonymous,
      name: this.name,
      inputs: this.inputs.map(r => JSON.parse(r.format(t)))
    });
    let n = "";
    return t !== Nn.sighash && (n += "event "), n += this.name + "(" + this.inputs.map(r => r.format(t)).join(t === Nn.full ? ", " : ",") + ") ", t !== Nn.sighash && this.anonymous && (n += "anonymous "), n.trim()
  }
  static from(t) {
    return typeof t == "string" ? Xl.fromString(t) : Xl.fromObject(t)
  }
  static fromObject(t) {
    if (Xl.isEventFragment(t)) return t;
    t.type !== "event" && Cn.throwArgumentError("invalid event object", "value", t);
    const n = {
      name: o2(t.name),
      anonymous: t.anonymous,
      inputs: t.inputs ? t.inputs.map(wi.fromObject) : [],
      type: "event"
    };
    return new Xl(ah, n)
  }
  static fromString(t) {
    let n = t.match(a2);
    n || Cn.throwArgumentError("invalid event string", "value", t);
    let r = !1;
    return n[3].split(" ").forEach(i => {
      switch (i.trim()) {
        case "anonymous":
          r = !0;
          break;
        case "":
          break;
        default:
          Cn.warn("unknown modifier: " + i)
      }
    }), Xl.fromObject({
      name: n[1].trim(),
      anonymous: r,
      inputs: s2(n[2], !0),
      type: "event"
    })
  }
  static isEventFragment(t) {
    return t && t._isFragment && t.type === "event"
  }
}

function TV(e, t) {
  t.gas = null;
  let n = e.split("@");
  return n.length !== 1 ? (n.length > 2 && Cn.throwArgumentError("invalid human-readable ABI signature", "value", e), n[1].match(/^[0-9]+$/) || Cn.throwArgumentError("invalid human-readable ABI signature gas", "value", e), t.gas = st.from(n[1]), n[0]) : e
}

function kV(e, t) {
  t.constant = !1, t.payable = !1, t.stateMutability = "nonpayable", e.split(" ").forEach(n => {
    switch (n.trim()) {
      case "constant":
        t.constant = !0;
        break;
      case "payable":
        t.payable = !0, t.stateMutability = "payable";
        break;
      case "nonpayable":
        t.payable = !1, t.stateMutability = "nonpayable";
        break;
      case "pure":
        t.constant = !0, t.stateMutability = "pure";
        break;
      case "view":
        t.constant = !0, t.stateMutability = "view";
        break;
      case "external":
      case "public":
      case "":
        break;
      default:
        console.log("unknown modifier: " + n)
    }
  })
}

function _V(e) {
  let t = {
    constant: !1,
    payable: !0,
    stateMutability: "payable"
  };
  return e.stateMutability != null ? (t.stateMutability = e.stateMutability, t.constant = t.stateMutability === "view" || t.stateMutability === "pure", e.constant != null && !!e.constant !== t.constant && Cn.throwArgumentError("cannot have constant function with mutability " + t.stateMutability, "value", e), t.payable = t.stateMutability === "payable", e.payable != null && !!e.payable !== t.payable && Cn.throwArgumentError("cannot have payable function with mutability " + t.stateMutability, "value", e)) : e.payable != null ? (t.payable = !!e.payable, e.constant == null && !t.payable && e.type !== "constructor" && Cn.throwArgumentError("unable to determine stateMutability", "value", e), t.constant = !!e.constant, t.constant ? t.stateMutability = "view" : t.stateMutability = t.payable ? "payable" : "nonpayable", t.payable && t.constant && Cn.throwArgumentError("cannot have constant payable function", "value", e)) : e.constant != null ? (t.constant = !!e.constant, t.payable = !t.constant, t.stateMutability = t.constant ? "view" : "payable") : e.type !== "constructor" && Cn.throwArgumentError("unable to determine stateMutability", "value", e), t
}
class Kc extends tu {
  format(t) {
    if (t || (t = Nn.sighash), Nn[t] || Cn.throwArgumentError("invalid format type", "format", t), t === Nn.json) return JSON.stringify({
      type: "constructor",
      stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
      payable: this.payable,
      gas: this.gas ? this.gas.toNumber() : void 0,
      inputs: this.inputs.map(r => JSON.parse(r.format(t)))
    });
    t === Nn.sighash && Cn.throwError("cannot format a constructor for sighash", Ae.errors.UNSUPPORTED_OPERATION, {
      operation: "format(sighash)"
    });
    let n = "constructor(" + this.inputs.map(r => r.format(t)).join(t === Nn.full ? ", " : ",") + ") ";
    return this.stateMutability && this.stateMutability !== "nonpayable" && (n += this.stateMutability + " "), n.trim()
  }
  static from(t) {
    return typeof t == "string" ? Kc.fromString(t) : Kc.fromObject(t)
  }
  static fromObject(t) {
    if (Kc.isConstructorFragment(t)) return t;
    t.type !== "constructor" && Cn.throwArgumentError("invalid constructor object", "value", t);
    let n = _V(t);
    n.constant && Cn.throwArgumentError("constructor cannot be constant", "value", t);
    const r = {
      name: null,
      type: t.type,
      inputs: t.inputs ? t.inputs.map(wi.fromObject) : [],
      payable: n.payable,
      stateMutability: n.stateMutability,
      gas: t.gas ? st.from(t.gas) : null
    };
    return new Kc(ah, r)
  }
  static fromString(t) {
    let n = {
      type: "constructor"
    };
    t = TV(t, n);
    let r = t.match(a2);
    return (!r || r[1].trim() !== "constructor") && Cn.throwArgumentError("invalid constructor string", "value", t), n.inputs = s2(r[2].trim(), !1), kV(r[3].trim(), n), Kc.fromObject(n)
  }
  static isConstructorFragment(t) {
    return t && t._isFragment && t.type === "constructor"
  }
}
class Qc extends Kc {
  format(t) {
    if (t || (t = Nn.sighash), Nn[t] || Cn.throwArgumentError("invalid format type", "format", t), t === Nn.json) return JSON.stringify({
      type: "function",
      name: this.name,
      constant: this.constant,
      stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
      payable: this.payable,
      gas: this.gas ? this.gas.toNumber() : void 0,
      inputs: this.inputs.map(r => JSON.parse(r.format(t))),
      outputs: this.outputs.map(r => JSON.parse(r.format(t)))
    });
    let n = "";
    return t !== Nn.sighash && (n += "function "), n += this.name + "(" + this.inputs.map(r => r.format(t)).join(t === Nn.full ? ", " : ",") + ") ", t !== Nn.sighash && (this.stateMutability ? this.stateMutability !== "nonpayable" && (n += this.stateMutability + " ") : this.constant && (n += "view "), this.outputs && this.outputs.length && (n += "returns (" + this.outputs.map(r => r.format(t)).join(", ") + ") "), this.gas != null && (n += "@" + this.gas.toString() + " ")), n.trim()
  }
  static from(t) {
    return typeof t == "string" ? Qc.fromString(t) : Qc.fromObject(t)
  }
  static fromObject(t) {
    if (Qc.isFunctionFragment(t)) return t;
    t.type !== "function" && Cn.throwArgumentError("invalid function object", "value", t);
    let n = _V(t);
    const r = {
      type: t.type,
      name: o2(t.name),
      constant: n.constant,
      inputs: t.inputs ? t.inputs.map(wi.fromObject) : [],
      outputs: t.outputs ? t.outputs.map(wi.fromObject) : [],
      payable: n.payable,
      stateMutability: n.stateMutability,
      gas: t.gas ? st.from(t.gas) : null
    };
    return new Qc(ah, r)
  }
  static fromString(t) {
    let n = {
      type: "function"
    };
    t = TV(t, n);
    let r = t.split(" returns ");
    r.length > 2 && Cn.throwArgumentError("invalid function string", "value", t);
    let i = r[0].match(a2);
    if (i || Cn.throwArgumentError("invalid function signature", "value", t), n.name = i[1].trim(), n.name && o2(n.name), n.inputs = s2(i[2], !1), kV(i[3].trim(), n), r.length > 1) {
      let s = r[1].match(a2);
      (s[1].trim() != "" || s[3].trim() != "") && Cn.throwArgumentError("unexpected tokens", "value", t), n.outputs = s2(s[2], !1)
    } else n.outputs = [];
    return Qc.fromObject(n)
  }
  static isFunctionFragment(t) {
    return t && t._isFragment && t.type === "function"
  }
}

function YN(e) {
  const t = e.format();
  return (t === "Error(string)" || t === "Panic(uint256)") && Cn.throwArgumentError(`cannot specify user defined ${t} error`, "fragment", e), e
}
class id extends tu {
  format(t) {
    if (t || (t = Nn.sighash), Nn[t] || Cn.throwArgumentError("invalid format type", "format", t), t === Nn.json) return JSON.stringify({
      type: "error",
      name: this.name,
      inputs: this.inputs.map(r => JSON.parse(r.format(t)))
    });
    let n = "";
    return t !== Nn.sighash && (n += "error "), n += this.name + "(" + this.inputs.map(r => r.format(t)).join(t === Nn.full ? ", " : ",") + ") ", n.trim()
  }
  static from(t) {
    return typeof t == "string" ? id.fromString(t) : id.fromObject(t)
  }
  static fromObject(t) {
    if (id.isErrorFragment(t)) return t;
    t.type !== "error" && Cn.throwArgumentError("invalid error object", "value", t);
    const n = {
      type: t.type,
      name: o2(t.name),
      inputs: t.inputs ? t.inputs.map(wi.fromObject) : []
    };
    return YN(new id(ah, n))
  }
  static fromString(t) {
    let n = {
        type: "error"
      },
      r = t.match(a2);
    return r || Cn.throwArgumentError("invalid error signature", "value", t), n.name = r[1].trim(), n.name && o2(n.name), n.inputs = s2(r[2], !1), YN(id.fromObject(n))
  }
  static isErrorFragment(t) {
    return t && t._isFragment && t.type === "error"
  }
}

function k0(e) {
  return e.match(/^uint($|[^1-9])/) ? e = "uint256" + e.substring(4) : e.match(/^int($|[^1-9])/) && (e = "int256" + e.substring(3)), e
}
const m5e = new RegExp("^[a-zA-Z$_][a-zA-Z0-9$_]*$");

function o2(e) {
  return (!e || !e.match(m5e)) && Cn.throwArgumentError(`invalid identifier "${e}"`, "value", e), e
}
const a2 = new RegExp("^([^)(]*)\\((.*)\\)([^)(]*)$");

function g5e(e) {
  e = e.trim();
  let t = [],
    n = "",
    r = 0;
  for (let i = 0; i < e.length; i++) {
    let s = e[i];
    s === "," && r === 0 ? (t.push(n), n = "") : (n += s, s === "(" ? r++ : s === ")" && (r--, r === -1 && Cn.throwArgumentError("unbalanced parenthesis", "value", e)))
  }
  return n && t.push(n), t
}
const gk = new Ae(ny);

function y5e(e) {
  const t = [],
    n = function (r, i) {
      if (Array.isArray(i))
        for (let s in i) {
          const o = r.slice();
          o.push(s);
          try {
            n(o, i[s])
          } catch (a) {
            t.push({
              path: o,
              error: a
            })
          }
        }
    };
  return n([], e), t
}
class vu {
  constructor(t, n, r, i) {
    this.name = t, this.type = n, this.localName = r, this.dynamic = i
  }
  _throwError(t, n) {
    gk.throwArgumentError(t, this.localName, n)
  }
}
class aA {
  constructor(t) {
    Ge(this, "wordSize", t || 32), this._data = [], this._dataLength = 0, this._padding = new Uint8Array(t)
  }
  get data() {
    return to(this._data)
  }
  get length() {
    return this._dataLength
  }
  _writeData(t) {
    return this._data.push(t), this._dataLength += t.length, t.length
  }
  appendWriter(t) {
    return this._writeData(Bo(t._data))
  }
  writeBytes(t) {
    let n = jt(t);
    const r = n.length % this.wordSize;
    return r && (n = Bo([n, this._padding.slice(r)])), this._writeData(n)
  }
  _getValue(t) {
    let n = jt(st.from(t));
    return n.length > this.wordSize && gk.throwError("value out-of-bounds", Ae.errors.BUFFER_OVERRUN, {
      length: this.wordSize,
      offset: n.length
    }), n.length % this.wordSize && (n = Bo([this._padding.slice(n.length % this.wordSize), n])), n
  }
  writeValue(t) {
    return this._writeData(this._getValue(t))
  }
  writeUpdatableValue() {
    const t = this._data.length;
    return this._data.push(this._padding), this._dataLength += this.wordSize, n => {
      this._data[t] = this._getValue(n)
    }
  }
}
class T3 {
  constructor(t, n, r, i) {
    Ge(this, "_data", jt(t)), Ge(this, "wordSize", n || 32), Ge(this, "_coerceFunc", r), Ge(this, "allowLoose", i), this._offset = 0
  }
  get data() {
    return St(this._data)
  }
  get consumed() {
    return this._offset
  }
  static coerce(t, n) {
    let r = t.match("^u?int([0-9]+)$");
    return r && parseInt(r[1]) <= 48 && (n = n.toNumber()), n
  }
  coerce(t, n) {
    return this._coerceFunc ? this._coerceFunc(t, n) : T3.coerce(t, n)
  }
  _peekBytes(t, n, r) {
    let i = Math.ceil(n / this.wordSize) * this.wordSize;
    return this._offset + i > this._data.length && (this.allowLoose && r && this._offset + n <= this._data.length ? i = n : gk.throwError("data out-of-bounds", Ae.errors.BUFFER_OVERRUN, {
      length: this._data.length,
      offset: this._offset + i
    })), this._data.slice(this._offset, this._offset + i)
  }
  subReader(t) {
    return new T3(this._data.slice(this._offset + t), this.wordSize, this._coerceFunc, this.allowLoose)
  }
  readBytes(t, n) {
    let r = this._peekBytes(0, t, !!n);
    return this._offset += r.length, r.slice(0, t)
  }
  readValue() {
    return st.from(this.readBytes(this.wordSize))
  }
}
var IV = {
  exports: {}
};
/**
 * [js-sha3]{@link https://github.com/emn178/js-sha3}
 *
 * @version 0.8.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2015-2018
 * @license MIT
 */
(function (e) {
  (function () {
    var t = "input is invalid type",
      n = "finalize already called",
      r = typeof window == "object",
      i = r ? window : {};
    i.JS_SHA3_NO_WINDOW && (r = !1);
    var s = !r && typeof self == "object",
      o = !i.JS_SHA3_NO_NODE_JS && typeof process == "object" && process.versions && process.versions.node;
    o ? i = rn : s && (i = self);
    var a = !i.JS_SHA3_NO_COMMON_JS && !0 && e.exports,
      c = !i.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer < "u",
      l = "0123456789abcdef".split(""),
      u = [31, 7936, 2031616, 520093696],
      f = [4, 1024, 262144, 67108864],
      h = [1, 256, 65536, 16777216],
      g = [6, 1536, 393216, 100663296],
      y = [0, 8, 16, 24],
      x = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648],
      k = [224, 256, 384, 512],
      _ = [128, 256],
      p = ["hex", "buffer", "arrayBuffer", "array", "digest"],
      v = {
        128: 168,
        256: 136
      };
    (i.JS_SHA3_NO_NODE_JS || !Array.isArray) && (Array.isArray = function (H) {
      return Object.prototype.toString.call(H) === "[object Array]"
    }), c && (i.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView) && (ArrayBuffer.isView = function (H) {
      return typeof H == "object" && H.buffer && H.buffer.constructor === ArrayBuffer
    });
    for (var S = function (H, ne, X) {
        return function (Z) {
          return new M(H, ne, H).update(Z)[X]()
        }
      }, I = function (H, ne, X) {
        return function (Z, te) {
          return new M(H, ne, te).update(Z)[X]()
        }
      }, A = function (H, ne, X) {
        return function (Z, te, F, J) {
          return b["cshake" + H].update(Z, te, F, J)[X]()
        }
      }, w = function (H, ne, X) {
        return function (Z, te, F, J) {
          return b["kmac" + H].update(Z, te, F, J)[X]()
        }
      }, E = function (H, ne, X, Z) {
        for (var te = 0; te < p.length; ++te) {
          var F = p[te];
          H[F] = ne(X, Z, F)
        }
        return H
      }, D = function (H, ne) {
        var X = S(H, ne, "hex");
        return X.create = function () {
          return new M(H, ne, H)
        }, X.update = function (Z) {
          return X.create().update(Z)
        }, E(X, S, H, ne)
      }, $ = function (H, ne) {
        var X = I(H, ne, "hex");
        return X.create = function (Z) {
          return new M(H, ne, Z)
        }, X.update = function (Z, te) {
          return X.create(te).update(Z)
        }, E(X, I, H, ne)
      }, V = function (H, ne) {
        var X = v[H],
          Z = A(H, ne, "hex");
        return Z.create = function (te, F, J) {
          return !F && !J ? b["shake" + H].create(te) : new M(H, ne, te).bytepad([F, J], X)
        }, Z.update = function (te, F, J, ie) {
          return Z.create(F, J, ie).update(te)
        }, E(Z, A, H, ne)
      }, G = function (H, ne) {
        var X = v[H],
          Z = w(H, ne, "hex");
        return Z.create = function (te, F, J) {
          return new Q(H, ne, F).bytepad(["KMAC", J], X).bytepad([te], X)
        }, Z.update = function (te, F, J, ie) {
          return Z.create(te, J, ie).update(F)
        }, E(Z, w, H, ne)
      }, L = [{
        name: "keccak",
        padding: h,
        bits: k,
        createMethod: D
      }, {
        name: "sha3",
        padding: g,
        bits: k,
        createMethod: D
      }, {
        name: "shake",
        padding: u,
        bits: _,
        createMethod: $
      }, {
        name: "cshake",
        padding: f,
        bits: _,
        createMethod: V
      }, {
        name: "kmac",
        padding: f,
        bits: _,
        createMethod: G
      }], b = {}, T = [], R = 0; R < L.length; ++R)
      for (var N = L[R], O = N.bits, U = 0; U < O.length; ++U) {
        var q = N.name + "_" + O[U];
        if (T.push(q), b[q] = N.createMethod(O[U], N.padding), N.name !== "sha3") {
          var W = N.name + O[U];
          T.push(W), b[W] = b[q]
        }
      }

    function M(H, ne, X) {
      this.blocks = [], this.s = [], this.padding = ne, this.outputBits = X, this.reset = !0, this.finalized = !1, this.block = 0, this.start = 0, this.blockCount = 1600 - (H << 1) >> 5, this.byteCount = this.blockCount << 2, this.outputBlocks = X >> 5, this.extraBytes = (X & 31) >> 3;
      for (var Z = 0; Z < 50; ++Z) this.s[Z] = 0
    }
    M.prototype.update = function (H) {
      if (this.finalized) throw new Error(n);
      var ne, X = typeof H;
      if (X !== "string") {
        if (X === "object") {
          if (H === null) throw new Error(t);
          if (c && H.constructor === ArrayBuffer) H = new Uint8Array(H);
          else if (!Array.isArray(H) && (!c || !ArrayBuffer.isView(H))) throw new Error(t)
        } else throw new Error(t);
        ne = !0
      }
      for (var Z = this.blocks, te = this.byteCount, F = H.length, J = this.blockCount, ie = 0, ce = this.s, ue, ge; ie < F;) {
        if (this.reset)
          for (this.reset = !1, Z[0] = this.block, ue = 1; ue < J + 1; ++ue) Z[ue] = 0;
        if (ne)
          for (ue = this.start; ie < F && ue < te; ++ie) Z[ue >> 2] |= H[ie] << y[ue++ & 3];
        else
          for (ue = this.start; ie < F && ue < te; ++ie) ge = H.charCodeAt(ie), ge < 128 ? Z[ue >> 2] |= ge << y[ue++ & 3] : ge < 2048 ? (Z[ue >> 2] |= (192 | ge >> 6) << y[ue++ & 3], Z[ue >> 2] |= (128 | ge & 63) << y[ue++ & 3]) : ge < 55296 || ge >= 57344 ? (Z[ue >> 2] |= (224 | ge >> 12) << y[ue++ & 3], Z[ue >> 2] |= (128 | ge >> 6 & 63) << y[ue++ & 3], Z[ue >> 2] |= (128 | ge & 63) << y[ue++ & 3]) : (ge = 65536 + ((ge & 1023) << 10 | H.charCodeAt(++ie) & 1023), Z[ue >> 2] |= (240 | ge >> 18) << y[ue++ & 3], Z[ue >> 2] |= (128 | ge >> 12 & 63) << y[ue++ & 3], Z[ue >> 2] |= (128 | ge >> 6 & 63) << y[ue++ & 3], Z[ue >> 2] |= (128 | ge & 63) << y[ue++ & 3]);
        if (this.lastByteIndex = ue, ue >= te) {
          for (this.start = ue - te, this.block = Z[J], ue = 0; ue < J; ++ue) ce[ue] ^= Z[ue];
          he(ce), this.reset = !0
        } else this.start = ue
      }
      return this
    }, M.prototype.encode = function (H, ne) {
      var X = H & 255,
        Z = 1,
        te = [X];
      for (H = H >> 8, X = H & 255; X > 0;) te.unshift(X), H = H >> 8, X = H & 255, ++Z;
      return ne ? te.push(Z) : te.unshift(Z), this.update(te), te.length
    }, M.prototype.encodeString = function (H) {
      var ne, X = typeof H;
      if (X !== "string") {
        if (X === "object") {
          if (H === null) throw new Error(t);
          if (c && H.constructor === ArrayBuffer) H = new Uint8Array(H);
          else if (!Array.isArray(H) && (!c || !ArrayBuffer.isView(H))) throw new Error(t)
        } else throw new Error(t);
        ne = !0
      }
      var Z = 0,
        te = H.length;
      if (ne) Z = te;
      else
        for (var F = 0; F < H.length; ++F) {
          var J = H.charCodeAt(F);
          J < 128 ? Z += 1 : J < 2048 ? Z += 2 : J < 55296 || J >= 57344 ? Z += 3 : (J = 65536 + ((J & 1023) << 10 | H.charCodeAt(++F) & 1023), Z += 4)
        }
      return Z += this.encode(Z * 8), this.update(H), Z
    }, M.prototype.bytepad = function (H, ne) {
      for (var X = this.encode(ne), Z = 0; Z < H.length; ++Z) X += this.encodeString(H[Z]);
      var te = ne - X % ne,
        F = [];
      return F.length = te, this.update(F), this
    }, M.prototype.finalize = function () {
      if (!this.finalized) {
        this.finalized = !0;
        var H = this.blocks,
          ne = this.lastByteIndex,
          X = this.blockCount,
          Z = this.s;
        if (H[ne >> 2] |= this.padding[ne & 3], this.lastByteIndex === this.byteCount)
          for (H[0] = H[X], ne = 1; ne < X + 1; ++ne) H[ne] = 0;
        for (H[X - 1] |= 2147483648, ne = 0; ne < X; ++ne) Z[ne] ^= H[ne];
        he(Z)
      }
    }, M.prototype.toString = M.prototype.hex = function () {
      this.finalize();
      for (var H = this.blockCount, ne = this.s, X = this.outputBlocks, Z = this.extraBytes, te = 0, F = 0, J = "", ie; F < X;) {
        for (te = 0; te < H && F < X; ++te, ++F) ie = ne[te], J += l[ie >> 4 & 15] + l[ie & 15] + l[ie >> 12 & 15] + l[ie >> 8 & 15] + l[ie >> 20 & 15] + l[ie >> 16 & 15] + l[ie >> 28 & 15] + l[ie >> 24 & 15];
        F % H === 0 && (he(ne), te = 0)
      }
      return Z && (ie = ne[te], J += l[ie >> 4 & 15] + l[ie & 15], Z > 1 && (J += l[ie >> 12 & 15] + l[ie >> 8 & 15]), Z > 2 && (J += l[ie >> 20 & 15] + l[ie >> 16 & 15])), J
    }, M.prototype.arrayBuffer = function () {
      this.finalize();
      var H = this.blockCount,
        ne = this.s,
        X = this.outputBlocks,
        Z = this.extraBytes,
        te = 0,
        F = 0,
        J = this.outputBits >> 3,
        ie;
      Z ? ie = new ArrayBuffer(X + 1 << 2) : ie = new ArrayBuffer(J);
      for (var ce = new Uint32Array(ie); F < X;) {
        for (te = 0; te < H && F < X; ++te, ++F) ce[F] = ne[te];
        F % H === 0 && he(ne)
      }
      return Z && (ce[te] = ne[te], ie = ie.slice(0, J)), ie
    }, M.prototype.buffer = M.prototype.arrayBuffer, M.prototype.digest = M.prototype.array = function () {
      this.finalize();
      for (var H = this.blockCount, ne = this.s, X = this.outputBlocks, Z = this.extraBytes, te = 0, F = 0, J = [], ie, ce; F < X;) {
        for (te = 0; te < H && F < X; ++te, ++F) ie = F << 2, ce = ne[te], J[ie] = ce & 255, J[ie + 1] = ce >> 8 & 255, J[ie + 2] = ce >> 16 & 255, J[ie + 3] = ce >> 24 & 255;
        F % H === 0 && he(ne)
      }
      return Z && (ie = F << 2, ce = ne[te], J[ie] = ce & 255, Z > 1 && (J[ie + 1] = ce >> 8 & 255), Z > 2 && (J[ie + 2] = ce >> 16 & 255)), J
    };

    function Q(H, ne, X) {
      M.call(this, H, ne, X)
    }
    Q.prototype = new M, Q.prototype.finalize = function () {
      return this.encode(this.outputBits, !0), M.prototype.finalize.call(this)
    };
    var he = function (H) {
      var ne, X, Z, te, F, J, ie, ce, ue, ge, et, He, se, pe, de, we, Ce, be, Se, Fe, Ne, Me, We, ke, ze, ct, Xe, _e, Ze, Ee, Oe, yt, tt, dt, xn, Ht, en, tn, Et, Ot, kn, Dt, Pt, _n, zt, kt, In, vt, _t, Pn, wt, $t, Mn, Rn, On, js, cn, $n, Us, zs, Ut, or, pi;
      for (Z = 0; Z < 48; Z += 2) te = H[0] ^ H[10] ^ H[20] ^ H[30] ^ H[40], F = H[1] ^ H[11] ^ H[21] ^ H[31] ^ H[41], J = H[2] ^ H[12] ^ H[22] ^ H[32] ^ H[42], ie = H[3] ^ H[13] ^ H[23] ^ H[33] ^ H[43], ce = H[4] ^ H[14] ^ H[24] ^ H[34] ^ H[44], ue = H[5] ^ H[15] ^ H[25] ^ H[35] ^ H[45], ge = H[6] ^ H[16] ^ H[26] ^ H[36] ^ H[46], et = H[7] ^ H[17] ^ H[27] ^ H[37] ^ H[47], He = H[8] ^ H[18] ^ H[28] ^ H[38] ^ H[48], se = H[9] ^ H[19] ^ H[29] ^ H[39] ^ H[49], ne = He ^ (J << 1 | ie >>> 31), X = se ^ (ie << 1 | J >>> 31), H[0] ^= ne, H[1] ^= X, H[10] ^= ne, H[11] ^= X, H[20] ^= ne, H[21] ^= X, H[30] ^= ne, H[31] ^= X, H[40] ^= ne, H[41] ^= X, ne = te ^ (ce << 1 | ue >>> 31), X = F ^ (ue << 1 | ce >>> 31), H[2] ^= ne, H[3] ^= X, H[12] ^= ne, H[13] ^= X, H[22] ^= ne, H[23] ^= X, H[32] ^= ne, H[33] ^= X, H[42] ^= ne, H[43] ^= X, ne = J ^ (ge << 1 | et >>> 31), X = ie ^ (et << 1 | ge >>> 31), H[4] ^= ne, H[5] ^= X, H[14] ^= ne, H[15] ^= X, H[24] ^= ne, H[25] ^= X, H[34] ^= ne, H[35] ^= X, H[44] ^= ne, H[45] ^= X, ne = ce ^ (He << 1 | se >>> 31), X = ue ^ (se << 1 | He >>> 31), H[6] ^= ne, H[7] ^= X, H[16] ^= ne, H[17] ^= X, H[26] ^= ne, H[27] ^= X, H[36] ^= ne, H[37] ^= X, H[46] ^= ne, H[47] ^= X, ne = ge ^ (te << 1 | F >>> 31), X = et ^ (F << 1 | te >>> 31), H[8] ^= ne, H[9] ^= X, H[18] ^= ne, H[19] ^= X, H[28] ^= ne, H[29] ^= X, H[38] ^= ne, H[39] ^= X, H[48] ^= ne, H[49] ^= X, pe = H[0], de = H[1], kt = H[11] << 4 | H[10] >>> 28, In = H[10] << 4 | H[11] >>> 28, _e = H[20] << 3 | H[21] >>> 29, Ze = H[21] << 3 | H[20] >>> 29, zs = H[31] << 9 | H[30] >>> 23, Ut = H[30] << 9 | H[31] >>> 23, Dt = H[40] << 18 | H[41] >>> 14, Pt = H[41] << 18 | H[40] >>> 14, dt = H[2] << 1 | H[3] >>> 31, xn = H[3] << 1 | H[2] >>> 31, we = H[13] << 12 | H[12] >>> 20, Ce = H[12] << 12 | H[13] >>> 20, vt = H[22] << 10 | H[23] >>> 22, _t = H[23] << 10 | H[22] >>> 22, Ee = H[33] << 13 | H[32] >>> 19, Oe = H[32] << 13 | H[33] >>> 19, or = H[42] << 2 | H[43] >>> 30, pi = H[43] << 2 | H[42] >>> 30, Rn = H[5] << 30 | H[4] >>> 2, On = H[4] << 30 | H[5] >>> 2, Ht = H[14] << 6 | H[15] >>> 26, en = H[15] << 6 | H[14] >>> 26, be = H[25] << 11 | H[24] >>> 21, Se = H[24] << 11 | H[25] >>> 21, Pn = H[34] << 15 | H[35] >>> 17, wt = H[35] << 15 | H[34] >>> 17, yt = H[45] << 29 | H[44] >>> 3, tt = H[44] << 29 | H[45] >>> 3, ke = H[6] << 28 | H[7] >>> 4, ze = H[7] << 28 | H[6] >>> 4, js = H[17] << 23 | H[16] >>> 9, cn = H[16] << 23 | H[17] >>> 9, tn = H[26] << 25 | H[27] >>> 7, Et = H[27] << 25 | H[26] >>> 7, Fe = H[36] << 21 | H[37] >>> 11, Ne = H[37] << 21 | H[36] >>> 11, $t = H[47] << 24 | H[46] >>> 8, Mn = H[46] << 24 | H[47] >>> 8, _n = H[8] << 27 | H[9] >>> 5, zt = H[9] << 27 | H[8] >>> 5, ct = H[18] << 20 | H[19] >>> 12, Xe = H[19] << 20 | H[18] >>> 12, $n = H[29] << 7 | H[28] >>> 25, Us = H[28] << 7 | H[29] >>> 25, Ot = H[38] << 8 | H[39] >>> 24, kn = H[39] << 8 | H[38] >>> 24, Me = H[48] << 14 | H[49] >>> 18, We = H[49] << 14 | H[48] >>> 18, H[0] = pe ^ ~we & be, H[1] = de ^ ~Ce & Se, H[10] = ke ^ ~ct & _e, H[11] = ze ^ ~Xe & Ze, H[20] = dt ^ ~Ht & tn, H[21] = xn ^ ~en & Et, H[30] = _n ^ ~kt & vt, H[31] = zt ^ ~In & _t, H[40] = Rn ^ ~js & $n, H[41] = On ^ ~cn & Us, H[2] = we ^ ~be & Fe, H[3] = Ce ^ ~Se & Ne, H[12] = ct ^ ~_e & Ee, H[13] = Xe ^ ~Ze & Oe, H[22] = Ht ^ ~tn & Ot, H[23] = en ^ ~Et & kn, H[32] = kt ^ ~vt & Pn, H[33] = In ^ ~_t & wt, H[42] = js ^ ~$n & zs, H[43] = cn ^ ~Us & Ut, H[4] = be ^ ~Fe & Me, H[5] = Se ^ ~Ne & We, H[14] = _e ^ ~Ee & yt, H[15] = Ze ^ ~Oe & tt, H[24] = tn ^ ~Ot & Dt, H[25] = Et ^ ~kn & Pt, H[34] = vt ^ ~Pn & $t, H[35] = _t ^ ~wt & Mn, H[44] = $n ^ ~zs & or, H[45] = Us ^ ~Ut & pi, H[6] = Fe ^ ~Me & pe, H[7] = Ne ^ ~We & de, H[16] = Ee ^ ~yt & ke, H[17] = Oe ^ ~tt & ze, H[26] = Ot ^ ~Dt & dt, H[27] = kn ^ ~Pt & xn, H[36] = Pn ^ ~$t & _n, H[37] = wt ^ ~Mn & zt, H[46] = zs ^ ~or & Rn, H[47] = Ut ^ ~pi & On, H[8] = Me ^ ~pe & we, H[9] = We ^ ~de & Ce, H[18] = yt ^ ~ke & ct, H[19] = tt ^ ~ze & Xe, H[28] = Dt ^ ~dt & Ht, H[29] = Pt ^ ~xn & en, H[38] = $t ^ ~_n & kt, H[39] = Mn ^ ~zt & In, H[48] = or ^ ~Rn & js, H[49] = pi ^ ~On & cn, H[0] ^= x[Z], H[1] ^= x[Z + 1]
    };
    if (a) e.exports = b;
    else
      for (R = 0; R < T.length; ++R) i[T[R]] = b[T[R]]
  })()
})(IV);
var v5e = IV.exports;
const b5e = Vo(v5e);

function di(e) {
  return "0x" + b5e.keccak_256(jt(e))
}
const w5e = "rlp/5.7.0",
  Hc = new Ae(w5e);

function JN(e) {
  const t = [];
  for (; e;) t.unshift(e & 255), e >>= 8;
  return t
}

function XN(e, t, n) {
  let r = 0;
  for (let i = 0; i < n; i++) r = r * 256 + e[t + i];
  return r
}

function PV(e) {
  if (Array.isArray(e)) {
    let r = [];
    if (e.forEach(function (s) {
        r = r.concat(PV(s))
      }), r.length <= 55) return r.unshift(192 + r.length), r;
    const i = JN(r.length);
    return i.unshift(247 + i.length), i.concat(r)
  }
  pk(e) || Hc.throwArgumentError("RLP object must be BytesLike", "object", e);
  const t = Array.prototype.slice.call(jt(e));
  if (t.length === 1 && t[0] <= 127) return t;
  if (t.length <= 55) return t.unshift(128 + t.length), t;
  const n = JN(t.length);
  return n.unshift(183 + n.length), n.concat(t)
}

function z5(e) {
  return St(PV(e))
}

function ZN(e, t, n, r) {
  const i = [];
  for (; n < t + 1 + r;) {
    const s = RV(e, n);
    i.push(s.result), n += s.consumed, n > t + 1 + r && Hc.throwError("child data too short", Ae.errors.BUFFER_OVERRUN, {})
  }
  return {
    consumed: 1 + r,
    result: i
  }
}

function RV(e, t) {
  if (e.length === 0 && Hc.throwError("data too short", Ae.errors.BUFFER_OVERRUN, {}), e[t] >= 248) {
    const n = e[t] - 247;
    t + 1 + n > e.length && Hc.throwError("data short segment too short", Ae.errors.BUFFER_OVERRUN, {});
    const r = XN(e, t + 1, n);
    return t + 1 + n + r > e.length && Hc.throwError("data long segment too short", Ae.errors.BUFFER_OVERRUN, {}), ZN(e, t, t + 1 + n, n + r)
  } else if (e[t] >= 192) {
    const n = e[t] - 192;
    return t + 1 + n > e.length && Hc.throwError("data array too short", Ae.errors.BUFFER_OVERRUN, {}), ZN(e, t, t + 1, n)
  } else if (e[t] >= 184) {
    const n = e[t] - 183;
    t + 1 + n > e.length && Hc.throwError("data array too short", Ae.errors.BUFFER_OVERRUN, {});
    const r = XN(e, t + 1, n);
    t + 1 + n + r > e.length && Hc.throwError("data array too short", Ae.errors.BUFFER_OVERRUN, {});
    const i = St(e.slice(t + 1 + n, t + 1 + n + r));
    return {
      consumed: 1 + n + r,
      result: i
    }
  } else if (e[t] >= 128) {
    const n = e[t] - 128;
    t + 1 + n > e.length && Hc.throwError("data too short", Ae.errors.BUFFER_OVERRUN, {});
    const r = St(e.slice(t + 1, t + 1 + n));
    return {
      consumed: 1 + n,
      result: r
    }
  }
  return {
    consumed: 1,
    result: St(e[t])
  }
}

function yk(e) {
  const t = jt(e),
    n = RV(t, 0);
  return n.consumed !== t.length && Hc.throwArgumentError("invalid rlp data", "data", e), n.result
}
const x5e = "address/5.7.0",
  q0 = new Ae(x5e);

function eM(e) {
  pn(e, 20) || q0.throwArgumentError("invalid address", "address", e), e = e.toLowerCase();
  const t = e.substring(2).split(""),
    n = new Uint8Array(40);
  for (let i = 0; i < 40; i++) n[i] = t[i].charCodeAt(0);
  const r = jt(di(n));
  for (let i = 0; i < 40; i += 2) r[i >> 1] >> 4 >= 8 && (t[i] = t[i].toUpperCase()), (r[i >> 1] & 15) >= 8 && (t[i + 1] = t[i + 1].toUpperCase());
  return "0x" + t.join("")
}
const E5e = 9007199254740991;

function S5e(e) {
  return Math.log10 ? Math.log10(e) : Math.log(e) / Math.LN10
}
const vk = {};
for (let e = 0; e < 10; e++) vk[String(e)] = String(e);
for (let e = 0; e < 26; e++) vk[String.fromCharCode(65 + e)] = String(10 + e);
const tM = Math.floor(S5e(E5e));

function C5e(e) {
  e = e.toUpperCase(), e = e.substring(4) + e.substring(0, 2) + "00";
  let t = e.split("").map(r => vk[r]).join("");
  for (; t.length >= tM;) {
    let r = t.substring(0, tM);
    t = parseInt(r, 10) % 97 + t.substring(r.length)
  }
  let n = String(98 - parseInt(t, 10) % 97);
  for (; n.length < 2;) n = "0" + n;
  return n
}

function ki(e) {
  let t = null;
  if (typeof e != "string" && q0.throwArgumentError("invalid address", "address", e), e.match(/^(0x)?[0-9a-fA-F]{40}$/)) e.substring(0, 2) !== "0x" && (e = "0x" + e), t = eM(e), e.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && t !== e && q0.throwArgumentError("bad address checksum", "address", e);
  else if (e.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    for (e.substring(2, 4) !== C5e(e) && q0.throwArgumentError("bad icap checksum", "address", e), t = o5e(e.substring(4)); t.length < 40;) t = "0" + t;
    t = eM("0x" + t)
  } else q0.throwArgumentError("invalid address", "address", e);
  return t
}

function k3(e) {
  try {
    return ki(e), !0
  } catch {}
  return !1
}

function OV(e) {
  let t = null;
  try {
    t = ki(e.from)
  } catch {
    q0.throwArgumentError("missing from address", "transaction", e)
  }
  const n = Mp(jt(st.from(e.nonce).toHexString()));
  return ki(rs(di(z5([t, n])), 12))
}
class A5e extends vu {
  constructor(t) {
    super("address", "address", t, !1)
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000"
  }
  encode(t, n) {
    try {
      n = ki(n)
    } catch (r) {
      this._throwError(r.message, n)
    }
    return t.writeValue(n)
  }
  decode(t) {
    return ki(zr(t.readValue().toHexString(), 20))
  }
}
class T5e extends vu {
  constructor(t) {
    super(t.name, t.type, void 0, t.dynamic), this.coder = t
  }
  defaultValue() {
    return this.coder.defaultValue()
  }
  encode(t, n) {
    return this.coder.encode(t, n)
  }
  decode(t) {
    return this.coder.decode(t)
  }
}
const G0 = new Ae(ny);

function DV(e, t, n) {
  let r = null;
  if (Array.isArray(n)) r = n;
  else if (n && typeof n == "object") {
    let c = {};
    r = t.map(l => {
      const u = l.localName;
      return u || G0.throwError("cannot encode object for signature with missing names", Ae.errors.INVALID_ARGUMENT, {
        argument: "values",
        coder: l,
        value: n
      }), c[u] && G0.throwError("cannot encode object for signature with duplicate names", Ae.errors.INVALID_ARGUMENT, {
        argument: "values",
        coder: l,
        value: n
      }), c[u] = !0, n[u]
    })
  } else G0.throwArgumentError("invalid tuple value", "tuple", n);
  t.length !== r.length && G0.throwArgumentError("types/value length mismatch", "tuple", n);
  let i = new aA(e.wordSize),
    s = new aA(e.wordSize),
    o = [];
  t.forEach((c, l) => {
    let u = r[l];
    if (c.dynamic) {
      let f = s.length;
      c.encode(s, u);
      let h = i.writeUpdatableValue();
      o.push(g => {
        h(g + f)
      })
    } else c.encode(i, u)
  }), o.forEach(c => {
    c(i.length)
  });
  let a = e.appendWriter(i);
  return a += e.appendWriter(s), a
}

function NV(e, t) {
  let n = [],
    r = e.subReader(0);
  t.forEach(s => {
    let o = null;
    if (s.dynamic) {
      let a = e.readValue(),
        c = r.subReader(a.toNumber());
      try {
        o = s.decode(c)
      } catch (l) {
        if (l.code === Ae.errors.BUFFER_OVERRUN) throw l;
        o = l, o.baseType = s.name, o.name = s.localName, o.type = s.type
      }
    } else try {
      o = s.decode(e)
    } catch (a) {
      if (a.code === Ae.errors.BUFFER_OVERRUN) throw a;
      o = a, o.baseType = s.name, o.name = s.localName, o.type = s.type
    }
    o != null && n.push(o)
  });
  const i = t.reduce((s, o) => {
    const a = o.localName;
    return a && (s[a] || (s[a] = 0), s[a]++), s
  }, {});
  t.forEach((s, o) => {
    let a = s.localName;
    if (!a || i[a] !== 1 || (a === "length" && (a = "_length"), n[a] != null)) return;
    const c = n[o];
    c instanceof Error ? Object.defineProperty(n, a, {
      enumerable: !0,
      get: () => {
        throw c
      }
    }) : n[a] = c
  });
  for (let s = 0; s < n.length; s++) {
    const o = n[s];
    o instanceof Error && Object.defineProperty(n, s, {
      enumerable: !0,
      get: () => {
        throw o
      }
    })
  }
  return Object.freeze(n)
}
class k5e extends vu {
  constructor(t, n, r) {
    const i = t.type + "[" + (n >= 0 ? n : "") + "]",
      s = n === -1 || t.dynamic;
    super("array", i, r, s), this.coder = t, this.length = n
  }
  defaultValue() {
    const t = this.coder.defaultValue(),
      n = [];
    for (let r = 0; r < this.length; r++) n.push(t);
    return n
  }
  encode(t, n) {
    Array.isArray(n) || this._throwError("expected array value", n);
    let r = this.length;
    r === -1 && (r = n.length, t.writeValue(n.length)), G0.checkArgumentCount(n.length, r, "coder array" + (this.localName ? " " + this.localName : ""));
    let i = [];
    for (let s = 0; s < n.length; s++) i.push(this.coder);
    return DV(t, i, n)
  }
  decode(t) {
    let n = this.length;
    n === -1 && (n = t.readValue().toNumber(), n * 32 > t._data.length && G0.throwError("insufficient data length", Ae.errors.BUFFER_OVERRUN, {
      length: t._data.length,
      count: n
    }));
    let r = [];
    for (let i = 0; i < n; i++) r.push(new T5e(this.coder));
    return t.coerce(this.name, NV(t, r))
  }
}
class _5e extends vu {
  constructor(t) {
    super("bool", "bool", t, !1)
  }
  defaultValue() {
    return !1
  }
  encode(t, n) {
    return t.writeValue(n ? 1 : 0)
  }
  decode(t) {
    return t.coerce(this.type, !t.readValue().isZero())
  }
}
class MV extends vu {
  constructor(t, n) {
    super(t, t, n, !0)
  }
  defaultValue() {
    return "0x"
  }
  encode(t, n) {
    n = jt(n);
    let r = t.writeValue(n.length);
    return r += t.writeBytes(n), r
  }
  decode(t) {
    return t.readBytes(t.readValue().toNumber(), !0)
  }
}
class I5e extends MV {
  constructor(t) {
    super("bytes", t)
  }
  decode(t) {
    return t.coerce(this.name, St(super.decode(t)))
  }
}
class P5e extends vu {
  constructor(t, n) {
    let r = "bytes" + String(t);
    super(r, r, n, !1), this.size = t
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2)
  }
  encode(t, n) {
    let r = jt(n);
    return r.length !== this.size && this._throwError("incorrect data length", n), t.writeBytes(r)
  }
  decode(t) {
    return t.coerce(this.name, St(t.readBytes(this.size)))
  }
}
class R5e extends vu {
  constructor(t) {
    super("null", "", t, !1)
  }
  defaultValue() {
    return null
  }
  encode(t, n) {
    return n != null && this._throwError("not null", n), t.writeBytes([])
  }
  decode(t) {
    return t.readBytes(0), t.coerce(this.name, null)
  }
}
const bk = "0x0000000000000000000000000000000000000000",
  O5e = st.from(-1),
  $V = st.from(0),
  D5e = st.from(1),
  wk = st.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"),
  N5e = "0x0000000000000000000000000000000000000000000000000000000000000000";
class M5e extends vu {
  constructor(t, n, r) {
    const i = (n ? "int" : "uint") + t * 8;
    super(i, i, r, !1), this.size = t, this.signed = n
  }
  defaultValue() {
    return 0
  }
  encode(t, n) {
    let r = st.from(n),
      i = wk.mask(t.wordSize * 8);
    if (this.signed) {
      let s = i.mask(this.size * 8 - 1);
      (r.gt(s) || r.lt(s.add(D5e).mul(O5e))) && this._throwError("value out-of-bounds", n)
    } else(r.lt($V) || r.gt(i.mask(this.size * 8))) && this._throwError("value out-of-bounds", n);
    return r = r.toTwos(this.size * 8).mask(this.size * 8), this.signed && (r = r.fromTwos(this.size * 8).toTwos(8 * t.wordSize)), t.writeValue(r)
  }
  decode(t) {
    let n = t.readValue().mask(this.size * 8);
    return this.signed && (n = n.fromTwos(this.size * 8)), t.coerce(this.name, n)
  }
}
const $5e = "strings/5.7.0",
  LV = new Ae($5e);
var c2;
(function (e) {
  e.current = "", e.NFC = "NFC", e.NFD = "NFD", e.NFKC = "NFKC", e.NFKD = "NFKD"
})(c2 || (c2 = {}));
var Ro;
(function (e) {
  e.UNEXPECTED_CONTINUE = "unexpected continuation byte", e.BAD_PREFIX = "bad codepoint prefix", e.OVERRUN = "string overrun", e.MISSING_CONTINUE = "missing continuation byte", e.OUT_OF_RANGE = "out of UTF-8 range", e.UTF16_SURROGATE = "UTF-16 surrogate", e.OVERLONG = "overlong representation"
})(Ro || (Ro = {}));

function L5e(e, t, n, r, i) {
  return LV.throwArgumentError(`invalid codepoint at offset ${t}; ${e}`, "bytes", n)
}

function BV(e, t, n, r, i) {
  if (e === Ro.BAD_PREFIX || e === Ro.UNEXPECTED_CONTINUE) {
    let s = 0;
    for (let o = t + 1; o < n.length && n[o] >> 6 === 2; o++) s++;
    return s
  }
  return e === Ro.OVERRUN ? n.length - t - 1 : 0
}

function B5e(e, t, n, r, i) {
  return e === Ro.OVERLONG ? (r.push(i), 0) : (r.push(65533), BV(e, t, n))
}
const F5e = Object.freeze({
  error: L5e,
  ignore: BV,
  replace: B5e
});

function FV(e, t) {
  t == null && (t = F5e.error), e = jt(e);
  const n = [];
  let r = 0;
  for (; r < e.length;) {
    const i = e[r++];
    if (!(i >> 7)) {
      n.push(i);
      continue
    }
    let s = null,
      o = null;
    if ((i & 224) === 192) s = 1, o = 127;
    else if ((i & 240) === 224) s = 2, o = 2047;
    else if ((i & 248) === 240) s = 3, o = 65535;
    else {
      (i & 192) === 128 ? r += t(Ro.UNEXPECTED_CONTINUE, r - 1, e, n) : r += t(Ro.BAD_PREFIX, r - 1, e, n);
      continue
    }
    if (r - 1 + s >= e.length) {
      r += t(Ro.OVERRUN, r - 1, e, n);
      continue
    }
    let a = i & (1 << 8 - s - 1) - 1;
    for (let c = 0; c < s; c++) {
      let l = e[r];
      if ((l & 192) != 128) {
        r += t(Ro.MISSING_CONTINUE, r, e, n), a = null;
        break
      }
      a = a << 6 | l & 63, r++
    }
    if (a !== null) {
      if (a > 1114111) {
        r += t(Ro.OUT_OF_RANGE, r - 1 - s, e, n, a);
        continue
      }
      if (a >= 55296 && a <= 57343) {
        r += t(Ro.UTF16_SURROGATE, r - 1 - s, e, n, a);
        continue
      }
      if (a <= o) {
        r += t(Ro.OVERLONG, r - 1 - s, e, n, a);
        continue
      }
      n.push(a)
    }
  }
  return n
}

function fl(e, t = c2.current) {
  t != c2.current && (LV.checkNormalize(), e = e.normalize(t));
  let n = [];
  for (let r = 0; r < e.length; r++) {
    const i = e.charCodeAt(r);
    if (i < 128) n.push(i);
    else if (i < 2048) n.push(i >> 6 | 192), n.push(i & 63 | 128);
    else if ((i & 64512) == 55296) {
      r++;
      const s = e.charCodeAt(r);
      if (r >= e.length || (s & 64512) !== 56320) throw new Error("invalid utf-8 string");
      const o = 65536 + ((i & 1023) << 10) + (s & 1023);
      n.push(o >> 18 | 240), n.push(o >> 12 & 63 | 128), n.push(o >> 6 & 63 | 128), n.push(o & 63 | 128)
    } else n.push(i >> 12 | 224), n.push(i >> 6 & 63 | 128), n.push(i & 63 | 128)
  }
  return jt(n)
}

function j5e(e) {
  return e.map(t => t <= 65535 ? String.fromCharCode(t) : (t -= 65536, String.fromCharCode((t >> 10 & 1023) + 55296, (t & 1023) + 56320))).join("")
}

function ry(e, t) {
  return j5e(FV(e, t))
}

function U5e(e, t = c2.current) {
  return FV(fl(e, t))
}
class z5e extends MV {
  constructor(t) {
    super("string", t)
  }
  defaultValue() {
    return ""
  }
  encode(t, n) {
    return super.encode(t, fl(n))
  }
  decode(t) {
    return ry(super.decode(t))
  }
}
class mb extends vu {
  constructor(t, n) {
    let r = !1;
    const i = [];
    t.forEach(o => {
      o.dynamic && (r = !0), i.push(o.type)
    });
    const s = "tuple(" + i.join(",") + ")";
    super("tuple", s, n, r), this.coders = t
  }
  defaultValue() {
    const t = [];
    this.coders.forEach(r => {
      t.push(r.defaultValue())
    });
    const n = this.coders.reduce((r, i) => {
      const s = i.localName;
      return s && (r[s] || (r[s] = 0), r[s]++), r
    }, {});
    return this.coders.forEach((r, i) => {
      let s = r.localName;
      !s || n[s] !== 1 || (s === "length" && (s = "_length"), t[s] == null && (t[s] = t[i]))
    }), Object.freeze(t)
  }
  encode(t, n) {
    return DV(t, this.coders, n)
  }
  decode(t) {
    return t.coerce(this.name, NV(t, this.coders))
  }
}
const gb = new Ae(ny),
  H5e = new RegExp(/^bytes([0-9]*)$/),
  V5e = new RegExp(/^(u?int)([0-9]*)$/);
class W5e {
  constructor(t) {
    Ge(this, "coerceFunc", t || null)
  }
  _getCoder(t) {
    switch (t.baseType) {
      case "address":
        return new A5e(t.name);
      case "bool":
        return new _5e(t.name);
      case "string":
        return new z5e(t.name);
      case "bytes":
        return new I5e(t.name);
      case "array":
        return new k5e(this._getCoder(t.arrayChildren), t.arrayLength, t.name);
      case "tuple":
        return new mb((t.components || []).map(r => this._getCoder(r)), t.name);
      case "":
        return new R5e(t.name)
    }
    let n = t.type.match(V5e);
    if (n) {
      let r = parseInt(n[2] || "256");
      return (r === 0 || r > 256 || r % 8 !== 0) && gb.throwArgumentError("invalid " + n[1] + " bit length", "param", t), new M5e(r / 8, n[1] === "int", t.name)
    }
    if (n = t.type.match(H5e), n) {
      let r = parseInt(n[1]);
      return (r === 0 || r > 32) && gb.throwArgumentError("invalid bytes length", "param", t), new P5e(r, t.name)
    }
    return gb.throwArgumentError("invalid type", "type", t.type)
  }
  _getWordSize() {
    return 32
  }
  _getReader(t, n) {
    return new T3(t, this._getWordSize(), this.coerceFunc, n)
  }
  _getWriter() {
    return new aA(this._getWordSize())
  }
  getDefaultValue(t) {
    const n = t.map(i => this._getCoder(wi.from(i)));
    return new mb(n, "_").defaultValue()
  }
  encode(t, n) {
    t.length !== n.length && gb.throwError("types/values length mismatch", Ae.errors.INVALID_ARGUMENT, {
      count: {
        types: t.length,
        values: n.length
      },
      value: {
        types: t,
        values: n
      }
    });
    const r = t.map(o => this._getCoder(wi.from(o))),
      i = new mb(r, "_"),
      s = this._getWriter();
    return i.encode(s, n), s.data
  }
  decode(t, n, r) {
    const i = t.map(o => this._getCoder(wi.from(o)));
    return new mb(i, "_").decode(this._getReader(jt(n), r))
  }
}
const q5e = new W5e;

function K0(e) {
  return di(fl(e))
}
const jV = "hash/5.7.0";

function UV(e) {
  e = atob(e);
  const t = [];
  for (let n = 0; n < e.length; n++) t.push(e.charCodeAt(n));
  return jt(t)
}

function zV(e) {
  e = jt(e);
  let t = "";
  for (let n = 0; n < e.length; n++) t += String.fromCharCode(e[n]);
  return btoa(t)
}

function HV(e, t) {
  t == null && (t = 1);
  const n = [],
    r = n.forEach,
    i = function (s, o) {
      r.call(s, function (a) {
        o > 0 && Array.isArray(a) ? i(a, o - 1) : n.push(a)
      })
    };
  return i(e, t), n
}

function G5e(e) {
  const t = {};
  for (let n = 0; n < e.length; n++) {
    const r = e[n];
    t[r[0]] = r[1]
  }
  return t
}

function K5e(e) {
  let t = 0;

  function n() {
    return e[t++] << 8 | e[t++]
  }
  let r = n(),
    i = 1,
    s = [0, 1];
  for (let I = 1; I < r; I++) s.push(i += n());
  let o = n(),
    a = t;
  t += o;
  let c = 0,
    l = 0;

  function u() {
    return c == 0 && (l = l << 8 | e[t++], c = 8), l >> --c & 1
  }
  const f = 31,
    h = Math.pow(2, f),
    g = h >>> 1,
    y = g >> 1,
    x = h - 1;
  let k = 0;
  for (let I = 0; I < f; I++) k = k << 1 | u();
  let _ = [],
    p = 0,
    v = h;
  for (;;) {
    let I = Math.floor(((k - p + 1) * i - 1) / v),
      A = 0,
      w = r;
    for (; w - A > 1;) {
      let $ = A + w >>> 1;
      I < s[$] ? w = $ : A = $
    }
    if (A == 0) break;
    _.push(A);
    let E = p + Math.floor(v * s[A] / i),
      D = p + Math.floor(v * s[A + 1] / i) - 1;
    for (; !((E ^ D) & g);) k = k << 1 & x | u(), E = E << 1 & x, D = D << 1 & x | 1;
    for (; E & ~D & y;) k = k & g | k << 1 & x >>> 1 | u(), E = E << 1 ^ g, D = (D ^ g) << 1 | g | 1;
    p = E, v = 1 + D - E
  }
  let S = r - 4;
  return _.map(I => {
    switch (I - S) {
      case 3:
        return S + 65792 + (e[a++] << 16 | e[a++] << 8 | e[a++]);
      case 2:
        return S + 256 + (e[a++] << 8 | e[a++]);
      case 1:
        return S + e[a++];
      default:
        return I - 1
    }
  })
}

function Q5e(e) {
  let t = 0;
  return () => e[t++]
}

function Y5e(e) {
  return Q5e(K5e(e))
}

function J5e(e) {
  return e & 1 ? ~e >> 1 : e >> 1
}

function X5e(e, t) {
  let n = Array(e);
  for (let r = 0; r < e; r++) n[r] = 1 + t();
  return n
}

function nM(e, t) {
  let n = Array(e);
  for (let r = 0, i = -1; r < e; r++) n[r] = i += 1 + t();
  return n
}

function Z5e(e, t) {
  let n = Array(e);
  for (let r = 0, i = 0; r < e; r++) n[r] = i += J5e(t());
  return n
}

function _3(e, t) {
  let n = nM(e(), e),
    r = e(),
    i = nM(r, e),
    s = X5e(r, e);
  for (let o = 0; o < r; o++)
    for (let a = 0; a < s[o]; a++) n.push(i[o] + a);
  return t ? n.map(o => t[o]) : n
}

function e6e(e) {
  let t = [];
  for (;;) {
    let n = e();
    if (n == 0) break;
    t.push(n6e(n, e))
  }
  for (;;) {
    let n = e() - 1;
    if (n < 0) break;
    t.push(r6e(n, e))
  }
  return G5e(HV(t))
}

function t6e(e) {
  let t = [];
  for (;;) {
    let n = e();
    if (n == 0) break;
    t.push(n)
  }
  return t
}

function VV(e, t, n) {
  let r = Array(e).fill(void 0).map(() => []);
  for (let i = 0; i < t; i++) Z5e(e, n).forEach((s, o) => r[o].push(s));
  return r
}

function n6e(e, t) {
  let n = 1 + t(),
    r = t(),
    i = t6e(t),
    s = VV(i.length, 1 + e, t);
  return HV(s.map((o, a) => {
    const c = o[0],
      l = o.slice(1);
    return Array(i[a]).fill(void 0).map((u, f) => {
      let h = f * r;
      return [c + f * n, l.map(g => g + h)]
    })
  }))
}

function r6e(e, t) {
  let n = 1 + t();
  return VV(n, 1 + e, t).map(i => [i[0], i.slice(1)])
}

function i6e(e) {
  let t = _3(e).sort((r, i) => r - i);
  return n();

  function n() {
    let r = [];
    for (;;) {
      let l = _3(e, t);
      if (l.length == 0) break;
      r.push({
        set: new Set(l),
        node: n()
      })
    }
    r.sort((l, u) => u.set.size - l.set.size);
    let i = e(),
      s = i % 3;
    i = i / 3 | 0;
    let o = !!(i & 1);
    i >>= 1;
    let a = i == 1,
      c = i == 2;
    return {
      branches: r,
      valid: s,
      fe0f: o,
      save: a,
      check: c
    }
  }
}

function s6e() {
  return Y5e(UV("AEQF2AO2DEsA2wIrAGsBRABxAN8AZwCcAEwAqgA0AGwAUgByADcATAAVAFYAIQAyACEAKAAYAFgAGwAjABQAMAAmADIAFAAfABQAKwATACoADgAbAA8AHQAYABoAGQAxADgALAAoADwAEwA9ABMAGgARAA4ADwAWABMAFgAIAA8AHgQXBYMA5BHJAS8JtAYoAe4AExozi0UAH21tAaMnBT8CrnIyhrMDhRgDygIBUAEHcoFHUPe8AXBjAewCjgDQR8IICIcEcQLwATXCDgzvHwBmBoHNAqsBdBcUAykgDhAMShskMgo8AY8jqAQfAUAfHw8BDw87MioGlCIPBwZCa4ELatMAAMspJVgsDl8AIhckSg8XAHdvTwBcIQEiDT4OPhUqbyECAEoAS34Aej8Ybx83JgT/Xw8gHxZ/7w8RICxPHA9vBw+Pfw8PHwAPFv+fAsAvCc8vEr8ivwD/EQ8Bol8OEBa/A78hrwAPCU8vESNvvwWfHwNfAVoDHr+ZAAED34YaAdJPAK7PLwSEgDLHAGo1Pz8Pvx9fUwMrpb8O/58VTzAPIBoXIyQJNF8hpwIVAT8YGAUADDNBaX3RAMomJCg9EhUeA29MABsZBTMNJipjOhc19gcIDR8bBwQHEggCWi6DIgLuAQYA+BAFCha3A5XiAEsqM7UFFgFLhAMjFTMYE1Klnw74nRVBG/ASCm0BYRN/BrsU3VoWy+S0vV8LQx+vN8gF2AC2AK5EAWwApgYDKmAAroQ0NDQ0AT+OCg7wAAIHRAbpNgVcBV0APTA5BfbPFgMLzcYL/QqqA82eBALKCjQCjqYCht0/k2+OAsXQAoP3ASTKDgDw6ACKAUYCMpIKJpRaAE4A5womABzZvs0REEKiACIQAd5QdAECAj4Ywg/wGqY2AVgAYADYvAoCGAEubA0gvAY2ALAAbpbvqpyEAGAEpgQAJgAG7gAgAEACmghUFwCqAMpAINQIwC4DthRAAPcycKgApoIdABwBfCisABoATwBqASIAvhnSBP8aH/ECeAKXAq40NjgDBTwFYQU6AXs3oABgAD4XNgmcCY1eCl5tIFZeUqGgyoNHABgAEQAaABNwWQAmABMATPMa3T34ADldyprmM1M2XociUQgLzvwAXT3xABgAEQAaABNwIGFAnADD8AAgAD4BBJWzaCcIAIEBFMAWwKoAAdq9BWAF5wLQpALEtQAKUSGkahR4GnJM+gsAwCgeFAiUAECQ0BQuL8AAIAAAADKeIheclvFqQAAETr4iAMxIARMgAMIoHhQIAn0E0pDQFC4HhznoAAAAIAI2C0/4lvFqQAAETgBJJwYCAy4ABgYAFAA8MBKYEH4eRhTkAjYeFcgACAYAeABsOqyQ5gRwDayqugEgaIIAtgoACgDmEABmBAWGme5OBJJA2m4cDeoAmITWAXwrMgOgAGwBCh6CBXYF1Tzg1wKAAFdiuABRAFwAXQBsAG8AdgBrAHYAbwCEAHEwfxQBVE5TEQADVFhTBwBDANILAqcCzgLTApQCrQL6vAAMAL8APLhNBKkE6glGKTAU4Dr4N2EYEwBCkABKk8rHAbYBmwIoAiU4Ajf/Aq4CowCAANIChzgaNBsCsTgeODcFXrgClQKdAqQBiQGYAqsCsjTsNHsfNPA0ixsAWTWiOAMFPDQSNCk2BDZHNow2TTZUNhk28Jk9VzI3QkEoAoICoQKwAqcAQAAxBV4FXbS9BW47YkIXP1ciUqs05DS/FwABUwJW11e6nHuYZmSh/RAYA8oMKvZ8KASoUAJYWAJ6ILAsAZSoqjpgA0ocBIhmDgDWAAawRDQoAAcuAj5iAHABZiR2AIgiHgCaAU68ACxuHAG0ygM8MiZIAlgBdF4GagJqAPZOHAMuBgoATkYAsABiAHgAMLoGDPj0HpKEBAAOJgAuALggTAHWAeAMEDbd20Uege0ADwAWADkAQgA9OHd+2MUQZBBhBgNNDkxxPxUQArEPqwvqERoM1irQ090ANK4H8ANYB/ADWANYB/AH8ANYB/ADWANYA1gDWBwP8B/YxRBkD00EcgWTBZAE2wiIJk4RhgctCNdUEnQjHEwDSgEBIypJITuYMxAlR0wRTQgIATZHbKx9PQNMMbBU+pCnA9AyVDlxBgMedhKlAC8PeCE1uk6DekxxpQpQT7NX9wBFBgASqwAS5gBJDSgAUCwGPQBI4zTYABNGAE2bAE3KAExdGABKaAbgAFBXAFCOAFBJABI2SWdObALDOq0//QomCZhvwHdTBkIQHCemEPgMNAG2ATwN7kvZBPIGPATKH34ZGg/OlZ0Ipi3eDO4m5C6igFsj9iqEBe5L9TzeC05RaQ9aC2YJ5DpkgU8DIgEOIowK3g06CG4Q9ArKbA3mEUYHOgPWSZsApgcCCxIdNhW2JhFirQsKOXgG/Br3C5AmsBMqev0F1BoiBk4BKhsAANAu6IWxWjJcHU9gBgQLJiPIFKlQIQ0mQLh4SRocBxYlqgKSQ3FKiFE3HpQh9zw+DWcuFFF9B/Y8BhlQC4I8n0asRQ8R0z6OPUkiSkwtBDaALDAnjAnQD4YMunxzAVoJIgmyDHITMhEYN8YIOgcaLpclJxYIIkaWYJsE+KAD9BPSAwwFQAlCBxQDthwuEy8VKgUOgSXYAvQ21i60ApBWgQEYBcwPJh/gEFFH4Q7qCJwCZgOEJewALhUiABginAhEZABgj9lTBi7MCMhqbSN1A2gU6GIRdAeSDlgHqBw0FcAc4nDJXgyGCSiksAlcAXYJmgFgBOQICjVcjKEgQmdUi1kYnCBiQUBd/QIyDGYVoES+h3kCjA9sEhwBNgF0BzoNAgJ4Ee4RbBCWCOyGBTW2M/k6JgRQIYQgEgooA1BszwsoJvoM+WoBpBJjAw00PnfvZ6xgtyUX/gcaMsZBYSHyC5NPzgydGsIYQ1QvGeUHwAP0GvQn60FYBgADpAQUOk4z7wS+C2oIjAlAAEoOpBgH2BhrCnKM0QEyjAG4mgNYkoQCcJAGOAcMAGgMiAV65gAeAqgIpAAGANADWAA6Aq4HngAaAIZCAT4DKDABIuYCkAOUCDLMAZYwAfQqBBzEDBYA+DhuSwLDsgKAa2ajBd5ZAo8CSjYBTiYEBk9IUgOwcuIA3ABMBhTgSAEWrEvMG+REAeBwLADIAPwABjYHBkIBzgH0bgC4AWALMgmjtLYBTuoqAIQAFmwB2AKKAN4ANgCA8gFUAE4FWvoF1AJQSgESMhksWGIBvAMgATQBDgB6BsyOpsoIIARuB9QCEBwV4gLvLwe2AgMi4BPOQsYCvd9WADIXUu5eZwqoCqdeaAC0YTQHMnM9UQAPH6k+yAdy/BZIiQImSwBQ5gBQQzSaNTFWSTYBpwGqKQK38AFtqwBI/wK37gK3rQK3sAK6280C0gK33AK3zxAAUEIAUD9SklKDArekArw5AEQAzAHCO147WTteO1k7XjtZO147WTteO1kDmChYI03AVU0oJqkKbV9GYewMpw3VRMk6ShPcYFJgMxPJLbgUwhXPJVcZPhq9JwYl5VUKDwUt1GYxCC00dhe9AEApaYNCY4ceMQpMHOhTklT5LRwAskujM7ANrRsWREEFSHXuYisWDwojAmSCAmJDXE6wXDchAqH4AmiZAmYKAp+FOBwMAmY8AmYnBG8EgAN/FAN+kzkHOXgYOYM6JCQCbB4CMjc4CwJtyAJtr/CLADRoRiwBaADfAOIASwYHmQyOAP8MwwAOtgJ3MAJ2o0ACeUxEAni7Hl3cRa9G9AJ8QAJ6yQJ9CgJ88UgBSH5kJQAsFklZSlwWGErNAtECAtDNSygDiFADh+dExpEzAvKiXQQDA69Lz0wuJgTQTU1NsAKLQAKK2cIcCB5EaAa4Ao44Ao5dQZiCAo7aAo5deVG1UzYLUtVUhgKT/AKTDQDqAB1VH1WwVdEHLBwplocy4nhnRTw6ApegAu+zWCKpAFomApaQApZ9nQCqWa1aCoJOADwClrYClk9cRVzSApnMApllXMtdCBoCnJw5wzqeApwXAp+cAp65iwAeEDIrEAKd8gKekwC2PmE1YfACntQCoG8BqgKeoCACnk+mY8lkKCYsAiewAiZ/AqD8AqBN2AKmMAKlzwKoAAB+AqfzaH1osgAESmodatICrOQCrK8CrWgCrQMCVx4CVd0CseLYAx9PbJgCsr4OArLpGGzhbWRtSWADJc4Ctl08QG6RAylGArhfArlIFgK5K3hwN3DiAr0aAy2zAzISAr6JcgMDM3ICvhtzI3NQAsPMAsMFc4N0TDZGdOEDPKgDPJsDPcACxX0CxkgCxhGKAshqUgLIRQLJUALJLwJkngLd03h6YniveSZL0QMYpGcDAmH1GfSVJXsMXpNevBICz2wCz20wTFTT9BSgAMeuAs90ASrrA04TfkwGAtwoAtuLAtJQA1JdA1NgAQIDVY2AikABzBfuYUZ2AILPg44C2sgC2d+EEYRKpz0DhqYAMANkD4ZyWvoAVgLfZgLeuXR4AuIw7RUB8zEoAfScAfLTiALr9ALpcXoAAur6AurlAPpIAboC7ooC652Wq5cEAu5AA4XhmHpw4XGiAvMEAGoDjheZlAL3FAORbwOSiAL3mQL52gL4Z5odmqy8OJsfA52EAv77ARwAOp8dn7QDBY4DpmsDptoA0sYDBmuhiaIGCgMMSgFgASACtgNGAJwEgLpoBgC8BGzAEowcggCEDC6kdjoAJAM0C5IKRoABZCgiAIzw3AYBLACkfng9ogigkgNmWAN6AEQCvrkEVqTGAwCsBRbAA+4iQkMCHR072jI2PTbUNsk2RjY5NvA23TZKNiU3EDcZN5I+RTxDRTBCJkK5VBYKFhZfwQCWygU3AJBRHpu+OytgNxa61A40GMsYjsn7BVwFXQVcBV0FaAVdBVwFXQVcBV0FXAVdBVwFXUsaCNyKAK4AAQUHBwKU7oICoW1e7jAEzgPxA+YDwgCkBFDAwADABKzAAOxFLhitA1UFTDeyPkM+bj51QkRCuwTQWWQ8X+0AWBYzsACNA8xwzAGm7EZ/QisoCTAbLDs6fnLfb8H2GccsbgFw13M1HAVkBW/Jxsm9CNRO8E8FDD0FBQw9FkcClOYCoMFegpDfADgcMiA2AJQACB8AsigKAIzIEAJKeBIApY5yPZQIAKQiHb4fvj5BKSRPQrZCOz0oXyxgOywfKAnGbgMClQaCAkILXgdeCD9IIGUgQj5fPoY+dT52Ao5CM0dAX9BTVG9SDzFwWTQAbxBzJF/lOEIQQglCCkKJIAls5AcClQICoKPMODEFxhi6KSAbiyfIRrMjtCgdWCAkPlFBIitCsEJRzAbMAV/OEyQzDg0OAQQEJ36i328/Mk9AybDJsQlq3tDRApUKAkFzXf1d/j9uALYP6hCoFgCTGD8kPsFKQiobrm0+zj0KSD8kPnVCRBwMDyJRTHFgMTJa5rwXQiQ2YfI/JD7BMEJEHGINTw4TOFlIRzwJO0icMQpyPyQ+wzJCRBv6DVgnKB01NgUKj2bwYzMqCoBkznBgEF+zYDIocwRIX+NgHj4HICNfh2C4CwdwFWpTG/lgUhYGAwRfv2Ts8mAaXzVgml/XYIJfuWC4HI1gUF9pYJZgMR6ilQHMAOwLAlDRefC0in4AXAEJA6PjCwc0IamOANMMCAECRQDFNRTZBgd+CwQlRA+r6+gLBDEFBnwUBXgKATIArwAGRAAHA3cDdAN2A3kDdwN9A3oDdQN7A30DfAN4A3oDfQAYEAAlAtYASwMAUAFsAHcKAHcAmgB3AHUAdQB2AHVu8UgAygDAAHcAdQB1AHYAdQALCgB3AAsAmgB3AAsCOwB3AAtu8UgAygDAAHgKAJoAdwB3AHUAdQB2AHUAeAB1AHUAdgB1bvFIAMoAwAALCgCaAHcACwB3AAsCOwB3AAtu8UgAygDAAH4ACwGgALcBpwC6AahdAu0COwLtbvFIAMoAwAALCgCaAu0ACwLtAAsCOwLtAAtu8UgAygDAA24ACwNvAAu0VsQAAzsAABCkjUIpAAsAUIusOggWcgMeBxVsGwL67U/2HlzmWOEeOgALASvuAAseAfpKUpnpGgYJDCIZM6YyARUE9ThqAD5iXQgnAJYJPnOzw0ZAEZxEKsIAkA4DhAHnTAIDxxUDK0lxCQlPYgIvIQVYJQBVqE1GakUAKGYiDToSBA1EtAYAXQJYAIF8GgMHRyAAIAjOe9YncekRAA0KACUrjwE7Ayc6AAYWAqaiKG4McEcqANoN3+Mg9TwCBhIkuCny+JwUQ29L008JluRxu3K+oAdqiHOqFH0AG5SUIfUJ5SxCGfxdipRzqTmT4V5Zb+r1Uo4Vm+NqSSEl2mNvR2JhIa8SpYO6ntdwFXHCWTCK8f2+Hxo7uiG3drDycAuKIMP5bhi06ACnqArH1rz4Rqg//lm6SgJGEVbF9xJHISaR6HxqxSnkw6shDnelHKNEfGUXSJRJ1GcsmtJw25xrZMDK9gXSm1/YMkdX4/6NKYOdtk/NQ3/NnDASjTc3fPjIjW/5sVfVObX2oTDWkr1dF9f3kxBsD3/3aQO8hPfRz+e0uEiJqt1161griu7gz8hDDwtpy+F+BWtefnKHZPAxcZoWbnznhJpy0e842j36bcNzGnIEusgGX0a8ZxsnjcSsPDZ09yZ36fCQbriHeQ72JRMILNl6ePPf2HWoVwgWAm1fb3V2sAY0+B6rAXqSwPBgseVmoqsBTSrm91+XasMYYySI8eeRxH3ZvHkMz3BQ5aJ3iUVbYPNM3/7emRtjlsMgv/9VyTsyt/mK+8fgWeT6SoFaclXqn42dAIsvAarF5vNNWHzKSkKQ/8Hfk5ZWK7r9yliOsooyBjRhfkHP4Q2DkWXQi6FG/9r/IwbmkV5T7JSopHKn1pJwm9tb5Ot0oyN1Z2mPpKXHTxx2nlK08fKk1hEYA8WgVVWL5lgx0iTv+KdojJeU23ZDjmiubXOxVXJKKi2Wjuh2HLZOFLiSC7Tls5SMh4f+Pj6xUSrNjFqLGehRNB8lC0QSLNmkJJx/wSG3MnjE9T1CkPwJI0wH2lfzwETIiVqUxg0dfu5q39Gt+hwdcxkhhNvQ4TyrBceof3Mhs/IxFci1HmHr4FMZgXEEczPiGCx0HRwzAqDq2j9AVm1kwN0mRVLWLylgtoPNapF5cY4Y1wJh/e0BBwZj44YgZrDNqvD/9Hv7GFYdUQeDJuQ3EWI4HaKqavU1XjC/n41kT4L79kqGq0kLhdTZvgP3TA3fS0ozVz+5piZsoOtIvBUFoMKbNcmBL6YxxaUAusHB38XrS8dQMnQwJfUUkpRoGr5AUeWicvBTzyK9g77+yCkf5PAysL7r/JjcZgrbvRpMW9iyaxZvKO6ceZN2EwIxKwVFPuvFuiEPGCoagbMo+SpydLrXqBzNCDGFCrO/rkcwa2xhokQZ5CdZ0AsU3JfSqJ6n5I14YA+P/uAgfhPU84Tlw7cEFfp7AEE8ey4sP12PTt4Cods1GRgDOB5xvyiR5m+Bx8O5nBCNctU8BevfV5A08x6RHd5jcwPTMDSZJOedIZ1cGQ704lxbAzqZOP05ZxaOghzSdvFBHYqomATARyAADK4elP8Ly3IrUZKfWh23Xy20uBUmLS4Pfagu9+oyVa2iPgqRP3F2CTUsvJ7+RYnN8fFZbU/HVvxvcFFDKkiTqV5UBZ3Gz54JAKByi9hkKMZJvuGgcSYXFmw08UyoQyVdfTD1/dMkCHXcTGAKeROgArsvmRrQTLUOXioOHGK2QkjHuoYFgXciZoTJd6Fs5q1QX1G+p/e26hYsEf7QZD1nnIyl/SFkNtYYmmBhpBrxl9WbY0YpHWRuw2Ll/tj9mD8P4snVzJl4F9J+1arVeTb9E5r2ILH04qStjxQNwn3m4YNqxmaNbLAqW2TN6LidwuJRqS+NXbtqxoeDXpxeGWmxzSkWxjkyCkX4NQRme6q5SAcC+M7+9ETfA/EwrzQajKakCwYyeunP6ZFlxU2oMEn1Pz31zeStW74G406ZJFCl1wAXIoUKkWotYEpOuXB1uVNxJ63dpJEqfxBeptwIHNrPz8BllZoIcBoXwgfJ+8VAUnVPvRvexnw0Ma/WiGYuJO5y8QTvEYBigFmhUxY5RqzE8OcywN/8m4UYrlaniJO75XQ6KSo9+tWHlu+hMi0UVdiKQp7NelnoZUzNaIyBPVeOwK6GNp+FfHuPOoyhaWuNvTYFkvxscMQWDh+zeFCFkgwbXftiV23ywJ4+uwRqmg9k3KzwIQpzppt8DBBOMbrqwQM5Gb05sEwdKzMiAqOloaA/lr0KA+1pr0/+HiWoiIjHA/wir2nIuS3PeU/ji3O6ZwoxcR1SZ9FhtLC5S0FIzFhbBWcGVP/KpxOPSiUoAdWUpqKH++6Scz507iCcxYI6rdMBICPJZea7OcmeFw5mObJSiqpjg2UoWNIs+cFhyDSt6geV5qgi3FunmwwDoGSMgerFOZGX1m0dMCYo5XOruxO063dwENK9DbnVM9wYFREzh4vyU1WYYJ/LRRp6oxgjqP/X5a8/4Af6p6NWkQferzBmXme0zY/4nwMJm/wd1tIqSwGz+E3xPEAOoZlJit3XddD7/BT1pllzOx+8bmQtANQ/S6fZexc6qi3W+Q2xcmXTUhuS5mpHQRvcxZUN0S5+PL9lXWUAaRZhEH8hTdAcuNMMCuVNKTEGtSUKNi3O6KhSaTzck8csZ2vWRZ+d7mW8c4IKwXIYd25S/zIftPkwPzufjEvOHWVD1m+FjpDVUTV0DGDuHj6QnaEwLu/dEgdLQOg9E1Sro9XHJ8ykLAwtPu+pxqKDuFexqON1sKQm7rwbE1E68UCfA/erovrTCG+DBSNg0l4goDQvZN6uNlbyLpcZAwj2UclycvLpIZMgv4yRlpb3YuMftozorbcGVHt/VeDV3+Fdf1TP0iuaCsPi2G4XeGhsyF1ubVDxkoJhmniQ0/jSg/eYML9KLfnCFgISWkp91eauR3IQvED0nAPXK+6hPCYs+n3+hCZbiskmVMG2da+0EsZPonUeIY8EbfusQXjsK/eFDaosbPjEfQS0RKG7yj5GG69M7MeO1HmiUYocgygJHL6M1qzUDDwUSmr99V7Sdr2F3JjQAJY+F0yH33Iv3+C9M38eML7gTgmNu/r2bUMiPvpYbZ6v1/IaESirBHNa7mPKn4dEmYg7v/+HQgPN1G79jBQ1+soydfDC2r+h2Bl/KIc5KjMK7OH6nb1jLsNf0EHVe2KBiE51ox636uyG6Lho0t3J34L5QY/ilE3mikaF4HKXG1mG1rCevT1Vv6GavltxoQe/bMrpZvRggnBxSEPEeEzkEdOxTnPXHVjUYdw8JYvjB/o7Eegc3Ma+NUxLLnsK0kJlinPmUHzHGtrk5+CAbVzFOBqpyy3QVUnzTDfC/0XD94/okH+OB+i7g9lolhWIjSnfIb+Eq43ZXOWmwvjyV/qqD+t0e+7mTEM74qP/Ozt8nmC7mRpyu63OB4KnUzFc074SqoyPUAgM+/TJGFo6T44EHnQU4X4z6qannVqgw/U7zCpwcmXV1AubIrvOmkKHazJAR55ePjp5tLBsN8vAqs3NAHdcEHOR2xQ0lsNAFzSUuxFQCFYvXLZJdOj9p4fNq6p0HBGUik2YzaI4xySy91KzhQ0+q1hjxvImRwPRf76tChlRkhRCi74NXZ9qUNeIwP+s5p+3m5nwPdNOHgSLD79n7O9m1n1uDHiMntq4nkYwV5OZ1ENbXxFd4PgrlvavZsyUO4MqYlqqn1O8W/I1dEZq5dXhrbETLaZIbC2Kj/Aa/QM+fqUOHdf0tXAQ1huZ3cmWECWSXy/43j35+Mvq9xws7JKseriZ1pEWKc8qlzNrGPUGcVgOa9cPJYIJsGnJTAUsEcDOEVULO5x0rXBijc1lgXEzQQKhROf8zIV82w8eswc78YX11KYLWQRcgHNJElBxfXr72lS2RBSl07qTKorO2uUDZr3sFhYsvnhLZn0A94KRzJ/7DEGIAhW5ZWFpL8gEwu1aLA9MuWZzNwl8Oze9Y+bX+v9gywRVnoB5I/8kXTXU3141yRLYrIOOz6SOnyHNy4SieqzkBXharjfjqq1q6tklaEbA8Qfm2DaIPs7OTq/nvJBjKfO2H9bH2cCMh1+5gspfycu8f/cuuRmtDjyqZ7uCIMyjdV3a+p3fqmXsRx4C8lujezIFHnQiVTXLXuI1XrwN3+siYYj2HHTvESUx8DlOTXpak9qFRK+L3mgJ1WsD7F4cu1aJoFoYQnu+wGDMOjJM3kiBQWHCcvhJ/HRdxodOQp45YZaOTA22Nb4XKCVxqkbwMYFhzYQYIAnCW8FW14uf98jhUG2zrKhQQ0q0CEq0t5nXyvUyvR8DvD69LU+g3i+HFWQMQ8PqZuHD+sNKAV0+M6EJC0szq7rEr7B5bQ8BcNHzvDMc9eqB5ZCQdTf80Obn4uzjwpYU7SISdtV0QGa9D3Wrh2BDQtpBKxaNFV+/Cy2P/Sv+8s7Ud0Fd74X4+o/TNztWgETUapy+majNQ68Lq3ee0ZO48VEbTZYiH1Co4OlfWef82RWeyUXo7woM03PyapGfikTnQinoNq5z5veLpeMV3HCAMTaZmA1oGLAn7XS3XYsz+XK7VMQsc4XKrmDXOLU/pSXVNUq8dIqTba///3x6LiLS6xs1xuCAYSfcQ3+rQgmu7uvf3THKt5Ooo97TqcbRqxx7EASizaQCBQllG/rYxVapMLgtLbZS64w1MDBMXX+PQpBKNwqUKOf2DDRDUXQf9EhOS0Qj4nTmlA8dzSLz/G1d+Ud8MTy/6ghhdiLpeerGY/UlDOfiuqFsMUU5/UYlP+BAmgRLuNpvrUaLlVkrqDievNVEAwF+4CoM1MZTmjxjJMsKJq+u8Zd7tNCUFy6LiyYXRJQ4VyvEQFFaCGKsxIwQkk7EzZ6LTJq2hUuPhvAW+gQnSG6J+MszC+7QCRHcnqDdyNRJ6T9xyS87A6MDutbzKGvGktpbXqtzWtXb9HsfK2cBMomjN9a4y+TaJLnXxAeX/HWzmf4cR4vALt/P4w4qgKY04ml4ZdLOinFYS6cup3G/1ie4+t1eOnpBNlqGqs75ilzkT4+DsZQxNvaSKJ//6zIbbk/M7LOhFmRc/1R+kBtz7JFGdZm/COotIdvQoXpTqP/1uqEUmCb/QWoGLMwO5ANcHzxdY48IGP5+J+zKOTBFZ4Pid+GTM+Wq12MV/H86xEJptBa6T+p3kgpwLedManBHC2GgNrFpoN2xnrMz9WFWX/8/ygSBkavq2Uv7FdCsLEYLu9LLIvAU0bNRDtzYl+/vXmjpIvuJFYjmI0im6QEYqnIeMsNjXG4vIutIGHijeAG/9EDBozKV5cldkHbLxHh25vT+ZEzbhXlqvpzKJwcEgfNwLAKFeo0/pvEE10XDB+EXRTXtSzJozQKFFAJhMxYkVaCW+E9AL7tMeU8acxidHqzb6lX4691UsDpy/LLRmT+epgW56+5Cw8tB4kMUv6s9lh3eRKbyGs+H/4mQMaYzPTf2OOdokEn+zzgvoD3FqNKk8QqGAXVsqcGdXrT62fSPkR2vROFi68A6se86UxRUk4cajfPyCC4G5wDhD+zNq4jodQ4u4n/m37Lr36n4LIAAsVr02dFi9AiwA81MYs2rm4eDlDNmdMRvEKRHfBwW5DdMNp0jPFZMeARqF/wL4XBfd+EMLBfMzpH5GH6NaW+1vrvMdg+VxDzatk3MXgO3ro3P/DpcC6+Mo4MySJhKJhSR01SGGGp5hPWmrrUgrv3lDnP+HhcI3nt3YqBoVAVTBAQT5iuhTg8nvPtd8ZeYj6w1x6RqGUBrSku7+N1+BaasZvjTk64RoIDlL8brpEcJx3OmY7jLoZsswdtmhfC/G21llXhITOwmvRDDeTTPbyASOa16cF5/A1fZAidJpqju3wYAy9avPR1ya6eNp9K8XYrrtuxlqi+bDKwlfrYdR0RRiKRVTLOH85+ZY7XSmzRpfZBJjaTa81VDcJHpZnZnSQLASGYW9l51ZV/h7eVzTi3Hv6hUsgc/51AqJRTkpbFVLXXszoBL8nBX0u/0jBLT8nH+fJePbrwURT58OY+UieRjd1vs04w0VG5VN2U6MoGZkQzKN/ptz0Q366dxoTGmj7i1NQGHi9GgnquXFYdrCfZBmeb7s0T6yrdlZH5cZuwHFyIJ/kAtGsTg0xH5taAAq44BAk1CPk9KVVbqQzrCUiFdF/6gtlPQ8bHHc1G1W92MXGZ5HEHftyLYs8mbD/9xYRUWkHmlM0zC2ilJlnNgV4bfALpQghxOUoZL7VTqtCHIaQSXm+YUMnpkXybnV+A6xlm2CVy8fn0Xlm2XRa0+zzOa21JWWmixfiPMSCZ7qA4rS93VN3pkpF1s5TonQjisHf7iU9ZGvUPOAKZcR1pbeVf/Ul7OhepGCaId9wOtqo7pJ7yLcBZ0pFkOF28y4zEI/kcUNmutBHaQpBdNM8vjCS6HZRokkeo88TBAjGyG7SR+6vUgTcyK9Imalj0kuxz0wmK+byQU11AiJFk/ya5dNduRClcnU64yGu/ieWSeOos1t3ep+RPIWQ2pyTYVbZltTbsb7NiwSi3AV+8KLWk7LxCnfZUetEM8ThnsSoGH38/nyAwFguJp8FjvlHtcWZuU4hPva0rHfr0UhOOJ/F6vS62FW7KzkmRll2HEc7oUq4fyi5T70Vl7YVIfsPHUCdHesf9Lk7WNVWO75JDkYbMI8TOW8JKVtLY9d6UJRITO8oKo0xS+o99Yy04iniGHAaGj88kEWgwv0OrHdY/nr76DOGNS59hXCGXzTKUvDl9iKpLSWYN1lxIeyywdNpTkhay74w2jFT6NS8qkjo5CxA1yfSYwp6AJIZNKIeEK5PJAW7ORgWgwp0VgzYpqovMrWxbu+DGZ6Lhie1RAqpzm8VUzKJOH3mCzWuTOLsN3VT/dv2eeYe9UjbR8YTBsLz7q60VN1sU51k+um1f8JxD5pPhbhSC8rRaB454tmh6YUWrJI3+GWY0qeWioj/tbkYITOkJaeuGt4JrJvHA+l0Gu7kY7XOaa05alMnRWVCXqFgLIwSY4uF59Ue5SU4QKuc/HamDxbr0x6csCetXGoP7Qn1Bk/J9DsynO/UD6iZ1Hyrz+jit0hDCwi/E9OjgKTbB3ZQKQ/0ZOvevfNHG0NK4Aj3Cp7NpRk07RT1i/S0EL93Ag8GRgKI9CfpajKyK6+Jj/PI1KO5/85VAwz2AwzP8FTBb075IxCXv6T9RVvWT2tUaqxDS92zrGUbWzUYk9mSs82pECH+fkqsDt93VW++4YsR/dHCYcQSYTO/KaBMDj9LSD/J/+z20Kq8XvZUAIHtm9hRPP3ItbuAu2Hm5lkPs92pd7kCxgRs0xOVBnZ13ccdA0aunrwv9SdqElJRC3g+oCu+nXyCgmXUs9yMjTMAIHfxZV+aPKcZeUBWt057Xo85Ks1Ir5gzEHCWqZEhrLZMuF11ziGtFQUds/EESajhagzcKsxamcSZxGth4UII+adPhQkUnx2WyN+4YWR+r3f8MnkyGFuR4zjzxJS8WsQYR5PTyRaD9ixa6Mh741nBHbzfjXHskGDq179xaRNrCIB1z1xRfWfjqw2pHc1zk9xlPpL8sQWAIuETZZhbnmL54rceXVNRvUiKrrqIkeogsl0XXb17ylNb0f4GA9Wd44vffEG8FSZGHEL2fbaTGRcSiCeA8PmA/f6Hz8HCS76fXUHwgwkzSwlI71ekZ7Fapmlk/KC+Hs8hUcw3N2LN5LhkVYyizYFl/uPeVP5lsoJHhhfWvvSWruCUW1ZcJOeuTbrDgywJ/qG07gZJplnTvLcYdNaH0KMYOYMGX+rB4NGPFmQsNaIwlWrfCezxre8zXBrsMT+edVLbLqN1BqB76JH4BvZTqUIMfGwPGEn+EnmTV86fPBaYbFL3DFEhjB45CewkXEAtJxk4/Ms2pPXnaRqdky0HOYdcUcE2zcXq4vaIvW2/v0nHFJH2XXe22ueDmq/18XGtELSq85j9X8q0tcNSSKJIX8FTuJF/Pf8j5PhqG2u+osvsLxYrvvfeVJL+4tkcXcr9JV7v0ERmj/X6fM3NC4j6dS1+9Umr2oPavqiAydTZPLMNRGY23LO9zAVDly7jD+70G5TPPLdhRIl4WxcYjLnM+SNcJ26FOrkrISUtPObIz5Zb3AG612krnpy15RMW+1cQjlnWFI6538qky9axd2oJmHIHP08KyP0ubGO+TQNOYuv2uh17yCIvR8VcStw7o1g0NM60sk+8Tq7YfIBJrtp53GkvzXH7OA0p8/n/u1satf/VJhtR1l8Wa6Gmaug7haSpaCaYQax6ta0mkutlb+eAOSG1aobM81D9A4iS1RRlzBBoVX6tU1S6WE2N9ORY6DfeLRC4l9Rvr5h95XDWB2mR1d4WFudpsgVYwiTwT31ljskD8ZyDOlm5DkGh9N/UB/0AI5Xvb8ZBmai2hQ4BWMqFwYnzxwB26YHSOv9WgY3JXnvoN+2R4rqGVh/LLDMtpFP+SpMGJNWvbIl5SOodbCczW2RKleksPoUeGEzrjtKHVdtZA+kfqO+rVx/iclCqwoopepvJpSTDjT+b9GWylGRF8EDbGlw6eUzmJM95Ovoz+kwLX3c2fTjFeYEsE7vUZm3mqdGJuKh2w9/QGSaqRHs99aScGOdDqkFcACoqdbBoQqqjamhH6Q9ng39JCg3lrGJwd50Qk9ovnqBTr8MME7Ps2wiVfygUmPoUBJJfJWX5Nda0nuncbFkA=="))
}
const H5 = s6e(),
  o6e = new Set(_3(H5)),
  a6e = new Set(_3(H5)),
  c6e = e6e(H5),
  l6e = i6e(H5),
  rM = 45,
  iM = 95;

function WV(e) {
  return U5e(e)
}

function u6e(e) {
  return e.filter(t => t != 65039)
}

function qV(e) {
  for (let t of e.split(".")) {
    let n = WV(t);
    try {
      for (let r = n.lastIndexOf(iM) - 1; r >= 0; r--)
        if (n[r] !== iM) throw new Error("underscore only allowed at start");
      if (n.length >= 4 && n.every(r => r < 128) && n[2] === rM && n[3] === rM) throw new Error("invalid label extension")
    } catch (r) {
      throw new Error(`Invalid label "${t}": ${r.message}`)
    }
  }
  return e
}

function d6e(e) {
  return qV(f6e(e, u6e))
}

function f6e(e, t) {
  let n = WV(e).reverse(),
    r = [];
  for (; n.length;) {
    let i = p6e(n);
    if (i) {
      r.push(...t(i));
      continue
    }
    let s = n.pop();
    if (o6e.has(s)) {
      r.push(s);
      continue
    }
    if (a6e.has(s)) continue;
    let o = c6e[s];
    if (o) {
      r.push(...o);
      continue
    }
    throw new Error(`Disallowed codepoint: 0x${s.toString(16).toUpperCase()}`)
  }
  return qV(h6e(String.fromCodePoint(...r)))
}

function h6e(e) {
  return e.normalize("NFC")
}

function p6e(e, t) {
  var n;
  let r = l6e,
    i, s, o = [],
    a = e.length;
  for (t && (t.length = 0); a;) {
    let c = e[--a];
    if (r = (n = r.branches.find(l => l.set.has(c))) === null || n === void 0 ? void 0 : n.node, !r) break;
    if (r.save) s = c;
    else if (r.check && c === s) break;
    o.push(c), r.fe0f && (o.push(65039), a > 0 && e[a - 1] == 65039 && a--), r.valid && (i = o.slice(), r.valid == 2 && i.splice(1, 1), t && t.push(...e.slice(a).reverse()), e.length = a)
  }
  return i
}
const m6e = new Ae(jV),
  GV = new Uint8Array(32);
GV.fill(0);

function sM(e) {
  if (e.length === 0) throw new Error("invalid ENS name; empty component");
  return e
}

function KV(e) {
  const t = fl(d6e(e)),
    n = [];
  if (e.length === 0) return n;
  let r = 0;
  for (let i = 0; i < t.length; i++) t[i] === 46 && (n.push(sM(t.slice(r, i))), r = i + 1);
  if (r >= t.length) throw new Error("invalid ENS name; empty component");
  return n.push(sM(t.slice(r))), n
}

function ww(e) {
  typeof e != "string" && m6e.throwArgumentError("invalid ENS name; not a string", "name", e);
  let t = GV;
  const n = KV(e);
  for (; n.length;) t = di(Bo([t, di(n.pop())]));
  return St(t)
}

function g6e(e) {
  return St(Bo(KV(e).map(t => {
    if (t.length > 63) throw new Error("invalid DNS encoded entry; length exceeds 63 bytes");
    const n = new Uint8Array(t.length + 1);
    return n.set(t, 1), n[0] = n.length - 1, n
  }))) + "00"
}
var y6e = function (e, t, n, r) {
  function i(s) {
    return s instanceof n ? s : new n(function (o) {
      o(s)
    })
  }
  return new(n || (n = Promise))(function (s, o) {
    function a(u) {
      try {
        l(r.next(u))
      } catch (f) {
        o(f)
      }
    }

    function c(u) {
      try {
        l(r.throw(u))
      } catch (f) {
        o(f)
      }
    }

    function l(u) {
      u.done ? s(u.value) : i(u.value).then(a, c)
    }
    l((r = r.apply(e, t || [])).next())
  })
};
const Ir = new Ae(jV),
  QV = new Uint8Array(32);
QV.fill(0);
const v6e = st.from(-1),
  YV = st.from(0),
  JV = st.from(1),
  b6e = st.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");

function w6e(e) {
  const t = jt(e),
    n = t.length % 32;
  return n ? to([t, QV.slice(n)]) : St(t)
}
const x6e = zr(JV.toHexString(), 32),
  E6e = zr(YV.toHexString(), 32),
  oM = {
    name: "string",
    version: "string",
    chainId: "uint256",
    verifyingContract: "address",
    salt: "bytes32"
  },
  _S = ["name", "version", "chainId", "verifyingContract", "salt"];

function aM(e) {
  return function (t) {
    return typeof t != "string" && Ir.throwArgumentError(`invalid domain value for ${JSON.stringify(e)}`, `domain.${e}`, t), t
  }
}
const S6e = {
  name: aM("name"),
  version: aM("version"),
  chainId: function (e) {
    try {
      return st.from(e).toString()
    } catch {}
    return Ir.throwArgumentError('invalid domain value for "chainId"', "domain.chainId", e)
  },
  verifyingContract: function (e) {
    try {
      return ki(e).toLowerCase()
    } catch {}
    return Ir.throwArgumentError('invalid domain value "verifyingContract"', "domain.verifyingContract", e)
  },
  salt: function (e) {
    try {
      const t = jt(e);
      if (t.length !== 32) throw new Error("bad length");
      return St(t)
    } catch {}
    return Ir.throwArgumentError('invalid domain value "salt"', "domain.salt", e)
  }
};

function IS(e) {
  {
    const t = e.match(/^(u?)int(\d*)$/);
    if (t) {
      const n = t[1] === "",
        r = parseInt(t[2] || "256");
      (r % 8 !== 0 || r > 256 || t[2] && t[2] !== String(r)) && Ir.throwArgumentError("invalid numeric width", "type", e);
      const i = b6e.mask(n ? r - 1 : r),
        s = n ? i.add(JV).mul(v6e) : YV;
      return function (o) {
        const a = st.from(o);
        return (a.lt(s) || a.gt(i)) && Ir.throwArgumentError(`value out-of-bounds for ${e}`, "value", o), zr(a.toTwos(256).toHexString(), 32)
      }
    }
  } {
    const t = e.match(/^bytes(\d+)$/);
    if (t) {
      const n = parseInt(t[1]);
      return (n === 0 || n > 32 || t[1] !== String(n)) && Ir.throwArgumentError("invalid bytes width", "type", e),
        function (r) {
          return jt(r).length !== n && Ir.throwArgumentError(`invalid length for ${e}`, "value", r), w6e(r)
        }
    }
  }
  switch (e) {
    case "address":
      return function (t) {
        return zr(ki(t), 32)
      };
    case "bool":
      return function (t) {
        return t ? x6e : E6e
      };
    case "bytes":
      return function (t) {
        return di(t)
      };
    case "string":
      return function (t) {
        return K0(t)
      }
  }
  return null
}

function cM(e, t) {
  return `${e}(${t.map(({name:n,type:r})=>r+" "+n).join(",")})`
}
class To {
  constructor(t) {
    Ge(this, "types", Object.freeze(Aa(t))), Ge(this, "_encoderCache", {}), Ge(this, "_types", {});
    const n = {},
      r = {},
      i = {};
    Object.keys(t).forEach(a => {
      n[a] = {}, r[a] = [], i[a] = {}
    });
    for (const a in t) {
      const c = {};
      t[a].forEach(l => {
        c[l.name] && Ir.throwArgumentError(`duplicate variable name ${JSON.stringify(l.name)} in ${JSON.stringify(a)}`, "types", t), c[l.name] = !0;
        const u = l.type.match(/^([^\x5b]*)(\x5b|$)/)[1];
        u === a && Ir.throwArgumentError(`circular type reference to ${JSON.stringify(u)}`, "types", t), !IS(u) && (r[u] || Ir.throwArgumentError(`unknown type ${JSON.stringify(u)}`, "types", t), r[u].push(a), n[a][u] = !0)
      })
    }
    const s = Object.keys(r).filter(a => r[a].length === 0);
    s.length === 0 ? Ir.throwArgumentError("missing primary type", "types", t) : s.length > 1 && Ir.throwArgumentError(`ambiguous primary types or unused types: ${s.map(a=>JSON.stringify(a)).join(", ")}`, "types", t), Ge(this, "primaryType", s[0]);

    function o(a, c) {
      c[a] && Ir.throwArgumentError(`circular type reference to ${JSON.stringify(a)}`, "types", t), c[a] = !0, Object.keys(n[a]).forEach(l => {
        r[l] && (o(l, c), Object.keys(c).forEach(u => {
          i[u][l] = !0
        }))
      }), delete c[a]
    }
    o(this.primaryType, {});
    for (const a in i) {
      const c = Object.keys(i[a]);
      c.sort(), this._types[a] = cM(a, t[a]) + c.map(l => cM(l, t[l])).join("")
    }
  }
  getEncoder(t) {
    let n = this._encoderCache[t];
    return n || (n = this._encoderCache[t] = this._getEncoder(t)), n
  }
  _getEncoder(t) {
    {
      const i = IS(t);
      if (i) return i
    }
    const n = t.match(/^(.*)(\x5b(\d*)\x5d)$/);
    if (n) {
      const i = n[1],
        s = this.getEncoder(i),
        o = parseInt(n[3]);
      return a => {
        o >= 0 && a.length !== o && Ir.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", a);
        let c = a.map(s);
        return this._types[i] && (c = c.map(di)), di(to(c))
      }
    }
    const r = this.types[t];
    if (r) {
      const i = K0(this._types[t]);
      return s => {
        const o = r.map(({
          name: a,
          type: c
        }) => {
          const l = this.getEncoder(c)(s[a]);
          return this._types[c] ? di(l) : l
        });
        return o.unshift(i), to(o)
      }
    }
    return Ir.throwArgumentError(`unknown type: ${t}`, "type", t)
  }
  encodeType(t) {
    const n = this._types[t];
    return n || Ir.throwArgumentError(`unknown type: ${JSON.stringify(t)}`, "name", t), n
  }
  encodeData(t, n) {
    return this.getEncoder(t)(n)
  }
  hashStruct(t, n) {
    return di(this.encodeData(t, n))
  }
  encode(t) {
    return this.encodeData(this.primaryType, t)
  }
  hash(t) {
    return this.hashStruct(this.primaryType, t)
  }
  _visit(t, n, r) {
    if (IS(t)) return r(t, n);
    const i = t.match(/^(.*)(\x5b(\d*)\x5d)$/);
    if (i) {
      const o = i[1],
        a = parseInt(i[3]);
      return a >= 0 && n.length !== a && Ir.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", n), n.map(c => this._visit(o, c, r))
    }
    const s = this.types[t];
    return s ? s.reduce((o, {
      name: a,
      type: c
    }) => (o[a] = this._visit(c, n[a], r), o), {}) : Ir.throwArgumentError(`unknown type: ${t}`, "type", t)
  }
  visit(t, n) {
    return this._visit(this.primaryType, t, n)
  }
  static from(t) {
    return new To(t)
  }
  static getPrimaryType(t) {
    return To.from(t).primaryType
  }
  static hashStruct(t, n, r) {
    return To.from(n).hashStruct(t, r)
  }
  static hashDomain(t) {
    const n = [];
    for (const r in t) {
      const i = oM[r];
      i || Ir.throwArgumentError(`invalid typed-data domain key: ${JSON.stringify(r)}`, "domain", t), n.push({
        name: r,
        type: i
      })
    }
    return n.sort((r, i) => _S.indexOf(r.name) - _S.indexOf(i.name)), To.hashStruct("EIP712Domain", {
      EIP712Domain: n
    }, t)
  }
  static encode(t, n, r) {
    return to(["0x1901", To.hashDomain(t), To.from(n).hash(r)])
  }
  static hash(t, n, r) {
    return di(To.encode(t, n, r))
  }
  static resolveNames(t, n, r, i) {
    return y6e(this, void 0, void 0, function* () {
      t = Cr(t);
      const s = {};
      t.verifyingContract && !pn(t.verifyingContract, 20) && (s[t.verifyingContract] = "0x");
      const o = To.from(n);
      o.visit(r, (a, c) => (a === "address" && !pn(c, 20) && (s[c] = "0x"), c));
      for (const a in s) s[a] = yield i(a);
      return t.verifyingContract && s[t.verifyingContract] && (t.verifyingContract = s[t.verifyingContract]), r = o.visit(r, (a, c) => a === "address" && s[c] ? s[c] : c), {
        domain: t,
        value: r
      }
    })
  }
  static getPayload(t, n, r) {
    To.hashDomain(t);
    const i = {},
      s = [];
    _S.forEach(c => {
      const l = t[c];
      l != null && (i[c] = S6e[c](l), s.push({
        name: c,
        type: oM[c]
      }))
    });
    const o = To.from(n),
      a = Cr(n);
    return a.EIP712Domain ? Ir.throwArgumentError("types must not contain EIP712Domain type", "types.EIP712Domain", n) : a.EIP712Domain = s, o.encode(r), {
      types: a,
      domain: i,
      primaryType: o.primaryType,
      message: o.visit(r, (c, l) => {
        if (c.match(/^bytes(\d*)/)) return St(jt(l));
        if (c.match(/^u?int/)) return st.from(l).toString();
        switch (c) {
          case "address":
            return l.toLowerCase();
          case "bool":
            return !!l;
          case "string":
            return typeof l != "string" && Ir.throwArgumentError("invalid string", "value", l), l
        }
        return Ir.throwArgumentError("unsupported type", "type", c)
      })
    }
  }
}
const kr = new Ae(ny);
class C6e extends ty {}
class A6e extends ty {}
class T6e extends ty {}
class cA extends ty {
  static isIndexed(t) {
    return !!(t && t._isIndexed)
  }
}
const k6e = {
  "0x08c379a0": {
    signature: "Error(string)",
    name: "Error",
    inputs: ["string"],
    reason: !0
  },
  "0x4e487b71": {
    signature: "Panic(uint256)",
    name: "Panic",
    inputs: ["uint256"]
  }
};

function lM(e, t) {
  const n = new Error(`deferred error during ABI decoding triggered accessing ${e}`);
  return n.error = t, n
}
class lA {
  constructor(t) {
    let n = [];
    typeof t == "string" ? n = JSON.parse(t) : n = t, Ge(this, "fragments", n.map(r => tu.from(r)).filter(r => r != null)), Ge(this, "_abiCoder", Xc(new.target, "getAbiCoder")()), Ge(this, "functions", {}), Ge(this, "errors", {}), Ge(this, "events", {}), Ge(this, "structs", {}), this.fragments.forEach(r => {
      let i = null;
      switch (r.type) {
        case "constructor":
          if (this.deploy) {
            kr.warn("duplicate definition - constructor");
            return
          }
          Ge(this, "deploy", r);
          return;
        case "function":
          i = this.functions;
          break;
        case "event":
          i = this.events;
          break;
        case "error":
          i = this.errors;
          break;
        default:
          return
      }
      let s = r.format();
      if (i[s]) {
        kr.warn("duplicate definition - " + s);
        return
      }
      i[s] = r
    }), this.deploy || Ge(this, "deploy", Kc.from({
      payable: !1,
      type: "constructor"
    })), Ge(this, "_isInterface", !0)
  }
  format(t) {
    t || (t = Nn.full), t === Nn.sighash && kr.throwArgumentError("interface does not support formatting sighash", "format", t);
    const n = this.fragments.map(r => r.format(t));
    return t === Nn.json ? JSON.stringify(n.map(r => JSON.parse(r))) : n
  }
  static getAbiCoder() {
    return q5e
  }
  static getAddress(t) {
    return ki(t)
  }
  static getSighash(t) {
    return rs(K0(t.format()), 0, 4)
  }
  static getEventTopic(t) {
    return K0(t.format())
  }
  getFunction(t) {
    if (pn(t)) {
      for (const r in this.functions)
        if (t === this.getSighash(r)) return this.functions[r];
      kr.throwArgumentError("no matching function", "sighash", t)
    }
    if (t.indexOf("(") === -1) {
      const r = t.trim(),
        i = Object.keys(this.functions).filter(s => s.split("(")[0] === r);
      return i.length === 0 ? kr.throwArgumentError("no matching function", "name", r) : i.length > 1 && kr.throwArgumentError("multiple matching functions", "name", r), this.functions[i[0]]
    }
    const n = this.functions[Qc.fromString(t).format()];
    return n || kr.throwArgumentError("no matching function", "signature", t), n
  }
  getEvent(t) {
    if (pn(t)) {
      const r = t.toLowerCase();
      for (const i in this.events)
        if (r === this.getEventTopic(i)) return this.events[i];
      kr.throwArgumentError("no matching event", "topichash", r)
    }
    if (t.indexOf("(") === -1) {
      const r = t.trim(),
        i = Object.keys(this.events).filter(s => s.split("(")[0] === r);
      return i.length === 0 ? kr.throwArgumentError("no matching event", "name", r) : i.length > 1 && kr.throwArgumentError("multiple matching events", "name", r), this.events[i[0]]
    }
    const n = this.events[Xl.fromString(t).format()];
    return n || kr.throwArgumentError("no matching event", "signature", t), n
  }
  getError(t) {
    if (pn(t)) {
      const r = Xc(this.constructor, "getSighash");
      for (const i in this.errors) {
        const s = this.errors[i];
        if (t === r(s)) return this.errors[i]
      }
      kr.throwArgumentError("no matching error", "sighash", t)
    }
    if (t.indexOf("(") === -1) {
      const r = t.trim(),
        i = Object.keys(this.errors).filter(s => s.split("(")[0] === r);
      return i.length === 0 ? kr.throwArgumentError("no matching error", "name", r) : i.length > 1 && kr.throwArgumentError("multiple matching errors", "name", r), this.errors[i[0]]
    }
    const n = this.errors[Qc.fromString(t).format()];
    return n || kr.throwArgumentError("no matching error", "signature", t), n
  }
  getSighash(t) {
    if (typeof t == "string") try {
      t = this.getFunction(t)
    } catch (n) {
      try {
        t = this.getError(t)
      } catch {
        throw n
      }
    }
    return Xc(this.constructor, "getSighash")(t)
  }
  getEventTopic(t) {
    return typeof t == "string" && (t = this.getEvent(t)), Xc(this.constructor, "getEventTopic")(t)
  }
  _decodeParams(t, n) {
    return this._abiCoder.decode(t, n)
  }
  _encodeParams(t, n) {
    return this._abiCoder.encode(t, n)
  }
  encodeDeploy(t) {
    return this._encodeParams(this.deploy.inputs, t || [])
  }
  decodeErrorResult(t, n) {
    typeof t == "string" && (t = this.getError(t));
    const r = jt(n);
    return St(r.slice(0, 4)) !== this.getSighash(t) && kr.throwArgumentError(`data signature does not match error ${t.name}.`, "data", St(r)), this._decodeParams(t.inputs, r.slice(4))
  }
  encodeErrorResult(t, n) {
    return typeof t == "string" && (t = this.getError(t)), St(Bo([this.getSighash(t), this._encodeParams(t.inputs, n || [])]))
  }
  decodeFunctionData(t, n) {
    typeof t == "string" && (t = this.getFunction(t));
    const r = jt(n);
    return St(r.slice(0, 4)) !== this.getSighash(t) && kr.throwArgumentError(`data signature does not match function ${t.name}.`, "data", St(r)), this._decodeParams(t.inputs, r.slice(4))
  }
  encodeFunctionData(t, n) {
    return typeof t == "string" && (t = this.getFunction(t)), St(Bo([this.getSighash(t), this._encodeParams(t.inputs, n || [])]))
  }
  decodeFunctionResult(t, n) {
    typeof t == "string" && (t = this.getFunction(t));
    let r = jt(n),
      i = null,
      s = "",
      o = null,
      a = null,
      c = null;
    switch (r.length % this._abiCoder._getWordSize()) {
      case 0:
        try {
          return this._abiCoder.decode(t.outputs, r)
        } catch {}
        break;
      case 4: {
        const l = St(r.slice(0, 4)),
          u = k6e[l];
        if (u) o = this._abiCoder.decode(u.inputs, r.slice(4)), a = u.name, c = u.signature, u.reason && (i = o[0]), a === "Error" ? s = `; VM Exception while processing transaction: reverted with reason string ${JSON.stringify(o[0])}` : a === "Panic" && (s = `; VM Exception while processing transaction: reverted with panic code ${o[0]}`);
        else try {
          const f = this.getError(l);
          o = this._abiCoder.decode(f.inputs, r.slice(4)), a = f.name, c = f.format()
        } catch {}
        break
      }
    }
    return kr.throwError("call revert exception" + s, Ae.errors.CALL_EXCEPTION, {
      method: t.format(),
      data: St(n),
      errorArgs: o,
      errorName: a,
      errorSignature: c,
      reason: i
    })
  }
  encodeFunctionResult(t, n) {
    return typeof t == "string" && (t = this.getFunction(t)), St(this._abiCoder.encode(t.outputs, n || []))
  }
  encodeFilterTopics(t, n) {
    typeof t == "string" && (t = this.getEvent(t)), n.length > t.inputs.length && kr.throwError("too many arguments for " + t.format(), Ae.errors.UNEXPECTED_ARGUMENT, {
      argument: "values",
      value: n
    });
    let r = [];
    t.anonymous || r.push(this.getEventTopic(t));
    const i = (s, o) => s.type === "string" ? K0(o) : s.type === "bytes" ? di(St(o)) : (s.type === "bool" && typeof o == "boolean" && (o = o ? "0x01" : "0x00"), s.type.match(/^u?int/) && (o = st.from(o).toHexString()), s.type === "address" && this._abiCoder.encode(["address"], [o]), zr(St(o), 32));
    for (n.forEach((s, o) => {
        let a = t.inputs[o];
        if (!a.indexed) {
          s != null && kr.throwArgumentError("cannot filter non-indexed parameters; must be null", "contract." + a.name, s);
          return
        }
        s == null ? r.push(null) : a.baseType === "array" || a.baseType === "tuple" ? kr.throwArgumentError("filtering with tuples or arrays not supported", "contract." + a.name, s) : Array.isArray(s) ? r.push(s.map(c => i(a, c))) : r.push(i(a, s))
      }); r.length && r[r.length - 1] === null;) r.pop();
    return r
  }
  encodeEventLog(t, n) {
    typeof t == "string" && (t = this.getEvent(t));
    const r = [],
      i = [],
      s = [];
    return t.anonymous || r.push(this.getEventTopic(t)), n.length !== t.inputs.length && kr.throwArgumentError("event arguments/values mismatch", "values", n), t.inputs.forEach((o, a) => {
      const c = n[a];
      if (o.indexed)
        if (o.type === "string") r.push(K0(c));
        else if (o.type === "bytes") r.push(di(c));
      else {
        if (o.baseType === "tuple" || o.baseType === "array") throw new Error("not implemented");
        r.push(this._abiCoder.encode([o.type], [c]))
      } else i.push(o), s.push(c)
    }), {
      data: this._abiCoder.encode(i, s),
      topics: r
    }
  }
  decodeEventLog(t, n, r) {
    if (typeof t == "string" && (t = this.getEvent(t)), r != null && !t.anonymous) {
      let h = this.getEventTopic(t);
      (!pn(r[0], 32) || r[0].toLowerCase() !== h) && kr.throwError("fragment/topic mismatch", Ae.errors.INVALID_ARGUMENT, {
        argument: "topics[0]",
        expected: h,
        value: r[0]
      }), r = r.slice(1)
    }
    let i = [],
      s = [],
      o = [];
    t.inputs.forEach((h, g) => {
      h.indexed ? h.type === "string" || h.type === "bytes" || h.baseType === "tuple" || h.baseType === "array" ? (i.push(wi.fromObject({
        type: "bytes32",
        name: h.name
      })), o.push(!0)) : (i.push(h), o.push(!1)) : (s.push(h), o.push(!1))
    });
    let a = r != null ? this._abiCoder.decode(i, Bo(r)) : null,
      c = this._abiCoder.decode(s, n, !0),
      l = [],
      u = 0,
      f = 0;
    t.inputs.forEach((h, g) => {
      if (h.indexed)
        if (a == null) l[g] = new cA({
          _isIndexed: !0,
          hash: null
        });
        else if (o[g]) l[g] = new cA({
        _isIndexed: !0,
        hash: a[f++]
      });
      else try {
        l[g] = a[f++]
      } catch (y) {
        l[g] = y
      } else try {
        l[g] = c[u++]
      } catch (y) {
        l[g] = y
      }
      if (h.name && l[h.name] == null) {
        const y = l[g];
        y instanceof Error ? Object.defineProperty(l, h.name, {
          enumerable: !0,
          get: () => {
            throw lM(`property ${JSON.stringify(h.name)}`, y)
          }
        }) : l[h.name] = y
      }
    });
    for (let h = 0; h < l.length; h++) {
      const g = l[h];
      g instanceof Error && Object.defineProperty(l, h, {
        enumerable: !0,
        get: () => {
          throw lM(`index ${h}`, g)
        }
      })
    }
    return Object.freeze(l)
  }
  parseTransaction(t) {
    let n = this.getFunction(t.data.substring(0, 10).toLowerCase());
    return n ? new A6e({
      args: this._abiCoder.decode(n.inputs, "0x" + t.data.substring(10)),
      functionFragment: n,
      name: n.name,
      signature: n.format(),
      sighash: this.getSighash(n),
      value: st.from(t.value || "0")
    }) : null
  }
  parseLog(t) {
    let n = this.getEvent(t.topics[0]);
    return !n || n.anonymous ? null : new C6e({
      eventFragment: n,
      name: n.name,
      signature: n.format(),
      topic: this.getEventTopic(n),
      args: this.decodeEventLog(n, t.data, t.topics)
    })
  }
  parseError(t) {
    const n = St(t);
    let r = this.getError(n.substring(0, 10).toLowerCase());
    return r ? new T6e({
      args: this._abiCoder.decode(r.inputs, "0x" + n.substring(10)),
      errorFragment: r,
      name: r.name,
      signature: r.format(),
      sighash: this.getSighash(r)
    }) : null
  }
  static isInterface(t) {
    return !!(t && t._isInterface)
  }
}
const _6e = "abstract-provider/5.7.0";
var I6e = function (e, t, n, r) {
  function i(s) {
    return s instanceof n ? s : new n(function (o) {
      o(s)
    })
  }
  return new(n || (n = Promise))(function (s, o) {
    function a(u) {
      try {
        l(r.next(u))
      } catch (f) {
        o(f)
      }
    }

    function c(u) {
      try {
        l(r.throw(u))
      } catch (f) {
        o(f)
      }
    }

    function l(u) {
      u.done ? s(u.value) : i(u.value).then(a, c)
    }
    l((r = r.apply(e, t || [])).next())
  })
};
const P6e = new Ae(_6e);
class R6e extends ty {
  static isForkEvent(t) {
    return !!(t && t._isForkEvent)
  }
}
class iy {
  constructor() {
    P6e.checkAbstract(new.target, iy), Ge(this, "_isProvider", !0)
  }
  getFeeData() {
    return I6e(this, void 0, void 0, function* () {
      const {
        block: t,
        gasPrice: n
      } = yield ei({
        block: this.getBlock("latest"),
        gasPrice: this.getGasPrice().catch(o => null)
      });
      let r = null,
        i = null,
        s = null;
      return t && t.baseFeePerGas && (r = t.baseFeePerGas, s = st.from("1500000000"), i = t.baseFeePerGas.mul(2).add(s)), {
        lastBaseFeePerGas: r,
        maxFeePerGas: i,
        maxPriorityFeePerGas: s,
        gasPrice: n
      }
    })
  }
  addListener(t, n) {
    return this.on(t, n)
  }
  removeListener(t, n) {
    return this.off(t, n)
  }
  static isProvider(t) {
    return !!(t && t._isProvider)
  }
}
const O6e = "abstract-signer/5.7.0";
var Ya = function (e, t, n, r) {
  function i(s) {
    return s instanceof n ? s : new n(function (o) {
      o(s)
    })
  }
  return new(n || (n = Promise))(function (s, o) {
    function a(u) {
      try {
        l(r.next(u))
      } catch (f) {
        o(f)
      }
    }

    function c(u) {
      try {
        l(r.throw(u))
      } catch (f) {
        o(f)
      }
    }

    function l(u) {
      u.done ? s(u.value) : i(u.value).then(a, c)
    }
    l((r = r.apply(e, t || [])).next())
  })
};
const la = new Ae(O6e),
  D6e = ["accessList", "ccipReadEnabled", "chainId", "customData", "data", "from", "gasLimit", "gasPrice", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "to", "type", "value"],
  N6e = [Ae.errors.INSUFFICIENT_FUNDS, Ae.errors.NONCE_EXPIRED, Ae.errors.REPLACEMENT_UNDERPRICED];
class sy {
  constructor() {
    la.checkAbstract(new.target, sy), Ge(this, "_isSigner", !0)
  }
  getBalance(t) {
    return Ya(this, void 0, void 0, function* () {
      return this._checkProvider("getBalance"), yield this.provider.getBalance(this.getAddress(), t)
    })
  }
  getTransactionCount(t) {
    return Ya(this, void 0, void 0, function* () {
      return this._checkProvider("getTransactionCount"), yield this.provider.getTransactionCount(this.getAddress(), t)
    })
  }
  estimateGas(t) {
    return Ya(this, void 0, void 0, function* () {
      this._checkProvider("estimateGas");
      const n = yield ei(this.checkTransaction(t));
      return yield this.provider.estimateGas(n)
    })
  }
  call(t, n) {
    return Ya(this, void 0, void 0, function* () {
      this._checkProvider("call");
      const r = yield ei(this.checkTransaction(t));
      return yield this.provider.call(r, n)
    })
  }
  sendTransaction(t) {
    return Ya(this, void 0, void 0, function* () {
      this._checkProvider("sendTransaction");
      const n = yield this.populateTransaction(t), r = yield this.signTransaction(n);
      return yield this.provider.sendTransaction(r)
    })
  }
  getChainId() {
    return Ya(this, void 0, void 0, function* () {
      return this._checkProvider("getChainId"), (yield this.provider.getNetwork()).chainId
    })
  }
  getGasPrice() {
    return Ya(this, void 0, void 0, function* () {
      return this._checkProvider("getGasPrice"), yield this.provider.getGasPrice()
    })
  }
  getFeeData() {
    return Ya(this, void 0, void 0, function* () {
      return this._checkProvider("getFeeData"), yield this.provider.getFeeData()
    })
  }
  resolveName(t) {
    return Ya(this, void 0, void 0, function* () {
      return this._checkProvider("resolveName"), yield this.provider.resolveName(t)
    })
  }
  checkTransaction(t) {
    for (const r in t) D6e.indexOf(r) === -1 && la.throwArgumentError("invalid transaction key: " + r, "transaction", t);
    const n = Cr(t);
    return n.from == null ? n.from = this.getAddress() : n.from = Promise.all([Promise.resolve(n.from), this.getAddress()]).then(r => (r[0].toLowerCase() !== r[1].toLowerCase() && la.throwArgumentError("from address mismatch", "transaction", t), r[0])), n
  }
  populateTransaction(t) {
    return Ya(this, void 0, void 0, function* () {
      const n = yield ei(this.checkTransaction(t));
      n.to != null && (n.to = Promise.resolve(n.to).then(i => Ya(this, void 0, void 0, function* () {
        if (i == null) return null;
        const s = yield this.resolveName(i);
        return s == null && la.throwArgumentError("provided ENS name resolves to null", "tx.to", i), s
      })), n.to.catch(i => {}));
      const r = n.maxFeePerGas != null || n.maxPriorityFeePerGas != null;
      if (n.gasPrice != null && (n.type === 2 || r) ? la.throwArgumentError("eip-1559 transaction do not support gasPrice", "transaction", t) : (n.type === 0 || n.type === 1) && r && la.throwArgumentError("pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "transaction", t), (n.type === 2 || n.type == null) && n.maxFeePerGas != null && n.maxPriorityFeePerGas != null) n.type = 2;
      else if (n.type === 0 || n.type === 1) n.gasPrice == null && (n.gasPrice = this.getGasPrice());
      else {
        const i = yield this.getFeeData();
        if (n.type == null)
          if (i.maxFeePerGas != null && i.maxPriorityFeePerGas != null)
            if (n.type = 2, n.gasPrice != null) {
              const s = n.gasPrice;
              delete n.gasPrice, n.maxFeePerGas = s, n.maxPriorityFeePerGas = s
            } else n.maxFeePerGas == null && (n.maxFeePerGas = i.maxFeePerGas), n.maxPriorityFeePerGas == null && (n.maxPriorityFeePerGas = i.maxPriorityFeePerGas);
        else i.gasPrice != null ? (r && la.throwError("network does not support EIP-1559", Ae.errors.UNSUPPORTED_OPERATION, {
          operation: "populateTransaction"
        }), n.gasPrice == null && (n.gasPrice = i.gasPrice), n.type = 0) : la.throwError("failed to get consistent fee data", Ae.errors.UNSUPPORTED_OPERATION, {
          operation: "signer.getFeeData"
        });
        else n.type === 2 && (n.maxFeePerGas == null && (n.maxFeePerGas = i.maxFeePerGas), n.maxPriorityFeePerGas == null && (n.maxPriorityFeePerGas = i.maxPriorityFeePerGas))
      }
      return n.nonce == null && (n.nonce = this.getTransactionCount("pending")), n.gasLimit == null && (n.gasLimit = this.estimateGas(n).catch(i => {
        if (N6e.indexOf(i.code) >= 0) throw i;
        return la.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Ae.errors.UNPREDICTABLE_GAS_LIMIT, {
          error: i,
          tx: n
        })
      })), n.chainId == null ? n.chainId = this.getChainId() : n.chainId = Promise.all([Promise.resolve(n.chainId), this.getChainId()]).then(i => (i[1] !== 0 && i[0] !== i[1] && la.throwArgumentError("chainId address mismatch", "transaction", t), i[0])), yield ei(n)
    })
  }
  _checkProvider(t) {
    this.provider || la.throwError("missing provider", Ae.errors.UNSUPPORTED_OPERATION, {
      operation: t || "_checkProvider"
    })
  }
  static isSigner(t) {
    return !!(t && t._isSigner)
  }
}
class xk extends sy {
  constructor(t, n) {
    super(), Ge(this, "address", t), Ge(this, "provider", n || null)
  }
  getAddress() {
    return Promise.resolve(this.address)
  }
  _fail(t, n) {
    return Promise.resolve().then(() => {
      la.throwError(t, Ae.errors.UNSUPPORTED_OPERATION, {
        operation: n
      })
    })
  }
  signMessage(t) {
    return this._fail("VoidSigner cannot sign messages", "signMessage")
  }
  signTransaction(t) {
    return this._fail("VoidSigner cannot sign transactions", "signTransaction")
  }
  _signTypedData(t, n, r) {
    return this._fail("VoidSigner cannot sign typed data", "signTypedData")
  }
  connect(t) {
    return new xk(this.address, t)
  }
}
var XV = {},
  wn = {},
  oy = ZV;

function ZV(e, t) {
  if (!e) throw new Error(t || "Assertion failed")
}
ZV.equal = function (t, n, r) {
  if (t != n) throw new Error(r || "Assertion failed: " + t + " != " + n)
};
var uA = {
  exports: {}
};
typeof Object.create == "function" ? uA.exports = function (t, n) {
  n && (t.super_ = n, t.prototype = Object.create(n.prototype, {
    constructor: {
      value: t,
      enumerable: !1,
      writable: !0,
      configurable: !0
    }
  }))
} : uA.exports = function (t, n) {
  if (n) {
    t.super_ = n;
    var r = function () {};
    r.prototype = n.prototype, t.prototype = new r, t.prototype.constructor = t
  }
};
var M6e = uA.exports,
  $6e = oy,
  L6e = M6e;
wn.inherits = L6e;

function B6e(e, t) {
  return (e.charCodeAt(t) & 64512) !== 55296 || t < 0 || t + 1 >= e.length ? !1 : (e.charCodeAt(t + 1) & 64512) === 56320
}

function F6e(e, t) {
  if (Array.isArray(e)) return e.slice();
  if (!e) return [];
  var n = [];
  if (typeof e == "string")
    if (t) {
      if (t === "hex")
        for (e = e.replace(/[^a-z0-9]+/ig, ""), e.length % 2 !== 0 && (e = "0" + e), i = 0; i < e.length; i += 2) n.push(parseInt(e[i] + e[i + 1], 16))
    } else
      for (var r = 0, i = 0; i < e.length; i++) {
        var s = e.charCodeAt(i);
        s < 128 ? n[r++] = s : s < 2048 ? (n[r++] = s >> 6 | 192, n[r++] = s & 63 | 128) : B6e(e, i) ? (s = 65536 + ((s & 1023) << 10) + (e.charCodeAt(++i) & 1023), n[r++] = s >> 18 | 240, n[r++] = s >> 12 & 63 | 128, n[r++] = s >> 6 & 63 | 128, n[r++] = s & 63 | 128) : (n[r++] = s >> 12 | 224, n[r++] = s >> 6 & 63 | 128, n[r++] = s & 63 | 128)
      } else
        for (i = 0; i < e.length; i++) n[i] = e[i] | 0;
  return n
}
wn.toArray = F6e;

function j6e(e) {
  for (var t = "", n = 0; n < e.length; n++) t += tW(e[n].toString(16));
  return t
}
wn.toHex = j6e;

function eW(e) {
  var t = e >>> 24 | e >>> 8 & 65280 | e << 8 & 16711680 | (e & 255) << 24;
  return t >>> 0
}
wn.htonl = eW;

function U6e(e, t) {
  for (var n = "", r = 0; r < e.length; r++) {
    var i = e[r];
    t === "little" && (i = eW(i)), n += nW(i.toString(16))
  }
  return n
}
wn.toHex32 = U6e;

function tW(e) {
  return e.length === 1 ? "0" + e : e
}
wn.zero2 = tW;

function nW(e) {
  return e.length === 7 ? "0" + e : e.length === 6 ? "00" + e : e.length === 5 ? "000" + e : e.length === 4 ? "0000" + e : e.length === 3 ? "00000" + e : e.length === 2 ? "000000" + e : e.length === 1 ? "0000000" + e : e
}
wn.zero8 = nW;

function z6e(e, t, n, r) {
  var i = n - t;
  $6e(i % 4 === 0);
  for (var s = new Array(i / 4), o = 0, a = t; o < s.length; o++, a += 4) {
    var c;
    r === "big" ? c = e[a] << 24 | e[a + 1] << 16 | e[a + 2] << 8 | e[a + 3] : c = e[a + 3] << 24 | e[a + 2] << 16 | e[a + 1] << 8 | e[a], s[o] = c >>> 0
  }
  return s
}
wn.join32 = z6e;

function H6e(e, t) {
  for (var n = new Array(e.length * 4), r = 0, i = 0; r < e.length; r++, i += 4) {
    var s = e[r];
    t === "big" ? (n[i] = s >>> 24, n[i + 1] = s >>> 16 & 255, n[i + 2] = s >>> 8 & 255, n[i + 3] = s & 255) : (n[i + 3] = s >>> 24, n[i + 2] = s >>> 16 & 255, n[i + 1] = s >>> 8 & 255, n[i] = s & 255)
  }
  return n
}
wn.split32 = H6e;

function V6e(e, t) {
  return e >>> t | e << 32 - t
}
wn.rotr32 = V6e;

function W6e(e, t) {
  return e << t | e >>> 32 - t
}
wn.rotl32 = W6e;

function q6e(e, t) {
  return e + t >>> 0
}
wn.sum32 = q6e;

function G6e(e, t, n) {
  return e + t + n >>> 0
}
wn.sum32_3 = G6e;

function K6e(e, t, n, r) {
  return e + t + n + r >>> 0
}
wn.sum32_4 = K6e;

function Q6e(e, t, n, r, i) {
  return e + t + n + r + i >>> 0
}
wn.sum32_5 = Q6e;

function Y6e(e, t, n, r) {
  var i = e[t],
    s = e[t + 1],
    o = r + s >>> 0,
    a = (o < r ? 1 : 0) + n + i;
  e[t] = a >>> 0, e[t + 1] = o
}
wn.sum64 = Y6e;

function J6e(e, t, n, r) {
  var i = t + r >>> 0,
    s = (i < t ? 1 : 0) + e + n;
  return s >>> 0
}
wn.sum64_hi = J6e;

function X6e(e, t, n, r) {
  var i = t + r;
  return i >>> 0
}
wn.sum64_lo = X6e;

function Z6e(e, t, n, r, i, s, o, a) {
  var c = 0,
    l = t;
  l = l + r >>> 0, c += l < t ? 1 : 0, l = l + s >>> 0, c += l < s ? 1 : 0, l = l + a >>> 0, c += l < a ? 1 : 0;
  var u = e + n + i + o + c;
  return u >>> 0
}
wn.sum64_4_hi = Z6e;

function eEe(e, t, n, r, i, s, o, a) {
  var c = t + r + s + a;
  return c >>> 0
}
wn.sum64_4_lo = eEe;

function tEe(e, t, n, r, i, s, o, a, c, l) {
  var u = 0,
    f = t;
  f = f + r >>> 0, u += f < t ? 1 : 0, f = f + s >>> 0, u += f < s ? 1 : 0, f = f + a >>> 0, u += f < a ? 1 : 0, f = f + l >>> 0, u += f < l ? 1 : 0;
  var h = e + n + i + o + c + u;
  return h >>> 0
}
wn.sum64_5_hi = tEe;

function nEe(e, t, n, r, i, s, o, a, c, l) {
  var u = t + r + s + a + l;
  return u >>> 0
}
wn.sum64_5_lo = nEe;

function rEe(e, t, n) {
  var r = t << 32 - n | e >>> n;
  return r >>> 0
}
wn.rotr64_hi = rEe;

function iEe(e, t, n) {
  var r = e << 32 - n | t >>> n;
  return r >>> 0
}
wn.rotr64_lo = iEe;

function sEe(e, t, n) {
  return e >>> n
}
wn.shr64_hi = sEe;

function oEe(e, t, n) {
  var r = e << 32 - n | t >>> n;
  return r >>> 0
}
wn.shr64_lo = oEe;
var Em = {},
  uM = wn,
  aEe = oy;

function V5() {
  this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32
}
Em.BlockHash = V5;
V5.prototype.update = function (t, n) {
  if (t = uM.toArray(t, n), this.pending ? this.pending = this.pending.concat(t) : this.pending = t, this.pendingTotal += t.length, this.pending.length >= this._delta8) {
    t = this.pending;
    var r = t.length % this._delta8;
    this.pending = t.slice(t.length - r, t.length), this.pending.length === 0 && (this.pending = null), t = uM.join32(t, 0, t.length - r, this.endian);
    for (var i = 0; i < t.length; i += this._delta32) this._update(t, i, i + this._delta32)
  }
  return this
};
V5.prototype.digest = function (t) {
  return this.update(this._pad()), aEe(this.pending === null), this._digest(t)
};
V5.prototype._pad = function () {
  var t = this.pendingTotal,
    n = this._delta8,
    r = n - (t + this.padLength) % n,
    i = new Array(r + this.padLength);
  i[0] = 128;
  for (var s = 1; s < r; s++) i[s] = 0;
  if (t <<= 3, this.endian === "big") {
    for (var o = 8; o < this.padLength; o++) i[s++] = 0;
    i[s++] = 0, i[s++] = 0, i[s++] = 0, i[s++] = 0, i[s++] = t >>> 24 & 255, i[s++] = t >>> 16 & 255, i[s++] = t >>> 8 & 255, i[s++] = t & 255
  } else
    for (i[s++] = t & 255, i[s++] = t >>> 8 & 255, i[s++] = t >>> 16 & 255, i[s++] = t >>> 24 & 255, i[s++] = 0, i[s++] = 0, i[s++] = 0, i[s++] = 0, o = 8; o < this.padLength; o++) i[s++] = 0;
  return i
};
var Sm = {},
  xl = {},
  cEe = wn,
  ol = cEe.rotr32;

function lEe(e, t, n, r) {
  if (e === 0) return rW(t, n, r);
  if (e === 1 || e === 3) return sW(t, n, r);
  if (e === 2) return iW(t, n, r)
}
xl.ft_1 = lEe;

function rW(e, t, n) {
  return e & t ^ ~e & n
}
xl.ch32 = rW;

function iW(e, t, n) {
  return e & t ^ e & n ^ t & n
}
xl.maj32 = iW;

function sW(e, t, n) {
  return e ^ t ^ n
}
xl.p32 = sW;

function uEe(e) {
  return ol(e, 2) ^ ol(e, 13) ^ ol(e, 22)
}
xl.s0_256 = uEe;

function dEe(e) {
  return ol(e, 6) ^ ol(e, 11) ^ ol(e, 25)
}
xl.s1_256 = dEe;

function fEe(e) {
  return ol(e, 7) ^ ol(e, 18) ^ e >>> 3
}
xl.g0_256 = fEe;

function hEe(e) {
  return ol(e, 17) ^ ol(e, 19) ^ e >>> 10
}
xl.g1_256 = hEe;
var $p = wn,
  pEe = Em,
  mEe = xl,
  PS = $p.rotl32,
  _g = $p.sum32,
  gEe = $p.sum32_5,
  yEe = mEe.ft_1,
  oW = pEe.BlockHash,
  vEe = [1518500249, 1859775393, 2400959708, 3395469782];

function hl() {
  if (!(this instanceof hl)) return new hl;
  oW.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.W = new Array(80)
}
$p.inherits(hl, oW);
var bEe = hl;
hl.blockSize = 512;
hl.outSize = 160;
hl.hmacStrength = 80;
hl.padLength = 64;
hl.prototype._update = function (t, n) {
  for (var r = this.W, i = 0; i < 16; i++) r[i] = t[n + i];
  for (; i < r.length; i++) r[i] = PS(r[i - 3] ^ r[i - 8] ^ r[i - 14] ^ r[i - 16], 1);
  var s = this.h[0],
    o = this.h[1],
    a = this.h[2],
    c = this.h[3],
    l = this.h[4];
  for (i = 0; i < r.length; i++) {
    var u = ~~(i / 20),
      f = gEe(PS(s, 5), yEe(u, o, a, c), l, r[i], vEe[u]);
    l = c, c = a, a = PS(o, 30), o = s, s = f
  }
  this.h[0] = _g(this.h[0], s), this.h[1] = _g(this.h[1], o), this.h[2] = _g(this.h[2], a), this.h[3] = _g(this.h[3], c), this.h[4] = _g(this.h[4], l)
};
hl.prototype._digest = function (t) {
  return t === "hex" ? $p.toHex32(this.h, "big") : $p.split32(this.h, "big")
};
var Lp = wn,
  wEe = Em,
  Cm = xl,
  xEe = oy,
  Ja = Lp.sum32,
  EEe = Lp.sum32_4,
  SEe = Lp.sum32_5,
  CEe = Cm.ch32,
  AEe = Cm.maj32,
  TEe = Cm.s0_256,
  kEe = Cm.s1_256,
  _Ee = Cm.g0_256,
  IEe = Cm.g1_256,
  aW = wEe.BlockHash,
  PEe = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];

function pl() {
  if (!(this instanceof pl)) return new pl;
  aW.call(this), this.h = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225], this.k = PEe, this.W = new Array(64)
}
Lp.inherits(pl, aW);
var cW = pl;
pl.blockSize = 512;
pl.outSize = 256;
pl.hmacStrength = 192;
pl.padLength = 64;
pl.prototype._update = function (t, n) {
  for (var r = this.W, i = 0; i < 16; i++) r[i] = t[n + i];
  for (; i < r.length; i++) r[i] = EEe(IEe(r[i - 2]), r[i - 7], _Ee(r[i - 15]), r[i - 16]);
  var s = this.h[0],
    o = this.h[1],
    a = this.h[2],
    c = this.h[3],
    l = this.h[4],
    u = this.h[5],
    f = this.h[6],
    h = this.h[7];
  for (xEe(this.k.length === r.length), i = 0; i < r.length; i++) {
    var g = SEe(h, kEe(l), CEe(l, u, f), this.k[i], r[i]),
      y = Ja(TEe(s), AEe(s, o, a));
    h = f, f = u, u = l, l = Ja(c, g), c = a, a = o, o = s, s = Ja(g, y)
  }
  this.h[0] = Ja(this.h[0], s), this.h[1] = Ja(this.h[1], o), this.h[2] = Ja(this.h[2], a), this.h[3] = Ja(this.h[3], c), this.h[4] = Ja(this.h[4], l), this.h[5] = Ja(this.h[5], u), this.h[6] = Ja(this.h[6], f), this.h[7] = Ja(this.h[7], h)
};
pl.prototype._digest = function (t) {
  return t === "hex" ? Lp.toHex32(this.h, "big") : Lp.split32(this.h, "big")
};
var dA = wn,
  lW = cW;

function du() {
  if (!(this instanceof du)) return new du;
  lW.call(this), this.h = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428]
}
dA.inherits(du, lW);
var REe = du;
du.blockSize = 512;
du.outSize = 224;
du.hmacStrength = 192;
du.padLength = 64;
du.prototype._digest = function (t) {
  return t === "hex" ? dA.toHex32(this.h.slice(0, 7), "big") : dA.split32(this.h.slice(0, 7), "big")
};
var ho = wn,
  OEe = Em,
  DEe = oy,
  al = ho.rotr64_hi,
  cl = ho.rotr64_lo,
  uW = ho.shr64_hi,
  dW = ho.shr64_lo,
  Hu = ho.sum64,
  RS = ho.sum64_hi,
  OS = ho.sum64_lo,
  NEe = ho.sum64_4_hi,
  MEe = ho.sum64_4_lo,
  $Ee = ho.sum64_5_hi,
  LEe = ho.sum64_5_lo,
  fW = OEe.BlockHash,
  BEe = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];

function Sc() {
  if (!(this instanceof Sc)) return new Sc;
  fW.call(this), this.h = [1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209], this.k = BEe, this.W = new Array(160)
}
ho.inherits(Sc, fW);
var hW = Sc;
Sc.blockSize = 1024;
Sc.outSize = 512;
Sc.hmacStrength = 192;
Sc.padLength = 128;
Sc.prototype._prepareBlock = function (t, n) {
  for (var r = this.W, i = 0; i < 32; i++) r[i] = t[n + i];
  for (; i < r.length; i += 2) {
    var s = QEe(r[i - 4], r[i - 3]),
      o = YEe(r[i - 4], r[i - 3]),
      a = r[i - 14],
      c = r[i - 13],
      l = GEe(r[i - 30], r[i - 29]),
      u = KEe(r[i - 30], r[i - 29]),
      f = r[i - 32],
      h = r[i - 31];
    r[i] = NEe(s, o, a, c, l, u, f, h), r[i + 1] = MEe(s, o, a, c, l, u, f, h)
  }
};
Sc.prototype._update = function (t, n) {
  this._prepareBlock(t, n);
  var r = this.W,
    i = this.h[0],
    s = this.h[1],
    o = this.h[2],
    a = this.h[3],
    c = this.h[4],
    l = this.h[5],
    u = this.h[6],
    f = this.h[7],
    h = this.h[8],
    g = this.h[9],
    y = this.h[10],
    x = this.h[11],
    k = this.h[12],
    _ = this.h[13],
    p = this.h[14],
    v = this.h[15];
  DEe(this.k.length === r.length);
  for (var S = 0; S < r.length; S += 2) {
    var I = p,
      A = v,
      w = WEe(h, g),
      E = qEe(h, g),
      D = FEe(h, g, y, x, k),
      $ = jEe(h, g, y, x, k, _),
      V = this.k[S],
      G = this.k[S + 1],
      L = r[S],
      b = r[S + 1],
      T = $Ee(I, A, w, E, D, $, V, G, L, b),
      R = LEe(I, A, w, E, D, $, V, G, L, b);
    I = HEe(i, s), A = VEe(i, s), w = UEe(i, s, o, a, c), E = zEe(i, s, o, a, c, l);
    var N = RS(I, A, w, E),
      O = OS(I, A, w, E);
    p = k, v = _, k = y, _ = x, y = h, x = g, h = RS(u, f, T, R), g = OS(f, f, T, R), u = c, f = l, c = o, l = a, o = i, a = s, i = RS(T, R, N, O), s = OS(T, R, N, O)
  }
  Hu(this.h, 0, i, s), Hu(this.h, 2, o, a), Hu(this.h, 4, c, l), Hu(this.h, 6, u, f), Hu(this.h, 8, h, g), Hu(this.h, 10, y, x), Hu(this.h, 12, k, _), Hu(this.h, 14, p, v)
};
Sc.prototype._digest = function (t) {
  return t === "hex" ? ho.toHex32(this.h, "big") : ho.split32(this.h, "big")
};

function FEe(e, t, n, r, i) {
  var s = e & n ^ ~e & i;
  return s < 0 && (s += 4294967296), s
}

function jEe(e, t, n, r, i, s) {
  var o = t & r ^ ~t & s;
  return o < 0 && (o += 4294967296), o
}

function UEe(e, t, n, r, i) {
  var s = e & n ^ e & i ^ n & i;
  return s < 0 && (s += 4294967296), s
}

function zEe(e, t, n, r, i, s) {
  var o = t & r ^ t & s ^ r & s;
  return o < 0 && (o += 4294967296), o
}

function HEe(e, t) {
  var n = al(e, t, 28),
    r = al(t, e, 2),
    i = al(t, e, 7),
    s = n ^ r ^ i;
  return s < 0 && (s += 4294967296), s
}

function VEe(e, t) {
  var n = cl(e, t, 28),
    r = cl(t, e, 2),
    i = cl(t, e, 7),
    s = n ^ r ^ i;
  return s < 0 && (s += 4294967296), s
}

function WEe(e, t) {
  var n = al(e, t, 14),
    r = al(e, t, 18),
    i = al(t, e, 9),
    s = n ^ r ^ i;
  return s < 0 && (s += 4294967296), s
}

function qEe(e, t) {
  var n = cl(e, t, 14),
    r = cl(e, t, 18),
    i = cl(t, e, 9),
    s = n ^ r ^ i;
  return s < 0 && (s += 4294967296), s
}

function GEe(e, t) {
  var n = al(e, t, 1),
    r = al(e, t, 8),
    i = uW(e, t, 7),
    s = n ^ r ^ i;
  return s < 0 && (s += 4294967296), s
}

function KEe(e, t) {
  var n = cl(e, t, 1),
    r = cl(e, t, 8),
    i = dW(e, t, 7),
    s = n ^ r ^ i;
  return s < 0 && (s += 4294967296), s
}

function QEe(e, t) {
  var n = al(e, t, 19),
    r = al(t, e, 29),
    i = uW(e, t, 6),
    s = n ^ r ^ i;
  return s < 0 && (s += 4294967296), s
}

function YEe(e, t) {
  var n = cl(e, t, 19),
    r = cl(t, e, 29),
    i = dW(e, t, 6),
    s = n ^ r ^ i;
  return s < 0 && (s += 4294967296), s
}
var fA = wn,
  pW = hW;

function fu() {
  if (!(this instanceof fu)) return new fu;
  pW.call(this), this.h = [3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428]
}
fA.inherits(fu, pW);
var JEe = fu;
fu.blockSize = 1024;
fu.outSize = 384;
fu.hmacStrength = 192;
fu.padLength = 128;
fu.prototype._digest = function (t) {
  return t === "hex" ? fA.toHex32(this.h.slice(0, 12), "big") : fA.split32(this.h.slice(0, 12), "big")
};
Sm.sha1 = bEe;
Sm.sha224 = REe;
Sm.sha256 = cW;
Sm.sha384 = JEe;
Sm.sha512 = hW;
var mW = {},
  ch = wn,
  XEe = Em,
  yb = ch.rotl32,
  dM = ch.sum32,
  Ig = ch.sum32_3,
  fM = ch.sum32_4,
  gW = XEe.BlockHash;

function ml() {
  if (!(this instanceof ml)) return new ml;
  gW.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little"
}
ch.inherits(ml, gW);
mW.ripemd160 = ml;
ml.blockSize = 512;
ml.outSize = 160;
ml.hmacStrength = 192;
ml.padLength = 64;
ml.prototype._update = function (t, n) {
  for (var r = this.h[0], i = this.h[1], s = this.h[2], o = this.h[3], a = this.h[4], c = r, l = i, u = s, f = o, h = a, g = 0; g < 80; g++) {
    var y = dM(yb(fM(r, hM(g, i, s, o), t[t4e[g] + n], ZEe(g)), r4e[g]), a);
    r = a, a = o, o = yb(s, 10), s = i, i = y, y = dM(yb(fM(c, hM(79 - g, l, u, f), t[n4e[g] + n], e4e(g)), i4e[g]), h), c = h, h = f, f = yb(u, 10), u = l, l = y
  }
  y = Ig(this.h[1], s, f), this.h[1] = Ig(this.h[2], o, h), this.h[2] = Ig(this.h[3], a, c), this.h[3] = Ig(this.h[4], r, l), this.h[4] = Ig(this.h[0], i, u), this.h[0] = y
};
ml.prototype._digest = function (t) {
  return t === "hex" ? ch.toHex32(this.h, "little") : ch.split32(this.h, "little")
};

function hM(e, t, n, r) {
  return e <= 15 ? t ^ n ^ r : e <= 31 ? t & n | ~t & r : e <= 47 ? (t | ~n) ^ r : e <= 63 ? t & r | n & ~r : t ^ (n | ~r)
}

function ZEe(e) {
  return e <= 15 ? 0 : e <= 31 ? 1518500249 : e <= 47 ? 1859775393 : e <= 63 ? 2400959708 : 2840853838
}

function e4e(e) {
  return e <= 15 ? 1352829926 : e <= 31 ? 1548603684 : e <= 47 ? 1836072691 : e <= 63 ? 2053994217 : 0
}
var t4e = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13],
  n4e = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11],
  r4e = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6],
  i4e = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11],
  s4e = wn,
  o4e = oy;

function Bp(e, t, n) {
  if (!(this instanceof Bp)) return new Bp(e, t, n);
  this.Hash = e, this.blockSize = e.blockSize / 8, this.outSize = e.outSize / 8, this.inner = null, this.outer = null, this._init(s4e.toArray(t, n))
}
var a4e = Bp;
Bp.prototype._init = function (t) {
  t.length > this.blockSize && (t = new this.Hash().update(t).digest()), o4e(t.length <= this.blockSize);
  for (var n = t.length; n < this.blockSize; n++) t.push(0);
  for (n = 0; n < t.length; n++) t[n] ^= 54;
  for (this.inner = new this.Hash().update(t), n = 0; n < t.length; n++) t[n] ^= 106;
  this.outer = new this.Hash().update(t)
};
Bp.prototype.update = function (t, n) {
  return this.inner.update(t, n), this
};
Bp.prototype.digest = function (t) {
  return this.outer.update(this.inner.digest()), this.outer.digest(t)
};
(function (e) {
  var t = e;
  t.utils = wn, t.common = Em, t.sha = Sm, t.ripemd = mW, t.hmac = a4e, t.sha1 = t.sha.sha1, t.sha256 = t.sha.sha256, t.sha224 = t.sha.sha224, t.sha384 = t.sha.sha384, t.sha512 = t.sha.sha512, t.ripemd160 = t.ripemd.ripemd160
})(XV);
const Uc = Vo(XV);

function Am(e, t, n) {
  return n = {
    path: t,
    exports: {},
    require: function (r, i) {
      return c4e(r, i ?? n.path)
    }
  }, e(n, n.exports), n.exports
}

function c4e() {
  throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs")
}
var Ek = yW;

function yW(e, t) {
  if (!e) throw new Error(t || "Assertion failed")
}
yW.equal = function (t, n, r) {
  if (t != n) throw new Error(r || "Assertion failed: " + t + " != " + n)
};
var hc = Am(function (e, t) {
    var n = t;

    function r(o, a) {
      if (Array.isArray(o)) return o.slice();
      if (!o) return [];
      var c = [];
      if (typeof o != "string") {
        for (var l = 0; l < o.length; l++) c[l] = o[l] | 0;
        return c
      }
      if (a === "hex") {
        o = o.replace(/[^a-z0-9]+/ig, ""), o.length % 2 !== 0 && (o = "0" + o);
        for (var l = 0; l < o.length; l += 2) c.push(parseInt(o[l] + o[l + 1], 16))
      } else
        for (var l = 0; l < o.length; l++) {
          var u = o.charCodeAt(l),
            f = u >> 8,
            h = u & 255;
          f ? c.push(f, h) : c.push(h)
        }
      return c
    }
    n.toArray = r;

    function i(o) {
      return o.length === 1 ? "0" + o : o
    }
    n.zero2 = i;

    function s(o) {
      for (var a = "", c = 0; c < o.length; c++) a += i(o[c].toString(16));
      return a
    }
    n.toHex = s, n.encode = function (a, c) {
      return c === "hex" ? s(a) : a
    }
  }),
  Ko = Am(function (e, t) {
    var n = t;
    n.assert = Ek, n.toArray = hc.toArray, n.zero2 = hc.zero2, n.toHex = hc.toHex, n.encode = hc.encode;

    function r(c, l, u) {
      var f = new Array(Math.max(c.bitLength(), u) + 1);
      f.fill(0);
      for (var h = 1 << l + 1, g = c.clone(), y = 0; y < f.length; y++) {
        var x, k = g.andln(h - 1);
        g.isOdd() ? (k > (h >> 1) - 1 ? x = (h >> 1) - k : x = k, g.isubn(x)) : x = 0, f[y] = x, g.iushrn(1)
      }
      return f
    }
    n.getNAF = r;

    function i(c, l) {
      var u = [
        [],
        []
      ];
      c = c.clone(), l = l.clone();
      for (var f = 0, h = 0, g; c.cmpn(-f) > 0 || l.cmpn(-h) > 0;) {
        var y = c.andln(3) + f & 3,
          x = l.andln(3) + h & 3;
        y === 3 && (y = -1), x === 3 && (x = -1);
        var k;
        y & 1 ? (g = c.andln(7) + f & 7, (g === 3 || g === 5) && x === 2 ? k = -y : k = y) : k = 0, u[0].push(k);
        var _;
        x & 1 ? (g = l.andln(7) + h & 7, (g === 3 || g === 5) && y === 2 ? _ = -x : _ = x) : _ = 0, u[1].push(_), 2 * f === k + 1 && (f = 1 - f), 2 * h === _ + 1 && (h = 1 - h), c.iushrn(1), l.iushrn(1)
      }
      return u
    }
    n.getJSF = i;

    function s(c, l, u) {
      var f = "_" + l;
      c.prototype[l] = function () {
        return this[f] !== void 0 ? this[f] : this[f] = u.call(this)
      }
    }
    n.cachedProperty = s;

    function o(c) {
      return typeof c == "string" ? n.toArray(c, "hex") : c
    }
    n.parseBytes = o;

    function a(c) {
      return new Xt(c, "hex", "le")
    }
    n.intFromLE = a
  }),
  I3 = Ko.getNAF,
  l4e = Ko.getJSF,
  P3 = Ko.assert;

function jd(e, t) {
  this.type = e, this.p = new Xt(t.p, 16), this.red = t.prime ? Xt.red(t.prime) : Xt.mont(this.p), this.zero = new Xt(0).toRed(this.red), this.one = new Xt(1).toRed(this.red), this.two = new Xt(2).toRed(this.red), this.n = t.n && new Xt(t.n, 16), this.g = t.g && this.pointFromJSON(t.g, t.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
  var n = this.n && this.p.div(this.n);
  !n || n.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red))
}
var Ah = jd;
jd.prototype.point = function () {
  throw new Error("Not implemented")
};
jd.prototype.validate = function () {
  throw new Error("Not implemented")
};
jd.prototype._fixedNafMul = function (t, n) {
  P3(t.precomputed);
  var r = t._getDoubles(),
    i = I3(n, 1, this._bitLength),
    s = (1 << r.step + 1) - (r.step % 2 === 0 ? 2 : 1);
  s /= 3;
  var o = [],
    a, c;
  for (a = 0; a < i.length; a += r.step) {
    c = 0;
    for (var l = a + r.step - 1; l >= a; l--) c = (c << 1) + i[l];
    o.push(c)
  }
  for (var u = this.jpoint(null, null, null), f = this.jpoint(null, null, null), h = s; h > 0; h--) {
    for (a = 0; a < o.length; a++) c = o[a], c === h ? f = f.mixedAdd(r.points[a]) : c === -h && (f = f.mixedAdd(r.points[a].neg()));
    u = u.add(f)
  }
  return u.toP()
};
jd.prototype._wnafMul = function (t, n) {
  var r = 4,
    i = t._getNAFPoints(r);
  r = i.wnd;
  for (var s = i.points, o = I3(n, r, this._bitLength), a = this.jpoint(null, null, null), c = o.length - 1; c >= 0; c--) {
    for (var l = 0; c >= 0 && o[c] === 0; c--) l++;
    if (c >= 0 && l++, a = a.dblp(l), c < 0) break;
    var u = o[c];
    P3(u !== 0), t.type === "affine" ? u > 0 ? a = a.mixedAdd(s[u - 1 >> 1]) : a = a.mixedAdd(s[-u - 1 >> 1].neg()) : u > 0 ? a = a.add(s[u - 1 >> 1]) : a = a.add(s[-u - 1 >> 1].neg())
  }
  return t.type === "affine" ? a.toP() : a
};
jd.prototype._wnafMulAdd = function (t, n, r, i, s) {
  var o = this._wnafT1,
    a = this._wnafT2,
    c = this._wnafT3,
    l = 0,
    u, f, h;
  for (u = 0; u < i; u++) {
    h = n[u];
    var g = h._getNAFPoints(t);
    o[u] = g.wnd, a[u] = g.points
  }
  for (u = i - 1; u >= 1; u -= 2) {
    var y = u - 1,
      x = u;
    if (o[y] !== 1 || o[x] !== 1) {
      c[y] = I3(r[y], o[y], this._bitLength), c[x] = I3(r[x], o[x], this._bitLength), l = Math.max(c[y].length, l), l = Math.max(c[x].length, l);
      continue
    }
    var k = [n[y], null, null, n[x]];
    n[y].y.cmp(n[x].y) === 0 ? (k[1] = n[y].add(n[x]), k[2] = n[y].toJ().mixedAdd(n[x].neg())) : n[y].y.cmp(n[x].y.redNeg()) === 0 ? (k[1] = n[y].toJ().mixedAdd(n[x]), k[2] = n[y].add(n[x].neg())) : (k[1] = n[y].toJ().mixedAdd(n[x]), k[2] = n[y].toJ().mixedAdd(n[x].neg()));
    var _ = [-3, -1, -5, -7, 0, 7, 5, 1, 3],
      p = l4e(r[y], r[x]);
    for (l = Math.max(p[0].length, l), c[y] = new Array(l), c[x] = new Array(l), f = 0; f < l; f++) {
      var v = p[0][f] | 0,
        S = p[1][f] | 0;
      c[y][f] = _[(v + 1) * 3 + (S + 1)], c[x][f] = 0, a[y] = k
    }
  }
  var I = this.jpoint(null, null, null),
    A = this._wnafT4;
  for (u = l; u >= 0; u--) {
    for (var w = 0; u >= 0;) {
      var E = !0;
      for (f = 0; f < i; f++) A[f] = c[f][u] | 0, A[f] !== 0 && (E = !1);
      if (!E) break;
      w++, u--
    }
    if (u >= 0 && w++, I = I.dblp(w), u < 0) break;
    for (f = 0; f < i; f++) {
      var D = A[f];
      D !== 0 && (D > 0 ? h = a[f][D - 1 >> 1] : D < 0 && (h = a[f][-D - 1 >> 1].neg()), h.type === "affine" ? I = I.mixedAdd(h) : I = I.add(h))
    }
  }
  for (u = 0; u < i; u++) a[u] = null;
  return s ? I : I.toP()
};

function Fa(e, t) {
  this.curve = e, this.type = t, this.precomputed = null
}
jd.BasePoint = Fa;
Fa.prototype.eq = function () {
  throw new Error("Not implemented")
};
Fa.prototype.validate = function () {
  return this.curve.validate(this)
};
jd.prototype.decodePoint = function (t, n) {
  t = Ko.toArray(t, n);
  var r = this.p.byteLength();
  if ((t[0] === 4 || t[0] === 6 || t[0] === 7) && t.length - 1 === 2 * r) {
    t[0] === 6 ? P3(t[t.length - 1] % 2 === 0) : t[0] === 7 && P3(t[t.length - 1] % 2 === 1);
    var i = this.point(t.slice(1, 1 + r), t.slice(1 + r, 1 + 2 * r));
    return i
  } else if ((t[0] === 2 || t[0] === 3) && t.length - 1 === r) return this.pointFromX(t.slice(1, 1 + r), t[0] === 3);
  throw new Error("Unknown point format")
};
Fa.prototype.encodeCompressed = function (t) {
  return this.encode(t, !0)
};
Fa.prototype._encode = function (t) {
  var n = this.curve.p.byteLength(),
    r = this.getX().toArray("be", n);
  return t ? [this.getY().isEven() ? 2 : 3].concat(r) : [4].concat(r, this.getY().toArray("be", n))
};
Fa.prototype.encode = function (t, n) {
  return Ko.encode(this._encode(n), t)
};
Fa.prototype.precompute = function (t) {
  if (this.precomputed) return this;
  var n = {
    doubles: null,
    naf: null,
    beta: null
  };
  return n.naf = this._getNAFPoints(8), n.doubles = this._getDoubles(4, t), n.beta = this._getBeta(), this.precomputed = n, this
};
Fa.prototype._hasDoubles = function (t) {
  if (!this.precomputed) return !1;
  var n = this.precomputed.doubles;
  return n ? n.points.length >= Math.ceil((t.bitLength() + 1) / n.step) : !1
};
Fa.prototype._getDoubles = function (t, n) {
  if (this.precomputed && this.precomputed.doubles) return this.precomputed.doubles;
  for (var r = [this], i = this, s = 0; s < n; s += t) {
    for (var o = 0; o < t; o++) i = i.dbl();
    r.push(i)
  }
  return {
    step: t,
    points: r
  }
};
Fa.prototype._getNAFPoints = function (t) {
  if (this.precomputed && this.precomputed.naf) return this.precomputed.naf;
  for (var n = [this], r = (1 << t) - 1, i = r === 1 ? null : this.dbl(), s = 1; s < r; s++) n[s] = n[s - 1].add(i);
  return {
    wnd: t,
    points: n
  }
};
Fa.prototype._getBeta = function () {
  return null
};
Fa.prototype.dblp = function (t) {
  for (var n = this, r = 0; r < t; r++) n = n.dbl();
  return n
};
var Sk = Am(function (e) {
    typeof Object.create == "function" ? e.exports = function (n, r) {
      r && (n.super_ = r, n.prototype = Object.create(r.prototype, {
        constructor: {
          value: n,
          enumerable: !1,
          writable: !0,
          configurable: !0
        }
      }))
    } : e.exports = function (n, r) {
      if (r) {
        n.super_ = r;
        var i = function () {};
        i.prototype = r.prototype, n.prototype = new i, n.prototype.constructor = n
      }
    }
  }),
  u4e = Ko.assert;

function ja(e) {
  Ah.call(this, "short", e), this.a = new Xt(e.a, 16).toRed(this.red), this.b = new Xt(e.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(e), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4)
}
Sk(ja, Ah);
var d4e = ja;
ja.prototype._getEndomorphism = function (t) {
  if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
    var n, r;
    if (t.beta) n = new Xt(t.beta, 16).toRed(this.red);
    else {
      var i = this._getEndoRoots(this.p);
      n = i[0].cmp(i[1]) < 0 ? i[0] : i[1], n = n.toRed(this.red)
    }
    if (t.lambda) r = new Xt(t.lambda, 16);
    else {
      var s = this._getEndoRoots(this.n);
      this.g.mul(s[0]).x.cmp(this.g.x.redMul(n)) === 0 ? r = s[0] : (r = s[1], u4e(this.g.mul(r).x.cmp(this.g.x.redMul(n)) === 0))
    }
    var o;
    return t.basis ? o = t.basis.map(function (a) {
      return {
        a: new Xt(a.a, 16),
        b: new Xt(a.b, 16)
      }
    }) : o = this._getEndoBasis(r), {
      beta: n,
      lambda: r,
      basis: o
    }
  }
};
ja.prototype._getEndoRoots = function (t) {
  var n = t === this.p ? this.red : Xt.mont(t),
    r = new Xt(2).toRed(n).redInvm(),
    i = r.redNeg(),
    s = new Xt(3).toRed(n).redNeg().redSqrt().redMul(r),
    o = i.redAdd(s).fromRed(),
    a = i.redSub(s).fromRed();
  return [o, a]
};
ja.prototype._getEndoBasis = function (t) {
  for (var n = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), r = t, i = this.n.clone(), s = new Xt(1), o = new Xt(0), a = new Xt(0), c = new Xt(1), l, u, f, h, g, y, x, k = 0, _, p; r.cmpn(0) !== 0;) {
    var v = i.div(r);
    _ = i.sub(v.mul(r)), p = a.sub(v.mul(s));
    var S = c.sub(v.mul(o));
    if (!f && _.cmp(n) < 0) l = x.neg(), u = s, f = _.neg(), h = p;
    else if (f && ++k === 2) break;
    x = _, i = r, r = _, a = s, s = p, c = o, o = S
  }
  g = _.neg(), y = p;
  var I = f.sqr().add(h.sqr()),
    A = g.sqr().add(y.sqr());
  return A.cmp(I) >= 0 && (g = l, y = u), f.negative && (f = f.neg(), h = h.neg()), g.negative && (g = g.neg(), y = y.neg()), [{
    a: f,
    b: h
  }, {
    a: g,
    b: y
  }]
};
ja.prototype._endoSplit = function (t) {
  var n = this.endo.basis,
    r = n[0],
    i = n[1],
    s = i.b.mul(t).divRound(this.n),
    o = r.b.neg().mul(t).divRound(this.n),
    a = s.mul(r.a),
    c = o.mul(i.a),
    l = s.mul(r.b),
    u = o.mul(i.b),
    f = t.sub(a).sub(c),
    h = l.add(u).neg();
  return {
    k1: f,
    k2: h
  }
};
ja.prototype.pointFromX = function (t, n) {
  t = new Xt(t, 16), t.red || (t = t.toRed(this.red));
  var r = t.redSqr().redMul(t).redIAdd(t.redMul(this.a)).redIAdd(this.b),
    i = r.redSqrt();
  if (i.redSqr().redSub(r).cmp(this.zero) !== 0) throw new Error("invalid point");
  var s = i.fromRed().isOdd();
  return (n && !s || !n && s) && (i = i.redNeg()), this.point(t, i)
};
ja.prototype.validate = function (t) {
  if (t.inf) return !0;
  var n = t.x,
    r = t.y,
    i = this.a.redMul(n),
    s = n.redSqr().redMul(n).redIAdd(i).redIAdd(this.b);
  return r.redSqr().redISub(s).cmpn(0) === 0
};
ja.prototype._endoWnafMulAdd = function (t, n, r) {
  for (var i = this._endoWnafT1, s = this._endoWnafT2, o = 0; o < t.length; o++) {
    var a = this._endoSplit(n[o]),
      c = t[o],
      l = c._getBeta();
    a.k1.negative && (a.k1.ineg(), c = c.neg(!0)), a.k2.negative && (a.k2.ineg(), l = l.neg(!0)), i[o * 2] = c, i[o * 2 + 1] = l, s[o * 2] = a.k1, s[o * 2 + 1] = a.k2
  }
  for (var u = this._wnafMulAdd(1, i, s, o * 2, r), f = 0; f < o * 2; f++) i[f] = null, s[f] = null;
  return u
};

function Pi(e, t, n, r) {
  Ah.BasePoint.call(this, e, "affine"), t === null && n === null ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new Xt(t, 16), this.y = new Xt(n, 16), r && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1)
}
Sk(Pi, Ah.BasePoint);
ja.prototype.point = function (t, n, r) {
  return new Pi(this, t, n, r)
};
ja.prototype.pointFromJSON = function (t, n) {
  return Pi.fromJSON(this, t, n)
};
Pi.prototype._getBeta = function () {
  if (this.curve.endo) {
    var t = this.precomputed;
    if (t && t.beta) return t.beta;
    var n = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
    if (t) {
      var r = this.curve,
        i = function (s) {
          return r.point(s.x.redMul(r.endo.beta), s.y)
        };
      t.beta = n, n.precomputed = {
        beta: null,
        naf: t.naf && {
          wnd: t.naf.wnd,
          points: t.naf.points.map(i)
        },
        doubles: t.doubles && {
          step: t.doubles.step,
          points: t.doubles.points.map(i)
        }
      }
    }
    return n
  }
};
Pi.prototype.toJSON = function () {
  return this.precomputed ? [this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  }] : [this.x, this.y]
};
Pi.fromJSON = function (t, n, r) {
  typeof n == "string" && (n = JSON.parse(n));
  var i = t.point(n[0], n[1], r);
  if (!n[2]) return i;

  function s(a) {
    return t.point(a[0], a[1], r)
  }
  var o = n[2];
  return i.precomputed = {
    beta: null,
    doubles: o.doubles && {
      step: o.doubles.step,
      points: [i].concat(o.doubles.points.map(s))
    },
    naf: o.naf && {
      wnd: o.naf.wnd,
      points: [i].concat(o.naf.points.map(s))
    }
  }, i
};
Pi.prototype.inspect = function () {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">"
};
Pi.prototype.isInfinity = function () {
  return this.inf
};
Pi.prototype.add = function (t) {
  if (this.inf) return t;
  if (t.inf) return this;
  if (this.eq(t)) return this.dbl();
  if (this.neg().eq(t)) return this.curve.point(null, null);
  if (this.x.cmp(t.x) === 0) return this.curve.point(null, null);
  var n = this.y.redSub(t.y);
  n.cmpn(0) !== 0 && (n = n.redMul(this.x.redSub(t.x).redInvm()));
  var r = n.redSqr().redISub(this.x).redISub(t.x),
    i = n.redMul(this.x.redSub(r)).redISub(this.y);
  return this.curve.point(r, i)
};
Pi.prototype.dbl = function () {
  if (this.inf) return this;
  var t = this.y.redAdd(this.y);
  if (t.cmpn(0) === 0) return this.curve.point(null, null);
  var n = this.curve.a,
    r = this.x.redSqr(),
    i = t.redInvm(),
    s = r.redAdd(r).redIAdd(r).redIAdd(n).redMul(i),
    o = s.redSqr().redISub(this.x.redAdd(this.x)),
    a = s.redMul(this.x.redSub(o)).redISub(this.y);
  return this.curve.point(o, a)
};
Pi.prototype.getX = function () {
  return this.x.fromRed()
};
Pi.prototype.getY = function () {
  return this.y.fromRed()
};
Pi.prototype.mul = function (t) {
  return t = new Xt(t, 16), this.isInfinity() ? this : this._hasDoubles(t) ? this.curve._fixedNafMul(this, t) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [t]) : this.curve._wnafMul(this, t)
};
Pi.prototype.mulAdd = function (t, n, r) {
  var i = [this, n],
    s = [t, r];
  return this.curve.endo ? this.curve._endoWnafMulAdd(i, s) : this.curve._wnafMulAdd(1, i, s, 2)
};
Pi.prototype.jmulAdd = function (t, n, r) {
  var i = [this, n],
    s = [t, r];
  return this.curve.endo ? this.curve._endoWnafMulAdd(i, s, !0) : this.curve._wnafMulAdd(1, i, s, 2, !0)
};
Pi.prototype.eq = function (t) {
  return this === t || this.inf === t.inf && (this.inf || this.x.cmp(t.x) === 0 && this.y.cmp(t.y) === 0)
};
Pi.prototype.neg = function (t) {
  if (this.inf) return this;
  var n = this.curve.point(this.x, this.y.redNeg());
  if (t && this.precomputed) {
    var r = this.precomputed,
      i = function (s) {
        return s.neg()
      };
    n.precomputed = {
      naf: r.naf && {
        wnd: r.naf.wnd,
        points: r.naf.points.map(i)
      },
      doubles: r.doubles && {
        step: r.doubles.step,
        points: r.doubles.points.map(i)
      }
    }
  }
  return n
};
Pi.prototype.toJ = function () {
  if (this.inf) return this.curve.jpoint(null, null, null);
  var t = this.curve.jpoint(this.x, this.y, this.curve.one);
  return t
};

function Vi(e, t, n, r) {
  Ah.BasePoint.call(this, e, "jacobian"), t === null && n === null && r === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new Xt(0)) : (this.x = new Xt(t, 16), this.y = new Xt(n, 16), this.z = new Xt(r, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one
}
Sk(Vi, Ah.BasePoint);
ja.prototype.jpoint = function (t, n, r) {
  return new Vi(this, t, n, r)
};
Vi.prototype.toP = function () {
  if (this.isInfinity()) return this.curve.point(null, null);
  var t = this.z.redInvm(),
    n = t.redSqr(),
    r = this.x.redMul(n),
    i = this.y.redMul(n).redMul(t);
  return this.curve.point(r, i)
};
Vi.prototype.neg = function () {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z)
};
Vi.prototype.add = function (t) {
  if (this.isInfinity()) return t;
  if (t.isInfinity()) return this;
  var n = t.z.redSqr(),
    r = this.z.redSqr(),
    i = this.x.redMul(n),
    s = t.x.redMul(r),
    o = this.y.redMul(n.redMul(t.z)),
    a = t.y.redMul(r.redMul(this.z)),
    c = i.redSub(s),
    l = o.redSub(a);
  if (c.cmpn(0) === 0) return l.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var u = c.redSqr(),
    f = u.redMul(c),
    h = i.redMul(u),
    g = l.redSqr().redIAdd(f).redISub(h).redISub(h),
    y = l.redMul(h.redISub(g)).redISub(o.redMul(f)),
    x = this.z.redMul(t.z).redMul(c);
  return this.curve.jpoint(g, y, x)
};
Vi.prototype.mixedAdd = function (t) {
  if (this.isInfinity()) return t.toJ();
  if (t.isInfinity()) return this;
  var n = this.z.redSqr(),
    r = this.x,
    i = t.x.redMul(n),
    s = this.y,
    o = t.y.redMul(n).redMul(this.z),
    a = r.redSub(i),
    c = s.redSub(o);
  if (a.cmpn(0) === 0) return c.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var l = a.redSqr(),
    u = l.redMul(a),
    f = r.redMul(l),
    h = c.redSqr().redIAdd(u).redISub(f).redISub(f),
    g = c.redMul(f.redISub(h)).redISub(s.redMul(u)),
    y = this.z.redMul(a);
  return this.curve.jpoint(h, g, y)
};
Vi.prototype.dblp = function (t) {
  if (t === 0) return this;
  if (this.isInfinity()) return this;
  if (!t) return this.dbl();
  var n;
  if (this.curve.zeroA || this.curve.threeA) {
    var r = this;
    for (n = 0; n < t; n++) r = r.dbl();
    return r
  }
  var i = this.curve.a,
    s = this.curve.tinv,
    o = this.x,
    a = this.y,
    c = this.z,
    l = c.redSqr().redSqr(),
    u = a.redAdd(a);
  for (n = 0; n < t; n++) {
    var f = o.redSqr(),
      h = u.redSqr(),
      g = h.redSqr(),
      y = f.redAdd(f).redIAdd(f).redIAdd(i.redMul(l)),
      x = o.redMul(h),
      k = y.redSqr().redISub(x.redAdd(x)),
      _ = x.redISub(k),
      p = y.redMul(_);
    p = p.redIAdd(p).redISub(g);
    var v = u.redMul(c);
    n + 1 < t && (l = l.redMul(g)), o = k, c = v, u = p
  }
  return this.curve.jpoint(o, u.redMul(s), c)
};
Vi.prototype.dbl = function () {
  return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl()
};
Vi.prototype._zeroDbl = function () {
  var t, n, r;
  if (this.zOne) {
    var i = this.x.redSqr(),
      s = this.y.redSqr(),
      o = s.redSqr(),
      a = this.x.redAdd(s).redSqr().redISub(i).redISub(o);
    a = a.redIAdd(a);
    var c = i.redAdd(i).redIAdd(i),
      l = c.redSqr().redISub(a).redISub(a),
      u = o.redIAdd(o);
    u = u.redIAdd(u), u = u.redIAdd(u), t = l, n = c.redMul(a.redISub(l)).redISub(u), r = this.y.redAdd(this.y)
  } else {
    var f = this.x.redSqr(),
      h = this.y.redSqr(),
      g = h.redSqr(),
      y = this.x.redAdd(h).redSqr().redISub(f).redISub(g);
    y = y.redIAdd(y);
    var x = f.redAdd(f).redIAdd(f),
      k = x.redSqr(),
      _ = g.redIAdd(g);
    _ = _.redIAdd(_), _ = _.redIAdd(_), t = k.redISub(y).redISub(y), n = x.redMul(y.redISub(t)).redISub(_), r = this.y.redMul(this.z), r = r.redIAdd(r)
  }
  return this.curve.jpoint(t, n, r)
};
Vi.prototype._threeDbl = function () {
  var t, n, r;
  if (this.zOne) {
    var i = this.x.redSqr(),
      s = this.y.redSqr(),
      o = s.redSqr(),
      a = this.x.redAdd(s).redSqr().redISub(i).redISub(o);
    a = a.redIAdd(a);
    var c = i.redAdd(i).redIAdd(i).redIAdd(this.curve.a),
      l = c.redSqr().redISub(a).redISub(a);
    t = l;
    var u = o.redIAdd(o);
    u = u.redIAdd(u), u = u.redIAdd(u), n = c.redMul(a.redISub(l)).redISub(u), r = this.y.redAdd(this.y)
  } else {
    var f = this.z.redSqr(),
      h = this.y.redSqr(),
      g = this.x.redMul(h),
      y = this.x.redSub(f).redMul(this.x.redAdd(f));
    y = y.redAdd(y).redIAdd(y);
    var x = g.redIAdd(g);
    x = x.redIAdd(x);
    var k = x.redAdd(x);
    t = y.redSqr().redISub(k), r = this.y.redAdd(this.z).redSqr().redISub(h).redISub(f);
    var _ = h.redSqr();
    _ = _.redIAdd(_), _ = _.redIAdd(_), _ = _.redIAdd(_), n = y.redMul(x.redISub(t)).redISub(_)
  }
  return this.curve.jpoint(t, n, r)
};
Vi.prototype._dbl = function () {
  var t = this.curve.a,
    n = this.x,
    r = this.y,
    i = this.z,
    s = i.redSqr().redSqr(),
    o = n.redSqr(),
    a = r.redSqr(),
    c = o.redAdd(o).redIAdd(o).redIAdd(t.redMul(s)),
    l = n.redAdd(n);
  l = l.redIAdd(l);
  var u = l.redMul(a),
    f = c.redSqr().redISub(u.redAdd(u)),
    h = u.redISub(f),
    g = a.redSqr();
  g = g.redIAdd(g), g = g.redIAdd(g), g = g.redIAdd(g);
  var y = c.redMul(h).redISub(g),
    x = r.redAdd(r).redMul(i);
  return this.curve.jpoint(f, y, x)
};
Vi.prototype.trpl = function () {
  if (!this.curve.zeroA) return this.dbl().add(this);
  var t = this.x.redSqr(),
    n = this.y.redSqr(),
    r = this.z.redSqr(),
    i = n.redSqr(),
    s = t.redAdd(t).redIAdd(t),
    o = s.redSqr(),
    a = this.x.redAdd(n).redSqr().redISub(t).redISub(i);
  a = a.redIAdd(a), a = a.redAdd(a).redIAdd(a), a = a.redISub(o);
  var c = a.redSqr(),
    l = i.redIAdd(i);
  l = l.redIAdd(l), l = l.redIAdd(l), l = l.redIAdd(l);
  var u = s.redIAdd(a).redSqr().redISub(o).redISub(c).redISub(l),
    f = n.redMul(u);
  f = f.redIAdd(f), f = f.redIAdd(f);
  var h = this.x.redMul(c).redISub(f);
  h = h.redIAdd(h), h = h.redIAdd(h);
  var g = this.y.redMul(u.redMul(l.redISub(u)).redISub(a.redMul(c)));
  g = g.redIAdd(g), g = g.redIAdd(g), g = g.redIAdd(g);
  var y = this.z.redAdd(a).redSqr().redISub(r).redISub(c);
  return this.curve.jpoint(h, g, y)
};
Vi.prototype.mul = function (t, n) {
  return t = new Xt(t, n), this.curve._wnafMul(this, t)
};
Vi.prototype.eq = function (t) {
  if (t.type === "affine") return this.eq(t.toJ());
  if (this === t) return !0;
  var n = this.z.redSqr(),
    r = t.z.redSqr();
  if (this.x.redMul(r).redISub(t.x.redMul(n)).cmpn(0) !== 0) return !1;
  var i = n.redMul(this.z),
    s = r.redMul(t.z);
  return this.y.redMul(s).redISub(t.y.redMul(i)).cmpn(0) === 0
};
Vi.prototype.eqXToP = function (t) {
  var n = this.z.redSqr(),
    r = t.toRed(this.curve.red).redMul(n);
  if (this.x.cmp(r) === 0) return !0;
  for (var i = t.clone(), s = this.curve.redN.redMul(n);;) {
    if (i.iadd(this.curve.n), i.cmp(this.curve.p) >= 0) return !1;
    if (r.redIAdd(s), this.x.cmp(r) === 0) return !0
  }
};
Vi.prototype.inspect = function () {
  return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">"
};
Vi.prototype.isInfinity = function () {
  return this.z.cmpn(0) === 0
};
var xw = Am(function (e, t) {
    var n = t;
    n.base = Ah, n.short = d4e, n.mont = null, n.edwards = null
  }),
  Ew = Am(function (e, t) {
    var n = t,
      r = Ko.assert;

    function i(a) {
      a.type === "short" ? this.curve = new xw.short(a) : a.type === "edwards" ? this.curve = new xw.edwards(a) : this.curve = new xw.mont(a), this.g = this.curve.g, this.n = this.curve.n, this.hash = a.hash, r(this.g.validate(), "Invalid curve"), r(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O")
    }
    n.PresetCurve = i;

    function s(a, c) {
      Object.defineProperty(n, a, {
        configurable: !0,
        enumerable: !0,
        get: function () {
          var l = new i(c);
          return Object.defineProperty(n, a, {
            configurable: !0,
            enumerable: !0,
            value: l
          }), l
        }
      })
    }
    s("p192", {
      type: "short",
      prime: "p192",
      p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
      b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
      n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
      hash: Uc.sha256,
      gRed: !1,
      g: ["188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012", "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"]
    }), s("p224", {
      type: "short",
      prime: "p224",
      p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
      b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
      n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
      hash: Uc.sha256,
      gRed: !1,
      g: ["b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21", "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"]
    }), s("p256", {
      type: "short",
      prime: null,
      p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
      a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
      b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
      n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
      hash: Uc.sha256,
      gRed: !1,
      g: ["6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296", "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"]
    }), s("p384", {
      type: "short",
      prime: null,
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
      a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
      b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
      n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
      hash: Uc.sha384,
      gRed: !1,
      g: ["aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7", "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"]
    }), s("p521", {
      type: "short",
      prime: null,
      p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
      a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
      b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
      n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
      hash: Uc.sha512,
      gRed: !1,
      g: ["000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66", "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"]
    }), s("curve25519", {
      type: "mont",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "76d06",
      b: "1",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: Uc.sha256,
      gRed: !1,
      g: ["9"]
    }), s("ed25519", {
      type: "edwards",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "-1",
      c: "1",
      d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: Uc.sha256,
      gRed: !1,
      g: ["216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a", "6666666666666666666666666666666666666666666666666666666666666658"]
    });
    var o;
    try {
      o = null.crash()
    } catch {
      o = void 0
    }
    s("secp256k1", {
      type: "short",
      prime: "k256",
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
      a: "0",
      b: "7",
      n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
      h: "1",
      hash: Uc.sha256,
      beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
      lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
      basis: [{
        a: "3086d221a7d46bcde86c90e49284eb15",
        b: "-e4437ed6010e88286f547fa90abfe4c3"
      }, {
        a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
        b: "3086d221a7d46bcde86c90e49284eb15"
      }],
      gRed: !1,
      g: ["79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798", "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8", o]
    })
  });

function Sd(e) {
  if (!(this instanceof Sd)) return new Sd(e);
  this.hash = e.hash, this.predResist = !!e.predResist, this.outLen = this.hash.outSize, this.minEntropy = e.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
  var t = hc.toArray(e.entropy, e.entropyEnc || "hex"),
    n = hc.toArray(e.nonce, e.nonceEnc || "hex"),
    r = hc.toArray(e.pers, e.persEnc || "hex");
  Ek(t.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._init(t, n, r)
}
var vW = Sd;
Sd.prototype._init = function (t, n, r) {
  var i = t.concat(n).concat(r);
  this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
  for (var s = 0; s < this.V.length; s++) this.K[s] = 0, this.V[s] = 1;
  this._update(i), this._reseed = 1, this.reseedInterval = 281474976710656
};
Sd.prototype._hmac = function () {
  return new Uc.hmac(this.hash, this.K)
};
Sd.prototype._update = function (t) {
  var n = this._hmac().update(this.V).update([0]);
  t && (n = n.update(t)), this.K = n.digest(), this.V = this._hmac().update(this.V).digest(), t && (this.K = this._hmac().update(this.V).update([1]).update(t).digest(), this.V = this._hmac().update(this.V).digest())
};
Sd.prototype.reseed = function (t, n, r, i) {
  typeof n != "string" && (i = r, r = n, n = null), t = hc.toArray(t, n), r = hc.toArray(r, i), Ek(t.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._update(t.concat(r || [])), this._reseed = 1
};
Sd.prototype.generate = function (t, n, r, i) {
  if (this._reseed > this.reseedInterval) throw new Error("Reseed is required");
  typeof n != "string" && (i = r, r = n, n = null), r && (r = hc.toArray(r, i || "hex"), this._update(r));
  for (var s = []; s.length < t;) this.V = this._hmac().update(this.V).digest(), s = s.concat(this.V);
  var o = s.slice(0, t);
  return this._update(r), this._reseed++, hc.encode(o, n)
};
var hA = Ko.assert;

function cs(e, t) {
  this.ec = e, this.priv = null, this.pub = null, t.priv && this._importPrivate(t.priv, t.privEnc), t.pub && this._importPublic(t.pub, t.pubEnc)
}
var Ck = cs;
cs.fromPublic = function (t, n, r) {
  return n instanceof cs ? n : new cs(t, {
    pub: n,
    pubEnc: r
  })
};
cs.fromPrivate = function (t, n, r) {
  return n instanceof cs ? n : new cs(t, {
    priv: n,
    privEnc: r
  })
};
cs.prototype.validate = function () {
  var t = this.getPublic();
  return t.isInfinity() ? {
    result: !1,
    reason: "Invalid public key"
  } : t.validate() ? t.mul(this.ec.curve.n).isInfinity() ? {
    result: !0,
    reason: null
  } : {
    result: !1,
    reason: "Public key * N != O"
  } : {
    result: !1,
    reason: "Public key is not a point"
  }
};
cs.prototype.getPublic = function (t, n) {
  return typeof t == "string" && (n = t, t = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), n ? this.pub.encode(n, t) : this.pub
};
cs.prototype.getPrivate = function (t) {
  return t === "hex" ? this.priv.toString(16, 2) : this.priv
};
cs.prototype._importPrivate = function (t, n) {
  this.priv = new Xt(t, n || 16), this.priv = this.priv.umod(this.ec.curve.n)
};
cs.prototype._importPublic = function (t, n) {
  if (t.x || t.y) {
    this.ec.curve.type === "mont" ? hA(t.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && hA(t.x && t.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(t.x, t.y);
    return
  }
  this.pub = this.ec.curve.decodePoint(t, n)
};
cs.prototype.derive = function (t) {
  return t.validate() || hA(t.validate(), "public point not validated"), t.mul(this.priv).getX()
};
cs.prototype.sign = function (t, n, r) {
  return this.ec.sign(t, this, n, r)
};
cs.prototype.verify = function (t, n) {
  return this.ec.verify(t, n, this)
};
cs.prototype.inspect = function () {
  return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >"
};
var f4e = Ko.assert;

function W5(e, t) {
  if (e instanceof W5) return e;
  this._importDER(e, t) || (f4e(e.r && e.s, "Signature without r or s"), this.r = new Xt(e.r, 16), this.s = new Xt(e.s, 16), e.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = e.recoveryParam)
}
var q5 = W5;

function h4e() {
  this.place = 0
}

function DS(e, t) {
  var n = e[t.place++];
  if (!(n & 128)) return n;
  var r = n & 15;
  if (r === 0 || r > 4) return !1;
  for (var i = 0, s = 0, o = t.place; s < r; s++, o++) i <<= 8, i |= e[o], i >>>= 0;
  return i <= 127 ? !1 : (t.place = o, i)
}

function pM(e) {
  for (var t = 0, n = e.length - 1; !e[t] && !(e[t + 1] & 128) && t < n;) t++;
  return t === 0 ? e : e.slice(t)
}
W5.prototype._importDER = function (t, n) {
  t = Ko.toArray(t, n);
  var r = new h4e;
  if (t[r.place++] !== 48) return !1;
  var i = DS(t, r);
  if (i === !1 || i + r.place !== t.length || t[r.place++] !== 2) return !1;
  var s = DS(t, r);
  if (s === !1) return !1;
  var o = t.slice(r.place, s + r.place);
  if (r.place += s, t[r.place++] !== 2) return !1;
  var a = DS(t, r);
  if (a === !1 || t.length !== a + r.place) return !1;
  var c = t.slice(r.place, a + r.place);
  if (o[0] === 0)
    if (o[1] & 128) o = o.slice(1);
    else return !1;
  if (c[0] === 0)
    if (c[1] & 128) c = c.slice(1);
    else return !1;
  return this.r = new Xt(o), this.s = new Xt(c), this.recoveryParam = null, !0
};

function NS(e, t) {
  if (t < 128) {
    e.push(t);
    return
  }
  var n = 1 + (Math.log(t) / Math.LN2 >>> 3);
  for (e.push(n | 128); --n;) e.push(t >>> (n << 3) & 255);
  e.push(t)
}
W5.prototype.toDER = function (t) {
  var n = this.r.toArray(),
    r = this.s.toArray();
  for (n[0] & 128 && (n = [0].concat(n)), r[0] & 128 && (r = [0].concat(r)), n = pM(n), r = pM(r); !r[0] && !(r[1] & 128);) r = r.slice(1);
  var i = [2];
  NS(i, n.length), i = i.concat(n), i.push(2), NS(i, r.length);
  var s = i.concat(r),
    o = [48];
  return NS(o, s.length), o = o.concat(s), Ko.encode(o, t)
};
var p4e = function () {
    throw new Error("unsupported")
  },
  bW = Ko.assert;

function Oa(e) {
  if (!(this instanceof Oa)) return new Oa(e);
  typeof e == "string" && (bW(Object.prototype.hasOwnProperty.call(Ew, e), "Unknown curve " + e), e = Ew[e]), e instanceof Ew.PresetCurve && (e = {
    curve: e
  }), this.curve = e.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = e.curve.g, this.g.precompute(e.curve.n.bitLength() + 1), this.hash = e.hash || e.curve.hash
}
var m4e = Oa;
Oa.prototype.keyPair = function (t) {
  return new Ck(this, t)
};
Oa.prototype.keyFromPrivate = function (t, n) {
  return Ck.fromPrivate(this, t, n)
};
Oa.prototype.keyFromPublic = function (t, n) {
  return Ck.fromPublic(this, t, n)
};
Oa.prototype.genKeyPair = function (t) {
  t || (t = {});
  for (var n = new vW({
      hash: this.hash,
      pers: t.pers,
      persEnc: t.persEnc || "utf8",
      entropy: t.entropy || p4e(this.hash.hmacStrength),
      entropyEnc: t.entropy && t.entropyEnc || "utf8",
      nonce: this.n.toArray()
    }), r = this.n.byteLength(), i = this.n.sub(new Xt(2));;) {
    var s = new Xt(n.generate(r));
    if (!(s.cmp(i) > 0)) return s.iaddn(1), this.keyFromPrivate(s)
  }
};
Oa.prototype._truncateToN = function (t, n) {
  var r = t.byteLength() * 8 - this.n.bitLength();
  return r > 0 && (t = t.ushrn(r)), !n && t.cmp(this.n) >= 0 ? t.sub(this.n) : t
};
Oa.prototype.sign = function (t, n, r, i) {
  typeof r == "object" && (i = r, r = null), i || (i = {}), n = this.keyFromPrivate(n, r), t = this._truncateToN(new Xt(t, 16));
  for (var s = this.n.byteLength(), o = n.getPrivate().toArray("be", s), a = t.toArray("be", s), c = new vW({
      hash: this.hash,
      entropy: o,
      nonce: a,
      pers: i.pers,
      persEnc: i.persEnc || "utf8"
    }), l = this.n.sub(new Xt(1)), u = 0;; u++) {
    var f = i.k ? i.k(u) : new Xt(c.generate(this.n.byteLength()));
    if (f = this._truncateToN(f, !0), !(f.cmpn(1) <= 0 || f.cmp(l) >= 0)) {
      var h = this.g.mul(f);
      if (!h.isInfinity()) {
        var g = h.getX(),
          y = g.umod(this.n);
        if (y.cmpn(0) !== 0) {
          var x = f.invm(this.n).mul(y.mul(n.getPrivate()).iadd(t));
          if (x = x.umod(this.n), x.cmpn(0) !== 0) {
            var k = (h.getY().isOdd() ? 1 : 0) | (g.cmp(y) !== 0 ? 2 : 0);
            return i.canonical && x.cmp(this.nh) > 0 && (x = this.n.sub(x), k ^= 1), new q5({
              r: y,
              s: x,
              recoveryParam: k
            })
          }
        }
      }
    }
  }
};
Oa.prototype.verify = function (t, n, r, i) {
  t = this._truncateToN(new Xt(t, 16)), r = this.keyFromPublic(r, i), n = new q5(n, "hex");
  var s = n.r,
    o = n.s;
  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0 || o.cmpn(1) < 0 || o.cmp(this.n) >= 0) return !1;
  var a = o.invm(this.n),
    c = a.mul(t).umod(this.n),
    l = a.mul(s).umod(this.n),
    u;
  return this.curve._maxwellTrick ? (u = this.g.jmulAdd(c, r.getPublic(), l), u.isInfinity() ? !1 : u.eqXToP(s)) : (u = this.g.mulAdd(c, r.getPublic(), l), u.isInfinity() ? !1 : u.getX().umod(this.n).cmp(s) === 0)
};
Oa.prototype.recoverPubKey = function (e, t, n, r) {
  bW((3 & n) === n, "The recovery param is more than two bits"), t = new q5(t, r);
  var i = this.n,
    s = new Xt(e),
    o = t.r,
    a = t.s,
    c = n & 1,
    l = n >> 1;
  if (o.cmp(this.curve.p.umod(this.curve.n)) >= 0 && l) throw new Error("Unable to find sencond key candinate");
  l ? o = this.curve.pointFromX(o.add(this.curve.n), c) : o = this.curve.pointFromX(o, c);
  var u = t.r.invm(i),
    f = i.sub(s).mul(u).umod(i),
    h = a.mul(u).umod(i);
  return this.g.mulAdd(f, o, h)
};
Oa.prototype.getKeyRecoveryParam = function (e, t, n, r) {
  if (t = new q5(t, r), t.recoveryParam !== null) return t.recoveryParam;
  for (var i = 0; i < 4; i++) {
    var s;
    try {
      s = this.recoverPubKey(e, t, i)
    } catch {
      continue
    }
    if (s.eq(n)) return i
  }
  throw new Error("Unable to find valid recovery factor")
};
var g4e = Am(function (e, t) {
    var n = t;
    n.version = "6.5.4", n.utils = Ko, n.rand = function () {
      throw new Error("unsupported")
    }, n.curve = xw, n.curves = Ew, n.ec = m4e, n.eddsa = null
  }),
  y4e = g4e.ec;
const v4e = "signing-key/5.7.0",
  pA = new Ae(v4e);
let MS = null;

function qc() {
  return MS || (MS = new y4e("secp256k1")), MS
}
class b4e {
  constructor(t) {
    Ge(this, "curve", "secp256k1"), Ge(this, "privateKey", St(t)), oh(this.privateKey) !== 32 && pA.throwArgumentError("invalid private key", "privateKey", "[[ REDACTED ]]");
    const n = qc().keyFromPrivate(jt(this.privateKey));
    Ge(this, "publicKey", "0x" + n.getPublic(!1, "hex")), Ge(this, "compressedPublicKey", "0x" + n.getPublic(!0, "hex")), Ge(this, "_isSigningKey", !0)
  }
  _addPoint(t) {
    const n = qc().keyFromPublic(jt(this.publicKey)),
      r = qc().keyFromPublic(jt(t));
    return "0x" + n.pub.add(r.pub).encodeCompressed("hex")
  }
  signDigest(t) {
    const n = qc().keyFromPrivate(jt(this.privateKey)),
      r = jt(t);
    r.length !== 32 && pA.throwArgumentError("bad digest length", "digest", t);
    const i = n.sign(r, {
      canonical: !0
    });
    return U5({
      recoveryParam: i.recoveryParam,
      r: zr("0x" + i.r.toString(16), 32),
      s: zr("0x" + i.s.toString(16), 32)
    })
  }
  computeSharedSecret(t) {
    const n = qc().keyFromPrivate(jt(this.privateKey)),
      r = qc().keyFromPublic(jt(wW(t)));
    return zr("0x" + n.derive(r.getPublic()).toString(16), 32)
  }
  static isSigningKey(t) {
    return !!(t && t._isSigningKey)
  }
}

function w4e(e, t) {
  const n = U5(t),
    r = {
      r: jt(n.r),
      s: jt(n.s)
    };
  return "0x" + qc().recoverPubKey(jt(e), r, n.recoveryParam).encode("hex", !1)
}

function wW(e, t) {
  const n = jt(e);
  if (n.length === 32) {
    const r = new b4e(n);
    return t ? "0x" + qc().keyFromPrivate(n).getPublic(!0, "hex") : r.publicKey
  } else {
    if (n.length === 33) return t ? St(n) : "0x" + qc().keyFromPublic(n).getPublic(!1, "hex");
    if (n.length === 65) return t ? "0x" + qc().keyFromPublic(n).getPublic(!0, "hex") : St(n)
  }
  return pA.throwArgumentError("invalid public or private key", "key", "[REDACTED]")
}
const x4e = "transactions/5.7.0",
  bu = new Ae(x4e);
var mM;
(function (e) {
  e[e.legacy = 0] = "legacy", e[e.eip2930 = 1] = "eip2930", e[e.eip1559 = 2] = "eip1559"
})(mM || (mM = {}));

function Ak(e) {
  return e === "0x" ? null : ki(e)
}

function ss(e) {
  return e === "0x" ? $V : st.from(e)
}

function E4e(e) {
  const t = wW(e);
  return ki(rs(di(rs(t, 1)), 12))
}

function xW(e, t) {
  return E4e(w4e(jt(e), t))
}

function Oo(e, t) {
  const n = Mp(st.from(e).toHexString());
  return n.length > 32 && bu.throwArgumentError("invalid length for " + t, "transaction:" + t, e), n
}

function $S(e, t) {
  return {
    address: ki(e),
    storageKeys: (t || []).map((n, r) => (oh(n) !== 32 && bu.throwArgumentError("invalid access list storageKey", `accessList[${e}:${r}]`, n), n.toLowerCase()))
  }
}

function Tm(e) {
  if (Array.isArray(e)) return e.map((n, r) => Array.isArray(n) ? (n.length > 2 && bu.throwArgumentError("access list expected to be [ address, storageKeys[] ]", `value[${r}]`, n), $S(n[0], n[1])) : $S(n.address, n.storageKeys));
  const t = Object.keys(e).map(n => {
    const r = e[n].reduce((i, s) => (i[s] = !0, i), {});
    return $S(n, Object.keys(r).sort())
  });
  return t.sort((n, r) => n.address.localeCompare(r.address)), t
}

function EW(e) {
  return Tm(e).map(t => [t.address, t.storageKeys])
}

function S4e(e, t) {
  if (e.gasPrice != null) {
    const r = st.from(e.gasPrice),
      i = st.from(e.maxFeePerGas || 0);
    r.eq(i) || bu.throwArgumentError("mismatch EIP-1559 gasPrice != maxFeePerGas", "tx", {
      gasPrice: r,
      maxFeePerGas: i
    })
  }
  const n = [Oo(e.chainId || 0, "chainId"), Oo(e.nonce || 0, "nonce"), Oo(e.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"), Oo(e.maxFeePerGas || 0, "maxFeePerGas"), Oo(e.gasLimit || 0, "gasLimit"), e.to != null ? ki(e.to) : "0x", Oo(e.value || 0, "value"), e.data || "0x", EW(e.accessList || [])];
  if (t) {
    const r = U5(t);
    n.push(Oo(r.recoveryParam, "recoveryParam")), n.push(Mp(r.r)), n.push(Mp(r.s))
  }
  return to(["0x02", z5(n)])
}

function C4e(e, t) {
  const n = [Oo(e.chainId || 0, "chainId"), Oo(e.nonce || 0, "nonce"), Oo(e.gasPrice || 0, "gasPrice"), Oo(e.gasLimit || 0, "gasLimit"), e.to != null ? ki(e.to) : "0x", Oo(e.value || 0, "value"), e.data || "0x", EW(e.accessList || [])];
  if (t) {
    const r = U5(t);
    n.push(Oo(r.recoveryParam, "recoveryParam")), n.push(Mp(r.r)), n.push(Mp(r.s))
  }
  return to(["0x01", z5(n)])
}

function SW(e, t, n) {
  try {
    const r = ss(t[0]).toNumber();
    if (r !== 0 && r !== 1) throw new Error("bad recid");
    e.v = r
  } catch {
    bu.throwArgumentError("invalid v for transaction type: 1", "v", t[0])
  }
  e.r = zr(t[1], 32), e.s = zr(t[2], 32);
  try {
    const r = di(n(e));
    e.from = xW(r, {
      r: e.r,
      s: e.s,
      recoveryParam: e.v
    })
  } catch {}
}

function A4e(e) {
  const t = yk(e.slice(1));
  t.length !== 9 && t.length !== 12 && bu.throwArgumentError("invalid component count for transaction type: 2", "payload", St(e));
  const n = ss(t[2]),
    r = ss(t[3]),
    i = {
      type: 2,
      chainId: ss(t[0]).toNumber(),
      nonce: ss(t[1]).toNumber(),
      maxPriorityFeePerGas: n,
      maxFeePerGas: r,
      gasPrice: null,
      gasLimit: ss(t[4]),
      to: Ak(t[5]),
      value: ss(t[6]),
      data: t[7],
      accessList: Tm(t[8])
    };
  return t.length === 9 || (i.hash = di(e), SW(i, t.slice(9), S4e)), i
}

function T4e(e) {
  const t = yk(e.slice(1));
  t.length !== 8 && t.length !== 11 && bu.throwArgumentError("invalid component count for transaction type: 1", "payload", St(e));
  const n = {
    type: 1,
    chainId: ss(t[0]).toNumber(),
    nonce: ss(t[1]).toNumber(),
    gasPrice: ss(t[2]),
    gasLimit: ss(t[3]),
    to: Ak(t[4]),
    value: ss(t[5]),
    data: t[6],
    accessList: Tm(t[7])
  };
  return t.length === 8 || (n.hash = di(e), SW(n, t.slice(8), C4e)), n
}

function k4e(e) {
  const t = yk(e);
  t.length !== 9 && t.length !== 6 && bu.throwArgumentError("invalid raw transaction", "rawTransaction", e);
  const n = {
    nonce: ss(t[0]).toNumber(),
    gasPrice: ss(t[1]),
    gasLimit: ss(t[2]),
    to: Ak(t[3]),
    value: ss(t[4]),
    data: t[5],
    chainId: 0
  };
  if (t.length === 6) return n;
  try {
    n.v = st.from(t[6]).toNumber()
  } catch {
    return n
  }
  if (n.r = zr(t[7], 32), n.s = zr(t[8], 32), st.from(n.r).isZero() && st.from(n.s).isZero()) n.chainId = n.v, n.v = 0;
  else {
    n.chainId = Math.floor((n.v - 35) / 2), n.chainId < 0 && (n.chainId = 0);
    let r = n.v - 27;
    const i = t.slice(0, 6);
    n.chainId !== 0 && (i.push(St(n.chainId)), i.push("0x"), i.push("0x"), r -= n.chainId * 2 + 8);
    const s = di(z5(i));
    try {
      n.from = xW(s, {
        r: St(n.r),
        s: St(n.s),
        recoveryParam: r
      })
    } catch {}
    n.hash = di(e)
  }
  return n.type = null, n
}

function _4e(e) {
  const t = jt(e);
  if (t[0] > 127) return k4e(t);
  switch (t[0]) {
    case 1:
      return T4e(t);
    case 2:
      return A4e(t)
  }
  return bu.throwError(`unsupported transaction type: ${t[0]}`, Ae.errors.UNSUPPORTED_OPERATION, {
    operation: "parseTransaction",
    transactionType: t[0]
  })
}
const I4e = "contracts/5.7.0";
var lh = function (e, t, n, r) {
  function i(s) {
    return s instanceof n ? s : new n(function (o) {
      o(s)
    })
  }
  return new(n || (n = Promise))(function (s, o) {
    function a(u) {
      try {
        l(r.next(u))
      } catch (f) {
        o(f)
      }
    }

    function c(u) {
      try {
        l(r.throw(u))
      } catch (f) {
        o(f)
      }
    }

    function l(u) {
      u.done ? s(u.value) : i(u.value).then(a, c)
    }
    l((r = r.apply(e, t || [])).next())
  })
};
const qr = new Ae(I4e);

function R3(e, t) {
  return lh(this, void 0, void 0, function* () {
    const n = yield t;
    typeof n != "string" && qr.throwArgumentError("invalid address or ENS name", "name", n);
    try {
      return ki(n)
    } catch {}
    e || qr.throwError("a provider or signer is needed to resolve ENS names", Ae.errors.UNSUPPORTED_OPERATION, {
      operation: "resolveName"
    });
    const r = yield e.resolveName(n);
    return r == null && qr.throwArgumentError("resolver or addr is not configured for ENS name", "name", n), r
  })
}

function Sw(e, t, n) {
  return lh(this, void 0, void 0, function* () {
    return Array.isArray(n) ? yield Promise.all(n.map((r, i) => Sw(e, Array.isArray(t) ? t[i] : t[r.name], r))): n.type === "address" ? yield R3(e, t): n.type === "tuple" ? yield Sw(e, t, n.components): n.baseType === "array" ? Array.isArray(t) ? yield Promise.all(t.map(r => Sw(e, r, n.arrayChildren))): Promise.reject(qr.makeError("invalid value for array", Ae.errors.INVALID_ARGUMENT, {
      argument: "value",
      value: t
    })): t
  })
}

function G5(e, t, n) {
  return lh(this, void 0, void 0, function* () {
    let r = {};
    n.length === t.inputs.length + 1 && typeof n[n.length - 1] == "object" && (r = Cr(n.pop())), qr.checkArgumentCount(n.length, t.inputs.length, "passed to contract"), e.signer ? r.from ? r.from = ei({
      override: R3(e.signer, r.from),
      signer: e.signer.getAddress()
    }).then(l => lh(this, void 0, void 0, function* () {
      return ki(l.signer) !== l.override && qr.throwError("Contract with a Signer cannot override from", Ae.errors.UNSUPPORTED_OPERATION, {
        operation: "overrides.from"
      }), l.override
    })) : r.from = e.signer.getAddress() : r.from && (r.from = R3(e.provider, r.from));
    const i = yield ei({
      args: Sw(e.signer || e.provider, n, t.inputs),
      address: e.resolvedAddress,
      overrides: ei(r) || {}
    }), s = e.interface.encodeFunctionData(t, i.args), o = {
      data: s,
      to: i.address
    }, a = i.overrides;
    if (a.nonce != null && (o.nonce = st.from(a.nonce).toNumber()), a.gasLimit != null && (o.gasLimit = st.from(a.gasLimit)), a.gasPrice != null && (o.gasPrice = st.from(a.gasPrice)), a.maxFeePerGas != null && (o.maxFeePerGas = st.from(a.maxFeePerGas)), a.maxPriorityFeePerGas != null && (o.maxPriorityFeePerGas = st.from(a.maxPriorityFeePerGas)), a.from != null && (o.from = a.from), a.type != null && (o.type = a.type), a.accessList != null && (o.accessList = Tm(a.accessList)), o.gasLimit == null && t.gas != null) {
      let l = 21e3;
      const u = jt(s);
      for (let f = 0; f < u.length; f++) l += 4, u[f] && (l += 64);
      o.gasLimit = st.from(t.gas).add(l)
    }
    if (a.value) {
      const l = st.from(a.value);
      !l.isZero() && !t.payable && qr.throwError("non-payable method cannot override value", Ae.errors.UNSUPPORTED_OPERATION, {
        operation: "overrides.value",
        value: r.value
      }), o.value = l
    }
    a.customData && (o.customData = Cr(a.customData)), a.ccipReadEnabled && (o.ccipReadEnabled = !!a.ccipReadEnabled), delete r.nonce, delete r.gasLimit, delete r.gasPrice, delete r.from, delete r.value, delete r.type, delete r.accessList, delete r.maxFeePerGas, delete r.maxPriorityFeePerGas, delete r.customData, delete r.ccipReadEnabled;
    const c = Object.keys(r).filter(l => r[l] != null);
    return c.length && qr.throwError(`cannot override ${c.map(l=>JSON.stringify(l)).join(",")}`, Ae.errors.UNSUPPORTED_OPERATION, {
      operation: "overrides",
      overrides: c
    }), o
  })
}

function P4e(e, t) {
  return function (...n) {
    return G5(e, t, n)
  }
}

function R4e(e, t) {
  const n = e.signer || e.provider;
  return function (...r) {
    return lh(this, void 0, void 0, function* () {
      n || qr.throwError("estimate require a provider or signer", Ae.errors.UNSUPPORTED_OPERATION, {
        operation: "estimateGas"
      });
      const i = yield G5(e, t, r);
      return yield n.estimateGas(i)
    })
  }
}

function O4e(e, t) {
  const n = t.wait.bind(t);
  t.wait = r => n(r).then(i => (i.events = i.logs.map(s => {
    let o = Aa(s),
      a = null;
    try {
      a = e.interface.parseLog(s)
    } catch {}
    return a && (o.args = a.args, o.decode = (c, l) => e.interface.decodeEventLog(a.eventFragment, c, l), o.event = a.name, o.eventSignature = a.signature), o.removeListener = () => e.provider, o.getBlock = () => e.provider.getBlock(i.blockHash), o.getTransaction = () => e.provider.getTransaction(i.transactionHash), o.getTransactionReceipt = () => Promise.resolve(i), o
  }), i))
}

function CW(e, t, n) {
  const r = e.signer || e.provider;
  return function (...i) {
    return lh(this, void 0, void 0, function* () {
      let s;
      if (i.length === t.inputs.length + 1 && typeof i[i.length - 1] == "object") {
        const c = Cr(i.pop());
        c.blockTag != null && (s = yield c.blockTag), delete c.blockTag, i.push(c)
      }
      e.deployTransaction != null && (yield e._deployed(s));
      const o = yield G5(e, t, i), a = yield r.call(o, s);
      try {
        let c = e.interface.decodeFunctionResult(t, a);
        return n && t.outputs.length === 1 && (c = c[0]), c
      } catch (c) {
        throw c.code === Ae.errors.CALL_EXCEPTION && (c.address = e.address, c.args = i, c.transaction = o), c
      }
    })
  }
}

function D4e(e, t) {
  return function (...n) {
    return lh(this, void 0, void 0, function* () {
      e.signer || qr.throwError("sending a transaction requires a signer", Ae.errors.UNSUPPORTED_OPERATION, {
        operation: "sendTransaction"
      }), e.deployTransaction != null && (yield e._deployed());
      const r = yield G5(e, t, n), i = yield e.signer.sendTransaction(r);
      return O4e(e, i), i
    })
  }
}

function gM(e, t, n) {
  return t.constant ? CW(e, t, n) : D4e(e, t)
}

function AW(e) {
  return e.address && (e.topics == null || e.topics.length === 0) ? "*" : (e.address || "*") + "@" + (e.topics ? e.topics.map(t => Array.isArray(t) ? t.join("|") : t).join(":") : "")
}
class l2 {
  constructor(t, n) {
    Ge(this, "tag", t), Ge(this, "filter", n), this._listeners = []
  }
  addListener(t, n) {
    this._listeners.push({
      listener: t,
      once: n
    })
  }
  removeListener(t) {
    let n = !1;
    this._listeners = this._listeners.filter(r => n || r.listener !== t ? !0 : (n = !0, !1))
  }
  removeAllListeners() {
    this._listeners = []
  }
  listeners() {
    return this._listeners.map(t => t.listener)
  }
  listenerCount() {
    return this._listeners.length
  }
  run(t) {
    const n = this.listenerCount();
    return this._listeners = this._listeners.filter(r => {
      const i = t.slice();
      return setTimeout(() => {
        r.listener.apply(this, i)
      }, 0), !r.once
    }), n
  }
  prepareEvent(t) {}
  getEmit(t) {
    return [t]
  }
}
class N4e extends l2 {
  constructor() {
    super("error", null)
  }
}
class yM extends l2 {
  constructor(t, n, r, i) {
    const s = {
      address: t
    };
    let o = n.getEventTopic(r);
    i ? (o !== i[0] && qr.throwArgumentError("topic mismatch", "topics", i), s.topics = i.slice()) : s.topics = [o], super(AW(s), s), Ge(this, "address", t), Ge(this, "interface", n), Ge(this, "fragment", r)
  }
  prepareEvent(t) {
    super.prepareEvent(t), t.event = this.fragment.name, t.eventSignature = this.fragment.format(), t.decode = (n, r) => this.interface.decodeEventLog(this.fragment, n, r);
    try {
      t.args = this.interface.decodeEventLog(this.fragment, t.data, t.topics)
    } catch (n) {
      t.args = null, t.decodeError = n
    }
  }
  getEmit(t) {
    const n = y5e(t.args);
    if (n.length) throw n[0].error;
    const r = (t.args || []).slice();
    return r.push(t), r
  }
}
class vM extends l2 {
  constructor(t, n) {
    super("*", {
      address: t
    }), Ge(this, "address", t), Ge(this, "interface", n)
  }
  prepareEvent(t) {
    super.prepareEvent(t);
    try {
      const n = this.interface.parseLog(t);
      t.event = n.name, t.eventSignature = n.signature, t.decode = (r, i) => this.interface.decodeEventLog(n.eventFragment, r, i), t.args = n.args
    } catch {}
  }
}
class M4e {
  constructor(t, n, r) {
    Ge(this, "interface", Xc(new.target, "getInterface")(n)), r == null ? (Ge(this, "provider", null), Ge(this, "signer", null)) : sy.isSigner(r) ? (Ge(this, "provider", r.provider || null), Ge(this, "signer", r)) : iy.isProvider(r) ? (Ge(this, "provider", r), Ge(this, "signer", null)) : qr.throwArgumentError("invalid signer or provider", "signerOrProvider", r), Ge(this, "callStatic", {}), Ge(this, "estimateGas", {}), Ge(this, "functions", {}), Ge(this, "populateTransaction", {}), Ge(this, "filters", {}); {
      const o = {};
      Object.keys(this.interface.events).forEach(a => {
        const c = this.interface.events[a];
        Ge(this.filters, a, (...l) => ({
          address: this.address,
          topics: this.interface.encodeFilterTopics(c, l)
        })), o[c.name] || (o[c.name] = []), o[c.name].push(a)
      }), Object.keys(o).forEach(a => {
        const c = o[a];
        c.length === 1 ? Ge(this.filters, a, this.filters[c[0]]) : qr.warn(`Duplicate definition of ${a} (${c.join(", ")})`)
      })
    }
    if (Ge(this, "_runningEvents", {}), Ge(this, "_wrappedEmits", {}), t == null && qr.throwArgumentError("invalid contract address or ENS name", "addressOrName", t), Ge(this, "address", t), this.provider) Ge(this, "resolvedAddress", R3(this.provider, t));
    else try {
      Ge(this, "resolvedAddress", Promise.resolve(ki(t)))
    } catch {
      qr.throwError("provider is required to use ENS name as contract address", Ae.errors.UNSUPPORTED_OPERATION, {
        operation: "new Contract"
      })
    }
    this.resolvedAddress.catch(o => {});
    const i = {},
      s = {};
    Object.keys(this.interface.functions).forEach(o => {
      const a = this.interface.functions[o];
      if (s[o]) {
        qr.warn(`Duplicate ABI entry for ${JSON.stringify(o)}`);
        return
      }
      s[o] = !0; {
        const c = a.name;
        i[`%${c}`] || (i[`%${c}`] = []), i[`%${c}`].push(o)
      }
      this[o] == null && Ge(this, o, gM(this, a, !0)), this.functions[o] == null && Ge(this.functions, o, gM(this, a, !1)), this.callStatic[o] == null && Ge(this.callStatic, o, CW(this, a, !0)), this.populateTransaction[o] == null && Ge(this.populateTransaction, o, P4e(this, a)), this.estimateGas[o] == null && Ge(this.estimateGas, o, R4e(this, a))
    }), Object.keys(i).forEach(o => {
      const a = i[o];
      if (a.length > 1) return;
      o = o.substring(1);
      const c = a[0];
      try {
        this[o] == null && Ge(this, o, this[c])
      } catch {}
      this.functions[o] == null && Ge(this.functions, o, this.functions[c]), this.callStatic[o] == null && Ge(this.callStatic, o, this.callStatic[c]), this.populateTransaction[o] == null && Ge(this.populateTransaction, o, this.populateTransaction[c]), this.estimateGas[o] == null && Ge(this.estimateGas, o, this.estimateGas[c])
    })
  }
  static getContractAddress(t) {
    return OV(t)
  }
  static getInterface(t) {
    return lA.isInterface(t) ? t : new lA(t)
  }
  deployed() {
    return this._deployed()
  }
  _deployed(t) {
    return this._deployedPromise || (this.deployTransaction ? this._deployedPromise = this.deployTransaction.wait().then(() => this) : this._deployedPromise = this.provider.getCode(this.address, t).then(n => (n === "0x" && qr.throwError("contract not deployed", Ae.errors.UNSUPPORTED_OPERATION, {
      contractAddress: this.address,
      operation: "getDeployed"
    }), this))), this._deployedPromise
  }
  fallback(t) {
    this.signer || qr.throwError("sending a transactions require a signer", Ae.errors.UNSUPPORTED_OPERATION, {
      operation: "sendTransaction(fallback)"
    });
    const n = Cr(t || {});
    return ["from", "to"].forEach(function (r) {
      n[r] != null && qr.throwError("cannot override " + r, Ae.errors.UNSUPPORTED_OPERATION, {
        operation: r
      })
    }), n.to = this.resolvedAddress, this.deployed().then(() => this.signer.sendTransaction(n))
  }
  connect(t) {
    typeof t == "string" && (t = new xk(t, this.provider));
    const n = new this.constructor(this.address, this.interface, t);
    return this.deployTransaction && Ge(n, "deployTransaction", this.deployTransaction), n
  }
  attach(t) {
    return new this.constructor(t, this.interface, this.signer || this.provider)
  }
  static isIndexed(t) {
    return cA.isIndexed(t)
  }
  _normalizeRunningEvent(t) {
    return this._runningEvents[t.tag] ? this._runningEvents[t.tag] : t
  }
  _getRunningEvent(t) {
    if (typeof t == "string") {
      if (t === "error") return this._normalizeRunningEvent(new N4e);
      if (t === "event") return this._normalizeRunningEvent(new l2("event", null));
      if (t === "*") return this._normalizeRunningEvent(new vM(this.address, this.interface));
      const n = this.interface.getEvent(t);
      return this._normalizeRunningEvent(new yM(this.address, this.interface, n))
    }
    if (t.topics && t.topics.length > 0) {
      try {
        const r = t.topics[0];
        if (typeof r != "string") throw new Error("invalid topic");
        const i = this.interface.getEvent(r);
        return this._normalizeRunningEvent(new yM(this.address, this.interface, i, t.topics))
      } catch {}
      const n = {
        address: this.address,
        topics: t.topics
      };
      return this._normalizeRunningEvent(new l2(AW(n), n))
    }
    return this._normalizeRunningEvent(new vM(this.address, this.interface))
  }
  _checkRunningEvents(t) {
    if (t.listenerCount() === 0) {
      delete this._runningEvents[t.tag];
      const n = this._wrappedEmits[t.tag];
      n && t.filter && (this.provider.off(t.filter, n), delete this._wrappedEmits[t.tag])
    }
  }
  _wrapEvent(t, n, r) {
    const i = Aa(n);
    return i.removeListener = () => {
      r && (t.removeListener(r), this._checkRunningEvents(t))
    }, i.getBlock = () => this.provider.getBlock(n.blockHash), i.getTransaction = () => this.provider.getTransaction(n.transactionHash), i.getTransactionReceipt = () => this.provider.getTransactionReceipt(n.transactionHash), t.prepareEvent(i), i
  }
  _addEventListener(t, n, r) {
    if (this.provider || qr.throwError("events require a provider or a signer with a provider", Ae.errors.UNSUPPORTED_OPERATION, {
        operation: "once"
      }), t.addListener(n, r), this._runningEvents[t.tag] = t, !this._wrappedEmits[t.tag]) {
      const i = s => {
        let o = this._wrapEvent(t, s, n);
        if (o.decodeError == null) try {
          const a = t.getEmit(o);
          this.emit(t.filter, ...a)
        } catch (a) {
          o.decodeError = a.error
        }
        t.filter != null && this.emit("event", o), o.decodeError != null && this.emit("error", o.decodeError, o)
      };
      this._wrappedEmits[t.tag] = i, t.filter != null && this.provider.on(t.filter, i)
    }
  }
  queryFilter(t, n, r) {
    const i = this._getRunningEvent(t),
      s = Cr(i.filter);
    return typeof n == "string" && pn(n, 32) ? (r != null && qr.throwArgumentError("cannot specify toBlock with blockhash", "toBlock", r), s.blockHash = n) : (s.fromBlock = n ?? 0, s.toBlock = r ?? "latest"), this.provider.getLogs(s).then(o => o.map(a => this._wrapEvent(i, a, null)))
  }
  on(t, n) {
    return this._addEventListener(this._getRunningEvent(t), n, !1), this
  }
  once(t, n) {
    return this._addEventListener(this._getRunningEvent(t), n, !0), this
  }
  emit(t, ...n) {
    if (!this.provider) return !1;
    const r = this._getRunningEvent(t),
      i = r.run(n) > 0;
    return this._checkRunningEvents(r), i
  }
  listenerCount(t) {
    return this.provider ? t == null ? Object.keys(this._runningEvents).reduce((n, r) => n + this._runningEvents[r].listenerCount(), 0) : this._getRunningEvent(t).listenerCount() : 0
  }
  listeners(t) {
    if (!this.provider) return [];
    if (t == null) {
      const n = [];
      for (let r in this._runningEvents) this._runningEvents[r].listeners().forEach(i => {
        n.push(i)
      });
      return n
    }
    return this._getRunningEvent(t).listeners()
  }
  removeAllListeners(t) {
    if (!this.provider) return this;
    if (t == null) {
      for (const r in this._runningEvents) {
        const i = this._runningEvents[r];
        i.removeAllListeners(), this._checkRunningEvents(i)
      }
      return this
    }
    const n = this._getRunningEvent(t);
    return n.removeAllListeners(), this._checkRunningEvents(n), this
  }
  off(t, n) {
    if (!this.provider) return this;
    const r = this._getRunningEvent(t);
    return r.removeListener(n), this._checkRunningEvents(r), this
  }
  removeListener(t, n) {
    return this.off(t, n)
  }
}
class K5 extends M4e {}
class TW {
  constructor(t) {
    Ge(this, "alphabet", t), Ge(this, "base", t.length), Ge(this, "_alphabetMap", {}), Ge(this, "_leader", t.charAt(0));
    for (let n = 0; n < t.length; n++) this._alphabetMap[t.charAt(n)] = n
  }
  encode(t) {
    let n = jt(t);
    if (n.length === 0) return "";
    let r = [0];
    for (let s = 0; s < n.length; ++s) {
      let o = n[s];
      for (let a = 0; a < r.length; ++a) o += r[a] << 8, r[a] = o % this.base, o = o / this.base | 0;
      for (; o > 0;) r.push(o % this.base), o = o / this.base | 0
    }
    let i = "";
    for (let s = 0; n[s] === 0 && s < n.length - 1; ++s) i += this._leader;
    for (let s = r.length - 1; s >= 0; --s) i += this.alphabet[r[s]];
    return i
  }
  decode(t) {
    if (typeof t != "string") throw new TypeError("Expected String");
    let n = [];
    if (t.length === 0) return new Uint8Array(n);
    n.push(0);
    for (let r = 0; r < t.length; r++) {
      let i = this._alphabetMap[t[r]];
      if (i === void 0) throw new Error("Non-base" + this.base + " character");
      let s = i;
      for (let o = 0; o < n.length; ++o) s += n[o] * this.base, n[o] = s & 255, s >>= 8;
      for (; s > 0;) n.push(s & 255), s >>= 8
    }
    for (let r = 0; t[r] === this._leader && r < t.length - 1; ++r) n.push(0);
    return jt(new Uint8Array(n.reverse()))
  }
}
new TW("abcdefghijklmnopqrstuvwxyz234567");
const mA = new TW("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");

function bM(e) {
  return "0x" + Uc.sha256().update(jt(e)).digest("hex")
}

function $4e(e) {
  e = e.slice();
  for (let t = e.length - 1; t > 0; t--) {
    const n = Math.floor(Math.random() * (t + 1)),
      r = e[t];
    e[t] = e[n], e[n] = r
  }
  return e
}
const L4e = "networks/5.7.1",
  wM = new Ae(L4e);

function B4e(e) {
  return e && typeof e.renetwork == "function"
}

function Yl(e) {
  const t = function (n, r) {
    r == null && (r = {});
    const i = [];
    if (n.InfuraProvider && r.infura !== "-") try {
      i.push(new n.InfuraProvider(e, r.infura))
    } catch {}
    if (n.EtherscanProvider && r.etherscan !== "-") try {
      i.push(new n.EtherscanProvider(e, r.etherscan))
    } catch {}
    if (n.AlchemyProvider && r.alchemy !== "-") try {
      i.push(new n.AlchemyProvider(e, r.alchemy))
    } catch {}
    if (n.PocketProvider && r.pocket !== "-") {
      const s = ["goerli", "ropsten", "rinkeby", "sepolia"];
      try {
        const o = new n.PocketProvider(e, r.pocket);
        o.network && s.indexOf(o.network.name) === -1 && i.push(o)
      } catch {}
    }
    if (n.CloudflareProvider && r.cloudflare !== "-") try {
      i.push(new n.CloudflareProvider(e))
    } catch {}
    if (n.AnkrProvider && r.ankr !== "-") try {
      const s = ["ropsten"],
        o = new n.AnkrProvider(e, r.ankr);
      o.network && s.indexOf(o.network.name) === -1 && i.push(o)
    } catch {}
    if (i.length === 0) return null;
    if (n.FallbackProvider) {
      let s = 1;
      return r.quorum != null ? s = r.quorum : e === "homestead" && (s = 2), new n.FallbackProvider(i, s)
    }
    return i[0]
  };
  return t.renetwork = function (n) {
    return Yl(n)
  }, t
}

function O3(e, t) {
  const n = function (r, i) {
    return r.JsonRpcProvider ? new r.JsonRpcProvider(e, t) : null
  };
  return n.renetwork = function (r) {
    return O3(e, r)
  }, n
}
const xM = {
    chainId: 1,
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    name: "homestead",
    _defaultProvider: Yl("homestead")
  },
  EM = {
    chainId: 3,
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    name: "ropsten",
    _defaultProvider: Yl("ropsten")
  },
  SM = {
    chainId: 63,
    name: "classicMordor",
    _defaultProvider: O3("https://www.ethercluster.com/mordor", "classicMordor")
  },
  vb = {
    unspecified: {
      chainId: 0,
      name: "unspecified"
    },
    homestead: xM,
    mainnet: xM,
    morden: {
      chainId: 2,
      name: "morden"
    },
    ropsten: EM,
    testnet: EM,
    rinkeby: {
      chainId: 4,
      ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
      name: "rinkeby",
      _defaultProvider: Yl("rinkeby")
    },
    kovan: {
      chainId: 42,
      name: "kovan",
      _defaultProvider: Yl("kovan")
    },
    goerli: {
      chainId: 5,
      ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
      name: "goerli",
      _defaultProvider: Yl("goerli")
    },
    kintsugi: {
      chainId: 1337702,
      name: "kintsugi"
    },
    sepolia: {
      chainId: 11155111,
      name: "sepolia",
      _defaultProvider: Yl("sepolia")
    },
    classic: {
      chainId: 61,
      name: "classic",
      _defaultProvider: O3("https://www.ethercluster.com/etc", "classic")
    },
    classicMorden: {
      chainId: 62,
      name: "classicMorden"
    },
    classicMordor: SM,
    classicTestnet: SM,
    classicKotti: {
      chainId: 6,
      name: "classicKotti",
      _defaultProvider: O3("https://www.ethercluster.com/kotti", "classicKotti")
    },
    xdai: {
      chainId: 100,
      name: "xdai"
    },
    matic: {
      chainId: 137,
      name: "matic",
      _defaultProvider: Yl("matic")
    },
    maticmum: {
      chainId: 80001,
      name: "maticmum"
    },
    optimism: {
      chainId: 10,
      name: "optimism",
      _defaultProvider: Yl("optimism")
    },
    "optimism-kovan": {
      chainId: 69,
      name: "optimism-kovan"
    },
    "optimism-goerli": {
      chainId: 420,
      name: "optimism-goerli"
    },
    arbitrum: {
      chainId: 42161,
      name: "arbitrum"
    },
    "arbitrum-rinkeby": {
      chainId: 421611,
      name: "arbitrum-rinkeby"
    },
    "arbitrum-goerli": {
      chainId: 421613,
      name: "arbitrum-goerli"
    },
    bnb: {
      chainId: 56,
      name: "bnb"
    },
    bnbt: {
      chainId: 97,
      name: "bnbt"
    }
  };

function F4e(e) {
  if (e == null) return null;
  if (typeof e == "number") {
    for (const r in vb) {
      const i = vb[r];
      if (i.chainId === e) return {
        name: i.name,
        chainId: i.chainId,
        ensAddress: i.ensAddress || null,
        _defaultProvider: i._defaultProvider || null
      }
    }
    return {
      chainId: e,
      name: "unknown"
    }
  }
  if (typeof e == "string") {
    const r = vb[e];
    return r == null ? null : {
      name: r.name,
      chainId: r.chainId,
      ensAddress: r.ensAddress,
      _defaultProvider: r._defaultProvider || null
    }
  }
  const t = vb[e.name];
  if (!t) return typeof e.chainId != "number" && wM.throwArgumentError("invalid network chainId", "network", e), e;
  e.chainId !== 0 && e.chainId !== t.chainId && wM.throwArgumentError("network chainId mismatch", "network", e);
  let n = e._defaultProvider || null;
  return n == null && t._defaultProvider && (B4e(t._defaultProvider) ? n = t._defaultProvider.renetwork(e) : n = t._defaultProvider), {
    name: e.name,
    chainId: t.chainId,
    ensAddress: e.ensAddress || t.ensAddress || null,
    _defaultProvider: n
  }
}
const j4e = "web/5.7.1";
var U4e = function (e, t, n, r) {
  function i(s) {
    return s instanceof n ? s : new n(function (o) {
      o(s)
    })
  }
  return new(n || (n = Promise))(function (s, o) {
    function a(u) {
      try {
        l(r.next(u))
      } catch (f) {
        o(f)
      }
    }

    function c(u) {
      try {
        l(r.throw(u))
      } catch (f) {
        o(f)
      }
    }

    function l(u) {
      u.done ? s(u.value) : i(u.value).then(a, c)
    }
    l((r = r.apply(e, t || [])).next())
  })
};

function z4e(e, t) {
  return U4e(this, void 0, void 0, function* () {
    t == null && (t = {});
    const n = {
      method: t.method || "GET",
      headers: t.headers || {},
      body: t.body || void 0
    };
    if (t.skipFetchSetup !== !0 && (n.mode = "cors", n.cache = "no-cache", n.credentials = "same-origin", n.redirect = "follow", n.referrer = "client"), t.fetchOptions != null) {
      const o = t.fetchOptions;
      o.mode && (n.mode = o.mode), o.cache && (n.cache = o.cache), o.credentials && (n.credentials = o.credentials), o.redirect && (n.redirect = o.redirect), o.referrer && (n.referrer = o.referrer)
    }
    const r = yield fetch(e, n), i = yield r.arrayBuffer(), s = {};
    return r.headers.forEach ? r.headers.forEach((o, a) => {
      s[a.toLowerCase()] = o
    }) : r.headers.keys().forEach(o => {
      s[o.toLowerCase()] = r.headers.get(o)
    }), {
      headers: s,
      statusCode: r.status,
      statusMessage: r.statusText,
      body: jt(new Uint8Array(i))
    }
  })
}
var H4e = function (e, t, n, r) {
  function i(s) {
    return s instanceof n ? s : new n(function (o) {
      o(s)
    })
  }
  return new(n || (n = Promise))(function (s, o) {
    function a(u) {
      try {
        l(r.next(u))
      } catch (f) {
        o(f)
      }
    }

    function c(u) {
      try {
        l(r.throw(u))
      } catch (f) {
        o(f)
      }
    }

    function l(u) {
      u.done ? s(u.value) : i(u.value).then(a, c)
    }
    l((r = r.apply(e, t || [])).next())
  })
};
const tc = new Ae(j4e);

function CM(e) {
  return new Promise(t => {
    setTimeout(t, e)
  })
}

function Vu(e, t) {
  if (e == null) return null;
  if (typeof e == "string") return e;
  if (pk(e)) {
    if (t && (t.split("/")[0] === "text" || t.split(";")[0].trim() === "application/json")) try {
      return ry(e)
    } catch {}
    return St(e)
  }
  return e
}

function V4e(e) {
  return fl(e.replace(/%([0-9a-f][0-9a-f])/gi, (t, n) => String.fromCharCode(parseInt(n, 16))))
}

function W4e(e, t, n) {
  const r = typeof e == "object" && e.throttleLimit != null ? e.throttleLimit : 12;
  tc.assertArgument(r > 0 && r % 1 === 0, "invalid connection throttle limit", "connection.throttleLimit", r);
  const i = typeof e == "object" ? e.throttleCallback : null,
    s = typeof e == "object" && typeof e.throttleSlotInterval == "number" ? e.throttleSlotInterval : 100;
  tc.assertArgument(s > 0 && s % 1 === 0, "invalid connection throttle slot interval", "connection.throttleSlotInterval", s);
  const o = typeof e == "object" ? !!e.errorPassThrough : !1,
    a = {};
  let c = null;
  const l = {
    method: "GET"
  };
  let u = !1,
    f = 2 * 60 * 1e3;
  if (typeof e == "string") c = e;
  else if (typeof e == "object") {
    if ((e == null || e.url == null) && tc.throwArgumentError("missing URL", "connection.url", e), c = e.url, typeof e.timeout == "number" && e.timeout > 0 && (f = e.timeout), e.headers)
      for (const _ in e.headers) a[_.toLowerCase()] = {
        key: _,
        value: String(e.headers[_])
      }, ["if-none-match", "if-modified-since"].indexOf(_.toLowerCase()) >= 0 && (u = !0);
    if (l.allowGzip = !!e.allowGzip, e.user != null && e.password != null) {
      c.substring(0, 6) !== "https:" && e.allowInsecureAuthentication !== !0 && tc.throwError("basic authentication requires a secure https url", Ae.errors.INVALID_ARGUMENT, {
        argument: "url",
        url: c,
        user: e.user,
        password: "[REDACTED]"
      });
      const _ = e.user + ":" + e.password;
      a.authorization = {
        key: "Authorization",
        value: "Basic " + zV(fl(_))
      }
    }
    e.skipFetchSetup != null && (l.skipFetchSetup = !!e.skipFetchSetup), e.fetchOptions != null && (l.fetchOptions = Cr(e.fetchOptions))
  }
  const h = new RegExp("^data:([^;:]*)?(;base64)?,(.*)$", "i"),
    g = c ? c.match(h) : null;
  if (g) try {
    const _ = {
      statusCode: 200,
      statusMessage: "OK",
      headers: {
        "content-type": g[1] || "text/plain"
      },
      body: g[2] ? UV(g[3]) : V4e(g[3])
    };
    let p = _.body;
    return n && (p = n(_.body, _)), Promise.resolve(p)
  } catch (_) {
    tc.throwError("processing response error", Ae.errors.SERVER_ERROR, {
      body: Vu(g[1], g[2]),
      error: _,
      requestBody: null,
      requestMethod: "GET",
      url: c
    })
  }
  t && (l.method = "POST", l.body = t, a["content-type"] == null && (a["content-type"] = {
    key: "Content-Type",
    value: "application/octet-stream"
  }), a["content-length"] == null && (a["content-length"] = {
    key: "Content-Length",
    value: String(t.length)
  }));
  const y = {};
  Object.keys(a).forEach(_ => {
    const p = a[_];
    y[p.key] = p.value
  }), l.headers = y;
  const x = function () {
      let _ = null;
      return {
        promise: new Promise(function (S, I) {
          f && (_ = setTimeout(() => {
            _ != null && (_ = null, I(tc.makeError("timeout", Ae.errors.TIMEOUT, {
              requestBody: Vu(l.body, y["content-type"]),
              requestMethod: l.method,
              timeout: f,
              url: c
            })))
          }, f))
        }),
        cancel: function () {
          _ != null && (clearTimeout(_), _ = null)
        }
      }
    }(),
    k = function () {
      return H4e(this, void 0, void 0, function* () {
        for (let _ = 0; _ < r; _++) {
          let p = null;
          try {
            if (p = yield z4e(c, l), _ < r) {
              if (p.statusCode === 301 || p.statusCode === 302) {
                const S = p.headers.location || "";
                if (l.method === "GET" && S.match(/^https:/)) {
                  c = p.headers.location;
                  continue
                }
              } else if (p.statusCode === 429) {
                let S = !0;
                if (i && (S = yield i(_, c)), S) {
                  let I = 0;
                  const A = p.headers["retry-after"];
                  typeof A == "string" && A.match(/^[1-9][0-9]*$/) ? I = parseInt(A) * 1e3 : I = s * parseInt(String(Math.random() * Math.pow(2, _))), yield CM(I);
                  continue
                }
              }
            }
          } catch (S) {
            p = S.response, p == null && (x.cancel(), tc.throwError("missing response", Ae.errors.SERVER_ERROR, {
              requestBody: Vu(l.body, y["content-type"]),
              requestMethod: l.method,
              serverError: S,
              url: c
            }))
          }
          let v = p.body;
          if (u && p.statusCode === 304 ? v = null : !o && (p.statusCode < 200 || p.statusCode >= 300) && (x.cancel(), tc.throwError("bad response", Ae.errors.SERVER_ERROR, {
              status: p.statusCode,
              headers: p.headers,
              body: Vu(v, p.headers ? p.headers["content-type"] : null),
              requestBody: Vu(l.body, y["content-type"]),
              requestMethod: l.method,
              url: c
            })), n) try {
            const S = yield n(v, p);
            return x.cancel(), S
          } catch (S) {
            if (S.throttleRetry && _ < r) {
              let I = !0;
              if (i && (I = yield i(_, c)), I) {
                const A = s * parseInt(String(Math.random() * Math.pow(2, _)));
                yield CM(A);
                continue
              }
            }
            x.cancel(), tc.throwError("processing response error", Ae.errors.SERVER_ERROR, {
              body: Vu(v, p.headers ? p.headers["content-type"] : null),
              error: S,
              requestBody: Vu(l.body, y["content-type"]),
              requestMethod: l.method,
              url: c
            })
          }
          return x.cancel(), v
        }
        return tc.throwError("failed response", Ae.errors.SERVER_ERROR, {
          requestBody: Vu(l.body, y["content-type"]),
          requestMethod: l.method,
          url: c
        })
      })
    }();
  return Promise.race([x.promise, k])
}

function Tk(e, t, n) {
  let r = (s, o) => {
      let a = null;
      if (s != null) try {
        a = JSON.parse(ry(s))
      } catch (c) {
        tc.throwError("invalid JSON", Ae.errors.SERVER_ERROR, {
          body: s,
          error: c
        })
      }
      return n && (a = n(a, o)), a
    },
    i = null;
  if (t != null) {
    i = fl(t);
    const s = typeof e == "string" ? {
      url: e
    } : Cr(e);
    s.headers ? Object.keys(s.headers).filter(a => a.toLowerCase() === "content-type").length !== 0 || (s.headers = Cr(s.headers), s.headers["content-type"] = "application/json") : s.headers = {
      "content-type": "application/json"
    }, e = s
  }
  return W4e(e, i, r)
}

function Q0(e, t) {
  return t || (t = {}), t = Cr(t), t.floor == null && (t.floor = 0), t.ceiling == null && (t.ceiling = 1e4), t.interval == null && (t.interval = 250), new Promise(function (n, r) {
    let i = null,
      s = !1;
    const o = () => s ? !1 : (s = !0, i && clearTimeout(i), !0);
    t.timeout && (i = setTimeout(() => {
      o() && r(new Error("timeout"))
    }, t.timeout));
    const a = t.retryLimit;
    let c = 0;

    function l() {
      return e().then(function (u) {
        if (u !== void 0) o() && n(u);
        else if (t.oncePoll) t.oncePoll.once("poll", l);
        else if (t.onceBlock) t.onceBlock.once("block", l);
        else if (!s) {
          if (c++, c > a) {
            o() && r(new Error("retry limit reached"));
            return
          }
          let f = t.interval * parseInt(String(Math.random() * Math.pow(2, c)));
          f < t.floor && (f = t.floor), f > t.ceiling && (f = t.ceiling), setTimeout(l, f)
        }
        return null
      }, function (u) {
        o() && r(u)
      })
    }
    l()
  })
}
var D3 = "qpzry9x8gf2tvdw0s3jn54khce6mua7l",
  gA = {};
for (var bb = 0; bb < D3.length; bb++) {
  var LS = D3.charAt(bb);
  if (gA[LS] !== void 0) throw new TypeError(LS + " is ambiguous");
  gA[LS] = bb
}

function fp(e) {
  var t = e >> 25;
  return (e & 33554431) << 5 ^ -(t >> 0 & 1) & 996825010 ^ -(t >> 1 & 1) & 642813549 ^ -(t >> 2 & 1) & 513874426 ^ -(t >> 3 & 1) & 1027748829 ^ -(t >> 4 & 1) & 705979059
}

function kW(e) {
  for (var t = 1, n = 0; n < e.length; ++n) {
    var r = e.charCodeAt(n);
    if (r < 33 || r > 126) return "Invalid prefix (" + e + ")";
    t = fp(t) ^ r >> 5
  }
  for (t = fp(t), n = 0; n < e.length; ++n) {
    var i = e.charCodeAt(n);
    t = fp(t) ^ i & 31
  }
  return t
}

function q4e(e, t, n) {
  if (n = n || 90, e.length + 7 + t.length > n) throw new TypeError("Exceeds length limit");
  e = e.toLowerCase();
  var r = kW(e);
  if (typeof r == "string") throw new Error(r);
  for (var i = e + "1", s = 0; s < t.length; ++s) {
    var o = t[s];
    if (o >> 5) throw new Error("Non 5-bit word");
    r = fp(r) ^ o, i += D3.charAt(o)
  }
  for (s = 0; s < 6; ++s) r = fp(r);
  for (r ^= 1, s = 0; s < 6; ++s) {
    var a = r >> (5 - s) * 5 & 31;
    i += D3.charAt(a)
  }
  return i
}

function _W(e, t) {
  if (t = t || 90, e.length < 8) return e + " too short";
  if (e.length > t) return "Exceeds length limit";
  var n = e.toLowerCase(),
    r = e.toUpperCase();
  if (e !== n && e !== r) return "Mixed-case string " + e;
  e = n;
  var i = e.lastIndexOf("1");
  if (i === -1) return "No separator character for " + e;
  if (i === 0) return "Missing prefix for " + e;
  var s = e.slice(0, i),
    o = e.slice(i + 1);
  if (o.length < 6) return "Data too short";
  var a = kW(s);
  if (typeof a == "string") return a;
  for (var c = [], l = 0; l < o.length; ++l) {
    var u = o.charAt(l),
      f = gA[u];
    if (f === void 0) return "Unknown character " + u;
    a = fp(a) ^ f, !(l + 6 >= o.length) && c.push(f)
  }
  return a !== 1 ? "Invalid checksum for " + e : {
    prefix: s,
    words: c
  }
}

function G4e() {
  var e = _W.apply(null, arguments);
  if (typeof e == "object") return e
}

function K4e(e) {
  var t = _W.apply(null, arguments);
  if (typeof t == "object") return t;
  throw new Error(t)
}

function Q5(e, t, n, r) {
  for (var i = 0, s = 0, o = (1 << n) - 1, a = [], c = 0; c < e.length; ++c)
    for (i = i << t | e[c], s += t; s >= n;) s -= n, a.push(i >> s & o);
  if (r) s > 0 && a.push(i << n - s & o);
  else {
    if (s >= t) return "Excess padding";
    if (i << n - s & o) return "Non-zero padding"
  }
  return a
}

function Q4e(e) {
  var t = Q5(e, 8, 5, !0);
  if (Array.isArray(t)) return t
}

function Y4e(e) {
  var t = Q5(e, 8, 5, !0);
  if (Array.isArray(t)) return t;
  throw new Error(t)
}

function J4e(e) {
  var t = Q5(e, 5, 8, !1);
  if (Array.isArray(t)) return t
}

function X4e(e) {
  var t = Q5(e, 5, 8, !1);
  if (Array.isArray(t)) return t;
  throw new Error(t)
}
var Z4e = {
  decodeUnsafe: G4e,
  decode: K4e,
  encode: q4e,
  toWordsUnsafe: Q4e,
  toWords: Y4e,
  fromWordsUnsafe: J4e,
  fromWords: X4e
};
const AM = Vo(Z4e),
  km = "providers/5.7.2",
  Pg = new Ae(km);
let TM = class ht {
  constructor() {
    this.formats = this.getDefaultFormats()
  }
  getDefaultFormats() {
    const t = {},
      n = this.address.bind(this),
      r = this.bigNumber.bind(this),
      i = this.blockTag.bind(this),
      s = this.data.bind(this),
      o = this.hash.bind(this),
      a = this.hex.bind(this),
      c = this.number.bind(this),
      l = this.type.bind(this),
      u = f => this.data(f, !0);
    return t.transaction = {
      hash: o,
      type: l,
      accessList: ht.allowNull(this.accessList.bind(this), null),
      blockHash: ht.allowNull(o, null),
      blockNumber: ht.allowNull(c, null),
      transactionIndex: ht.allowNull(c, null),
      confirmations: ht.allowNull(c, null),
      from: n,
      gasPrice: ht.allowNull(r),
      maxPriorityFeePerGas: ht.allowNull(r),
      maxFeePerGas: ht.allowNull(r),
      gasLimit: r,
      to: ht.allowNull(n, null),
      value: r,
      nonce: c,
      data: s,
      r: ht.allowNull(this.uint256),
      s: ht.allowNull(this.uint256),
      v: ht.allowNull(c),
      creates: ht.allowNull(n, null),
      raw: ht.allowNull(s)
    }, t.transactionRequest = {
      from: ht.allowNull(n),
      nonce: ht.allowNull(c),
      gasLimit: ht.allowNull(r),
      gasPrice: ht.allowNull(r),
      maxPriorityFeePerGas: ht.allowNull(r),
      maxFeePerGas: ht.allowNull(r),
      to: ht.allowNull(n),
      value: ht.allowNull(r),
      data: ht.allowNull(u),
      type: ht.allowNull(c),
      accessList: ht.allowNull(this.accessList.bind(this), null)
    }, t.receiptLog = {
      transactionIndex: c,
      blockNumber: c,
      transactionHash: o,
      address: n,
      topics: ht.arrayOf(o),
      data: s,
      logIndex: c,
      blockHash: o
    }, t.receipt = {
      to: ht.allowNull(this.address, null),
      from: ht.allowNull(this.address, null),
      contractAddress: ht.allowNull(n, null),
      transactionIndex: c,
      root: ht.allowNull(a),
      gasUsed: r,
      logsBloom: ht.allowNull(s),
      blockHash: o,
      transactionHash: o,
      logs: ht.arrayOf(this.receiptLog.bind(this)),
      blockNumber: c,
      confirmations: ht.allowNull(c, null),
      cumulativeGasUsed: r,
      effectiveGasPrice: ht.allowNull(r),
      status: ht.allowNull(c),
      type: l
    }, t.block = {
      hash: ht.allowNull(o),
      parentHash: o,
      number: c,
      timestamp: c,
      nonce: ht.allowNull(a),
      difficulty: this.difficulty.bind(this),
      gasLimit: r,
      gasUsed: r,
      miner: ht.allowNull(n),
      extraData: s,
      transactions: ht.allowNull(ht.arrayOf(o)),
      baseFeePerGas: ht.allowNull(r)
    }, t.blockWithTransactions = Cr(t.block), t.blockWithTransactions.transactions = ht.allowNull(ht.arrayOf(this.transactionResponse.bind(this))), t.filter = {
      fromBlock: ht.allowNull(i, void 0),
      toBlock: ht.allowNull(i, void 0),
      blockHash: ht.allowNull(o, void 0),
      address: ht.allowNull(n, void 0),
      topics: ht.allowNull(this.topics.bind(this), void 0)
    }, t.filterLog = {
      blockNumber: ht.allowNull(c),
      blockHash: ht.allowNull(o),
      transactionIndex: c,
      removed: ht.allowNull(this.boolean.bind(this)),
      address: n,
      data: ht.allowFalsish(s, "0x"),
      topics: ht.arrayOf(o),
      transactionHash: o,
      logIndex: c
    }, t
  }
  accessList(t) {
    return Tm(t || [])
  }
  number(t) {
    return t === "0x" ? 0 : st.from(t).toNumber()
  }
  type(t) {
    return t === "0x" || t == null ? 0 : st.from(t).toNumber()
  }
  bigNumber(t) {
    return st.from(t)
  }
  boolean(t) {
    if (typeof t == "boolean") return t;
    if (typeof t == "string") {
      if (t = t.toLowerCase(), t === "true") return !0;
      if (t === "false") return !1
    }
    throw new Error("invalid boolean - " + t)
  }
  hex(t, n) {
    return typeof t == "string" && (!n && t.substring(0, 2) !== "0x" && (t = "0x" + t), pn(t)) ? t.toLowerCase() : Pg.throwArgumentError("invalid hash", "value", t)
  }
  data(t, n) {
    const r = this.hex(t, n);
    if (r.length % 2 !== 0) throw new Error("invalid data; odd-length - " + t);
    return r
  }
  address(t) {
    return ki(t)
  }
  callAddress(t) {
    if (!pn(t, 32)) return null;
    const n = ki(rs(t, 12));
    return n === bk ? null : n
  }
  contractAddress(t) {
    return OV(t)
  }
  blockTag(t) {
    if (t == null) return "latest";
    if (t === "earliest") return "0x0";
    switch (t) {
      case "earliest":
        return "0x0";
      case "latest":
      case "pending":
      case "safe":
      case "finalized":
        return t
    }
    if (typeof t == "number" || pn(t)) return mk(t);
    throw new Error("invalid blockTag")
  }
  hash(t, n) {
    const r = this.hex(t, n);
    return oh(r) !== 32 ? Pg.throwArgumentError("invalid hash", "value", t) : r
  }
  difficulty(t) {
    if (t == null) return null;
    const n = st.from(t);
    try {
      return n.toNumber()
    } catch {}
    return null
  }
  uint256(t) {
    if (!pn(t)) throw new Error("invalid uint256");
    return zr(t, 32)
  }
  _block(t, n) {
    t.author != null && t.miner == null && (t.miner = t.author);
    const r = t._difficulty != null ? t._difficulty : t.difficulty,
      i = ht.check(n, t);
    return i._difficulty = r == null ? null : st.from(r), i
  }
  block(t) {
    return this._block(t, this.formats.block)
  }
  blockWithTransactions(t) {
    return this._block(t, this.formats.blockWithTransactions)
  }
  transactionRequest(t) {
    return ht.check(this.formats.transactionRequest, t)
  }
  transactionResponse(t) {
    t.gas != null && t.gasLimit == null && (t.gasLimit = t.gas), t.to && st.from(t.to).isZero() && (t.to = "0x0000000000000000000000000000000000000000"), t.input != null && t.data == null && (t.data = t.input), t.to == null && t.creates == null && (t.creates = this.contractAddress(t)), (t.type === 1 || t.type === 2) && t.accessList == null && (t.accessList = []);
    const n = ht.check(this.formats.transaction, t);
    if (t.chainId != null) {
      let r = t.chainId;
      pn(r) && (r = st.from(r).toNumber()), n.chainId = r
    } else {
      let r = t.networkId;
      r == null && n.v == null && (r = t.chainId), pn(r) && (r = st.from(r).toNumber()), typeof r != "number" && n.v != null && (r = (n.v - 35) / 2, r < 0 && (r = 0), r = parseInt(r)), typeof r != "number" && (r = 0), n.chainId = r
    }
    return n.blockHash && n.blockHash.replace(/0/g, "") === "x" && (n.blockHash = null), n
  }
  transaction(t) {
    return _4e(t)
  }
  receiptLog(t) {
    return ht.check(this.formats.receiptLog, t)
  }
  receipt(t) {
    const n = ht.check(this.formats.receipt, t);
    if (n.root != null)
      if (n.root.length <= 4) {
        const r = st.from(n.root).toNumber();
        r === 0 || r === 1 ? (n.status != null && n.status !== r && Pg.throwArgumentError("alt-root-status/status mismatch", "value", {
          root: n.root,
          status: n.status
        }), n.status = r, delete n.root) : Pg.throwArgumentError("invalid alt-root-status", "value.root", n.root)
      } else n.root.length !== 66 && Pg.throwArgumentError("invalid root hash", "value.root", n.root);
    return n.status != null && (n.byzantium = !0), n
  }
  topics(t) {
    return Array.isArray(t) ? t.map(n => this.topics(n)) : t != null ? this.hash(t, !0) : null
  }
  filter(t) {
    return ht.check(this.formats.filter, t)
  }
  filterLog(t) {
    return ht.check(this.formats.filterLog, t)
  }
  static check(t, n) {
    const r = {};
    for (const i in t) try {
      const s = t[i](n[i]);
      s !== void 0 && (r[i] = s)
    } catch (s) {
      throw s.checkKey = i, s.checkValue = n[i], s
    }
    return r
  }
  static allowNull(t, n) {
    return function (r) {
      return r == null ? n : t(r)
    }
  }
  static allowFalsish(t, n) {
    return function (r) {
      return r ? t(r) : n
    }
  }
  static arrayOf(t) {
    return function (n) {
      if (!Array.isArray(n)) throw new Error("not an array");
      const r = [];
      return n.forEach(function (i) {
        r.push(t(i))
      }), r
    }
  }
};

function eSe(e) {
  return e && typeof e.isCommunityResource == "function"
}

function kM(e) {
  return eSe(e) && e.isCommunityResource()
}
var Gt = function (e, t, n, r) {
  function i(s) {
    return s instanceof n ? s : new n(function (o) {
      o(s)
    })
  }
  return new(n || (n = Promise))(function (s, o) {
    function a(u) {
      try {
        l(r.next(u))
      } catch (f) {
        o(f)
      }
    }

    function c(u) {
      try {
        l(r.throw(u))
      } catch (f) {
        o(f)
      }
    }

    function l(u) {
      u.done ? s(u.value) : i(u.value).then(a, c)
    }
    l((r = r.apply(e, t || [])).next())
  })
};
const dn = new Ae(km),
  tSe = 10;

function _M(e) {
  return e == null ? "null" : (oh(e) !== 32 && dn.throwArgumentError("invalid topic", "topic", e), e.toLowerCase())
}

function IM(e) {
  for (e = e.slice(); e.length > 0 && e[e.length - 1] == null;) e.pop();
  return e.map(t => {
    if (Array.isArray(t)) {
      const n = {};
      t.forEach(i => {
        n[_M(i)] = !0
      });
      const r = Object.keys(n);
      return r.sort(), r.join("|")
    } else return _M(t)
  }).join("&")
}

function nSe(e) {
  return e === "" ? [] : e.split(/&/g).map(t => {
    if (t === "") return [];
    const n = t.split("|").map(r => r === "null" ? null : r);
    return n.length === 1 ? n[0] : n
  })
}

function m0(e) {
  if (typeof e == "string") {
    if (e = e.toLowerCase(), oh(e) === 32) return "tx:" + e;
    if (e.indexOf(":") === -1) return e
  } else {
    if (Array.isArray(e)) return "filter:*:" + IM(e);
    if (R6e.isForkEvent(e)) throw dn.warn("not implemented"), new Error("not implemented");
    if (e && typeof e == "object") return "filter:" + (e.address || "*") + ":" + IM(e.topics || [])
  }
  throw new Error("invalid event - " + e)
}

function Rg() {
  return new Date().getTime()
}

function PM(e) {
  return new Promise(t => {
    setTimeout(t, e)
  })
}
const rSe = ["block", "network", "pending", "poll"];
let iSe = class {
  constructor(t, n, r) {
    Ge(this, "tag", t), Ge(this, "listener", n), Ge(this, "once", r), this._lastBlockNumber = -2, this._inflight = !1
  }
  get event() {
    switch (this.type) {
      case "tx":
        return this.hash;
      case "filter":
        return this.filter
    }
    return this.tag
  }
  get type() {
    return this.tag.split(":")[0]
  }
  get hash() {
    const t = this.tag.split(":");
    return t[0] !== "tx" ? null : t[1]
  }
  get filter() {
    const t = this.tag.split(":");
    if (t[0] !== "filter") return null;
    const n = t[1],
      r = nSe(t[2]),
      i = {};
    return r.length > 0 && (i.topics = r), n && n !== "*" && (i.address = n), i
  }
  pollable() {
    return this.tag.indexOf(":") >= 0 || rSe.indexOf(this.tag) >= 0
  }
};
const sSe = {
  0: {
    symbol: "btc",
    p2pkh: 0,
    p2sh: 5,
    prefix: "bc"
  },
  2: {
    symbol: "ltc",
    p2pkh: 48,
    p2sh: 50,
    prefix: "ltc"
  },
  3: {
    symbol: "doge",
    p2pkh: 30,
    p2sh: 22
  },
  60: {
    symbol: "eth",
    ilk: "eth"
  },
  61: {
    symbol: "etc",
    ilk: "eth"
  },
  700: {
    symbol: "xdai",
    ilk: "eth"
  }
};

function BS(e) {
  return zr(st.from(e).toHexString(), 32)
}

function RM(e) {
  return mA.encode(Bo([e, rs(bM(bM(e)), 0, 4)]))
}
const IW = new RegExp("^(ipfs)://(.*)$", "i"),
  OM = [new RegExp("^(https)://(.*)$", "i"), new RegExp("^(data):(.*)$", "i"), IW, new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i")];

function Cw(e, t) {
  try {
    return ry(u2(e, t))
  } catch {}
  return null
}

function u2(e, t) {
  if (e === "0x") return null;
  const n = st.from(rs(e, t, t + 32)).toNumber(),
    r = st.from(rs(e, n, n + 32)).toNumber();
  return rs(e, n + 32, n + 32 + r)
}

function FS(e) {
  return e.match(/^ipfs:\/\/ipfs\//i) ? e = e.substring(12) : e.match(/^ipfs:\/\//i) ? e = e.substring(7) : dn.throwArgumentError("unsupported IPFS format", "link", e), `https://gateway.ipfs.io/ipfs/${e}`
}

function DM(e) {
  const t = jt(e);
  if (t.length > 32) throw new Error("internal; should not happen");
  const n = new Uint8Array(32);
  return n.set(t, 32 - t.length), n
}

function oSe(e) {
  if (e.length % 32 === 0) return e;
  const t = new Uint8Array(Math.ceil(e.length / 32) * 32);
  return t.set(e), t
}

function PW(e) {
  const t = [];
  let n = 0;
  for (let r = 0; r < e.length; r++) t.push(null), n += 32;
  for (let r = 0; r < e.length; r++) {
    const i = jt(e[r]);
    t[r] = DM(n), t.push(DM(i.length)), t.push(oSe(i)), n += 32 + Math.ceil(i.length / 32) * 32
  }
  return to(t)
}
class NM {
  constructor(t, n, r, i) {
    Ge(this, "provider", t), Ge(this, "name", r), Ge(this, "address", t.formatter.address(n)), Ge(this, "_resolvedAddress", i)
  }
  supportsWildcard() {
    return this._supportsEip2544 || (this._supportsEip2544 = this.provider.call({
      to: this.address,
      data: "0x01ffc9a79061b92300000000000000000000000000000000000000000000000000000000"
    }).then(t => st.from(t).eq(1)).catch(t => {
      if (t.code === Ae.errors.CALL_EXCEPTION) return !1;
      throw this._supportsEip2544 = null, t
    })), this._supportsEip2544
  }
  _fetch(t, n) {
    return Gt(this, void 0, void 0, function* () {
      const r = {
        to: this.address,
        ccipReadEnabled: !0,
        data: to([t, ww(this.name), n || "0x"])
      };
      let i = !1;
      (yield this.supportsWildcard()) && (i = !0, r.data = to(["0x9061b923", PW([g6e(this.name), r.data])]));
      try {
        let s = yield this.provider.call(r);
        return jt(s).length % 32 === 4 && dn.throwError("resolver threw error", Ae.errors.CALL_EXCEPTION, {
          transaction: r,
          data: s
        }), i && (s = u2(s, 0)), s
      } catch (s) {
        if (s.code === Ae.errors.CALL_EXCEPTION) return null;
        throw s
      }
    })
  }
  _fetchBytes(t, n) {
    return Gt(this, void 0, void 0, function* () {
      const r = yield this._fetch(t, n);
      return r != null ? u2(r, 0) : null
    })
  }
  _getAddress(t, n) {
    const r = sSe[String(t)];
    if (r == null && dn.throwError(`unsupported coin type: ${t}`, Ae.errors.UNSUPPORTED_OPERATION, {
        operation: `getAddress(${t})`
      }), r.ilk === "eth") return this.provider.formatter.address(n);
    const i = jt(n);
    if (r.p2pkh != null) {
      const s = n.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/);
      if (s) {
        const o = parseInt(s[1], 16);
        if (s[2].length === o * 2 && o >= 1 && o <= 75) return RM(Bo([
          [r.p2pkh], "0x" + s[2]
        ]))
      }
    }
    if (r.p2sh != null) {
      const s = n.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/);
      if (s) {
        const o = parseInt(s[1], 16);
        if (s[2].length === o * 2 && o >= 1 && o <= 75) return RM(Bo([
          [r.p2sh], "0x" + s[2]
        ]))
      }
    }
    if (r.prefix != null) {
      const s = i[1];
      let o = i[0];
      if (o === 0 ? s !== 20 && s !== 32 && (o = -1) : o = -1, o >= 0 && i.length === 2 + s && s >= 1 && s <= 75) {
        const a = AM.toWords(i.slice(2));
        return a.unshift(o), AM.encode(r.prefix, a)
      }
    }
    return null
  }
  getAddress(t) {
    return Gt(this, void 0, void 0, function* () {
      if (t == null && (t = 60), t === 60) try {
        const i = yield this._fetch("0x3b3b57de");
        return i === "0x" || i === N5e ? null : this.provider.formatter.callAddress(i)
      } catch (i) {
        if (i.code === Ae.errors.CALL_EXCEPTION) return null;
        throw i
      }
      const n = yield this._fetchBytes("0xf1cb7e06", BS(t));
      if (n == null || n === "0x") return null;
      const r = this._getAddress(t, n);
      return r == null && dn.throwError("invalid or unsupported coin data", Ae.errors.UNSUPPORTED_OPERATION, {
        operation: `getAddress(${t})`,
        coinType: t,
        data: n
      }), r
    })
  }
  getAvatar() {
    return Gt(this, void 0, void 0, function* () {
      const t = [{
        type: "name",
        content: this.name
      }];
      try {
        const n = yield this.getText("avatar");
        if (n == null) return null;
        for (let r = 0; r < OM.length; r++) {
          const i = n.match(OM[r]);
          if (i == null) continue;
          const s = i[1].toLowerCase();
          switch (s) {
            case "https":
              return t.push({
                type: "url",
                content: n
              }), {
                linkage: t,
                url: n
              };
            case "data":
              return t.push({
                type: "data",
                content: n
              }), {
                linkage: t,
                url: n
              };
            case "ipfs":
              return t.push({
                type: "ipfs",
                content: n
              }), {
                linkage: t,
                url: FS(n)
              };
            case "erc721":
            case "erc1155": {
              const o = s === "erc721" ? "0xc87b56dd" : "0x0e89341c";
              t.push({
                type: s,
                content: n
              });
              const a = this._resolvedAddress || (yield this.getAddress()),
                c = (i[2] || "").split("/");
              if (c.length !== 2) return null;
              const l = yield this.provider.formatter.address(c[0]), u = zr(st.from(c[1]).toHexString(), 32);
              if (s === "erc721") {
                const x = this.provider.formatter.callAddress(yield this.provider.call({
                  to: l,
                  data: to(["0x6352211e", u])
                }));
                if (a !== x) return null;
                t.push({
                  type: "owner",
                  content: x
                })
              } else if (s === "erc1155") {
                const x = st.from(yield this.provider.call({
                  to: l,
                  data: to(["0x00fdd58e", zr(a, 32), u])
                }));
                if (x.isZero()) return null;
                t.push({
                  type: "balance",
                  content: x.toString()
                })
              }
              const f = {
                to: this.provider.formatter.address(c[0]),
                data: to([o, u])
              };
              let h = Cw(yield this.provider.call(f), 0);
              if (h == null) return null;
              t.push({
                type: "metadata-url-base",
                content: h
              }), s === "erc1155" && (h = h.replace("{id}", u.substring(2)), t.push({
                type: "metadata-url-expanded",
                content: h
              })), h.match(/^ipfs:/i) && (h = FS(h)), t.push({
                type: "metadata-url",
                content: h
              });
              const g = yield Tk(h);
              if (!g) return null;
              t.push({
                type: "metadata",
                content: JSON.stringify(g)
              });
              let y = g.image;
              if (typeof y != "string") return null;
              if (!y.match(/^(https:\/\/|data:)/i)) {
                if (y.match(IW) == null) return null;
                t.push({
                  type: "url-ipfs",
                  content: y
                }), y = FS(y)
              }
              return t.push({
                type: "url",
                content: y
              }), {
                linkage: t,
                url: y
              }
            }
          }
        }
      } catch {}
      return null
    })
  }
  getContentHash() {
    return Gt(this, void 0, void 0, function* () {
      const t = yield this._fetchBytes("0xbc1c58d1");
      if (t == null || t === "0x") return null;
      const n = t.match(/^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
      if (n) {
        const o = parseInt(n[3], 16);
        if (n[4].length === o * 2) return "ipfs://" + mA.encode("0x" + n[1])
      }
      const r = t.match(/^0xe5010172(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
      if (r) {
        const o = parseInt(r[3], 16);
        if (r[4].length === o * 2) return "ipns://" + mA.encode("0x" + r[1])
      }
      const i = t.match(/^0xe40101fa011b20([0-9a-f]*)$/);
      if (i && i[1].length === 32 * 2) return "bzz://" + i[1];
      const s = t.match(/^0x90b2c605([0-9a-f]*)$/);
      if (s && s[1].length === 34 * 2) {
        const o = {
          "=": "",
          "+": "-",
          "/": "_"
        };
        return "sia://" + zV("0x" + s[1]).replace(/[=+\/]/g, c => o[c])
      }
      return dn.throwError("invalid or unsupported content hash data", Ae.errors.UNSUPPORTED_OPERATION, {
        operation: "getContentHash()",
        data: t
      })
    })
  }
  getText(t) {
    return Gt(this, void 0, void 0, function* () {
      let n = fl(t);
      n = Bo([BS(64), BS(n.length), n]), n.length % 32 !== 0 && (n = Bo([n, zr("0x", 32 - t.length % 32)]));
      const r = yield this._fetchBytes("0x59d1d43c", St(n));
      return r == null || r === "0x" ? null : ry(r)
    })
  }
}
let jS = null,
  aSe = 1;
class RW extends iy {
  constructor(t) {
    if (super(), this._events = [], this._emitted = {
        block: -2
      }, this.disableCcipRead = !1, this.formatter = new.target.getFormatter(), Ge(this, "anyNetwork", t === "any"), this.anyNetwork && (t = this.detectNetwork()), t instanceof Promise) this._networkPromise = t, t.catch(n => {}), this._ready().catch(n => {});
    else {
      const n = Xc(new.target, "getNetwork")(t);
      n ? (Ge(this, "_network", n), this.emit("network", n, null)) : dn.throwArgumentError("invalid network", "network", t)
    }
    this._maxInternalBlockNumber = -1024, this._lastBlockNumber = -2, this._maxFilterBlockRange = 10, this._pollingInterval = 4e3, this._fastQueryDate = 0
  }
  _ready() {
    return Gt(this, void 0, void 0, function* () {
      if (this._network == null) {
        let t = null;
        if (this._networkPromise) try {
          t = yield this._networkPromise
        } catch {}
        t == null && (t = yield this.detectNetwork()), t || dn.throwError("no network detected", Ae.errors.UNKNOWN_ERROR, {}), this._network == null && (this.anyNetwork ? this._network = t : Ge(this, "_network", t), this.emit("network", t, null))
      }
      return this._network
    })
  }
  get ready() {
    return Q0(() => this._ready().then(t => t, t => {
      if (!(t.code === Ae.errors.NETWORK_ERROR && t.event === "noNetwork")) throw t
    }))
  }
  static getFormatter() {
    return jS == null && (jS = new TM), jS
  }
  static getNetwork(t) {
    return F4e(t ?? "homestead")
  }
  ccipReadFetch(t, n, r) {
    return Gt(this, void 0, void 0, function* () {
      if (this.disableCcipRead || r.length === 0) return null;
      const i = t.to.toLowerCase(),
        s = n.toLowerCase(),
        o = [];
      for (let a = 0; a < r.length; a++) {
        const c = r[a],
          l = c.replace("{sender}", i).replace("{data}", s),
          u = c.indexOf("{data}") >= 0 ? null : JSON.stringify({
            data: s,
            sender: i
          }),
          f = yield Tk({
            url: l,
            errorPassThrough: !0
          }, u, (g, y) => (g.status = y.statusCode, g));
        if (f.data) return f.data;
        const h = f.message || "unknown error";
        if (f.status >= 400 && f.status < 500) return dn.throwError(`response not found during CCIP fetch: ${h}`, Ae.errors.SERVER_ERROR, {
          url: c,
          errorMessage: h
        });
        o.push(h)
      }
      return dn.throwError(`error encountered during CCIP fetch: ${o.map(a=>JSON.stringify(a)).join(", ")}`, Ae.errors.SERVER_ERROR, {
        urls: r,
        errorMessages: o
      })
    })
  }
  _getInternalBlockNumber(t) {
    return Gt(this, void 0, void 0, function* () {
      if (yield this._ready(), t > 0)
        for (; this._internalBlockNumber;) {
          const i = this._internalBlockNumber;
          try {
            const s = yield i;
            if (Rg() - s.respTime <= t) return s.blockNumber;
            break
          } catch {
            if (this._internalBlockNumber === i) break
          }
        }
      const n = Rg(),
        r = ei({
          blockNumber: this.perform("getBlockNumber", {}),
          networkError: this.getNetwork().then(i => null, i => i)
        }).then(({
          blockNumber: i,
          networkError: s
        }) => {
          if (s) throw this._internalBlockNumber === r && (this._internalBlockNumber = null), s;
          const o = Rg();
          return i = st.from(i).toNumber(), i < this._maxInternalBlockNumber && (i = this._maxInternalBlockNumber), this._maxInternalBlockNumber = i, this._setFastBlockNumber(i), {
            blockNumber: i,
            reqTime: n,
            respTime: o
          }
        });
      return this._internalBlockNumber = r, r.catch(i => {
        this._internalBlockNumber === r && (this._internalBlockNumber = null)
      }), (yield r).blockNumber
    })
  }
  poll() {
    return Gt(this, void 0, void 0, function* () {
      const t = aSe++,
        n = [];
      let r = null;
      try {
        r = yield this._getInternalBlockNumber(100 + this.pollingInterval / 2)
      } catch (i) {
        this.emit("error", i);
        return
      }
      if (this._setFastBlockNumber(r), this.emit("poll", t, r), r === this._lastBlockNumber) {
        this.emit("didPoll", t);
        return
      }
      if (this._emitted.block === -2 && (this._emitted.block = r - 1), Math.abs(this._emitted.block - r) > 1e3) dn.warn(`network block skew detected; skipping block events (emitted=${this._emitted.block} blockNumber${r})`), this.emit("error", dn.makeError("network block skew detected", Ae.errors.NETWORK_ERROR, {
        blockNumber: r,
        event: "blockSkew",
        previousBlockNumber: this._emitted.block
      })), this.emit("block", r);
      else
        for (let i = this._emitted.block + 1; i <= r; i++) this.emit("block", i);
      this._emitted.block !== r && (this._emitted.block = r, Object.keys(this._emitted).forEach(i => {
        if (i === "block") return;
        const s = this._emitted[i];
        s !== "pending" && r - s > 12 && delete this._emitted[i]
      })), this._lastBlockNumber === -2 && (this._lastBlockNumber = r - 1), this._events.forEach(i => {
        switch (i.type) {
          case "tx": {
            const s = i.hash;
            let o = this.getTransactionReceipt(s).then(a => (!a || a.blockNumber == null || (this._emitted["t:" + s] = a.blockNumber, this.emit(s, a)), null)).catch(a => {
              this.emit("error", a)
            });
            n.push(o);
            break
          }
          case "filter": {
            if (!i._inflight) {
              i._inflight = !0, i._lastBlockNumber === -2 && (i._lastBlockNumber = r - 1);
              const s = i.filter;
              s.fromBlock = i._lastBlockNumber + 1, s.toBlock = r;
              const o = s.toBlock - this._maxFilterBlockRange;
              o > s.fromBlock && (s.fromBlock = o), s.fromBlock < 0 && (s.fromBlock = 0);
              const a = this.getLogs(s).then(c => {
                i._inflight = !1, c.length !== 0 && c.forEach(l => {
                  l.blockNumber > i._lastBlockNumber && (i._lastBlockNumber = l.blockNumber), this._emitted["b:" + l.blockHash] = l.blockNumber, this._emitted["t:" + l.transactionHash] = l.blockNumber, this.emit(s, l)
                })
              }).catch(c => {
                this.emit("error", c), i._inflight = !1
              });
              n.push(a)
            }
            break
          }
        }
      }), this._lastBlockNumber = r, Promise.all(n).then(() => {
        this.emit("didPoll", t)
      }).catch(i => {
        this.emit("error", i)
      })
    })
  }
  resetEventsBlock(t) {
    this._lastBlockNumber = t - 1, this.polling && this.poll()
  }
  get network() {
    return this._network
  }
  detectNetwork() {
    return Gt(this, void 0, void 0, function* () {
      return dn.throwError("provider does not support network detection", Ae.errors.UNSUPPORTED_OPERATION, {
        operation: "provider.detectNetwork"
      })
    })
  }
  getNetwork() {
    return Gt(this, void 0, void 0, function* () {
      const t = yield this._ready(), n = yield this.detectNetwork();
      if (t.chainId !== n.chainId) {
        if (this.anyNetwork) return this._network = n, this._lastBlockNumber = -2, this._fastBlockNumber = null, this._fastBlockNumberPromise = null, this._fastQueryDate = 0, this._emitted.block = -2, this._maxInternalBlockNumber = -1024, this._internalBlockNumber = null, this.emit("network", n, t), yield PM(0), this._network;
        const r = dn.makeError("underlying network changed", Ae.errors.NETWORK_ERROR, {
          event: "changed",
          network: t,
          detectedNetwork: n
        });
        throw this.emit("error", r), r
      }
      return t
    })
  }
  get blockNumber() {
    return this._getInternalBlockNumber(100 + this.pollingInterval / 2).then(t => {
      this._setFastBlockNumber(t)
    }, t => {}), this._fastBlockNumber != null ? this._fastBlockNumber : -1
  }
  get polling() {
    return this._poller != null
  }
  set polling(t) {
    t && !this._poller ? (this._poller = setInterval(() => {
      this.poll()
    }, this.pollingInterval), this._bootstrapPoll || (this._bootstrapPoll = setTimeout(() => {
      this.poll(), this._bootstrapPoll = setTimeout(() => {
        this._poller || this.poll(), this._bootstrapPoll = null
      }, this.pollingInterval)
    }, 0))) : !t && this._poller && (clearInterval(this._poller), this._poller = null)
  }
  get pollingInterval() {
    return this._pollingInterval
  }
  set pollingInterval(t) {
    if (typeof t != "number" || t <= 0 || parseInt(String(t)) != t) throw new Error("invalid polling interval");
    this._pollingInterval = t, this._poller && (clearInterval(this._poller), this._poller = setInterval(() => {
      this.poll()
    }, this._pollingInterval))
  }
  _getFastBlockNumber() {
    const t = Rg();
    return t - this._fastQueryDate > 2 * this._pollingInterval && (this._fastQueryDate = t, this._fastBlockNumberPromise = this.getBlockNumber().then(n => ((this._fastBlockNumber == null || n > this._fastBlockNumber) && (this._fastBlockNumber = n), this._fastBlockNumber))), this._fastBlockNumberPromise
  }
  _setFastBlockNumber(t) {
    this._fastBlockNumber != null && t < this._fastBlockNumber || (this._fastQueryDate = Rg(), (this._fastBlockNumber == null || t > this._fastBlockNumber) && (this._fastBlockNumber = t, this._fastBlockNumberPromise = Promise.resolve(t)))
  }
  waitForTransaction(t, n, r) {
    return Gt(this, void 0, void 0, function* () {
      return this._waitForTransaction(t, n ?? 1, r || 0, null)
    })
  }
  _waitForTransaction(t, n, r, i) {
    return Gt(this, void 0, void 0, function* () {
      const s = yield this.getTransactionReceipt(t);
      return (s ? s.confirmations : 0) >= n ? s : new Promise((o, a) => {
        const c = [];
        let l = !1;
        const u = function () {
            return l ? !0 : (l = !0, c.forEach(h => {
              h()
            }), !1)
          },
          f = h => {
            h.confirmations < n || u() || o(h)
          };
        if (this.on(t, f), c.push(() => {
            this.removeListener(t, f)
          }), i) {
          let h = i.startBlock,
            g = null;
          const y = x => Gt(this, void 0, void 0, function* () {
            l || (yield PM(1e3), this.getTransactionCount(i.from).then(k => Gt(this, void 0, void 0, function* () {
              if (!l) {
                if (k <= i.nonce) h = x;
                else {
                  {
                    const _ = yield this.getTransaction(t);
                    if (_ && _.blockNumber != null) return
                  }
                  for (g == null && (g = h - 3, g < i.startBlock && (g = i.startBlock)); g <= x;) {
                    if (l) return;
                    const _ = yield this.getBlockWithTransactions(g);
                    for (let p = 0; p < _.transactions.length; p++) {
                      const v = _.transactions[p];
                      if (v.hash === t) return;
                      if (v.from === i.from && v.nonce === i.nonce) {
                        if (l) return;
                        const S = yield this.waitForTransaction(v.hash, n);
                        if (u()) return;
                        let I = "replaced";
                        v.data === i.data && v.to === i.to && v.value.eq(i.value) ? I = "repriced" : v.data === "0x" && v.from === v.to && v.value.isZero() && (I = "cancelled"), a(dn.makeError("transaction was replaced", Ae.errors.TRANSACTION_REPLACED, {
                          cancelled: I === "replaced" || I === "cancelled",
                          reason: I,
                          replacement: this._wrapTransaction(v),
                          hash: t,
                          receipt: S
                        }));
                        return
                      }
                    }
                    g++
                  }
                }
                l || this.once("block", y)
              }
            }), k => {
              l || this.once("block", y)
            }))
          });
          if (l) return;
          this.once("block", y), c.push(() => {
            this.removeListener("block", y)
          })
        }
        if (typeof r == "number" && r > 0) {
          const h = setTimeout(() => {
            u() || a(dn.makeError("timeout exceeded", Ae.errors.TIMEOUT, {
              timeout: r
            }))
          }, r);
          h.unref && h.unref(), c.push(() => {
            clearTimeout(h)
          })
        }
      })
    })
  }
  getBlockNumber() {
    return Gt(this, void 0, void 0, function* () {
      return this._getInternalBlockNumber(0)
    })
  }
  getGasPrice() {
    return Gt(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const t = yield this.perform("getGasPrice", {});
      try {
        return st.from(t)
      } catch (n) {
        return dn.throwError("bad result from backend", Ae.errors.SERVER_ERROR, {
          method: "getGasPrice",
          result: t,
          error: n
        })
      }
    })
  }
  getBalance(t, n) {
    return Gt(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const r = yield ei({
        address: this._getAddress(t),
        blockTag: this._getBlockTag(n)
      }), i = yield this.perform("getBalance", r);
      try {
        return st.from(i)
      } catch (s) {
        return dn.throwError("bad result from backend", Ae.errors.SERVER_ERROR, {
          method: "getBalance",
          params: r,
          result: i,
          error: s
        })
      }
    })
  }
  getTransactionCount(t, n) {
    return Gt(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const r = yield ei({
        address: this._getAddress(t),
        blockTag: this._getBlockTag(n)
      }), i = yield this.perform("getTransactionCount", r);
      try {
        return st.from(i).toNumber()
      } catch (s) {
        return dn.throwError("bad result from backend", Ae.errors.SERVER_ERROR, {
          method: "getTransactionCount",
          params: r,
          result: i,
          error: s
        })
      }
    })
  }
  getCode(t, n) {
    return Gt(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const r = yield ei({
        address: this._getAddress(t),
        blockTag: this._getBlockTag(n)
      }), i = yield this.perform("getCode", r);
      try {
        return St(i)
      } catch (s) {
        return dn.throwError("bad result from backend", Ae.errors.SERVER_ERROR, {
          method: "getCode",
          params: r,
          result: i,
          error: s
        })
      }
    })
  }
  getStorageAt(t, n, r) {
    return Gt(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const i = yield ei({
        address: this._getAddress(t),
        blockTag: this._getBlockTag(r),
        position: Promise.resolve(n).then(o => mk(o))
      }), s = yield this.perform("getStorageAt", i);
      try {
        return St(s)
      } catch (o) {
        return dn.throwError("bad result from backend", Ae.errors.SERVER_ERROR, {
          method: "getStorageAt",
          params: i,
          result: s,
          error: o
        })
      }
    })
  }
  _wrapTransaction(t, n, r) {
    if (n != null && oh(n) !== 32) throw new Error("invalid response - sendTransaction");
    const i = t;
    return n != null && t.hash !== n && dn.throwError("Transaction hash mismatch from Provider.sendTransaction.", Ae.errors.UNKNOWN_ERROR, {
      expectedHash: t.hash,
      returnedHash: n
    }), i.wait = (s, o) => Gt(this, void 0, void 0, function* () {
      s == null && (s = 1), o == null && (o = 0);
      let a;
      s !== 0 && r != null && (a = {
        data: t.data,
        from: t.from,
        nonce: t.nonce,
        to: t.to,
        value: t.value,
        startBlock: r
      });
      const c = yield this._waitForTransaction(t.hash, s, o, a);
      return c == null && s === 0 ? null : (this._emitted["t:" + t.hash] = c.blockNumber, c.status === 0 && dn.throwError("transaction failed", Ae.errors.CALL_EXCEPTION, {
        transactionHash: t.hash,
        transaction: t,
        receipt: c
      }), c)
    }), i
  }
  sendTransaction(t) {
    return Gt(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const n = yield Promise.resolve(t).then(s => St(s)), r = this.formatter.transaction(t);
      r.confirmations == null && (r.confirmations = 0);
      const i = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
      try {
        const s = yield this.perform("sendTransaction", {
          signedTransaction: n
        });
        return this._wrapTransaction(r, s, i)
      } catch (s) {
        throw s.transaction = r, s.transactionHash = r.hash, s
      }
    })
  }
  _getTransactionRequest(t) {
    return Gt(this, void 0, void 0, function* () {
      const n = yield t, r = {};
      return ["from", "to"].forEach(i => {
        n[i] != null && (r[i] = Promise.resolve(n[i]).then(s => s ? this._getAddress(s) : null))
      }), ["gasLimit", "gasPrice", "maxFeePerGas", "maxPriorityFeePerGas", "value"].forEach(i => {
        n[i] != null && (r[i] = Promise.resolve(n[i]).then(s => s ? st.from(s) : null))
      }), ["type"].forEach(i => {
        n[i] != null && (r[i] = Promise.resolve(n[i]).then(s => s ?? null))
      }), n.accessList && (r.accessList = this.formatter.accessList(n.accessList)), ["data"].forEach(i => {
        n[i] != null && (r[i] = Promise.resolve(n[i]).then(s => s ? St(s) : null))
      }), this.formatter.transactionRequest(yield ei(r))
    })
  }
  _getFilter(t) {
    return Gt(this, void 0, void 0, function* () {
      t = yield t;
      const n = {};
      return t.address != null && (n.address = this._getAddress(t.address)), ["blockHash", "topics"].forEach(r => {
        t[r] != null && (n[r] = t[r])
      }), ["fromBlock", "toBlock"].forEach(r => {
        t[r] != null && (n[r] = this._getBlockTag(t[r]))
      }), this.formatter.filter(yield ei(n))
    })
  }
  _call(t, n, r) {
    return Gt(this, void 0, void 0, function* () {
      r >= tSe && dn.throwError("CCIP read exceeded maximum redirections", Ae.errors.SERVER_ERROR, {
        redirects: r,
        transaction: t
      });
      const i = t.to,
        s = yield this.perform("call", {
          transaction: t,
          blockTag: n
        });
      if (r >= 0 && n === "latest" && i != null && s.substring(0, 10) === "0x556f1830" && oh(s) % 32 === 4) try {
        const o = rs(s, 4),
          a = rs(o, 0, 32);
        st.from(a).eq(i) || dn.throwError("CCIP Read sender did not match", Ae.errors.CALL_EXCEPTION, {
          name: "OffchainLookup",
          signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
          transaction: t,
          data: s
        });
        const c = [],
          l = st.from(rs(o, 32, 64)).toNumber(),
          u = st.from(rs(o, l, l + 32)).toNumber(),
          f = rs(o, l + 32);
        for (let _ = 0; _ < u; _++) {
          const p = Cw(f, _ * 32);
          p == null && dn.throwError("CCIP Read contained corrupt URL string", Ae.errors.CALL_EXCEPTION, {
            name: "OffchainLookup",
            signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
            transaction: t,
            data: s
          }), c.push(p)
        }
        const h = u2(o, 64);
        st.from(rs(o, 100, 128)).isZero() || dn.throwError("CCIP Read callback selector included junk", Ae.errors.CALL_EXCEPTION, {
          name: "OffchainLookup",
          signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
          transaction: t,
          data: s
        });
        const g = rs(o, 96, 100),
          y = u2(o, 128),
          x = yield this.ccipReadFetch(t, h, c);
        x == null && dn.throwError("CCIP Read disabled or provided no URLs", Ae.errors.CALL_EXCEPTION, {
          name: "OffchainLookup",
          signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
          transaction: t,
          data: s
        });
        const k = {
          to: i,
          data: to([g, PW([x, y])])
        };
        return this._call(k, n, r + 1)
      } catch (o) {
        if (o.code === Ae.errors.SERVER_ERROR) throw o
      }
      try {
        return St(s)
      } catch (o) {
        return dn.throwError("bad result from backend", Ae.errors.SERVER_ERROR, {
          method: "call",
          params: {
            transaction: t,
            blockTag: n
          },
          result: s,
          error: o
        })
      }
    })
  }
  call(t, n) {
    return Gt(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const r = yield ei({
        transaction: this._getTransactionRequest(t),
        blockTag: this._getBlockTag(n),
        ccipReadEnabled: Promise.resolve(t.ccipReadEnabled)
      });
      return this._call(r.transaction, r.blockTag, r.ccipReadEnabled ? 0 : -1)
    })
  }
  estimateGas(t) {
    return Gt(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const n = yield ei({
        transaction: this._getTransactionRequest(t)
      }), r = yield this.perform("estimateGas", n);
      try {
        return st.from(r)
      } catch (i) {
        return dn.throwError("bad result from backend", Ae.errors.SERVER_ERROR, {
          method: "estimateGas",
          params: n,
          result: r,
          error: i
        })
      }
    })
  }
  _getAddress(t) {
    return Gt(this, void 0, void 0, function* () {
      t = yield t, typeof t != "string" && dn.throwArgumentError("invalid address or ENS name", "name", t);
      const n = yield this.resolveName(t);
      return n == null && dn.throwError("ENS name not configured", Ae.errors.UNSUPPORTED_OPERATION, {
        operation: `resolveName(${JSON.stringify(t)})`
      }), n
    })
  }
  _getBlock(t, n) {
    return Gt(this, void 0, void 0, function* () {
      yield this.getNetwork(), t = yield t;
      let r = -128;
      const i = {
        includeTransactions: !!n
      };
      if (pn(t, 32)) i.blockHash = t;
      else try {
        i.blockTag = yield this._getBlockTag(t), pn(i.blockTag) && (r = parseInt(i.blockTag.substring(2), 16))
      } catch {
        dn.throwArgumentError("invalid block hash or block tag", "blockHashOrBlockTag", t)
      }
      return Q0(() => Gt(this, void 0, void 0, function* () {
        const s = yield this.perform("getBlock", i);
        if (s == null) return i.blockHash != null && this._emitted["b:" + i.blockHash] == null || i.blockTag != null && r > this._emitted.block ? null : void 0;
        if (n) {
          let o = null;
          for (let c = 0; c < s.transactions.length; c++) {
            const l = s.transactions[c];
            if (l.blockNumber == null) l.confirmations = 0;
            else if (l.confirmations == null) {
              o == null && (o = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval));
              let u = o - l.blockNumber + 1;
              u <= 0 && (u = 1), l.confirmations = u
            }
          }
          const a = this.formatter.blockWithTransactions(s);
          return a.transactions = a.transactions.map(c => this._wrapTransaction(c)), a
        }
        return this.formatter.block(s)
      }), {
        oncePoll: this
      })
    })
  }
  getBlock(t) {
    return this._getBlock(t, !1)
  }
  getBlockWithTransactions(t) {
    return this._getBlock(t, !0)
  }
  getTransaction(t) {
    return Gt(this, void 0, void 0, function* () {
      yield this.getNetwork(), t = yield t;
      const n = {
        transactionHash: this.formatter.hash(t, !0)
      };
      return Q0(() => Gt(this, void 0, void 0, function* () {
        const r = yield this.perform("getTransaction", n);
        if (r == null) return this._emitted["t:" + t] == null ? null : void 0;
        const i = this.formatter.transactionResponse(r);
        if (i.blockNumber == null) i.confirmations = 0;
        else if (i.confirmations == null) {
          let o = (yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval)) - i.blockNumber + 1;
          o <= 0 && (o = 1), i.confirmations = o
        }
        return this._wrapTransaction(i)
      }), {
        oncePoll: this
      })
    })
  }
  getTransactionReceipt(t) {
    return Gt(this, void 0, void 0, function* () {
      yield this.getNetwork(), t = yield t;
      const n = {
        transactionHash: this.formatter.hash(t, !0)
      };
      return Q0(() => Gt(this, void 0, void 0, function* () {
        const r = yield this.perform("getTransactionReceipt", n);
        if (r == null) return this._emitted["t:" + t] == null ? null : void 0;
        if (r.blockHash == null) return;
        const i = this.formatter.receipt(r);
        if (i.blockNumber == null) i.confirmations = 0;
        else if (i.confirmations == null) {
          let o = (yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval)) - i.blockNumber + 1;
          o <= 0 && (o = 1), i.confirmations = o
        }
        return i
      }), {
        oncePoll: this
      })
    })
  }
  getLogs(t) {
    return Gt(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const n = yield ei({
        filter: this._getFilter(t)
      }), r = yield this.perform("getLogs", n);
      return r.forEach(i => {
        i.removed == null && (i.removed = !1)
      }), TM.arrayOf(this.formatter.filterLog.bind(this.formatter))(r)
    })
  }
  getEtherPrice() {
    return Gt(this, void 0, void 0, function* () {
      return yield this.getNetwork(), this.perform("getEtherPrice", {})
    })
  }
  _getBlockTag(t) {
    return Gt(this, void 0, void 0, function* () {
      if (t = yield t, typeof t == "number" && t < 0) {
        t % 1 && dn.throwArgumentError("invalid BlockTag", "blockTag", t);
        let n = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
        return n += t, n < 0 && (n = 0), this.formatter.blockTag(n)
      }
      return this.formatter.blockTag(t)
    })
  }
  getResolver(t) {
    return Gt(this, void 0, void 0, function* () {
      let n = t;
      for (;;) {
        if (n === "" || n === "." || t !== "eth" && n === "eth") return null;
        const r = yield this._getResolver(n, "getResolver");
        if (r != null) {
          const i = new NM(this, r, t);
          return n !== t && !(yield i.supportsWildcard()) ? null : i
        }
        n = n.split(".").slice(1).join(".")
      }
    })
  }
  _getResolver(t, n) {
    return Gt(this, void 0, void 0, function* () {
      n == null && (n = "ENS");
      const r = yield this.getNetwork();
      r.ensAddress || dn.throwError("network does not support ENS", Ae.errors.UNSUPPORTED_OPERATION, {
        operation: n,
        network: r.name
      });
      try {
        const i = yield this.call({
          to: r.ensAddress,
          data: "0x0178b8bf" + ww(t).substring(2)
        });
        return this.formatter.callAddress(i)
      } catch {}
      return null
    })
  }
  resolveName(t) {
    return Gt(this, void 0, void 0, function* () {
      t = yield t;
      try {
        return Promise.resolve(this.formatter.address(t))
      } catch (r) {
        if (pn(t)) throw r
      }
      typeof t != "string" && dn.throwArgumentError("invalid ENS name", "name", t);
      const n = yield this.getResolver(t);
      return n ? yield n.getAddress(): null
    })
  }
  lookupAddress(t) {
    return Gt(this, void 0, void 0, function* () {
      t = yield t, t = this.formatter.address(t);
      const n = t.substring(2).toLowerCase() + ".addr.reverse",
        r = yield this._getResolver(n, "lookupAddress");
      if (r == null) return null;
      const i = Cw(yield this.call({
        to: r,
        data: "0x691f3431" + ww(n).substring(2)
      }), 0);
      return (yield this.resolveName(i)) != t ? null : i
    })
  }
  getAvatar(t) {
    return Gt(this, void 0, void 0, function* () {
      let n = null;
      if (pn(t)) {
        const s = this.formatter.address(t).substring(2).toLowerCase() + ".addr.reverse",
          o = yield this._getResolver(s, "getAvatar");
        if (!o) return null;
        n = new NM(this, o, s);
        try {
          const a = yield n.getAvatar();
          if (a) return a.url
        } catch (a) {
          if (a.code !== Ae.errors.CALL_EXCEPTION) throw a
        }
        try {
          const a = Cw(yield this.call({
            to: o,
            data: "0x691f3431" + ww(s).substring(2)
          }), 0);
          n = yield this.getResolver(a)
        } catch (a) {
          if (a.code !== Ae.errors.CALL_EXCEPTION) throw a;
          return null
        }
      } else if (n = yield this.getResolver(t), !n) return null;
      const r = yield n.getAvatar();
      return r == null ? null : r.url
    })
  }
  perform(t, n) {
    return dn.throwError(t + " not implemented", Ae.errors.NOT_IMPLEMENTED, {
      operation: t
    })
  }
  _startEvent(t) {
    this.polling = this._events.filter(n => n.pollable()).length > 0
  }
  _stopEvent(t) {
    this.polling = this._events.filter(n => n.pollable()).length > 0
  }
  _addEventListener(t, n, r) {
    const i = new iSe(m0(t), n, r);
    return this._events.push(i), this._startEvent(i), this
  }
  on(t, n) {
    return this._addEventListener(t, n, !1)
  }
  once(t, n) {
    return this._addEventListener(t, n, !0)
  }
  emit(t, ...n) {
    let r = !1,
      i = [],
      s = m0(t);
    return this._events = this._events.filter(o => o.tag !== s ? !0 : (setTimeout(() => {
      o.listener.apply(this, n)
    }, 0), r = !0, o.once ? (i.push(o), !1) : !0)), i.forEach(o => {
      this._stopEvent(o)
    }), r
  }
  listenerCount(t) {
    if (!t) return this._events.length;
    let n = m0(t);
    return this._events.filter(r => r.tag === n).length
  }
  listeners(t) {
    if (t == null) return this._events.map(r => r.listener);
    let n = m0(t);
    return this._events.filter(r => r.tag === n).map(r => r.listener)
  }
  off(t, n) {
    if (n == null) return this.removeAllListeners(t);
    const r = [];
    let i = !1,
      s = m0(t);
    return this._events = this._events.filter(o => o.tag !== s || o.listener != n || i ? !0 : (i = !0, r.push(o), !1)), r.forEach(o => {
      this._stopEvent(o)
    }), this
  }
  removeAllListeners(t) {
    let n = [];
    if (t == null) n = this._events, this._events = [];
    else {
      const r = m0(t);
      this._events = this._events.filter(i => i.tag !== r ? !0 : (n.push(i), !1))
    }
    return n.forEach(r => {
      this._stopEvent(r)
    }), this
  }
}
var Gl = function (e, t, n, r) {
  function i(s) {
    return s instanceof n ? s : new n(function (o) {
      o(s)
    })
  }
  return new(n || (n = Promise))(function (s, o) {
    function a(u) {
      try {
        l(r.next(u))
      } catch (f) {
        o(f)
      }
    }

    function c(u) {
      try {
        l(r.throw(u))
      } catch (f) {
        o(f)
      }
    }

    function l(u) {
      u.done ? s(u.value) : i(u.value).then(a, c)
    }
    l((r = r.apply(e, t || [])).next())
  })
};
const ti = new Ae(km),
  cSe = ["call", "estimateGas"];

function E1(e, t) {
  if (e == null) return null;
  if (typeof e.message == "string" && e.message.match("reverted")) {
    const n = pn(e.data) ? e.data : null;
    if (!t || n) return {
      message: e.message,
      data: n
    }
  }
  if (typeof e == "object") {
    for (const n in e) {
      const r = E1(e[n], t);
      if (r) return r
    }
    return null
  }
  if (typeof e == "string") try {
    return E1(JSON.parse(e), t)
  } catch {}
  return null
}

function OW(e, t, n) {
  const r = n.transaction || n.signedTransaction;
  if (e === "call") {
    const s = E1(t, !0);
    if (s) return s.data;
    ti.throwError("missing revert data in call exception; Transaction reverted without a reason string", Ae.errors.CALL_EXCEPTION, {
      data: "0x",
      transaction: r,
      error: t
    })
  }
  if (e === "estimateGas") {
    let s = E1(t.body, !1);
    s == null && (s = E1(t, !1)), s && ti.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Ae.errors.UNPREDICTABLE_GAS_LIMIT, {
      reason: s.message,
      method: e,
      transaction: r,
      error: t
    })
  }
  let i = t.message;
  throw t.code === Ae.errors.SERVER_ERROR && t.error && typeof t.error.message == "string" ? i = t.error.message : typeof t.body == "string" ? i = t.body : typeof t.responseText == "string" && (i = t.responseText), i = (i || "").toLowerCase(), i.match(/insufficient funds|base fee exceeds gas limit|InsufficientFunds/i) && ti.throwError("insufficient funds for intrinsic transaction cost", Ae.errors.INSUFFICIENT_FUNDS, {
    error: t,
    method: e,
    transaction: r
  }), i.match(/nonce (is )?too low/i) && ti.throwError("nonce has already been used", Ae.errors.NONCE_EXPIRED, {
    error: t,
    method: e,
    transaction: r
  }), i.match(/replacement transaction underpriced|transaction gas price.*too low/i) && ti.throwError("replacement fee too low", Ae.errors.REPLACEMENT_UNDERPRICED, {
    error: t,
    method: e,
    transaction: r
  }), i.match(/only replay-protected/i) && ti.throwError("legacy pre-eip-155 transactions not supported", Ae.errors.UNSUPPORTED_OPERATION, {
    error: t,
    method: e,
    transaction: r
  }), cSe.indexOf(e) >= 0 && i.match(/gas required exceeds allowance|always failing transaction|execution reverted|revert/) && ti.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Ae.errors.UNPREDICTABLE_GAS_LIMIT, {
    error: t,
    method: e,
    transaction: r
  }), t
}

function MM(e) {
  return new Promise(function (t) {
    setTimeout(t, e)
  })
}

function lSe(e) {
  if (e.error) {
    const t = new Error(e.error.message);
    throw t.code = e.error.code, t.data = e.error.data, t
  }
  return e.result
}

function Og(e) {
  return e && e.toLowerCase()
}
const yA = {};
class DW extends sy {
  constructor(t, n, r) {
    if (super(), t !== yA) throw new Error("do not call the JsonRpcSigner constructor directly; use provider.getSigner");
    Ge(this, "provider", n), r == null && (r = 0), typeof r == "string" ? (Ge(this, "_address", this.provider.formatter.address(r)), Ge(this, "_index", null)) : typeof r == "number" ? (Ge(this, "_index", r), Ge(this, "_address", null)) : ti.throwArgumentError("invalid address or index", "addressOrIndex", r)
  }
  connect(t) {
    return ti.throwError("cannot alter JSON-RPC Signer connection", Ae.errors.UNSUPPORTED_OPERATION, {
      operation: "connect"
    })
  }
  connectUnchecked() {
    return new uSe(yA, this.provider, this._address || this._index)
  }
  getAddress() {
    return this._address ? Promise.resolve(this._address) : this.provider.send("eth_accounts", []).then(t => (t.length <= this._index && ti.throwError("unknown account #" + this._index, Ae.errors.UNSUPPORTED_OPERATION, {
      operation: "getAddress"
    }), this.provider.formatter.address(t[this._index])))
  }
  sendUncheckedTransaction(t) {
    t = Cr(t);
    const n = this.getAddress().then(r => (r && (r = r.toLowerCase()), r));
    if (t.gasLimit == null) {
      const r = Cr(t);
      r.from = n, t.gasLimit = this.provider.estimateGas(r)
    }
    return t.to != null && (t.to = Promise.resolve(t.to).then(r => Gl(this, void 0, void 0, function* () {
      if (r == null) return null;
      const i = yield this.provider.resolveName(r);
      return i == null && ti.throwArgumentError("provided ENS name resolves to null", "tx.to", r), i
    }))), ei({
      tx: ei(t),
      sender: n
    }).then(({
      tx: r,
      sender: i
    }) => {
      r.from != null ? r.from.toLowerCase() !== i && ti.throwArgumentError("from address mismatch", "transaction", t) : r.from = i;
      const s = this.provider.constructor.hexlifyTransaction(r, {
        from: !0
      });
      return this.provider.send("eth_sendTransaction", [s]).then(o => o, o => (typeof o.message == "string" && o.message.match(/user denied/i) && ti.throwError("user rejected transaction", Ae.errors.ACTION_REJECTED, {
        action: "sendTransaction",
        transaction: r
      }), OW("sendTransaction", o, s)))
    })
  }
  signTransaction(t) {
    return ti.throwError("signing transactions is unsupported", Ae.errors.UNSUPPORTED_OPERATION, {
      operation: "signTransaction"
    })
  }
  sendTransaction(t) {
    return Gl(this, void 0, void 0, function* () {
      const n = yield this.provider._getInternalBlockNumber(100 + 2 * this.provider.pollingInterval), r = yield this.sendUncheckedTransaction(t);
      try {
        return yield Q0(() => Gl(this, void 0, void 0, function* () {
          const i = yield this.provider.getTransaction(r);
          if (i !== null) return this.provider._wrapTransaction(i, r, n)
        }), {
          oncePoll: this.provider
        })
      } catch (i) {
        throw i.transactionHash = r, i
      }
    })
  }
  signMessage(t) {
    return Gl(this, void 0, void 0, function* () {
      const n = typeof t == "string" ? fl(t) : t,
        r = yield this.getAddress();
      try {
        return yield this.provider.send("personal_sign", [St(n), r.toLowerCase()])
      } catch (i) {
        throw typeof i.message == "string" && i.message.match(/user denied/i) && ti.throwError("user rejected signing", Ae.errors.ACTION_REJECTED, {
          action: "signMessage",
          from: r,
          messageData: t
        }), i
      }
    })
  }
  _legacySignMessage(t) {
    return Gl(this, void 0, void 0, function* () {
      const n = typeof t == "string" ? fl(t) : t,
        r = yield this.getAddress();
      try {
        return yield this.provider.send("eth_sign", [r.toLowerCase(), St(n)])
      } catch (i) {
        throw typeof i.message == "string" && i.message.match(/user denied/i) && ti.throwError("user rejected signing", Ae.errors.ACTION_REJECTED, {
          action: "_legacySignMessage",
          from: r,
          messageData: t
        }), i
      }
    })
  }
  _signTypedData(t, n, r) {
    return Gl(this, void 0, void 0, function* () {
      const i = yield To.resolveNames(t, n, r, o => this.provider.resolveName(o)), s = yield this.getAddress();
      try {
        return yield this.provider.send("eth_signTypedData_v4", [s.toLowerCase(), JSON.stringify(To.getPayload(i.domain, n, i.value))])
      } catch (o) {
        throw typeof o.message == "string" && o.message.match(/user denied/i) && ti.throwError("user rejected signing", Ae.errors.ACTION_REJECTED, {
          action: "_signTypedData",
          from: s,
          messageData: {
            domain: i.domain,
            types: n,
            value: i.value
          }
        }), o
      }
    })
  }
  unlock(t) {
    return Gl(this, void 0, void 0, function* () {
      const n = this.provider,
        r = yield this.getAddress();
      return n.send("personal_unlockAccount", [r.toLowerCase(), t, null])
    })
  }
}
class uSe extends DW {
  sendTransaction(t) {
    return this.sendUncheckedTransaction(t).then(n => ({
      hash: n,
      nonce: null,
      gasLimit: null,
      gasPrice: null,
      data: null,
      value: null,
      chainId: null,
      confirmations: 0,
      from: null,
      wait: r => this.provider.waitForTransaction(n, r)
    }))
  }
}
const dSe = {
  chainId: !0,
  data: !0,
  gasLimit: !0,
  gasPrice: !0,
  nonce: !0,
  to: !0,
  value: !0,
  type: !0,
  accessList: !0,
  maxFeePerGas: !0,
  maxPriorityFeePerGas: !0
};
let NW = class extends RW {
  constructor(t, n) {
    let r = n;
    r == null && (r = new Promise((i, s) => {
      setTimeout(() => {
        this.detectNetwork().then(o => {
          i(o)
        }, o => {
          s(o)
        })
      }, 0)
    })), super(r), t || (t = Xc(this.constructor, "defaultUrl")()), typeof t == "string" ? Ge(this, "connection", Object.freeze({
      url: t
    })) : Ge(this, "connection", Object.freeze(Cr(t))), this._nextId = 42
  }
  get _cache() {
    return this._eventLoopCache == null && (this._eventLoopCache = {}), this._eventLoopCache
  }
  static defaultUrl() {
    return "http://localhost:8545"
  }
  detectNetwork() {
    return this._cache.detectNetwork || (this._cache.detectNetwork = this._uncachedDetectNetwork(), setTimeout(() => {
      this._cache.detectNetwork = null
    }, 0)), this._cache.detectNetwork
  }
  _uncachedDetectNetwork() {
    return Gl(this, void 0, void 0, function* () {
      yield MM(0);
      let t = null;
      try {
        t = yield this.send("eth_chainId", [])
      } catch {
        try {
          t = yield this.send("net_version", [])
        } catch {}
      }
      if (t != null) {
        const n = Xc(this.constructor, "getNetwork");
        try {
          return n(st.from(t).toNumber())
        } catch (r) {
          return ti.throwError("could not detect network", Ae.errors.NETWORK_ERROR, {
            chainId: t,
            event: "invalidNetwork",
            serverError: r
          })
        }
      }
      return ti.throwError("could not detect network", Ae.errors.NETWORK_ERROR, {
        event: "noNetwork"
      })
    })
  }
  getSigner(t) {
    return new DW(yA, this, t)
  }
  getUncheckedSigner(t) {
    return this.getSigner(t).connectUnchecked()
  }
  listAccounts() {
    return this.send("eth_accounts", []).then(t => t.map(n => this.formatter.address(n)))
  }
  send(t, n) {
    const r = {
      method: t,
      params: n,
      id: this._nextId++,
      jsonrpc: "2.0"
    };
    this.emit("debug", {
      action: "request",
      request: Aa(r),
      provider: this
    });
    const i = ["eth_chainId", "eth_blockNumber"].indexOf(t) >= 0;
    if (i && this._cache[t]) return this._cache[t];
    const s = Tk(this.connection, JSON.stringify(r), lSe).then(o => (this.emit("debug", {
      action: "response",
      request: r,
      response: o,
      provider: this
    }), o), o => {
      throw this.emit("debug", {
        action: "response",
        error: o,
        request: r,
        provider: this
      }), o
    });
    return i && (this._cache[t] = s, setTimeout(() => {
      this._cache[t] = null
    }, 0)), s
  }
  prepareRequest(t, n) {
    switch (t) {
      case "getBlockNumber":
        return ["eth_blockNumber", []];
      case "getGasPrice":
        return ["eth_gasPrice", []];
      case "getBalance":
        return ["eth_getBalance", [Og(n.address), n.blockTag]];
      case "getTransactionCount":
        return ["eth_getTransactionCount", [Og(n.address), n.blockTag]];
      case "getCode":
        return ["eth_getCode", [Og(n.address), n.blockTag]];
      case "getStorageAt":
        return ["eth_getStorageAt", [Og(n.address), zr(n.position, 32), n.blockTag]];
      case "sendTransaction":
        return ["eth_sendRawTransaction", [n.signedTransaction]];
      case "getBlock":
        return n.blockTag ? ["eth_getBlockByNumber", [n.blockTag, !!n.includeTransactions]] : n.blockHash ? ["eth_getBlockByHash", [n.blockHash, !!n.includeTransactions]] : null;
      case "getTransaction":
        return ["eth_getTransactionByHash", [n.transactionHash]];
      case "getTransactionReceipt":
        return ["eth_getTransactionReceipt", [n.transactionHash]];
      case "call":
        return ["eth_call", [Xc(this.constructor, "hexlifyTransaction")(n.transaction, {
          from: !0
        }), n.blockTag]];
      case "estimateGas":
        return ["eth_estimateGas", [Xc(this.constructor, "hexlifyTransaction")(n.transaction, {
          from: !0
        })]];
      case "getLogs":
        return n.filter && n.filter.address != null && (n.filter.address = Og(n.filter.address)), ["eth_getLogs", [n.filter]]
    }
    return null
  }
  perform(t, n) {
    return Gl(this, void 0, void 0, function* () {
      if (t === "call" || t === "estimateGas") {
        const i = n.transaction;
        if (i && i.type != null && st.from(i.type).isZero() && i.maxFeePerGas == null && i.maxPriorityFeePerGas == null) {
          const s = yield this.getFeeData();
          s.maxFeePerGas == null && s.maxPriorityFeePerGas == null && (n = Cr(n), n.transaction = Cr(i), delete n.transaction.type)
        }
      }
      const r = this.prepareRequest(t, n);
      r == null && ti.throwError(t + " not implemented", Ae.errors.NOT_IMPLEMENTED, {
        operation: t
      });
      try {
        return yield this.send(r[0], r[1])
      } catch (i) {
        return OW(t, i, n)
      }
    })
  }
  _startEvent(t) {
    t.tag === "pending" && this._startPending(), super._startEvent(t)
  }
  _startPending() {
    if (this._pendingFilter != null) return;
    const t = this,
      n = this.send("eth_newPendingTransactionFilter", []);
    this._pendingFilter = n, n.then(function (r) {
      function i() {
        t.send("eth_getFilterChanges", [r]).then(function (s) {
          if (t._pendingFilter != n) return null;
          let o = Promise.resolve();
          return s.forEach(function (a) {
            t._emitted["t:" + a.toLowerCase()] = "pending", o = o.then(function () {
              return t.getTransaction(a).then(function (c) {
                return t.emit("pending", c), null
              })
            })
          }), o.then(function () {
            return MM(1e3)
          })
        }).then(function () {
          if (t._pendingFilter != n) {
            t.send("eth_uninstallFilter", [r]);
            return
          }
          return setTimeout(function () {
            i()
          }, 0), null
        }).catch(s => {})
      }
      return i(), r
    }).catch(r => {})
  }
  _stopEvent(t) {
    t.tag === "pending" && this.listenerCount("pending") === 0 && (this._pendingFilter = null), super._stopEvent(t)
  }
  static hexlifyTransaction(t, n) {
    const r = Cr(dSe);
    if (n)
      for (const s in n) n[s] && (r[s] = !0);
    l5e(t, r);
    const i = {};
    return ["chainId", "gasLimit", "gasPrice", "type", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "value"].forEach(function (s) {
      if (t[s] == null) return;
      const o = mk(st.from(t[s]));
      s === "gasLimit" && (s = "gas"), i[s] = o
    }), ["from", "to", "data"].forEach(function (s) {
      t[s] != null && (i[s] = St(t[s]))
    }), t.accessList && (i.accessList = Tm(t.accessList)), i
  }
};
var fSe = function (e, t, n, r) {
  function i(s) {
    return s instanceof n ? s : new n(function (o) {
      o(s)
    })
  }
  return new(n || (n = Promise))(function (s, o) {
    function a(u) {
      try {
        l(r.next(u))
      } catch (f) {
        o(f)
      }
    }

    function c(u) {
      try {
        l(r.throw(u))
      } catch (f) {
        o(f)
      }
    }

    function l(u) {
      u.done ? s(u.value) : i(u.value).then(a, c)
    }
    l((r = r.apply(e, t || [])).next())
  })
};
const hSe = new Ae(km);
class $M extends NW {
  detectNetwork() {
    const t = Object.create(null, {
      detectNetwork: {
        get: () => super.detectNetwork
      }
    });
    return fSe(this, void 0, void 0, function* () {
      let n = this.network;
      return n == null && (n = yield t.detectNetwork.call(this), n || hSe.throwError("no network detected", Ae.errors.UNKNOWN_ERROR, {}), this._network == null && (Ge(this, "_network", n), this.emit("network", n, null))), n
    })
  }
}
var N3 = function (e, t, n, r) {
  function i(s) {
    return s instanceof n ? s : new n(function (o) {
      o(s)
    })
  }
  return new(n || (n = Promise))(function (s, o) {
    function a(u) {
      try {
        l(r.next(u))
      } catch (f) {
        o(f)
      }
    }

    function c(u) {
      try {
        l(r.throw(u))
      } catch (f) {
        o(f)
      }
    }

    function l(u) {
      u.done ? s(u.value) : i(u.value).then(a, c)
    }
    l((r = r.apply(e, t || [])).next())
  })
};
const Cf = new Ae(km);

function wb() {
  return new Date().getTime()
}

function LM(e) {
  let t = null;
  for (let n = 0; n < e.length; n++) {
    const r = e[n];
    if (r == null) return null;
    t ? t.name === r.name && t.chainId === r.chainId && (t.ensAddress === r.ensAddress || t.ensAddress == null && r.ensAddress == null) || Cf.throwArgumentError("provider mismatch", "networks", e) : t = r
  }
  return t
}

function BM(e, t) {
  e = e.slice().sort();
  const n = Math.floor(e.length / 2);
  if (e.length % 2) return e[n];
  const r = e[n - 1],
    i = e[n];
  return t != null && Math.abs(r - i) > t ? null : (r + i) / 2
}

function Y0(e) {
  if (e === null) return "null";
  if (typeof e == "number" || typeof e == "boolean") return JSON.stringify(e);
  if (typeof e == "string") return e;
  if (st.isBigNumber(e)) return e.toString();
  if (Array.isArray(e)) return JSON.stringify(e.map(t => Y0(t)));
  if (typeof e == "object") {
    const t = Object.keys(e);
    return t.sort(), "{" + t.map(n => {
      let r = e[n];
      return typeof r == "function" ? r = "[function]" : r = Y0(r), JSON.stringify(n) + ":" + r
    }).join(",") + "}"
  }
  throw new Error("unknown value type: " + typeof e)
}
let pSe = 1;

function FM(e) {
  let t = null,
    n = null,
    r = new Promise(o => {
      t = function () {
        n && (clearTimeout(n), n = null), o()
      }, n = setTimeout(t, e)
    });
  const i = o => (r = r.then(o), r);

  function s() {
    return r
  }
  return {
    cancel: t,
    getPromise: s,
    wait: i
  }
}
const mSe = [Ae.errors.CALL_EXCEPTION, Ae.errors.INSUFFICIENT_FUNDS, Ae.errors.NONCE_EXPIRED, Ae.errors.REPLACEMENT_UNDERPRICED, Ae.errors.UNPREDICTABLE_GAS_LIMIT],
  gSe = ["address", "args", "errorArgs", "errorSignature", "method", "transaction"];

function xb(e, t) {
  const n = {
    weight: e.weight
  };
  return Object.defineProperty(n, "provider", {
    get: () => e.provider
  }), e.start && (n.start = e.start), t && (n.duration = t - e.start), e.done && (e.error ? n.error = e.error : n.result = e.result || null), n
}

function ySe(e, t) {
  return function (n) {
    const r = {};
    n.forEach(s => {
      const o = e(s.result);
      r[o] || (r[o] = {
        count: 0,
        result: s.result
      }), r[o].count++
    });
    const i = Object.keys(r);
    for (let s = 0; s < i.length; s++) {
      const o = r[i[s]];
      if (o.count >= t) return o.result
    }
  }
}

function vSe(e, t, n) {
  let r = Y0;
  switch (t) {
    case "getBlockNumber":
      return function (i) {
        const s = i.map(a => a.result);
        let o = BM(i.map(a => a.result), 2);
        if (o != null) return o = Math.ceil(o), s.indexOf(o + 1) >= 0 && o++, o >= e._highestBlockNumber && (e._highestBlockNumber = o), e._highestBlockNumber
      };
    case "getGasPrice":
      return function (i) {
        const s = i.map(o => o.result);
        return s.sort(), s[Math.floor(s.length / 2)]
      };
    case "getEtherPrice":
      return function (i) {
        return BM(i.map(s => s.result))
      };
    case "getBalance":
    case "getTransactionCount":
    case "getCode":
    case "getStorageAt":
    case "call":
    case "estimateGas":
    case "getLogs":
      break;
    case "getTransaction":
    case "getTransactionReceipt":
      r = function (i) {
        return i == null ? null : (i = Cr(i), i.confirmations = -1, Y0(i))
      };
      break;
    case "getBlock":
      n.includeTransactions ? r = function (i) {
        return i == null ? null : (i = Cr(i), i.transactions = i.transactions.map(s => (s = Cr(s), s.confirmations = -1, s)), Y0(i))
      } : r = function (i) {
        return i == null ? null : Y0(i)
      };
      break;
    default:
      throw new Error("unknown method: " + t)
  }
  return ySe(r, e.quorum)
}

function Dg(e, t) {
  return N3(this, void 0, void 0, function* () {
    const n = e.provider;
    return n.blockNumber != null && n.blockNumber >= t || t === -1 ? n : Q0(() => new Promise((r, i) => {
      setTimeout(function () {
        return n.blockNumber >= t ? r(n) : e.cancelled ? r(null) : r(void 0)
      }, 0)
    }), {
      oncePoll: n
    })
  })
}

function bSe(e, t, n, r) {
  return N3(this, void 0, void 0, function* () {
    let i = e.provider;
    switch (n) {
      case "getBlockNumber":
      case "getGasPrice":
        return i[n]();
      case "getEtherPrice":
        if (i.getEtherPrice) return i.getEtherPrice();
        break;
      case "getBalance":
      case "getTransactionCount":
      case "getCode":
        return r.blockTag && pn(r.blockTag) && (i = yield Dg(e, t)), i[n](r.address, r.blockTag || "latest");
      case "getStorageAt":
        return r.blockTag && pn(r.blockTag) && (i = yield Dg(e, t)), i.getStorageAt(r.address, r.position, r.blockTag || "latest");
      case "getBlock":
        return r.blockTag && pn(r.blockTag) && (i = yield Dg(e, t)), i[r.includeTransactions ? "getBlockWithTransactions" : "getBlock"](r.blockTag || r.blockHash);
      case "call":
      case "estimateGas":
        return r.blockTag && pn(r.blockTag) && (i = yield Dg(e, t)), n === "call" && r.blockTag ? i[n](r.transaction, r.blockTag) : i[n](r.transaction);
      case "getTransaction":
      case "getTransactionReceipt":
        return i[n](r.transactionHash);
      case "getLogs": {
        let s = r.filter;
        return (s.fromBlock && pn(s.fromBlock) || s.toBlock && pn(s.toBlock)) && (i = yield Dg(e, t)), i.getLogs(s)
      }
    }
    return Cf.throwError("unknown method error", Ae.errors.UNKNOWN_ERROR, {
      method: n,
      params: r
    })
  })
}
class jM extends RW {
  constructor(t, n) {
    t.length === 0 && Cf.throwArgumentError("missing providers", "providers", t);
    const r = t.map((o, a) => {
        if (iy.isProvider(o)) {
          const u = kM(o) ? 2e3 : 750;
          return Object.freeze({
            provider: o,
            weight: 1,
            stallTimeout: u,
            priority: 1
          })
        }
        const c = Cr(o);
        c.priority == null && (c.priority = 1), c.stallTimeout == null && (c.stallTimeout = kM(o) ? 2e3 : 750), c.weight == null && (c.weight = 1);
        const l = c.weight;
        return (l % 1 || l > 512 || l < 1) && Cf.throwArgumentError("invalid weight; must be integer in [1, 512]", `providers[${a}].weight`, l), Object.freeze(c)
      }),
      i = r.reduce((o, a) => o + a.weight, 0);
    n == null ? n = i / 2 : n > i && Cf.throwArgumentError("quorum will always fail; larger than total weight", "quorum", n);
    let s = LM(r.map(o => o.provider.network));
    s == null && (s = new Promise((o, a) => {
      setTimeout(() => {
        this.detectNetwork().then(o, a)
      }, 0)
    })), super(s), Ge(this, "providerConfigs", Object.freeze(r)), Ge(this, "quorum", n), this._highestBlockNumber = -1
  }
  detectNetwork() {
    return N3(this, void 0, void 0, function* () {
      const t = yield Promise.all(this.providerConfigs.map(n => n.provider.getNetwork()));
      return LM(t)
    })
  }
  perform(t, n) {
    return N3(this, void 0, void 0, function* () {
      if (t === "sendTransaction") {
        const c = yield Promise.all(this.providerConfigs.map(l => l.provider.sendTransaction(n.signedTransaction).then(u => u.hash, u => u)));
        for (let l = 0; l < c.length; l++) {
          const u = c[l];
          if (typeof u == "string") return u
        }
        throw c[0]
      }
      this._highestBlockNumber === -1 && t !== "getBlockNumber" && (yield this.getBlockNumber());
      const r = vSe(this, t, n),
        i = $4e(this.providerConfigs.map(Cr));
      i.sort((c, l) => c.priority - l.priority);
      const s = this._highestBlockNumber;
      let o = 0,
        a = !0;
      for (;;) {
        const c = wb();
        let l = i.filter(g => g.runner && c - g.start < g.stallTimeout).reduce((g, y) => g + y.weight, 0);
        for (; l < this.quorum && o < i.length;) {
          const g = i[o++],
            y = pSe++;
          g.start = wb(), g.staller = FM(g.stallTimeout), g.staller.wait(() => {
            g.staller = null
          }), g.runner = bSe(g, s, t, n).then(x => {
            g.done = !0, g.result = x, this.listenerCount("debug") && this.emit("debug", {
              action: "request",
              rid: y,
              backend: xb(g, wb()),
              request: {
                method: t,
                params: Aa(n)
              },
              provider: this
            })
          }, x => {
            g.done = !0, g.error = x, this.listenerCount("debug") && this.emit("debug", {
              action: "request",
              rid: y,
              backend: xb(g, wb()),
              request: {
                method: t,
                params: Aa(n)
              },
              provider: this
            })
          }), this.listenerCount("debug") && this.emit("debug", {
            action: "request",
            rid: y,
            backend: xb(g, null),
            request: {
              method: t,
              params: Aa(n)
            },
            provider: this
          }), l += g.weight
        }
        const u = [];
        i.forEach(g => {
          g.done || !g.runner || (u.push(g.runner), g.staller && u.push(g.staller.getPromise()))
        }), u.length && (yield Promise.race(u));
        const f = i.filter(g => g.done && g.error == null);
        if (f.length >= this.quorum) {
          const g = r(f);
          if (g !== void 0) return i.forEach(y => {
            y.staller && y.staller.cancel(), y.cancelled = !0
          }), g;
          a || (yield FM(100).getPromise()), a = !1
        }
        const h = i.reduce((g, y) => {
          if (!y.done || y.error == null) return g;
          const x = y.error.code;
          return mSe.indexOf(x) >= 0 && (g[x] || (g[x] = {
            error: y.error,
            weight: 0
          }), g[x].weight += y.weight), g
        }, {});
        if (Object.keys(h).forEach(g => {
            const y = h[g];
            if (y.weight < this.quorum) return;
            i.forEach(_ => {
              _.staller && _.staller.cancel(), _.cancelled = !0
            });
            const x = y.error,
              k = {};
            gSe.forEach(_ => {
              x[_] != null && (k[_] = x[_])
            }), Cf.throwError(x.reason || x.message, g, k)
          }), i.filter(g => !g.done).length === 0) break
      }
      return i.forEach(c => {
        c.staller && c.staller.cancel(), c.cancelled = !0
      }), Cf.throwError("failed to meet quorum", Ae.errors.SERVER_ERROR, {
        method: t,
        params: n,
        results: i.map(c => xb(c)),
        provider: this
      })
    })
  }
}
const UM = new Ae(km);
let wSe = 1;

function zM(e, t) {
  const n = "Web3LegacyFetcher";
  return function (r, i) {
    const s = {
      method: r,
      params: i,
      id: wSe++,
      jsonrpc: "2.0"
    };
    return new Promise((o, a) => {
      this.emit("debug", {
        action: "request",
        fetcher: n,
        request: Aa(s),
        provider: this
      }), t(s, (c, l) => {
        if (c) return this.emit("debug", {
          action: "response",
          fetcher: n,
          error: c,
          request: s,
          provider: this
        }), a(c);
        if (this.emit("debug", {
            action: "response",
            fetcher: n,
            request: s,
            response: l,
            provider: this
          }), l.error) {
          const u = new Error(l.error.message);
          return u.code = l.error.code, u.data = l.error.data, a(u)
        }
        o(l.result)
      })
    })
  }
}

function xSe(e) {
  return function (t, n) {
    n == null && (n = []);
    const r = {
      method: t,
      params: n
    };
    return this.emit("debug", {
      action: "request",
      fetcher: "Eip1193Fetcher",
      request: Aa(r),
      provider: this
    }), e.request(r).then(i => (this.emit("debug", {
      action: "response",
      fetcher: "Eip1193Fetcher",
      request: r,
      response: i,
      provider: this
    }), i), i => {
      throw this.emit("debug", {
        action: "response",
        fetcher: "Eip1193Fetcher",
        request: r,
        error: i,
        provider: this
      }), i
    })
  }
}
class Y5 extends NW {
  constructor(t, n) {
    t == null && UM.throwArgumentError("missing provider", "provider", t);
    let r = null,
      i = null,
      s = null;
    typeof t == "function" ? (r = "unknown:", i = t) : (r = t.host || t.path || "", !r && t.isMetaMask && (r = "metamask"), s = t, t.request ? (r === "" && (r = "eip-1193:"), i = xSe(t)) : t.sendAsync ? i = zM(t, t.sendAsync.bind(t)) : t.send ? i = zM(t, t.send.bind(t)) : UM.throwArgumentError("unsupported provider", "provider", t), r || (r = "unknown:")), super(r, n), Ge(this, "jsonRpcFetchFunc", i), Ge(this, "provider", s)
  }
  send(t, n) {
    return this.jsonRpcFetchFunc(t, n)
  }
}
const Rt = e => "0x" + st.from(e)._hex.split("0x")[1].replace(/\b0+/g, ""),
  MW = [{
    key: It.ETH,
    chainType: At.EVM,
    name: "Ethereum",
    coin: ae.ETH,
    id: 1,
    mainnet: !0,
    logoURI: "https://raw.githubusercontent.com/lifinance/types/main/src/assets/icons/chains/ethereum.svg",
    tokenlistUrl: "https://gateway.ipfs.io/ipns/tokens.uniswap.org",
    multicallAddress: Ft[B.ETH],
    metamask: {
      chainId: Rt(1),
      blockExplorerUrls: ["https://etherscan.io/"],
      chainName: "Ethereum Mainnet",
      nativeCurrency: {
        name: "ETH",
        symbol: "ETH",
        decimals: 18
      },
      rpcUrls: ["https://mainnet.infura.io/v3/9aa3d95b3bc440fa88ea12eaa4456161"]
    }
  }, {
    key: It.POL,
    chainType: At.EVM,
    name: "Polygon",
    coin: ae.MATIC,
    id: 137,
    mainnet: !0,
    logoURI: "https://raw.githubusercontent.com/lifinance/types/main/src/assets/icons/chains/polygon.svg",
    tokenlistUrl: "https://unpkg.com/quickswap-default-token-list@1.0.71/build/quickswap-default.tokenlist.json",
    faucetUrls: ["https://stakely.io/faucet/polygon-matic"],
    multicallAddress: Ft[B.POL],
    metamask: {
      chainId: Rt(137),
      blockExplorerUrls: ["https://polygonscan.com/", "https://explorer-mainnet.maticvigil.com/"],
      chainName: "Matic(Polygon) Mainnet",
      nativeCurrency: {
        name: "MATIC",
        symbol: "MATIC",
        decimals: 18
      },
      rpcUrls: ["https://polygon-rpc.com/", "https://rpc-mainnet.maticvigil.com/"]
    }
  }, {
    key: It.BSC,
    chainType: At.EVM,
    name: "BSC",
    coin: ae.BNB,
    id: 56,
    mainnet: !0,
    logoURI: "https://raw.githubusercontent.com/lifinance/types/main/src/assets/icons/chains/bsc.svg",
    tokenlistUrl: "https://tokens.pancakeswap.finance/pancakeswap-extended.json",
    faucetUrls: ["https://stakely.io/faucet/bsc-chain-bnb"],
    multicallAddress: Ft[B.BSC],
    metamask: {
      chainId: Rt(56),
      blockExplorerUrls: ["https://bscscan.com/"],
      chainName: "Binance Smart Chain Mainnet",
      nativeCurrency: {
        name: "BNB",
        symbol: "BNB",
        decimals: 18
      },
      rpcUrls: ["https://bsc-dataseed.binance.org/", "https://bsc-dataseed1.defibit.io/", "https://bsc-dataseed1.ninicoin.io/"]
    }
  }, {
    key: It.DAI,
    chainType: At.EVM,
    name: "Gnosis",
    coin: ae.DAI,
    id: 100,
    mainnet: !0,
    logoURI: "https://raw.githubusercontent.com/lifinance/types/main/src/assets/icons/chains/gnosis.svg",
    tokenlistUrl: "https://tokens.honeyswap.org/",
    faucetUrls: ["https://stakely.io/faucet/xdai-chain"],
    multicallAddress: Ft[B.DAI],
    metamask: {
      chainId: Rt(100),
      blockExplorerUrls: ["https://blockscout.com/xdai/mainnet/"],
      chainName: "Gnosis Chain",
      nativeCurrency: {
        name: "xDai",
        symbol: "xDai",
        decimals: 18
      },
      rpcUrls: ["https://rpc.gnosischain.com/", "https://rpc.ankr.com/gnosis", "https://xdai-rpc.gateway.pokt.network"]
    }
  }, {
    key: It.FTM,
    chainType: At.EVM,
    name: "Fantom",
    coin: ae.FTM,
    id: 250,
    mainnet: !0,
    logoURI: "https://raw.githubusercontent.com/lifinance/types/main/src/assets/icons/chains/fantom.svg",
    tokenlistUrl: "https://raw.githubusercontent.com/SpookySwap/spooky-info/master/src/constants/token/spookyswap.json",
    faucetUrls: ["https://stakely.io/faucet/fantom-blockchain-ftm", "https://docs.spookyswap.finance/getting-started/how-to-get-fantom-gas"],
    multicallAddress: Ft[B.FTM],
    metamask: {
      chainId: Rt(250),
      blockExplorerUrls: ["https://ftmscan.com/"],
      chainName: "Fantom Opera",
      nativeCurrency: {
        name: "FTM",
        symbol: "FTM",
        decimals: 18
      },
      rpcUrls: ["https://rpc.ftm.tools/", "https://rpcapi.fantom.network"]
    }
  }, {
    key: It.OKT,
    chainType: At.EVM,
    name: "OKXChain",
    coin: ae.OKT,
    id: 66,
    mainnet: !0,
    logoURI: "https://raw.githubusercontent.com/lifinance/types/main/src/assets/icons/chains/okx.svg",
    tokenlistUrl: "https://raw.githubusercontent.com/sushiswap/default-token-list/master/tokens/okex.json",
    multicallAddress: Ft[B.OKT],
    metamask: {
      chainId: Rt(66),
      blockExplorerUrls: ["https://www.oklink.com/en/okc/"],
      chainName: "OKXChain Mainnet",
      nativeCurrency: {
        name: "OKT",
        symbol: "OKT",
        decimals: 18
      },
      rpcUrls: ["https://exchainrpc.okex.org"]
    }
  }, {
    key: It.AVA,
    chainType: At.EVM,
    name: "Avalanche",
    coin: ae.AVAX,
    id: 43114,
    mainnet: !0,
    logoURI: "https://raw.githubusercontent.com/lifinance/types/main/src/assets/icons/chains/avalanche.svg",
    tokenlistUrl: "https://raw.githubusercontent.com/sushiswap/default-token-list/master/tokens/avalanche.json",
    multicallAddress: Ft[B.AVA],
    metamask: {
      chainId: Rt(43114),
      blockExplorerUrls: ["https://cchain.explorer.avax.network/"],
      chainName: "Avalanche Mainnet",
      nativeCurrency: {
        name: "AVAX",
        symbol: "AVAX",
        decimals: 18
      },
      rpcUrls: ["https://api.avax.network/ext/bc/C/rpc"]
    }
  }, {
    key: It.ARB,
    chainType: At.EVM,
    name: "Arbitrum",
    coin: ae.ETH,
    id: 42161,
    mainnet: !0,
    logoURI: "https://raw.githubusercontent.com/lifinance/types/main/src/assets/icons/chains/arbitrum.svg",
    tokenlistUrl: "https://raw.githubusercontent.com/sushiswap/default-token-list/master/tokens/arbitrum.json",
    faucetUrls: ["https://bridge.arbitrum.io/"],
    multicallAddress: Ft[B.ARB],
    metamask: {
      chainId: Rt(42161),
      blockExplorerUrls: ["https://arbiscan.io/"],
      chainName: "Arbitrum",
      nativeCurrency: {
        name: "AETH",
        symbol: "AETH",
        decimals: 18
      },
      rpcUrls: ["https://arb1.arbitrum.io/rpc"]
    }
  }, {
    key: It.HEC,
    chainType: At.EVM,
    name: "Huobi ECO Chain Mainnet",
    coin: ae.HT,
    id: 128,
    mainnet: !0,
    logoURI: "https://raw.githubusercontent.com/lifinance/types/main/src/assets/icons/chains/heco.png",
    tokenlistUrl: "https://raw.githubusercontent.com/sushiswap/default-token-list/master/tokens/heco.json",
    multicallAddress: Ft[B.HEC],
    metamask: {
      chainId: Rt(128),
      blockExplorerUrls: ["https://hecoinfo.com/"],
      chainName: "Huobi ECO Chain Mainnet",
      nativeCurrency: {
        name: "HT",
        symbol: "HT",
        decimals: 18
      },
      rpcUrls: ["https://http-mainnet.hecochain.com"]
    }
  }, {
    key: It.OPT,
    chainType: At.EVM,
    name: "Optimism",
    coin: ae.ETH,
    id: 10,
    mainnet: !0,
    logoURI: "https://raw.githubusercontent.com/lifinance/types/main/src/assets/icons/chains/optimism.svg",
    tokenlistUrl: "https://static.optimism.io/optimism.tokenlist.json",
    faucetUrls: ["https://gateway.optimism.io/"],
    multicallAddress: Ft[B.OPT],
    metamask: {
      chainId: Rt(10),
      blockExplorerUrls: ["https://optimistic.etherscan.io/"],
      chainName: "Optimism",
      nativeCurrency: {
        name: "ETH",
        symbol: "ETH",
        decimals: 18
      },
      rpcUrls: ["https://mainnet.optimism.io/"]
    }
  }, {
    key: It.FSN,
    chainType: At.EVM,
    name: "Fusion Mainnet",
    coin: ae.FSN,
    id: 32659,
    logoURI: "https://raw.githubusercontent.com/lifinance/types/main/src/assets/icons/chains/fusion.png",
    mainnet: !0,
    multicallAddress: Ft[B.FSN],
    metamask: {
      chainId: Rt(32659),
      blockExplorerUrls: ["https://fsnex.com/"],
      chainName: "Fusion Mainnet",
      nativeCurrency: {
        name: "FSN",
        symbol: "FSN",
        decimals: 18
      },
      rpcUrls: ["https://fsnmainnet2.anyswap.exchange"]
    }
  }, {
    key: It.ONE,
    chainType: At.EVM,
    name: "Harmony",
    coin: ae.ONE,
    id: 16666e5,
    mainnet: !0,
    logoURI: "https://raw.githubusercontent.com/lifinance/types/main/src/assets/icons/chains/harmony.svg",
    tokenlistUrl: "https://d1xrz6ki9z98vb.cloudfront.net/venomswap/lists/venomswap-default.tokenlist.json",
    faucetUrls: ["https://stakely.io/faucet/harmony-one"],
    multicallAddress: Ft[B.ONE],
    metamask: {
      chainId: Rt(16666e5),
      blockExplorerUrls: ["https://explorer.harmony.one/"],
      chainName: "Harmony Mainnet Shard 0",
      nativeCurrency: {
        name: "ONE",
        symbol: "ONE",
        decimals: 18
      },
      rpcUrls: ["https://api.harmony.one"]
    }
  }, {
    key: It.MOR,
    chainType: At.EVM,
    name: "Moonriver",
    coin: ae.MOVR,
    id: 1285,
    mainnet: !0,
    logoURI: "https://raw.githubusercontent.com/lifinance/types/main/src/assets/icons/chains/moonriver.svg",
    tokenlistUrl: "https://raw.githubusercontent.com/sushiswap/default-token-list/master/tokens/moonriver.json",
    multicallAddress: Ft[B.MOR],
    metamask: {
      chainId: Rt(1285),
      blockExplorerUrls: ["https://blockscout.moonriver.moonbeam.network/"],
      chainName: "Moonriver",
      nativeCurrency: {
        name: "Moonriver",
        symbol: "MOVR",
        decimals: 18
      },
      rpcUrls: ["https://rpc.api.moonriver.moonbeam.network"]
    }
  }, {
    key: It.MOO,
    chainType: At.EVM,
    name: "Moonbeam",
    coin: ae.GLMR,
    id: 1284,
    mainnet: !0,
    logoURI: "https://raw.githubusercontent.com/lifinance/types/main/src/assets/icons/chains/moonbeam.svg",
    tokenlistUrl: "https://raw.githubusercontent.com/BeamSwap/beamswap-tokenlist/main/tokenlist.json",
    multicallAddress: Ft[B.MOO],
    metamask: {
      chainId: Rt(1284),
      blockExplorerUrls: ["https://blockscout.moonbeam.network/"],
      chainName: "Moonbeam",
      nativeCurrency: {
        name: "GLMR",
        symbol: "GLMR",
        decimals: 18
      },
      rpcUrls: ["https://rpc.api.moonbeam.network"]
    }
  }, {
    key: It.EXP,
    chainType: At.EVM,
    name: "Expanse Network",
    coin: ae.EXP,
    id: 2,
    mainnet: !0,
    logoURI: "https://raw.githubusercontent.com/lifinance/types/main/src/assets/icons/chains/expanse.png",
    multicallAddress: Ft[B.EXP],
    metamask: {
      chainId: Rt(2),
      blockExplorerUrls: ["https://expanse.tech/"],
      chainName: "Expanse Network",
      nativeCurrency: {
        name: "EXP",
        symbol: "EXP",
        decimals: 18
      },
      rpcUrls: ["https://node.expanse.tech"]
    }
  }, {
    key: It.TCH,
    chainType: At.EVM,
    name: "ThaiChain",
    coin: ae.TCH,
    id: 7,
    mainnet: !0,
    multicallAddress: Ft[B.TCH],
    metamask: {
      chainId: Rt(7),
      blockExplorerUrls: ["https://thaichain.io/"],
      chainName: "ThaiChain",
      nativeCurrency: {
        name: "TCH",
        symbol: "TCH",
        decimals: 18
      },
      rpcUrls: ["https://rpc.dome.cloud/"]
    }
  }, {
    key: It.UBQ,
    chainType: At.EVM,
    name: "Ubiq",
    coin: ae.UBQ,
    id: 8,
    mainnet: !0,
    multicallAddress: Ft[B.UBQ],
    metamask: {
      chainId: Rt(8),
      blockExplorerUrls: ["https://ubiqscan.io/"],
      chainName: "Ubiq",
      nativeCurrency: {
        name: "UBQ",
        symbol: "UBQ",
        decimals: 18
      },
      rpcUrls: ["https://rpc.octano.dev/"]
    }
  }, {
    key: It.MET,
    chainType: At.EVM,
    name: "Metadium Mainnet",
    coin: ae.META,
    id: 11,
    mainnet: !0,
    multicallAddress: Ft[B.MET],
    metamask: {
      chainId: Rt(11),
      blockExplorerUrls: ["https://metadium.com/"],
      chainName: "Metadium Mainnet",
      nativeCurrency: {
        name: "META",
        symbol: "META",
        decimals: 18
      },
      rpcUrls: ["https://api.metadium.com/prod"]
    }
  }, {
    key: It.DIO,
    chainType: At.EVM,
    name: "DIODE",
    coin: ae.DIODE,
    id: 15,
    mainnet: !0,
    multicallAddress: Ft[B.DIO],
    metamask: {
      chainId: Rt(15),
      blockExplorerUrls: ["https://diode.io/prenet/"],
      chainName: "Diode Prenet",
      nativeCurrency: {
        name: "Diodes",
        symbol: "DIODE",
        decimals: 18
      },
      rpcUrls: ["https://prenet.diode.io:8443/"]
    }
  }, {
    key: It.CEL,
    chainType: At.EVM,
    name: "CELO",
    coin: ae.CELO,
    id: 42220,
    mainnet: !0,
    logoURI: "https://raw.githubusercontent.com/lifinance/types/main/src/assets/icons/chains/celo.svg",
    tokenlistUrl: "https://raw.githubusercontent.com/sushiswap/default-token-list/master/tokens/celo.json",
    faucetUrls: ["https://stakely.io/faucet/celo-platform", "https://free-online-app.com/faucet-for-eth-evm-chains/"],
    multicallAddress: Ft[B.CEL],
    metamask: {
      chainId: Rt(42220),
      blockExplorerUrls: ["https://explorer.celo.org/"],
      chainName: "Celo Mainnet",
      nativeCurrency: {
        name: "CELO",
        symbol: "CELO",
        decimals: 18
      },
      rpcUrls: ["https://forno.celo.org"]
    }
  }, {
    key: It.FUS,
    chainType: At.EVM,
    name: "FUSE",
    coin: ae.FUSE,
    id: 122,
    mainnet: !0,
    logoURI: "https://raw.githubusercontent.com/lifinance/types/main/src/assets/icons/chains/fuse.svg",
    tokenlistUrl: "https://raw.githubusercontent.com/sushiswap/default-token-list/master/tokens/fuse.json",
    multicallAddress: Ft[B.FUS],
    metamask: {
      chainId: Rt(122),
      blockExplorerUrls: ["https://explorer.fuse.io/"],
      chainName: "Fuse Mainnet",
      nativeCurrency: {
        name: "FUSE",
        symbol: "FUSE",
        decimals: 18
      },
      rpcUrls: ["https://rpc.fuse.io"]
    }
  }, {
    key: It.TLO,
    chainType: At.EVM,
    name: "Telos",
    coin: ae.TLOS,
    id: 40,
    mainnet: !0,
    tokenlistUrl: "https://raw.githubusercontent.com/sushiswap/default-token-list/master/tokens/telos.json",
    multicallAddress: Ft[B.TLO],
    metamask: {
      chainId: Rt(40),
      blockExplorerUrls: ["https://telos.net/"],
      chainName: "Telos EVM Mainnet",
      nativeCurrency: {
        name: "Telos",
        symbol: "TLOS",
        decimals: 18
      },
      rpcUrls: ["https://mainnet.telos.net/evm"]
    }
  }, {
    key: It.CRO,
    chainType: At.EVM,
    name: "Cronos",
    coin: ae.CRO,
    id: 25,
    mainnet: !0,
    logoURI: "https://raw.githubusercontent.com/lifinance/types/main/src/assets/icons/chains/cronos.svg",
    tokenlistUrl: "https://raw.githubusercontent.com/cronaswap/cronaswap-tokenlists/main/cronaswap-default.tokenlist.json",
    multicallAddress: Ft[B.CRO],
    metamask: {
      chainId: Rt(25),
      blockExplorerUrls: ["https://cronos.crypto.org/explorer/"],
      chainName: "Cronos",
      nativeCurrency: {
        name: "Crypto.org Coin",
        symbol: "CRO",
        decimals: 18
      },
      rpcUrls: ["https://evm-cronos.crypto.org"]
    }
  }, {
    key: It.BOB,
    chainType: At.EVM,
    name: "Boba",
    coin: ae.ETH,
    id: 288,
    mainnet: !0,
    logoURI: "https://raw.githubusercontent.com/lifinance/types/main/src/assets/icons/chains/boba.png",
    tokenlistUrl: "https://raw.githubusercontent.com/OolongSwap/boba-community-token-list/main/build/boba.tokenlist.json",
    multicallAddress: Ft[B.BOB],
    metamask: {
      chainId: Rt(288),
      blockExplorerUrls: ["https://blockexplorer.boba.network/"],
      chainName: "Boba",
      nativeCurrency: {
        name: "ETH",
        symbol: "ETH",
        decimals: 18
      },
      rpcUrls: ["https://mainnet.boba.network/"]
    }
  }, {
    key: It.SHI,
    chainType: At.EVM,
    name: "Shiba",
    coin: ae.SHIB,
    id: 27,
    mainnet: !0,
    multicallAddress: Ft[B.SHI],
    metamask: {
      chainId: Rt(27),
      blockExplorerUrls: ["https://exp.shibachain.net/"],
      chainName: "Shiba",
      nativeCurrency: {
        name: "SHIB",
        symbol: "SHIB",
        decimals: 18
      },
      rpcUrls: ["https://rpc.shibachain.net"]
    }
  }, {
    key: It.GL1,
    chainType: At.EVM,
    name: "Genesis L1",
    coin: ae.L1,
    id: 29,
    mainnet: !0,
    multicallAddress: Ft[B.GL1],
    metamask: {
      chainId: Rt(29),
      blockExplorerUrls: ["https://explorer.genesisl1.org/"],
      chainName: "Genesis L1",
      nativeCurrency: {
        name: "L1",
        symbol: "L1",
        decimals: 18
      },
      rpcUrls: ["https://rpc.genesisl1.org"]
    }
  }, {
    key: It.RSK,
    chainType: At.EVM,
    name: "RSK Mainnet",
    coin: ae.RBTC,
    id: 30,
    mainnet: !0,
    multicallAddress: Ft[B.RSK],
    metamask: {
      chainId: Rt(30),
      blockExplorerUrls: ["https://explorer.rsk.co/"],
      chainName: "RSK Mainnet",
      nativeCurrency: {
        name: "RBTC",
        symbol: "RBTC",
        decimals: 18
      },
      rpcUrls: ["https://public-node.rsk.co"]
    }
  }, {
    key: It.TBW,
    chainType: At.EVM,
    name: "TBWG",
    coin: ae.TBG,
    id: 35,
    mainnet: !0,
    multicallAddress: Ft[B.TBW],
    metamask: {
      chainId: Rt(35),
      blockExplorerUrls: ["https://tbwg.io/"],
      chainName: "TBWG",
      nativeCurrency: {
        name: "TBG",
        symbol: "TBG",
        decimals: 18
      },
      rpcUrls: ["https://rpc.tbwg.io"]
    }
  }, {
    key: It.VEL,
    chainType: At.EVM,
    name: "Velas",
    coin: ae.VLX,
    id: 106,
    mainnet: !0,
    multicallAddress: Ft[B.VEL],
    logoURI: "https://raw.githubusercontent.com/lifinance/types/main/src/assets/icons/chains/velas.png",
    faucetUrls: ["https://stakely.io/faucet/velas-vlx"],
    metamask: {
      chainId: Rt(106),
      blockExplorerUrls: ["https://evmexplorer.velas.com/"],
      chainName: "Velas",
      nativeCurrency: {
        name: "VLX",
        symbol: "VLX",
        decimals: 18
      },
      rpcUrls: ["https://evmexplorer.velas.com/rpc"]
    }
  }, {
    key: It.MAM,
    chainType: At.EVM,
    name: "Metis",
    coin: ae.METIS,
    id: 1088,
    mainnet: !0,
    logoURI: "https://raw.githubusercontent.com/lifinance/types/main/src/assets/icons/chains/metis.png",
    tokenlistUrl: "https://raw.githubusercontent.com/digitalnativeinc/default-token-list/dnf/tokens/metis.json",
    multicallAddress: Ft[B.MAM],
    metamask: {
      chainId: Rt(1088),
      blockExplorerUrls: ["https://andromeda-explorer.metis.io/"],
      chainName: "Metis",
      nativeCurrency: {
        name: "METIS",
        symbol: "METIS",
        decimals: 18
      },
      rpcUrls: ["https://andromeda.metis.io/?owner=1088"]
    }
  }, {
    key: It.AUR,
    chainType: At.EVM,
    name: "Aurora",
    coin: ae.ETH,
    id: 1313161554,
    mainnet: !0,
    logoURI: "https://raw.githubusercontent.com/lifinance/types/main/src/assets/icons/chains/aurora.png",
    tokenlistUrl: "https://aurora.dev/tokens.json",
    multicallAddress: Ft[B.AUR],
    metamask: {
      chainId: Rt(1313161554),
      blockExplorerUrls: ["https://aurorascan.dev/"],
      chainName: "Aurora",
      nativeCurrency: {
        name: "ETH",
        symbol: "ETH",
        decimals: 18
      },
      rpcUrls: ["https://mainnet.aurora.dev"]
    }
  }, {
    key: It.EVM,
    chainType: At.EVM,
    name: "Evmos",
    coin: ae.EVM,
    id: 9001,
    mainnet: !0,
    logoURI: "https://raw.githubusercontent.com/lifinance/types/main/src/assets/icons/chains/evmos.svg",
    multicallAddress: Ft[B.EVM],
    metamask: {
      chainId: Rt(9001),
      blockExplorerUrls: ["https://evm.evmos.org/"],
      chainName: "Evmos",
      nativeCurrency: {
        name: "EVMOS",
        symbol: "EVMOS",
        decimals: 18
      },
      rpcUrls: ["https://eth.bd.evmos.org:8545"]
    }
  }, {
    key: It.ERA,
    chainType: At.EVM,
    name: "zkSync Era",
    coin: ae.ETH,
    id: 324,
    mainnet: !0,
    logoURI: "https://raw.githubusercontent.com/lifinance/types/main/src/assets/icons/chains/zksync.svg",
    multicallAddress: Ft[B.ERA],
    metamask: {
      chainId: Rt(324),
      blockExplorerUrls: ["https://explorer.zksync.io/"],
      chainName: "zkSync Era Mainnet",
      nativeCurrency: {
        name: "ETH",
        symbol: "ETH",
        decimals: 18
      },
      rpcUrls: ["https://mainnet.era.zksync.io"]
    }
  }, {
    key: It.PZE,
    chainType: At.EVM,
    name: "Polygon zkEVM",
    coin: ae.ETH,
    id: 1101,
    mainnet: !0,
    logoURI: "https://raw.githubusercontent.com/lifinance/types/main/src/assets/icons/chains/zkevm.png",
    multicallAddress: Ft[B.PZE],
    metamask: {
      chainId: Rt(1101),
      blockExplorerUrls: ["https://zkevm.polygonscan.com/"],
      chainName: "Polygon zkEVM",
      nativeCurrency: {
        name: "ETH",
        symbol: "ETH",
        decimals: 18
      },
      rpcUrls: ["https://zkevm-rpc.com"]
    }
  }, {
    key: It.BAS,
    chainType: At.EVM,
    name: "BASE",
    coin: ae.ETH,
    id: 8453,
    mainnet: !0,
    logoURI: "https://raw.githubusercontent.com/lifinance/types/main/src/assets/icons/chains/base.svg",
    multicallAddress: Ft[B.BAS],
    metamask: {
      chainId: Rt(8453),
      blockExplorerUrls: ["https://basescan.org/"],
      chainName: "BASE",
      nativeCurrency: {
        name: "Ethereum",
        symbol: "ETH",
        decimals: 18
      },
      rpcUrls: ["https://mainnet.base.org"]
    }
  }, {
    key: It.LNA,
    chainType: At.EVM,
    name: "Linea",
    coin: ae.ETH,
    id: 59144,
    mainnet: !0,
    logoURI: "https://raw.githubusercontent.com/lifinance/types/main/src/assets/icons/chains/linea.svg",
    multicallAddress: Ft[B.LNA],
    metamask: {
      chainId: Rt(59144),
      blockExplorerUrls: ["https://lineascan.build/"],
      chainName: "LINEA",
      nativeCurrency: {
        name: "ETH",
        symbol: "ETH",
        decimals: 18
      },
      rpcUrls: ["https://rpc.linea.build"]
    }
  }, {
    key: It.GOR,
    chainType: At.EVM,
    name: "Goerli",
    coin: ae.ETH,
    id: 5,
    mainnet: !1,
    logoURI: "https://raw.githubusercontent.com/lifinance/types/main/src/assets/icons/chains/ethereum_goerli.png",
    tokenlistUrl: "https://raw.githubusercontent.com/compound-finance/token-list/master/compound.tokenlist.json",
    faucetUrls: ["https://goerli-faucet.slock.it/"],
    multicallAddress: Ft[B.GOR],
    metamask: {
      chainId: Rt(5),
      blockExplorerUrls: ["https://goerli.etherscan.io/"],
      chainName: "Ethereum Testnet Görli",
      nativeCurrency: {
        name: "ETH",
        symbol: "ETH",
        decimals: 18
      },
      rpcUrls: ["https://rpc.ankr.com/eth_goerli"]
    }
  }, {
    key: It.METT,
    chainType: At.EVM,
    name: "Metadium Testnet",
    coin: ae.KAL,
    id: 12,
    mainnet: !1,
    multicallAddress: Ft[B.METT],
    metamask: {
      chainId: Rt(12),
      blockExplorerUrls: ["https://metadium.com/"],
      chainName: "Metadium Testnet",
      nativeCurrency: {
        name: "KAL",
        symbol: "KAL",
        decimals: 18
      },
      rpcUrls: ["https://api.metadium.com/dev"]
    }
  }, {
    key: It.DIOT,
    chainType: At.EVM,
    name: "DIODE",
    coin: ae.SDIODE,
    id: 13,
    mainnet: !1,
    multicallAddress: Ft[B.DIOT],
    metamask: {
      chainId: Rt(13),
      blockExplorerUrls: ["https://diode.io/staging/"],
      chainName: "Diode Testnet Staging",
      nativeCurrency: {
        name: "Staging Diodes",
        symbol: "sDIODE",
        decimals: 18
      },
      rpcUrls: ["https://staging.diode.io:8443/"]
    }
  }, {
    key: It.MUM,
    chainType: At.EVM,
    name: "Polygon Testnet",
    coin: ae.MATIC,
    id: 80001,
    mainnet: !1,
    logoURI: "https://raw.githubusercontent.com/lifinance/types/main/src/assets/icons/chains/polygon_test.png",
    tokenlistUrl: "https://raw.githubusercontent.com/elkfinance/tokens/main/mumbai.tokenlist.json",
    faucetUrls: ["https://faucet.matic.network/"],
    multicallAddress: Ft[B.MUM],
    metamask: {
      chainId: Rt(80001),
      blockExplorerUrls: ["https://explorer-mumbai.maticvigil.com/"],
      chainName: "Matic(Polygon) Testnet Mumbai",
      nativeCurrency: {
        name: "MATIC",
        symbol: "tMATIC",
        decimals: 18
      },
      rpcUrls: ["https://rpc-mumbai.matic.today"]
    }
  }, {
    key: It.ARBG,
    chainType: At.EVM,
    name: "Arbitrum Görli",
    coin: ae.ETH,
    id: 421613,
    mainnet: !1,
    logoURI: "https://raw.githubusercontent.com/lifinance/types/main/src/assets/icons/chains/arbitrum_test.png",
    faucetUrls: ["https://bridge.arbitrum.io/"],
    multicallAddress: Ft[B.ARBG],
    metamask: {
      chainId: Rt(421613),
      blockExplorerUrls: ["https://goerli-rollup-explorer.arbitrum.io/"],
      chainName: "Arbitrum Görli",
      nativeCurrency: {
        name: "AGOR",
        symbol: "AGOR",
        decimals: 18
      },
      rpcUrls: ["https://goerli-rollup.arbitrum.io/rpc/	"]
    }
  }, {
    key: It.OPTG,
    chainType: At.EVM,
    name: "Optimistic Ethereum Testnet Goerli",
    coin: ae.ETH,
    id: 420,
    mainnet: !1,
    logoURI: "https://raw.githubusercontent.com/lifinance/types/main/src/assets/icons/chains/optimism_test.png",
    faucetUrls: ["https://gateway.optimism.io/"],
    multicallAddress: Ft[B.OPTG],
    metamask: {
      chainId: Rt(420),
      blockExplorerUrls: ["https://blockscout.com/optimism/goerli/"],
      chainName: "Optimistic Ethereum Testnet Goerli",
      nativeCurrency: {
        name: "tETH",
        symbol: "tETH",
        decimals: 18
      },
      rpcUrls: ["https://goerli.optimism.io/"]
    }
  }, {
    key: It.BSCT,
    chainType: At.EVM,
    name: "Binance Smart Chain Testnet",
    coin: ae.BNB,
    id: 97,
    mainnet: !1,
    logoURI: "https://raw.githubusercontent.com/lifinance/types/main/src/assets/icons/chains/bsc_test.png",
    faucetUrls: ["https://testnet.binance.org/faucet-smart"],
    multicallAddress: Ft[B.BSCT],
    metamask: {
      chainId: Rt(97),
      blockExplorerUrls: ["https://testnet.bscscan.com/"],
      chainName: "Binance Smart Chain Testnet",
      nativeCurrency: {
        name: "tBNB",
        symbol: "tBNB",
        decimals: 18
      },
      rpcUrls: ["https://data-seed-prebsc-1-s1.binance.org:8545/"]
    }
  }, {
    key: It.HECT,
    chainType: At.EVM,
    name: "Huobi ECO Chain Testnet",
    coin: "HTT",
    id: 256,
    mainnet: !1,
    faucetUrls: ["https://scan-testnet.hecochain.com/faucet"],
    multicallAddress: Ft[B.HECT],
    metamask: {
      chainId: Rt(256),
      blockExplorerUrls: ["https://scan-testnet.hecochain.com/"],
      chainName: "Huobi ECO Chain Testnet",
      nativeCurrency: {
        name: "HT",
        symbol: "HT",
        decimals: 18
      },
      rpcUrls: ["https://http-testnet.hecochain.com"]
    }
  }, {
    key: It.ONET,
    chainType: At.EVM,
    name: "Harmony Testnet",
    coin: ae.ONE,
    id: 16667e5,
    mainnet: !1,
    logoURI: "https://raw.githubusercontent.com/lifinance/types/main/src/assets/icons/chains/harmony_test.png",
    multicallAddress: Ft[B.ONET],
    metamask: {
      chainId: Rt(16667e5),
      blockExplorerUrls: ["https://explorer.pops.one/", "https://explorer.testnet.harmony.one/"],
      chainName: "Harmony Testnet Shard 0",
      nativeCurrency: {
        name: "ONE",
        symbol: "ONE",
        decimals: 18
      },
      rpcUrls: ["https://api.s0.b.hmny.io"]
    }
  }, {
    key: It.FUST,
    chainType: At.EVM,
    name: "SPARK",
    coin: ae.SPARK,
    id: 123,
    mainnet: !1,
    multicallAddress: Ft[B.FUST],
    metamask: {
      chainId: Rt(123),
      blockExplorerUrls: ["https://explorer.fusespark.io/"],
      chainName: "Fuse Sparknet",
      nativeCurrency: {
        name: "Spark",
        symbol: "SPARK",
        decimals: 18
      },
      rpcUrls: ["https://rpc.fusespark.io"]
    }
  }, {
    key: It.TLOT,
    chainType: At.EVM,
    name: "Telos Testnet",
    coin: ae.TLOS,
    id: 41,
    mainnet: !1,
    faucetUrls: ["https://app.telos.net/testnet/developers"],
    multicallAddress: Ft[B.TLOT],
    metamask: {
      chainId: Rt(41),
      blockExplorerUrls: ["https://telos.net/"],
      chainName: "Telos EVM Mainnet",
      nativeCurrency: {
        name: "Telos",
        symbol: "TLOS",
        decimals: 18
      },
      rpcUrls: ["https://testnet.telos.net/evm"]
    }
  }, {
    key: It.RSKT,
    chainType: At.EVM,
    name: "RSK Testnet",
    coin: ae.TRBTC,
    id: 31,
    mainnet: !0,
    multicallAddress: Ft[B.RSKT],
    metamask: {
      chainId: Rt(31),
      blockExplorerUrls: ["https://rsk.co/"],
      chainName: "RSK Testnet",
      nativeCurrency: {
        name: "tRBTC",
        symbol: "TRBTC",
        decimals: 18
      },
      rpcUrls: ["https://public-node.testnet.rsk.co"]
    }
  }, {
    key: It.AVAT,
    chainType: At.EVM,
    name: "Avalanche Fuji Testnet",
    coin: ae.AVAX,
    id: 43113,
    mainnet: !1,
    logoURI: "https://raw.githubusercontent.com/lifinance/types/main/src/assets/icons/chains/avalanche_test.png",
    multicallAddress: Ft[B.AVAT],
    faucetUrls: ["https://faucet.avax-test.network/"],
    metamask: {
      chainId: Rt(43113),
      blockExplorerUrls: ["https://testnet.snowtrace.io/"],
      chainName: "Avalanche Fuji Testnet",
      nativeCurrency: {
        name: "AVAX",
        symbol: "AVAX",
        decimals: 18
      },
      rpcUrls: ["https://api.avax-test.network/ext/bc/C/rpc"]
    }
  }, {
    key: It.LNAT,
    chainType: At.EVM,
    name: "Linea Testnet",
    coin: ae.ETH,
    id: 59140,
    mainnet: !1,
    logoURI: "https://raw.githubusercontent.com/lifinance/types/main/src/assets/icons/chains/linea.svg",
    multicallAddress: Ft[B.LNAT],
    faucetUrls: ["https://faucetlink.to/goerli"],
    metamask: {
      chainId: Rt(59140),
      blockExplorerUrls: ["https://explorer.goerli.linea.build/"],
      chainName: "Linea Testnet",
      nativeCurrency: {
        name: "crETH",
        symbol: "crETH",
        decimals: 18
      },
      rpcUrls: ["https://rpc.goerli.linea.build"]
    }
  }],
  $W = [{
    key: It.SOL,
    chainType: At.SVM,
    name: "Solana",
    coin: ae.SOL,
    id: B.SOL,
    mainnet: !0,
    logoURI: "https://raw.githubusercontent.com/lifinance/types/main/src/assets/icons/chains/solana.svg",
    faucetUrls: ["https://stakely.io/faucet/solana-sol"],
    metamask: {
      chainId: B.SOL.toString(),
      blockExplorerUrls: ["https://explorer.solana.com/", "https://solscan.io/", "https://solana.fm/"],
      chainName: "Solana",
      nativeCurrency: {
        name: "SOL",
        symbol: "SOL",
        decimals: 9
      },
      rpcUrls: ["https://api.mainnet-beta.solana.com"]
    }
  }],
  HM = [...MW, ...$W],
  LW = [...MW, ...$W],
  VM = e => {
    const t = LW.find(n => n.key === e);
    if (!t) throw new Error("Invalid chainKey");
    return t
  },
  BW = e => {
    const t = LW.find(n => n.id === e);
    if (!t) throw new Error("Invalid chainId");
    return t
  },
  ESe = [{
    key: ae.ETH,
    name: ae.ETH,
    logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2/logo.png",
    verified: !0,
    chains: {
      [B.ETH]: {
        address: "0x0000000000000000000000000000000000000000",
        decimals: 18
      },
      [B.BSC]: {
        address: "0x2170ed0880ac9a755fd29b2688956bd959f933f8",
        decimals: 18
      },
      [B.SOL]: {
        address: "7vfCXTUXx5WJV5JADk17DUJ4ksgau7utNKj4b963voxs",
        decimals: 8,
        name: "Wrapped SOL (Wormhole)"
      },
      [B.POL]: {
        address: "0x7ceb23fd6bc0add59e62ac25578270cff1b9f619",
        decimals: 18
      },
      [B.DAI]: {
        address: "0x6a023ccd1ff6f2045c3309768ead9e68f978f6e1",
        decimals: 18,
        symbol: "WETH",
        name: "Wrapped Ether"
      },
      [B.OPT]: {
        address: "0x0000000000000000000000000000000000000000",
        decimals: 18
      },
      [B.ARB]: {
        address: "0x0000000000000000000000000000000000000000",
        decimals: 18
      },
      [B.ERA]: {
        address: "0x0000000000000000000000000000000000000000",
        decimals: 18
      },
      [B.PZE]: {
        address: "0x0000000000000000000000000000000000000000",
        decimals: 18
      },
      [B.BAS]: {
        address: "0x0000000000000000000000000000000000000000",
        decimals: 18
      },
      [B.LNA]: {
        address: "0x0000000000000000000000000000000000000000",
        decimals: 18
      },
      [B.FTM]: {
        address: "0x74b23882a30290451a17c44f4f05243b6b58c76d",
        decimals: 18
      },
      [B.AVA]: {
        address: "0x49d5c2bdffac6ce2bfdb6640f4f80f226bc10bab",
        decimals: 18,
        symbol: "WETH.e",
        name: "Wrapped Ether"
      },
      [B.ONE]: {
        address: "0x6983d1e6def3690c4d616b13597a09e6193ea013",
        decimals: 18
      },
      [B.HEC]: {
        address: "0x64ff637fb478863b7468bc97d30a5bf3a428a1fd",
        decimals: 18,
        name: "Heco-Peg ETH Token"
      },
      [B.OKT]: {
        address: "0xef71ca2ee68f45b9ad6f72fbdb33d707b872315c",
        decimals: 18,
        symbol: "ETHK",
        name: "ETHK"
      },
      [B.BOB]: {
        address: "0x0000000000000000000000000000000000000000",
        decimals: 18
      },
      [B.MOO]: {
        address: "0xfa9343c3897324496a05fc75abed6bac29f8a40f",
        decimals: 18
      },
      [B.AUR]: {
        address: "0x0000000000000000000000000000000000000000",
        decimals: 18,
        symbol: "AETH",
        name: "AETH"
      },
      [B.VEL]: {
        address: "0x85219708c49aa701871ad330a94ea0f41dff24ca",
        decimals: 18
      },
      [B.GOR]: {
        address: "0x0000000000000000000000000000000000000000",
        decimals: 18
      },
      [B.ONET]: {
        address: "0x268d6ff391b41b36a13b1693bd25f87fb4e4b392",
        decimals: 18
      },
      [B.BSCT]: {
        address: "0xd66c6b4f0be8ce5b39d52e0fd1344c389929b378",
        decimals: 18
      },
      [B.OPTG]: {
        address: "0x0000000000000000000000000000000000000000",
        decimals: 18
      },
      [B.ARBG]: {
        address: "0x0000000000000000000000000000000000000000",
        decimals: 18
      },
      [B.LNAT]: {
        address: "0x0000000000000000000000000000000000000000",
        decimals: 18
      }
    }
  }, {
    key: ae.MATIC,
    name: ae.MATIC,
    logoURI: "https://static.debank.com/image/matic_token/logo_url/matic/6f5a6b6f0732a7a235131bd7804d357c.png",
    verified: !0,
    chains: {
      [B.ETH]: {
        address: "0x7d1afa7b718fb893db30a3abc0cfc608aacfebb0",
        decimals: 18,
        name: "Matic Token"
      },
      [B.SOL]: {
        address: "Gz7VkD4MacbEB6yC5XD3HcumEiYx2EtDYYrfikGsvopG",
        decimals: 8,
        name: "Wrapped Matic (Wormhole)"
      },
      [B.BSC]: {
        address: "0xcc42724c6683b7e57334c4e856f4c9965ed682bd",
        decimals: 18,
        name: "Matic Token"
      },
      [B.POL]: {
        address: "0x0000000000000000000000000000000000000000",
        decimals: 18
      },
      [B.DAI]: {
        address: "0x7122d7661c4564b7c6cd4878b06766489a6028a2",
        decimals: 18,
        name: "Matic Token"
      },
      [B.VEL]: {
        address: "0x6ab0b8c1a35f9f4ce107ccbd05049cb1dbd99ec5",
        decimals: 18
      },
      [B.MUM]: {
        address: "0x0000000000000000000000000000000000000000",
        decimals: 18
      },
      [B.LNAT]: {
        address: "0xa55C7E1274bE5db2275a0BDd055f81e8263b7954",
        decimals: 18
      }
    }
  }, {
    key: ae.BNB,
    name: ae.BNB,
    logoURI: "https://assets.coingecko.com/coins/images/825/small/binance-coin-logo.png?1547034615",
    verified: !0,
    chains: {
      [B.ETH]: {
        address: "0xb8c77482e45f1f44de1745f52c74426c631bdd52",
        decimals: 18
      },
      [B.SOL]: {
        address: "9gP2kCy3wA1ctvYWQk75guqXuHfrEomqydHLtcTCqiLa",
        decimals: 8,
        name: "Wrapped BNB (Wormhole)"
      },
      [B.BSC]: {
        address: "0x0000000000000000000000000000000000000000",
        decimals: 18
      },
      [B.POL]: {
        address: "0xa649325aa7c5093d12d6f98eb4378deae68ce23f",
        decimals: 18
      },
      [B.DAI]: {
        address: "0xca8d20f3e0144a72c6b5d576e9bd3fd8557e2b04",
        decimals: 18,
        symbol: "WBNB",
        name: "Wrapped BNB"
      },
      [B.ONE]: {
        address: "0xb1f6e61e1e113625593a22fa6aa94f8052bc39e0",
        decimals: 18,
        symbol: "bscBNB"
      },
      [B.MOO]: {
        address: "0xc9baa8cfdde8e328787e29b4b078abf2dadc2055",
        decimals: 18
      },
      [B.VEL]: {
        address: "0x2b8e9cd44c9e09d936149549a8d207c918ecb5c4",
        decimals: 18
      },
      [B.BSCT]: {
        address: "0x0000000000000000000000000000000000000000",
        decimals: 18
      },
      [B.ONET]: {
        address: "0xbef55684b382bae72051813a898d17282066c007",
        decimals: 18
      },
      [B.LNAT]: {
        address: "0x5471ea8f739dd37E9B81Be9c5c77754D8AA953E4",
        decimals: 18
      }
    }
  }, {
    key: ae.DAI,
    name: "DAI Stablecoin",
    logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0x6B175474E89094C44Da98b954EedeAC495271d0F/logo.png",
    verified: !0,
    chains: {
      [B.ETH]: {
        address: "0x6b175474e89094c44da98b954eedeac495271d0f",
        decimals: 18
      },
      [B.SOL]: {
        address: "EjmyN6qEC1Tf1JxiG1ae7UTJhUxSwk1TCWNWqxWV4J6o",
        decimals: 8,
        name: "DAI Stablecoin (Wormhole)"
      },
      [B.BSC]: {
        address: "0x1af3f329e8be154074d8769d1ffa4ee058b1dbc3",
        decimals: 18
      },
      [B.POL]: {
        address: "0x8f3cf7ad23cd3cadbd9735aff958023239c6a063",
        decimals: 18,
        name: "(PoS) DAI Stablecoin"
      },
      [B.DAI]: {
        address: "0x0000000000000000000000000000000000000000",
        decimals: 18,
        symbol: "xDAI",
        name: "xDAI Native Token"
      },
      [B.OPT]: {
        address: "0xda10009cbd5d07dd0cecc66161fc93d7c9000da1",
        decimals: 18
      },
      [B.ERA]: {
        address: "0x4bef76b6b7f2823c6c1f4fcfeacd85c24548ad7e",
        decimals: 18
      },
      [B.FTM]: {
        address: "0x8d11ec38a3eb5e956b052f67da8bdc9bef8abf3e",
        decimals: 18
      },
      [B.ONE]: {
        address: "0xef977d2f931c1978db5f6747666fa1eacb0d0339",
        decimals: 18,
        symbol: "1DAI"
      },
      [B.AVA]: {
        address: "0xd586e7f844cea2f87f50152665bcbc2c279d8d70",
        decimals: 18,
        symbol: "DAI.e"
      },
      [B.ARB]: {
        address: "0xda10009cbd5d07dd0cecc66161fc93d7c9000da1",
        decimals: 18
      },
      [B.OKT]: {
        address: "0x21cde7e32a6caf4742d00d44b07279e7596d26b9",
        decimals: 18,
        symbol: "DAIK"
      },
      [B.CRO]: {
        address: "0xf2001b145b43032aaf5ee2884e456ccd805f677d",
        decimals: 18
      },
      [B.FUS]: {
        address: "0x94ba7a27c7a95863d1bdc7645ac2951e0cca06ba",
        decimals: 18,
        name: "DAI Stablecoin"
      },
      [B.CEL]: {
        address: "0x90ca507a5d4458a4c6c6249d186b6dcb02a5bccd",
        decimals: 18
      },
      [B.MOO]: {
        address: "0x765277eebeca2e31912c9946eae1021199b39c61",
        decimals: 18
      },
      [B.BOB]: {
        address: "0xf74195bb8a5cf652411867c5c2c5b8c2a402be35",
        decimals: 18
      },
      [B.EVM]: {
        address: "0x461d52769884ca6235B685EF2040F47d30C94EB5",
        decimals: 18
      },
      [B.VEL]: {
        address: "0xe3f5a90f9cb311505cd691a46596599aa1a0ad7d",
        decimals: 18
      },
      [B.GOR]: {
        address: "0xdc31ee1784292379fbb2964b3b9c4124d8f89c60",
        decimals: 18
      },
      [B.MUM]: {
        address: "0xb224913ce3851b0a0d7c0fb461eef40f2e31ddb8",
        decimals: 18
      }
    }
  }, {
    key: ae.FTM,
    name: ae.FTM,
    logoURI: "https://static.debank.com/image/ftm_token/logo_url/ftm/33fdb9c5067e94f3a1b9e78f6fa86984.png",
    verified: !0,
    chains: {
      [B.FTM]: {
        address: "0x0000000000000000000000000000000000000000",
        decimals: 18
      },
      [B.SOL]: {
        address: "8gC27rQF4NEDYfyf5aS8ZmQJUum5gufowKGYRRba4ENN",
        decimals: 8,
        name: "Fantom Token (Wormhole)"
      }
    }
  }, {
    key: ae.OKT,
    name: ae.OKT,
    logoURI: "https://static.debank.com/image/okt_token/logo_url/okt/1228cd92320b3d33769bd08eecfb5391.png",
    verified: !0,
    chains: {
      [B.OKT]: {
        address: "0x0000000000000000000000000000000000000000",
        decimals: 18
      }
    }
  }, {
    key: ae.AVAX,
    name: ae.AVAX,
    logoURI: "https://static.debank.com/image/avax_token/logo_url/avax/0b9c84359c84d6bdd5bfda9c2d4c4a82.png",
    verified: !0,
    chains: {
      [B.AVA]: {
        address: "0x0000000000000000000000000000000000000000",
        decimals: 18
      },
      [B.SOL]: {
        address: "KgV1GvrHQmRBY8sHQQeUKwTm2r2h8t4C8qt12Cw1HVE",
        decimals: 8,
        name: "Avalanche (Wormhole)"
      },
      [B.AVAT]: {
        address: "0x0000000000000000000000000000000000000000",
        decimals: 18
      },
      [B.LNAT]: {
        address: "0x265B25e22bcd7f10a5bD6E6410F10537Cc7567e8",
        decimals: 18
      }
    }
  }, {
    key: ae.HT,
    name: ae.HT,
    logoURI: "https://static.debank.com/image/heco_token/logo_url/heco/c399dcddde07e1944c4dd8f922832b53.png",
    verified: !0,
    chains: {
      [B.HEC]: {
        address: "0x0000000000000000000000000000000000000000",
        decimals: 18
      }
    }
  }, {
    key: ae.ONE,
    name: ae.ONE,
    logoURI: "https://assets.coingecko.com/coins/images/18183/small/wonelogo.png",
    verified: !0,
    chains: {
      [B.ONE]: {
        address: "0x0000000000000000000000000000000000000000",
        decimals: 18
      },
      [B.BSC]: {
        address: "0x03ff0ff224f904be3118461335064bb48df47938",
        decimals: 18,
        name: "Harmony ONE"
      },
      [B.ONET]: {
        address: "0x0000000000000000000000000000000000000000",
        decimals: 18
      }
    }
  }, {
    key: ae.FSN,
    name: ae.FSN,
    logoURI: "https://www.bscscan.com/token/images/anyFSN_32.png",
    verified: !0,
    chains: {
      [B.FSN]: {
        address: "0x0000000000000000000000000000000000000000",
        decimals: 18
      }
    }
  }, {
    key: ae.MOVR,
    name: ae.MOVR,
    logoURI: "https://assets.coingecko.com/coins/images/17984/small/9285.png",
    verified: !0,
    chains: {
      [B.MOR]: {
        address: "0x0000000000000000000000000000000000000000",
        decimals: 18
      },
      [B.MOO]: {
        address: "0x1d4c2a246311bb9f827f4c768e277ff5787b7d7e",
        decimals: 18
      }
    }
  }, {
    key: ae.USDT,
    name: ae.USDT,
    logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xdAC17F958D2ee523a2206206994597C13D831ec7/logo.png",
    verified: !0,
    chains: {
      [B.ETH]: {
        address: "0xdac17f958d2ee523a2206206994597c13d831ec7",
        decimals: 6
      },
      [B.SOL]: {
        address: "Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB",
        decimals: 6,
        name: "USDT"
      },
      [B.BSC]: {
        address: "0x55d398326f99059ff775485246999027b3197955",
        decimals: 18
      },
      [B.POL]: {
        address: "0xc2132d05d31c914a87c6611c10748aeb04b58e8f",
        decimals: 6
      },
      [B.DAI]: {
        address: "0x4ecaba5870353805a9f068101a40e0f32ed605c6",
        decimals: 6
      },
      [B.OPT]: {
        address: "0x94b008aa00579c1307b0ef2c499ad98a8ce58e58",
        decimals: 6
      },
      [B.FTM]: {
        address: "0x049d68029688eabf473097a2fc38ef61633a3c7a",
        decimals: 6
      },
      [B.ARB]: {
        address: "0xfd086bc7cd5c481dcc9c85ebe478a1c0b69fcbb9",
        decimals: 6
      },
      [B.ONE]: {
        address: "0x3c2b8be99c50593081eaa2a724f0b8285f5aba8f",
        decimals: 6
      },
      [B.AVA]: {
        address: "0xc7198437980c041c805a1edcba50c1ce5db95118",
        decimals: 6,
        symbol: "USDT.e",
        name: "Tether USD"
      },
      [B.MOR]: {
        address: "0xb44a9b6905af7c801311e8f4e76932ee959c663c",
        decimals: 6
      },
      [B.OKT]: {
        address: "0x382bb369d343125bfb2117af9c149795c6c65c50",
        decimals: 18
      },
      [B.CRO]: {
        address: "0x66e428c3f67a68878562e79a0234c1f83c208770",
        decimals: 6
      },
      [B.HEC]: {
        address: "0xa71edc38d189767582c38a3145b5873052c3e47a",
        decimals: 18
      },
      [B.FUS]: {
        address: "0xfadbbf8ce7d5b7041be672561bba99f79c532e10",
        decimals: 6
      },
      [B.CEL]: {
        address: "0x88eec49252c8cbc039dcdb394c0c2ba2f1637ea0",
        decimals: 6
      },
      [B.MOO]: {
        address: "0xefaeee334f0fd1712f9a8cc375f427d9cdd40d73",
        decimals: 6
      },
      [B.BOB]: {
        address: "0x5de1677344d3cb0d7d465c10b72a8f60699c062d",
        decimals: 6
      },
      [B.EVM]: {
        address: "0x7FF4a56B32ee13D7D4D405887E0eA37d61Ed919e",
        decimals: 6
      },
      [B.AUR]: {
        address: "0x4988a896b1227218e4A686fdE5EabdcAbd91571f",
        decimals: 6
      },
      [B.VEL]: {
        address: "0x01445c31581c354b7338ac35693ab2001b50b9ae",
        decimals: 6,
        name: "Multichain USDT"
      },
      [B.LNA]: {
        address: "0xa219439258ca9da29e9cc4ce5596924745e12b93",
        decimals: 6,
        name: "USDT"
      },
      [B.GOR]: {
        address: "0x509ee0d083ddf8ac028f2a56731412edd63223b9",
        decimals: 6
      }
    }
  }, {
    key: ae.sgUSDC,
    name: ae.sgUSDC,
    logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48/logo.png",
    verified: !0,
    chains: {
      [B.GOR]: {
        address: "0xDf0360Ad8C5ccf25095Aa97ee5F2785c8d848620",
        decimals: 6
      },
      [B.MUM]: {
        address: "0x742DfA5Aa70a8212857966D491D67B09Ce7D6ec7",
        decimals: 6
      },
      [B.ARBG]: {
        address: "0x6aad876244e7a1ad44ec4824ce813729e5b6c291",
        decimals: 6
      }
    }
  }, {
    key: ae.sgBUSD,
    name: ae.sgBUSD,
    logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48/logo.png",
    verified: !0,
    chains: {
      [B.BSCT]: {
        address: "0x1010Bb1b9Dff29e6233E7947e045e0ba58f6E92e",
        decimals: 6
      }
    }
  }, {
    key: ae.sgUSDT,
    name: ae.sgUSDT,
    logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48/logo.png",
    verified: !0,
    chains: {
      [B.GOR]: {
        address: "0x5bcc22abec37337630c0e0dd41d64fd86caee951",
        decimals: 6
      },
      [B.MUM]: {
        address: "0x6fc340be8e378c2ff56476409ef48da9a3b781a0",
        decimals: 6
      },
      [B.BSCT]: {
        address: "0xf49e250aeb5abdf660d643583adfd0be41464efd",
        decimals: 6
      },
      [B.ARBG]: {
        address: "0x533046f316590c19d99c74ee661c6d541b64471c",
        decimals: 6
      }
    }
  }, {
    key: ae.sgMETIS,
    name: ae.sgMETIS,
    logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48/logo.png",
    verified: !0,
    chains: {
      [B.GOR]: {
        address: "0x9874a71b976daa037741d18b86bc6b2f9957fc8a",
        decimals: 18
      },
      [B.BSCT]: {
        address: "0x8362af3426e6c7a77438f29bdc81c8f27cd541ab",
        decimals: 18
      }
    }
  }, {
    key: ae.sgWOO,
    name: ae.sgWOO,
    logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48/logo.png",
    verified: !0,
    chains: {
      [B.GOR]: {
        address: "0xc9ba30be110864264577ad091c47f986318b213e",
        decimals: 18
      },
      [B.MUM]: {
        address: "0xb9C468f4308f3f937B4Fc79946244459bBC3cf65",
        decimals: 18
      },
      [B.BSCT]: {
        address: "0x6df6db769dd1c845596f7e65a1c86c98d6147cc3",
        decimals: 18
      },
      [B.ARBG]: {
        address: "0xac9da6d889e82d08de63f5752f91b151ffe059fb",
        decimals: 18
      }
    }
  }, {
    key: ae.cbtCELR,
    name: ae.cbtCELR,
    logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48/logo.png",
    verified: !0,
    chains: {
      [B.GOR]: {
        address: "0x5D3c0F4cA5EE99f8E8F59Ff9A5fAb04F6a7e007f",
        decimals: 18
      },
      [B.BSCT]: {
        address: "0x5471ea8f739dd37E9B81Be9c5c77754D8AA953E4",
        decimals: 18
      }
    }
  }, {
    key: ae.cbtUSDT,
    name: ae.cbtUSDT,
    logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48/logo.png",
    verified: !0,
    chains: {
      [B.GOR]: {
        address: "0xf4b2cbc3ba04c478f0dc824f4806ac39982dce73",
        decimals: 6
      },
      [B.BSCT]: {
        address: "0x7d43AABC515C356145049227CeE54B608342c0ad",
        decimals: 6
      }
    }
  }, {
    key: ae.cbtWUSDT,
    name: ae.cbtWUSDT,
    logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48/logo.png",
    verified: !0,
    chains: {
      [B.GOR]: {
        address: "0x9D39Fc627A6d9d9F8C831c16995b209548cc3401",
        decimals: 6
      },
      [B.BSCT]: {
        address: "0xC826C23327098cd8A37f140114F2173A8F62DD29",
        decimals: 6
      }
    }
  }, {
    key: ae.cbtWUSDC,
    name: ae.cbtWUSDC,
    logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48/logo.png",
    verified: !0,
    chains: {
      [B.GOR]: {
        address: "0x4a63Afc71427807586dA190Bb0D3adB461fF9589",
        decimals: 6
      }
    }
  }, {
    key: ae.cbtUSDC,
    name: ae.cbtUSDC,
    logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48/logo.png",
    verified: !0,
    chains: {
      [B.MUM]: {
        address: "0x6de33698e9e9b787e09d3bd7771ef63557e148bb",
        decimals: 6
      },
      [B.AVAT]: {
        address: "0x2979a1cb90EEB9e75d7fB4f9813FCC40E4a7fD8b",
        decimals: 6
      },
      [B.BSCT]: {
        address: "0x317F8d18FB16E49a958Becd0EA72f8E153d25654",
        decimals: 6
      },
      [B.GOR]: {
        address: "0xCbE56b00d173A26a5978cE90Db2E33622fD95A28",
        decimals: 6
      }
    }
  }, {
    key: ae.USDC,
    name: "USD Coin",
    logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48/logo.png",
    verified: !0,
    chains: {
      [B.BAS]: {
        address: "0xd9aaec86b65d86f6a7b5b1b0c42ffa531710b6ca",
        decimals: 6,
        name: "USD Base Coin"
      },
      [B.ETH]: {
        address: "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
        decimals: 6
      },
      [B.SOL]: {
        address: "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
        decimals: 6,
        name: "USD Coin"
      },
      [B.BSC]: {
        address: "0x8ac76a51cc950d9822d68b83fe1ad97b32cd580d",
        decimals: 18
      },
      [B.POL]: {
        address: "0x3c499c542cef5e3811e1192ce70d8cc03d5c3359",
        decimals: 6
      },
      [B.DAI]: {
        address: "0xddafbb505ad214d7b80b1f830fccc89b60fb7a83",
        decimals: 6
      },
      [B.OPT]: {
        address: "0x7f5c764cbc14f9669b88837ca1490cca17c31607",
        decimals: 6
      },
      [B.ERA]: {
        address: "0x3355df6d4c9c3035724fd0e3914de96a5a83aaf4",
        decimals: 6
      },
      [B.PZE]: {
        address: "0xa8ce8aee21bc2a48a5ef670afcc9274c7bbbc035",
        decimals: 6
      },
      [B.FTM]: {
        address: "0x04068da6c83afcfa0e13ba15a6696662335d5b75",
        decimals: 6
      },
      [B.ARB]: {
        address: "0xaf88d065e77c8cC2239327C5EDb3A432268e5831",
        decimals: 6
      },
      [B.ONE]: {
        address: "0x985458e523db3d53125813ed68c274899e9dfab4",
        decimals: 6
      },
      [B.AVA]: {
        address: "0xb97ef9ef8734c71904d8002f8b6bc66dd9c48a6e",
        decimals: 6
      },
      [B.MOR]: {
        address: "0xe3f5a90f9cb311505cd691a46596599aa1a0ad7d",
        decimals: 6
      },
      [B.HEC]: {
        address: "0x9362bbef4b8313a8aa9f0c9808b80577aa26b73b",
        decimals: 6
      },
      [B.OKT]: {
        address: "0xc946daf81b08146b1c7a8da2a851ddf2b3eaaf85",
        decimals: 18
      },
      [B.CRO]: {
        address: "0xc21223249ca28397b4b6541dffaecc539bff0c59",
        decimals: 6
      },
      [B.FUS]: {
        address: "0x620fd5fa44be6af63715ef4e65ddfa0387ad13f5",
        decimals: 6
      },
      [B.CEL]: {
        address: "0xef4229c8c3250c675f21bcefa42f58efbff6002a",
        decimals: 6
      },
      [B.MOO]: {
        address: "0x818ec0a7fe18ff94269904fced6ae3dae6d6dc0b",
        decimals: 6
      },
      [B.BOB]: {
        address: "0x66a2a913e447d6b4bf33efbec43aaef87890fbbc",
        decimals: 6
      },
      [B.EVM]: {
        address: "0x51e44FfaD5C2B122C8b635671FCC8139dc636E82",
        decimals: 6
      },
      [B.AUR]: {
        address: "0xB12BFcA5A55806AaF64E99521918A4bf0fC40802",
        decimals: 6
      },
      [B.VEL]: {
        address: "0xe2c120f188ebd5389f71cf4d9c16d05b62a58993",
        decimals: 6,
        name: "Multichain USDC"
      },
      [B.LNA]: {
        address: "0x176211869ca2b568f2a7d4ee941e073a821ee1ff",
        decimals: 6,
        name: "USDC.e"
      },
      [B.GOR]: {
        address: "0xd87ba7a50b2e7e660f678a895e4b72e7cb4ccd9c",
        decimals: 6
      },
      [B.MUM]: {
        address: "0x6d4dd09982853f08d9966ac3ca4eb5885f16f2b2",
        decimals: 6
      },
      [B.LNAT]: {
        address: "0x964FF70695da981027c81020B1c58d833D49A640",
        decimals: 6,
        name: "Linea USD Coin"
      }
    }
  }, {
    key: ae.USDCe,
    name: ae.USDCe,
    logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48/logo.png",
    verified: !0,
    chains: {
      [B.POL]: {
        address: "0x2791bca1f2de4661ed88a30c99a7a9449aa84174",
        decimals: 6,
        name: "Bridged USD Coin",
        symbol: "USDC.e"
      },
      [B.ARB]: {
        address: "0xff970a61a04b1ca14834a43f5de4533ebddb5cc8",
        decimals: 6,
        name: "Bridged USD Coin",
        symbol: "USDC.e"
      },
      [B.AVA]: {
        address: "0xa7d7079b0fead91f3e65f86e8915cb59c1a4c664",
        decimals: 6,
        name: "Bridged USD Coin",
        symbol: "USDC.e"
      }
    }
  }, {
    key: ae.BUSD,
    name: ae.BUSD,
    logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/binance/assets/BUSD-BD1/logo.png",
    verified: !0,
    chains: {
      [B.ETH]: {
        address: "0x4Fabb145d64652a948d72533023f6E7A623C7C53",
        decimals: 18
      },
      [B.BSC]: {
        address: "0xe9e7cea3dedca5984780bafc599bd69add087d56",
        decimals: 18
      },
      [B.OPT]: {
        address: "0x9C9e5fD8bbc25984B178FdCE6117Defa39d2db39",
        decimals: 18
      },
      [B.POL]: {
        address: "0x9C9e5fD8bbc25984B178FdCE6117Defa39d2db39",
        decimals: 18
      },
      [B.AVA]: {
        address: "0x9C9e5fD8bbc25984B178FdCE6117Defa39d2db39",
        decimals: 18
      },
      [B.SOL]: {
        address: "33fsBLA8djQm82RpHmE3SuVrPGtZBWNYExsEUeKX1HXX",
        decimals: 18
      },
      [B.FUS]: {
        address: "0x6a5F6A8121592BeCd6747a38d67451B310F7f156",
        decimals: 18
      },
      [B.VEL]: {
        address: "0xc111c29a988ae0c0087d97b33c6e6766808a3bd3",
        decimals: 18
      },
      [B.ONE]: {
        address: "0xe176ebe47d621b984a73036b9da5d834411ef734",
        decimals: 18
      },
      [B.BSCT]: {
        address: "0xeB3Eb991D39Dac92616da64b7c6D5af5cCFf1627",
        decimals: 18
      },
      [B.LNAT]: {
        address: "0x7d43AABC515C356145049227CeE54B608342c0ad",
        decimals: 18
      }
    }
  }, {
    key: ae.TEST,
    name: ae.TEST,
    logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2/logo.png",
    verified: !1,
    chains: {
      [B.GOR]: {
        address: "0x8a1cad3703e0beae0e0237369b4fcd04228d1682",
        decimals: 18
      },
      [B.MUM]: {
        address: "0xe71678794fff8846bff855f716b0ce9d9a78e844",
        decimals: 18
      },
      [B.BSCT]: {
        address: "0xd86bcb7d85163fbc81756bb9cc22225d6abccadb",
        decimals: 18
      }
    }
  }, {
    key: ae.CXTT,
    name: ae.CXTT,
    logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2/logo.png",
    verified: !1,
    chains: {
      [B.GOR]: {
        address: "0x7ea6eA49B0b0Ae9c5db7907d139D9Cd3439862a1",
        name: "Goerli CXTT",
        decimals: 18
      },
      [B.LNAT]: {
        address: "0xb706319d37b945727e71ae0d4353699d19112576",
        decimals: 18
      },
      [B.MUM]: {
        address: "0xeDb95D8037f769B72AAab41deeC92903A98C9E16",
        decimals: 18
      },
      [B.ARBG]: {
        address: "0xDC805eAaaBd6F68904cA706C221c72F8a8a68F9f",
        decimals: 18
      },
      [B.OPTG]: {
        address: "0x68Db1c8d85C09d546097C65ec7DCBFF4D6497CbF",
        decimals: 18
      }
    }
  }, {
    key: ae.WBTC,
    name: ae.WBTC,
    logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599/logo.png",
    verified: !0,
    chains: {
      [B.ETH]: {
        address: "0x2260fac5e5542a773aa44fbcfedf7c193bc2c599",
        decimals: 8
      },
      [B.SOL]: {
        address: "qfnqNqs3nCAHjnyCgLRDbBtq4p2MtHZxw8YjSyYhPoL",
        decimals: 8,
        name: "Wrapped BTC (Wormhole)"
      },
      [B.POL]: {
        address: "0x1bfd67037b42cf73acf2047067bd4f2c47d9bfd6",
        decimals: 8
      },
      [B.DAI]: {
        address: "0x8e5bbbb09ed1ebde8674cda39a0c169401db4252",
        decimals: 8
      },
      [B.FTM]: {
        address: "0x321162cd933e2be498cd2267a90534a804051b11",
        decimals: 8
      },
      [B.OPT]: {
        address: "0x68f180fcce6836688e9084f035309e29bf0a2095",
        decimals: 8
      },
      [B.AVA]: {
        address: "0x50b7545627a5162f82a992c33b87adc75187b218",
        decimals: 8
      },
      [B.ARB]: {
        address: "0x2f2a2543b76a4166549f7aab2e75bef0aefc5b0f",
        decimals: 8
      },
      [B.ONE]: {
        address: "0x3095c7557bcb296ccc6e363de01b760ba031f2d9",
        decimals: 8
      },
      [B.MOR]: {
        address: "0xe6a991ffa8cfe62b0bf6bf72959a3d4f11b2e0f5",
        decimals: 8
      },
      [B.OKT]: {
        address: "0x506f731f7656e2fb34b587b912808f2a7ab640bd",
        decimals: 18
      },
      [B.CRO]: {
        address: "0x062e66477faf219f25d27dced647bf57c3107d52",
        decimals: 8
      },
      [B.FUS]: {
        address: "0x33284f95ccb7b948d9d352e1439561cf83d8d00d",
        decimals: 8
      },
      [B.CEL]: {
        address: "0xbaab46e28388d2779e6e31fd00cf0e5ad95e327b",
        decimals: 8
      },
      [B.MOO]: {
        address: "0x922d641a426dcffaef11680e5358f34d97d112e1",
        decimals: 8
      },
      [B.BOB]: {
        address: "0xdc0486f8bf31df57a952bcd3c1d3e166e3d9ec8b",
        decimals: 8
      },
      [B.EVM]: {
        address: "0xF80699Dc594e00aE7bA200c7533a07C1604A106D",
        decimals: 8
      },
      [B.AUR]: {
        address: "0xF4eB217Ba2454613b15dBdea6e5f22276410e89e",
        decimals: 8
      }
    }
  }, {
    key: ae.WETH,
    name: ae.WETH,
    logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2/logo.png",
    verified: !0,
    chains: {
      [B.ETH]: {
        address: "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2",
        decimals: 18
      },
      [B.SOL]: {
        address: "AaAEw2VCw1XzgvKB8Rj2DyK2ZVau9fbt2bE8hZFWsMyE",
        decimals: 9,
        name: "Allbridge from Ethereum"
      },
      [B.BSC]: {
        address: "0x2170ed0880ac9a755fd29b2688956bd959f933f8",
        decimals: 18
      },
      [B.DAI]: {
        address: "0x6a023ccd1ff6f2045c3309768ead9e68f978f6e1",
        decimals: 18,
        symbol: "WETH",
        name: "Wrapped Ether"
      },
      [B.POL]: {
        address: "0x7ceb23fd6bc0add59e62ac25578270cff1b9f619",
        decimals: 18,
        symbol: "WETH",
        name: "Wrapped Ether"
      },
      [B.FTM]: {
        address: "0x74b23882a30290451a17c44f4f05243b6b58c76d",
        decimals: 18
      },
      [B.BAS]: {
        address: "0x4200000000000000000000000000000000000006",
        decimals: 18
      },
      [B.LNA]: {
        address: "0xe5d7c2a44ffddf6b295a15c148167daaaf5cf34f",
        decimals: 18
      },
      [B.AVA]: {
        address: "0x49d5c2bdffac6ce2bfdb6640f4f80f226bc10bab",
        decimals: 18,
        symbol: "WETH.e",
        name: "Wrapped Ether"
      },
      [B.ARB]: {
        address: "0x82af49447d8a07e3bd95bd0d56f35241523fbab1",
        decimals: 18
      },
      [B.OPT]: {
        address: "0x4200000000000000000000000000000000000006",
        decimals: 18
      },
      [B.MOR]: {
        address: "0x639a647fbe20b6c8ac19e48e2de44ea792c62c5c",
        decimals: 18
      },
      [B.HEC]: {
        address: "0x639a647fbe20b6c8ac19e48e2de44ea792c62c5c",
        decimals: 18
      },
      [B.CRO]: {
        address: "0xe44fd7fcb2b1581822d0c862b68222998a0c299a",
        decimals: 18
      },
      [B.FUS]: {
        address: "0xa722c13135930332eb3d749b2f0906559d2c5b99",
        decimals: 18
      },
      [B.CEL]: {
        address: "0x122013fd7df1c6f636a5bb8f03108e876548b455",
        decimals: 18
      },
      [B.MOO]: {
        address: "0xfA9343C3897324496A05fC75abeD6bAC29f8A40f",
        decimals: 18
      },
      [B.BOB]: {
        address: "0xdeaddeaddeaddeaddeaddeaddeaddeaddead0000",
        decimals: 18
      },
      [B.EVM]: {
        address: "0x5842C5532b61aCF3227679a8b1BD0242a41752f2",
        decimals: 18
      },
      [B.AUR]: {
        address: "0xC9BdeEd33CD01541e1eeD10f90519d2C06Fe3feB",
        decimals: 18
      },
      [B.GOR]: {
        address: "0xb4fbf271143f4fbf7b91a5ded31805e42b2208d6",
        decimals: 18
      },
      [B.MUM]: {
        address: "0xa6fa4fb5f76172d178d61b04b0ecd319c5d1c0aa",
        decimals: 18
      },
      [B.OPTG]: {
        address: "0x4200000000000000000000000000000000000006",
        decimals: 18
      },
      [B.LNAT]: {
        address: "0x2C1b868d6596a18e32E61B901E4060C872647b6C",
        decimals: 18
      }
    }
  }, {
    key: ae.SUSHI,
    name: ae.SUSHI,
    logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599/logo.png",
    verified: !0,
    chains: {
      [B.ETH]: {
        address: "0x6b3595068778dd592e39a122f4f5a5cf09c90fe2",
        decimals: 18
      },
      [B.SOL]: {
        address: "ChVzxWRmrTeSgwd3Ui3UumcN8KX7VK3WaD4KGeSKpypj",
        decimals: 8
      },
      [B.POL]: {
        address: "0x0b3f868e0be5597d5db7feb59e1cadbb0fdda50a",
        decimals: 18
      },
      [B.BSC]: {
        address: "0x947950bcc74888a40ffa2593c5798f11fc9124c4",
        decimals: 18
      },
      [B.DAI]: {
        address: "0x2995d1317dcd4f0ab89f4ae60f3f020a4f17c7ce",
        decimals: 18
      },
      [B.FTM]: {
        address: "0xae75a438b2e0cb8bb01ec1e1e376de11d44477cc",
        decimals: 18
      },
      [B.AVA]: {
        address: "0x37b608519f91f70f2eeb0e5ed9af4061722e4f76",
        decimals: 18
      },
      [B.ARB]: {
        address: "0xd4d42f0b6def4ce0383636770ef773390d85c61a",
        decimals: 18
      },
      [B.ONE]: {
        address: "0xbec775cb42abfa4288de81f387a9b1a3c4bc552a",
        decimals: 18
      },
      [B.MOR]: {
        address: "0xf390830df829cf22c53c8840554b98eafc5dcbc2",
        decimals: 18
      },
      [B.OKT]: {
        address: "0x2218e0d5e0173769f5b4939a3ae423f7e5e4eab7",
        decimals: 18
      },
      [B.HEC]: {
        address: "0x52e00b2da5bd7940ffe26b609a42f957f31118d5",
        decimals: 18
      },
      [B.FUS]: {
        address: "0x90708b20ccc1eb95a4fa7c8b18fd2c22a0ff9e78",
        decimals: 18
      },
      [B.CEL]: {
        address: "0x29dfce9c22003a4999930382fd00f9fd6133acd1",
        decimals: 18
      }
    }
  }, {
    key: ae.DODO,
    name: ae.DODO,
    logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0x43Dfc4159D86F3A37A5A4B3D4580b888ad7d4DDd/logo.png",
    verified: !0,
    chains: {
      [B.ETH]: {
        address: "0x43dfc4159d86f3a37a5a4b3d4580b888ad7d4ddd",
        decimals: 18
      },
      [B.BSC]: {
        address: "0x67ee3cb086f8a16f34bee3ca72fad36f7db929e2",
        decimals: 18
      },
      [B.ARB]: {
        address: "0x69eb4fa4a2fbd498c257c57ea8b7655a2559a581",
        decimals: 18
      }
    }
  }, {
    key: ae.MCB,
    name: ae.MCB,
    logoURI: "https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/0x4e352cF164E64ADCBad318C3a1e222E9EBa4Ce42/logo.png",
    verified: !0,
    chains: {
      [B.ETH]: {
        address: "0x4e352cf164e64adcbad318c3a1e222e9eba4ce42",
        decimals: 18
      },
      [B.ARB]: {
        address: "0x4e352cf164e64adcbad318c3a1e222e9eba4ce42",
        decimals: 18
      }
    }
  }, {
    key: ae.CELR,
    name: ae.CELR,
    logoURI: "https://static.debank.com/image/bsc_token/logo_url/0x1f9f6a696c6fd109cd3956f45dc709d2b3902163/1eb9c8f251098ea22a2cb30a877da86a.png",
    verified: !0,
    chains: {
      [B.ETH]: {
        address: "0x4f9254c83eb525f9fcf346490bbb3ed28a81c667",
        decimals: 18
      },
      [B.BSC]: {
        address: "0x1f9f6a696c6fd109cd3956f45dc709d2b3902163",
        decimals: 18
      },
      [B.ARB]: {
        address: "0x3a8b787f78d775aecfeea15706d4221b40f345ab",
        decimals: 18
      }
    }
  }, {
    key: ae.IF,
    name: ae.IF,
    logoURI: "https://s2.coinmarketcap.com/static/img/coins/64x64/10932.png",
    verified: !0,
    chains: {
      [B.ETH]: {
        address: "0xb0e1fc65c1a741b4662b813eb787d369b8614af1",
        decimals: 18
      },
      [B.BSC]: {
        address: "0xb0e1fc65c1a741b4662b813eb787d369b8614af1",
        decimals: 18
      }
    }
  }, {
    key: ae.CRO,
    name: ae.CRO,
    logoURI: "https://s2.coinmarketcap.com/static/img/coins/64x64/3635.png",
    verified: !0,
    chains: {
      [B.CRO]: {
        address: "0x0000000000000000000000000000000000000000",
        decimals: 18
      }
    }
  }, {
    key: ae.FUSE,
    name: ae.FUSE,
    logoURI: "https://s2.coinmarketcap.com/static/img/coins/64x64/5634.png",
    verified: !0,
    chains: {
      [B.FUS]: {
        address: "0x0000000000000000000000000000000000000000",
        decimals: 18
      }
    }
  }, {
    key: ae.CELO,
    name: ae.CELO,
    logoURI: "https://s2.coinmarketcap.com/static/img/coins/64x64/5567.png",
    verified: !0,
    chains: {
      [B.CEL]: {
        address: "0x471ece3750da237f93b8e339c536989b8978a438",
        decimals: 18
      },
      [B.SOL]: {
        address: "GNCjk3FmPPgZTkbQRSxr6nCvLtYMbXKMnRxg8BgJs62e",
        decimals: 9,
        name: "Allbridge from Celo"
      }
    }
  }, {
    key: ae.GLMR,
    name: ae.GLMR,
    logoURI: "https://s2.coinmarketcap.com/static/img/coins/64x64/6836.png",
    verified: !0,
    chains: {
      [B.MOO]: {
        address: "0x0000000000000000000000000000000000000000",
        decimals: 18
      }
    }
  }, {
    key: ae.METIS,
    name: ae.METIS,
    logoURI: "https://s2.coinmarketcap.com/static/img/coins/64x64/9640.png",
    verified: !0,
    chains: {
      [B.MAM]: {
        address: "0x0000000000000000000000000000000000000000",
        decimals: 18
      }
    }
  }, {
    key: ae.EVM,
    name: "EVMOS",
    logoURI: "https://raw.githubusercontent.com/cronus-finance/token-list/main/assets/evmos/0xD4949664cD82660AaE99bEdc034a0deA8A0bd517/logo.png",
    verified: !0,
    chains: {
      [B.EVM]: {
        address: "0x0000000000000000000000000000000000000000",
        decimals: 18,
        symbol: "EVMOS",
        name: "EVMOS"
      }
    }
  }, {
    key: ae.VLX,
    name: "Velas",
    logoURI: "https://raw.githubusercontent.com/lifinance/types/main/src/assets/icons/tokens/vlx.png",
    verified: !0,
    chains: {
      [B.VEL]: {
        address: "0x0000000000000000000000000000000000000000",
        decimals: 18
      }
    }
  }, {
    key: ae.SOL,
    name: ae.SOL,
    logoURI: "https://assets.coingecko.com/coins/images/4128/small/solana.png",
    verified: !0,
    chains: {
      [B.SOL]: {
        address: "So11111111111111111111111111111111111111112",
        decimals: 9,
        name: "Wrapped SOL"
      },
      [B.ETH]: {
        address: "0xD31a59c85aE9D8edEFeC411D448f90841571b89c",
        decimals: 9,
        name: "Wrapped SOL (Wormhole)"
      },
      [B.POL]: {
        address: "0xd93f7E271cB87c23AaA73edC008A79646d1F9912",
        decimals: 9,
        name: "Wrapped SOL (Wormhole)"
      },
      [B.FTM]: {
        address: "0xd99021C2A33e4Cf243010539c9e9b7c52E0236c1",
        decimals: 9,
        name: "Token Wrapped SOL (Wormhole)"
      },
      [B.AVA]: {
        address: "0xFE6B19286885a4F7F55AdAD09C3Cd1f906D2478F",
        decimals: 9,
        symbol: "WSOL",
        name: "Wrapped SOL (Wormhole)"
      },
      [B.AUR]: {
        address: "0x3370C8961A1697F22B49c99669C1d98fE63d031D",
        decimals: 9,
        symbol: "WSOL",
        name: "Token Wrapped SOL (Wormhole)"
      },
      [B.CEL]: {
        address: "0x4581E64115d46CcdeE65Be2336bEc86c9BA54C01",
        decimals: 9,
        symbol: "WSOL",
        name: "Token Wrapped SOL (Wormhole)"
      }
    }
  }],
  SSe = ESe.map(e => {
    var t, n, r;
    const i = {
      key: e.key,
      name: e.name,
      logoURI: e.logoURI,
      verified: e.verified,
      chains: {}
    };
    for (const [s, o] of Object.entries(e.chains)) i.chains[s] = {
      address: o.address,
      decimals: o.decimals,
      symbol: (t = o.symbol) !== null && t !== void 0 ? t : e.key,
      chainId: parseInt(s),
      coinKey: e.key,
      name: (r = (n = o.name) !== null && n !== void 0 ? n : e.name) !== null && r !== void 0 ? r : e.key,
      logoURI: e.logoURI
    };
    return i
  }),
  CSe = {
    [B.ETH]: {
      address: "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2",
      symbol: "WETH",
      decimals: 18,
      chainId: B.ETH,
      coinKey: ae.WETH,
      name: "WETH",
      logoURI: "https://static.debank.com/image/eth_token/logo_url/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2/61844453e63cf81301f845d7864236f6.png"
    },
    [B.SOL]: {
      address: "So11111111111111111111111111111111111111112",
      symbol: "SOL",
      decimals: 9,
      chainId: B.SOL,
      coinKey: ae.SOL,
      name: "Wrapped SOL",
      logoURI: "https://assets.coingecko.com/coins/images/4128/small/solana.png"
    },
    [B.BSC]: {
      address: "0xbb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c",
      symbol: "WBNB",
      decimals: 18,
      chainId: B.BSC,
      coinKey: "WBNB",
      name: "WBNB",
      logoURI: "https://static.debank.com/image/coin/logo_url/bnb/9784283a36f23a58982fc964574ea530.png"
    },
    [B.POL]: {
      address: "0x0d500b1d8e8ef31e21c99d1db9a6444d3adf1270",
      symbol: "WMATIC",
      decimals: 18,
      chainId: B.POL,
      coinKey: "WMATIC",
      name: "WMATIC",
      logoURI: "https://static.debank.com/image/matic_token/logo_url/0x0d500b1d8e8ef31e21c99d1db9a6444d3adf1270/f6e604ba0324726a3d687c618aa4f163.png"
    },
    [B.DAI]: {
      address: "0xe91d153e0b41518a2ce8dd3d7944fa863463a97d",
      symbol: "WXDAI",
      decimals: 18,
      chainId: B.DAI,
      coinKey: "WXDAI",
      name: "WXDAI",
      logoURI: "https://static.debank.com/image/xdai_token/logo_url/0xe91d153e0b41518a2ce8dd3d7944fa863463a97d/3fedab836c5425fc3fc2eb542c34c81a.png"
    },
    [B.OPT]: {
      address: "0x4200000000000000000000000000000000000006",
      symbol: "WETH",
      decimals: 18,
      chainId: B.OPT,
      coinKey: ae.WETH,
      name: "Wrapped ETH",
      logoURI: "https://static.debank.com/image/op_token/logo_url/0x4200000000000000000000000000000000000006/61844453e63cf81301f845d7864236f6.png"
    },
    [B.ERA]: {
      address: "0x5aea5775959fbc2557cc8789bc1bf90a239d9a91",
      symbol: "WETH",
      decimals: 18,
      chainId: B.ERA,
      coinKey: ae.WETH,
      name: "Wrapped Ether",
      logoURI: "https://static.debank.com/image/era_token/logo_url/0x5aea5775959fbc2557cc8789bc1bf90a239d9a91/61844453e63cf81301f845d7864236f6.png"
    },
    [B.PZE]: {
      address: "0x4f9a0e7fd2bf6067db6994cf12e4495df938e6e9",
      symbol: "WETH",
      decimals: 18,
      chainId: B.PZE,
      coinKey: ae.WETH,
      name: "Wrapped Ether",
      logoURI: "https://static.debank.com/image/pze_token/logo_url/0x4f9a0e7fd2bf6067db6994cf12e4495df938e6e9/61844453e63cf81301f845d7864236f6.png"
    },
    [B.BAS]: {
      address: "0x4200000000000000000000000000000000000006",
      symbol: "WETH",
      decimals: 18,
      chainId: B.BAS,
      coinKey: ae.WETH,
      name: "Wrapped Ether",
      logoURI: "https://static.debank.com/image/coin/logo_url/eth/d61441782d4a08a7479d54aea211679e.png"
    },
    [B.LNA]: {
      address: "0xe5d7c2a44ffddf6b295a15c148167daaaf5cf34f",
      symbol: "WETH",
      decimals: 18,
      chainId: B.LNA,
      coinKey: ae.WETH,
      name: "Wrapped Ether",
      logoURI: "https://static.debank.com/image/mtr_token/logo_url/0x79a61d3a28f8c8537a3df63092927cfa1150fb3c/61844453e63cf81301f845d7864236f6.png"
    },
    [B.FTM]: {
      address: "0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83",
      symbol: "wFTM",
      decimals: 18,
      chainId: B.FTM,
      coinKey: "wFTM",
      name: "wFTM",
      logoURI: "https://static.debank.com/image/ftm_token/logo_url/0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83/2b7d91858f9c62aafc8d7778b9c22f57.png"
    },
    [B.ONE]: {
      address: "0xcf664087a5bb0237a0bad6742852ec6c8d69a27a",
      symbol: "WONE",
      decimals: 18,
      chainId: B.ONE,
      coinKey: "WONE",
      name: "WRAPPED ONE",
      logoURI: "https://assets.coingecko.com/coins/images/18183/small/wonelogo.png"
    },
    [B.AVA]: {
      address: "0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7",
      symbol: "WAVAX",
      decimals: 18,
      chainId: B.AVA,
      coinKey: "WAVAX",
      name: "Wrapped AVAX",
      logoURI: "https://static.debank.com/image/avax_token/logo_url/0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7/753d82f0137617110f8dec56309b4065.png"
    },
    [B.ARB]: {
      address: "0x82af49447d8a07e3bd95bd0d56f35241523fbab1",
      symbol: "WETH",
      decimals: 18,
      chainId: B.ARB,
      coinKey: ae.WETH,
      name: "WETH",
      logoURI: "https://static.debank.com/image/era_token/logo_url/0x5aea5775959fbc2557cc8789bc1bf90a239d9a91/61844453e63cf81301f845d7864236f6.png"
    },
    [B.MOR]: {
      address: "0x98878b06940ae243284ca214f92bb71a2b032b8a",
      symbol: "WMOVR",
      decimals: 18,
      chainId: B.MOR,
      coinKey: "WMOVR",
      name: "WMOVR",
      logoURI: "https://assets.coingecko.com/coins/images/17984/small/9285.png"
    },
    [B.OKT]: {
      address: "0x8f8526dbfd6e38e3d8307702ca8469bae6c56c15",
      symbol: "wOKT",
      decimals: 18,
      chainId: B.OKT,
      coinKey: "wOKT",
      name: "wOKT",
      logoURI: "https://static.debank.com/image/okt_token/logo_url/okt/1228cd92320b3d33769bd08eecfb5391.png"
    },
    [B.HEC]: {
      address: "0x5545153ccfca01fbd7dd11c0b23ba694d9509a6f",
      symbol: "wHT",
      decimals: 18,
      chainId: B.HEC,
      coinKey: "wHT",
      name: "wHT",
      logoURI: "https://static.debank.com/image/heco_token/logo_url/heco/c399dcddde07e1944c4dd8f922832b53.png"
    },
    [B.CRO]: {
      address: "0x5c7f8a570d578ed84e63fdfa7b1ee72deae1ae23",
      symbol: "WCRO",
      decimals: 18,
      chainId: B.CRO,
      coinKey: "WCRO",
      name: "WCRO",
      logoURI: "https://raw.githubusercontent.com/cronaswap/default-token-list/main/assets/tokens/cronos/0x5C7F8A570d578ED84E63fdFA7b1eE72dEae1AE23/logo.png"
    },
    [B.FUS]: {
      address: "0x0be9e53fd7edac9f859882afdda116645287c629",
      symbol: "WFUSE",
      decimals: 18,
      chainId: B.FUS,
      coinKey: "WFUSE",
      name: "Wrapped Fuse",
      logoURI: "https://fuselogo.s3.eu-central-1.amazonaws.com/wfuse.png"
    },
    [B.MOO]: {
      address: "0xacc15dc74880c9944775448304b263d191c6077f",
      symbol: "WGLMR",
      decimals: 18,
      chainId: B.MOO,
      coinKey: "WGLMR",
      name: "Wrapped GLMR",
      logoURI: "https://static.debank.com/image/mobm_token/logo_url/0xacc15dc74880c9944775448304b263d191c6077f/a8442077d76b258297181c3e6eb8c9cc.png"
    },
    [B.MAM]: {
      address: "0x75cb093E4D61d2A2e65D8e0BBb01DE8d89b53481",
      symbol: "WMETIS",
      decimals: 18,
      chainId: B.MAM,
      coinKey: "WMETIS",
      name: "Wrapped Metis",
      logoURI: "https://s2.coinmarketcap.com/static/img/coins/64x64/9640.png"
    },
    [B.BOB]: {
      address: "0xdeaddeaddeaddeaddeaddeaddeaddeaddead0000",
      symbol: "WETH",
      decimals: 18,
      chainId: B.BOB,
      coinKey: ae.WETH,
      name: "Wrapped ETH",
      logoURI: "https://static.debank.com/image/boba_token/logo_url/0xdeaddeaddeaddeaddeaddeaddeaddeaddead0000/b1947b38a90e559eb950453965714be4.png"
    },
    [B.CEL]: {
      address: "0x471ece3750da237f93b8e339c536989b8978a438",
      symbol: "CELO",
      decimals: 18,
      chainId: B.CEL,
      coinKey: ae.CELO,
      name: "Celo native asset",
      logoURI: "https://s2.coinmarketcap.com/static/img/coins/64x64/5567.png"
    },
    [B.EVM]: {
      address: "0xd4949664cd82660aae99bedc034a0dea8a0bd517",
      symbol: "WEVMOS",
      decimals: 18,
      chainId: B.EVM,
      coinKey: "WEVMOS",
      name: "Wrapped Evmos",
      logoURI: "https://raw.githubusercontent.com/cronus-finance/token-list/main/assets/evmos/0xD4949664cD82660AaE99bEdc034a0deA8A0bd517/logo.png"
    },
    [B.AUR]: {
      address: "0x0000000000000000000000000000000000000000",
      symbol: "AETH",
      decimals: 18,
      chainId: B.AUR,
      coinKey: "AETH",
      name: "AETH",
      logoURI: "https://static.debank.com/image/aurora_token/logo_url/aurora/d61441782d4a08a7479d54aea211679e.png"
    },
    [B.VEL]: {
      address: "0xc579d1f3cf86749e05cd06f7ade17856c2ce3126",
      symbol: "WVLX",
      decimals: 18,
      chainId: B.VEL,
      coinKey: "WVLX",
      name: "Wrapped VLX",
      logoURI: "https://raw.githubusercontent.com/lifinance/types/main/src/assets/icons/tokens/vlx.png"
    },
    [B.GOR]: {
      address: "0xb4fbf271143f4fbf7b91a5ded31805e42b2208d6",
      symbol: "WETH",
      decimals: 18,
      chainId: B.GOR,
      coinKey: ae.WETH,
      name: "WETH",
      logoURI: "https://static.debank.com/image/era_token/logo_url/0x5aea5775959fbc2557cc8789bc1bf90a239d9a91/61844453e63cf81301f845d7864236f6.png"
    },
    [B.MUM]: {
      address: "0x9c3c9283d3e44854697cd22d3faa240cfb032889",
      symbol: "WMATIC",
      decimals: 18,
      chainId: B.MUM,
      coinKey: "WMATIC",
      name: "WMATIC",
      logoURI: "https://static.debank.com/image/matic_token/logo_url/0x0d500b1d8e8ef31e21c99d1db9a6444d3adf1270/f6e604ba0324726a3d687c618aa4f163.png"
    },
    [B.ONET]: {
      address: "0x7466d7d0c21fa05f32f5a0fa27e12bdc06348ce2",
      symbol: "WONE",
      decimals: 18,
      chainId: B.ONET,
      coinKey: "WONE",
      name: "WRAPPED ONE",
      logoURI: "https://assets.coingecko.com/coins/images/18183/small/wonelogo.png"
    },
    [B.ARBG]: {
      address: "0x42da9eE191833756c618778145A86E6709f70C9b",
      symbol: "WETH",
      decimals: 18,
      chainId: B.ARBG,
      coinKey: ae.WETH,
      name: "WETH",
      logoURI: "https://static.debank.com/image/era_token/logo_url/0x5aea5775959fbc2557cc8789bc1bf90a239d9a91/61844453e63cf81301f845d7864236f6.png"
    },
    [B.OPTG]: {
      address: "0x4200000000000000000000000000000000000006",
      symbol: "WETH",
      decimals: 18,
      chainId: B.OPTG,
      coinKey: ae.WETH,
      name: "WETH",
      logoURI: "https://static.debank.com/image/era_token/logo_url/0x5aea5775959fbc2557cc8789bc1bf90a239d9a91/61844453e63cf81301f845d7864236f6.png"
    },
    [B.BSCT]: {
      address: "0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd",
      symbol: "WBNB",
      decimals: 18,
      chainId: B.BSCT,
      coinKey: "WBNB",
      name: "WBNB",
      logoURI: "https://static.debank.com/image/coin/logo_url/bnb/9784283a36f23a58982fc964574ea530.png"
    },
    [B.LNAT]: {
      address: "0x2C1b868d6596a18e32E61B901E4060C872647b6C",
      symbol: "WETH",
      decimals: 18,
      chainId: B.LNAT,
      coinKey: ae.WETH,
      name: "WETH",
      logoURI: "https://static.debank.com/image/era_token/logo_url/0x5aea5775959fbc2557cc8789bc1bf90a239d9a91/61844453e63cf81301f845d7864236f6.png"
    },
    [B.AVAT]: {
      address: "0xd00ae08403B9bbb9124bB305C09058E32C39A48c",
      symbol: "WAVAX",
      decimals: 18,
      chainId: B.AVA,
      coinKey: "WAVAX",
      name: "Wrapped AVAX",
      logoURI: "https://static.debank.com/image/avax_token/logo_url/0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7/753d82f0137617110f8dec56309b4065.png"
    }
  },
  ASe = e => {
    const t = SSe.find(n => n.key === e);
    if (!t) throw new Error("Invalid Coin");
    return t
  },
  Be = (e, t) => {
    const r = ASe(e).chains[t];
    if (!r) throw new Error(`Invalid chain ${t} to coin ${e}`);
    return r
  },
  zn = e => {
    const t = CSe[e];
    if (!t) throw new Error(`Wrapped Gas Token not defined for chain ${e}.`);
    return t
  };
var Af;
(function (e) {
  e.oneinch = "1inch", e.paraswap = "paraswap", e.openocean = "openocean", e.zerox = "0x", e.dodo = "dodo"
})(Af || (Af = {}));
Af.oneinch, Af.paraswap, Af.openocean, Af.zerox, Af.dodo;
B.ETH, zn(B.ETH), Be(ae.DAI, B.ETH), Be(ae.USDC, B.ETH), Be(ae.USDT, B.ETH), Be(ae.WBTC, B.ETH), B.ETH, zn(B.ETH), Be(ae.DAI, B.ETH), Be(ae.USDC, B.ETH), Be(ae.USDT, B.ETH), Be(ae.WBTC, B.ETH), B.ETH, Be(ae.SUSHI, B.ETH), B.POL, zn(B.POL), Be(ae.DAI, B.POL), Be(ae.USDC, B.POL), Be(ae.USDT, B.POL), Be(ae.ETH, B.POL), Be(ae.WBTC, B.POL), B.POL, B.POL, zn(B.POL), Be(ae.ETH, B.POL), B.POL, B.POL, zn(B.POL), Be(ae.USDC, B.POL), Be(ae.DAI, B.POL), Be(ae.USDT, B.POL), Be(ae.ETH, B.POL), Be(ae.WBTC, B.POL), Be(ae.SUSHI, B.POL), B.POL, zn(B.POL), Be(ae.USDC, B.POL), B.BSC, zn(B.BSC), B.BSC, B.BSC, B.BSC, B.BSC, zn(B.BSC), Be(ae.ETH, B.BSC), Be(ae.DAI, B.BSC), Be(ae.USDC, B.BSC), Be(ae.USDT, B.BSC), B.BSC, B.BSC, Be(ae.SUSHI, B.BSC), B.BSC, zn(B.BSC), Be(ae.USDC, B.BSC), B.DAI, zn(B.DAI), Be(ae.WETH, B.DAI), Be(ae.USDC, B.DAI), B.DAI, B.DAI, zn(B.DAI), Be(ae.USDC, B.DAI), Be(ae.USDT, B.DAI), Be(ae.WBTC, B.DAI), Be(ae.WETH, B.DAI), Be(ae.SUSHI, B.DAI), B.DAI, zn(B.DAI), B.DAI, B.FTM, zn(B.FTM), Be(ae.USDC, B.FTM), Be(ae.USDT, B.FTM), Be(ae.DAI, B.FTM), B.FTM, zn(B.FTM), Be(ae.DAI, B.FTM), Be(ae.USDC, B.FTM), Be(ae.WBTC, B.FTM), Be(ae.WETH, B.FTM), Be(ae.SUSHI, B.FTM), B.FTM, zn(B.FTM), Be(ae.WBTC, B.FTM), Be(ae.WETH, B.FTM), Be(ae.USDC, B.FTM), Be(ae.DAI, B.FTM), B.FTM, zn(B.FTM), B.FTM, B.ONE, Be(ae.ONE, B.ONE), zn(B.ONE), B.ONE, B.ONE, B.ONE, B.ONE, B.ONE, B.ONE, zn(B.ONE), Be(ae.DAI, B.ONE), Be(ae.USDC, B.ONE), Be(ae.USDT, B.ONE), Be(ae.ETH, B.ONE), Be(ae.WBTC, B.ONE), Be(ae.SUSHI, B.ONE), B.AVA, zn(B.AVA), Be(ae.USDC, B.AVA), Be(ae.USDT, B.AVA), Be(ae.DAI, B.AVA), Be(ae.WBTC, B.AVA), Be(ae.WETH, B.AVA), Be(ae.SUSHI, B.AVA), B.AVA, zn(B.AVA), Be(ae.USDC, B.AVA), Be(ae.USDT, B.AVA), B.ARB, Be(ae.WETH, B.ARB), Be(ae.WBTC, B.ARB), Be(ae.USDC, B.ARB), Be(ae.USDT, B.ARB), Be(ae.SUSHI, B.ARB), B.ARB, B.MOR, zn(B.MOR), Be(ae.WETH, B.MOR), Be(ae.WBTC, B.MOR), Be(ae.USDC, B.MOR), Be(ae.USDT, B.MOR), Be(ae.SUSHI, B.MOR), B.MOR, B.MOR, B.MOR, B.MOR, zn(B.MOR), Be(ae.USDC, B.MOR), B.MOR, B.MOR, B.HEC, zn(B.HEC), Be(ae.ETH, B.HEC), Be(ae.USDC, B.HEC), Be(ae.USDT, B.HEC), Be(ae.SUSHI, B.HEC), B.HEC, B.HEC, B.OKT, zn(B.OKT), Be(ae.ETH, B.OKT), Be(ae.WBTC, B.OKT), Be(ae.DAI, B.OKT), Be(ae.USDC, B.OKT), Be(ae.USDT, B.OKT), Be(ae.SUSHI, B.OKT), B.OKT, Be(ae.OKT, B.OKT), Be(ae.ETH, B.OKT), Be(ae.USDT, B.OKT), B.OKT, B.OKT, B.OKT, B.OKT, B.OKT, ae.USDT, B.OKT, B.CRO, Be(ae.CRO, B.CRO), Be(ae.USDC, B.CRO), B.CRO, B.MOO, B.MOO, B.MOO, B.MOO, B.MOO, zn(B.MOO), Be(ae.BNB, B.MOO), Be(ae.ETH, B.MOO), B.FUS, zn(B.FUS), Be(ae.USDC, B.FUS), Be(ae.USDT, B.FUS), Be(ae.WBTC, B.FUS), Be(ae.WETH, B.FUS), Be(ae.DAI, B.FUS), Be(ae.SUSHI, B.FUS), B.CEL, zn(B.CEL), B.CEL, B.CEL, B.CEL, zn(B.CEL), Be(ae.USDC, B.CEL), Be(ae.WBTC, B.CEL), Be(ae.WETH, B.CEL), Be(ae.SUSHI, B.CEL), B.CEL, B.CEL, B.BOB, Be(ae.ETH, B.BOB), zn(B.BOB), Be(ae.WBTC, B.BOB), Be(ae.DAI, B.BOB), Be(ae.USDC, B.BOB), Be(ae.USDT, B.BOB), B.BOB, B.BOB, B.GOR, Be(ae.ETH, B.GOR), Be(ae.WETH, B.GOR), B.ONET, B.BSCT, zn(B.ONET), B.VEL, B.VEL, B.VEL, B.VEL;
const TSe = {
    status: "NOT_STARTED",
    process: []
  },
  kSe = ["RECOMMENDED", "FASTEST", "CHEAPEST", "SAFEST"];
var WM;
(function (e) {
  e[e.DefaultError = 1e3] = "DefaultError", e[e.FailedToBuildTransactionError = 1001] = "FailedToBuildTransactionError", e[e.NoQuoteError = 1002] = "NoQuoteError", e[e.NotFoundError = 1003] = "NotFoundError", e[e.NotProcessableError = 1004] = "NotProcessableError", e[e.RateLimitError = 1005] = "RateLimitError", e[e.ServerError = 1006] = "ServerError", e[e.SlippageError = 1007] = "SlippageError", e[e.ThirdPartyError = 1008] = "ThirdPartyError", e[e.TimeoutError = 1009] = "TimeoutError", e[e.UnauthorizedError = 1010] = "UnauthorizedError", e[e.ValidationError = 1011] = "ValidationError"
})(WM || (WM = {}));
var Cc;
(function (e) {
  e.RPCError = "RPCError", e.ProviderError = "ProviderError", e.ServerError = "ServerError", e.TransactionError = "TransactionError", e.ValidationError = "ValidationError", e.NotFoundError = "NotFoundError", e.UnknownError = "UnknownError", e.SlippageError = "SlippageError"
})(Cc || (Cc = {}));
var nn;
(function (e) {
  e[e.InternalError = 1e3] = "InternalError", e[e.ValidationError = 1001] = "ValidationError", e[e.TransactionUnderpriced = 1002] = "TransactionUnderpriced", e[e.TransactionFailed = 1003] = "TransactionFailed", e[e.Timeout = 1004] = "Timeout", e[e.ProviderUnavailable = 1005] = "ProviderUnavailable", e[e.NotFound = 1006] = "NotFound", e[e.ChainSwitchError = 1007] = "ChainSwitchError", e[e.TransactionUnprepared = 1008] = "TransactionUnprepared", e[e.GasLimitError = 1009] = "GasLimitError", e[e.TransactionCanceled = 1010] = "TransactionCanceled", e[e.SlippageError = 1011] = "SlippageError", e[e.TransactionRejected = 1012] = "TransactionRejected", e[e.BalanceError = 1013] = "BalanceError", e[e.AllowanceRequired = 1014] = "AllowanceRequired", e[e.InsufficientFunds = 1015] = "InsufficientFunds"
})(nn || (nn = {}));
var S1;
(function (e) {
  e.ActionRejected = "ACTION_REJECTED", e.CallExecption = "CALL_EXCEPTION", e.InsufficientFunds = "INSUFFICIENT_FUNDS"
})(S1 || (S1 = {}));
var ed;
(function (e) {
  e.ERC20Allowance = "ERC20: transfer amount exceeds allowance", e.LowGas = "intrinsic gas too low", e.OutOfGas = "out of gas", e.Underpriced = "underpriced", e.LowReplacementFee = "replacement fee too low"
})(ed || (ed = {}));
var qf;
(function (e) {
  e.UnknownError = "Unknown error occurred.", e.SlippageError = "The slippage is larger than the defined threshold. Please request a new route to get a fresh quote.", e.GasLimitLow = "Gas limit is too low.", e.TransactionUnderpriced = "Transaction is underpriced.", e.Default = "Something went wrong."
})(qf || (qf = {}));
var qM;
(function (e) {
  e[e.invalidInput = -32e3] = "invalidInput", e[e.resourceNotFound = -32001] = "resourceNotFound", e[e.resourceUnavailable = -32002] = "resourceUnavailable", e[e.transactionRejected = -32003] = "transactionRejected", e[e.methodNotSupported = -32004] = "methodNotSupported", e[e.limitExceeded = -32005] = "limitExceeded", e[e.parse = -32700] = "parse", e[e.invalidRequest = -32600] = "invalidRequest", e[e.methodNotFound = -32601] = "methodNotFound", e[e.invalidParams = -32602] = "invalidParams", e[e.internal = -32603] = "internal"
})(qM || (qM = {}));
var M3;
(function (e) {
  e[e.userRejectedRequest = 4001] = "userRejectedRequest", e[e.unauthorized = 4100] = "unauthorized", e[e.unsupportedMethod = 4200] = "unsupportedMethod", e[e.disconnected = 4900] = "disconnected", e[e.chainDisconnected = 4901] = "chainDisconnected"
})(M3 || (M3 = {}));
class Ua extends Error {
  constructor(t, n, r, i, s) {
    super(r), Object.setPrototypeOf(this, Ua.prototype), this.code = n, this.name = t.toString(), this.htmlMessage = i, s && (this.stack = s)
  }
}
class GM extends Ua {
  constructor(t, n, r, i) {
    super(Cc.RPCError, t, n, r, i)
  }
}
class $3 extends Ua {
  constructor(t, n, r, i) {
    super(Cc.ProviderError, t, n, r, i)
  }
}
class Fp extends Ua {
  constructor(t, n, r) {
    super(Cc.ServerError, nn.InternalError, t, n, r)
  }
}
class Rr extends Ua {
  constructor(t, n, r) {
    super(Cc.ValidationError, nn.ValidationError, t, n, r)
  }
}
class lc extends Ua {
  constructor(t, n, r, i) {
    super(Cc.TransactionError, t, n, r, i)
  }
}
class _Se extends Ua {
  constructor(t, n, r) {
    super(Cc.SlippageError, nn.SlippageError, t, n, r)
  }
}
class ISe extends Ua {
  constructor(t, n, r) {
    super(Cc.ValidationError, nn.BalanceError, t, n, r)
  }
}
class PSe extends Ua {
  constructor(t, n, r) {
    super(Cc.NotFoundError, nn.NotFound, t, n, r)
  }
}
class RSe extends Ua {
  constructor(t, n, r, i) {
    super(Cc.UnknownError, t, n, r, i)
  }
}
class OSe extends Error {
  constructor(t) {
    const n = t.status || t.status === 0 ? t.status : "",
      r = t.statusText || "",
      i = `${n} ${r}`.trim(),
      s = i ? `status code ${i}` : "an unknown error";
    super(`Request failed with ${s}`), this.name = "HTTPError", this.response = t, this.status = t.status
  }
}
const kk = [{
  name: "approve",
  inputs: [{
    internalType: "address",
    name: "spender",
    type: "address"
  }, {
    internalType: "uint256",
    name: "amount",
    type: "uint256"
  }],
  outputs: [{
    internalType: "bool",
    name: "",
    type: "bool"
  }],
  stateMutability: "nonpayable",
  type: "function"
}, {
  name: "allowance",
  inputs: [{
    internalType: "address",
    name: "owner",
    type: "address"
  }, {
    internalType: "address",
    name: "spender",
    type: "address"
  }],
  outputs: [{
    internalType: "uint256",
    name: "",
    type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}];
var DSe = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i,
  US = Math.ceil,
  ua = Math.floor,
  Ys = "[BigNumber Error] ",
  KM = Ys + "Number primitive has more than 15 significant digits: ",
  Xa = 1e14,
  Yt = 14,
  zS = 9007199254740991,
  HS = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13],
  Wu = 1e7,
  yi = 1e9;

function FW(e) {
  var t, n, r, i = p.prototype = {
      constructor: p,
      toString: null,
      valueOf: null
    },
    s = new p(1),
    o = 20,
    a = 4,
    c = -7,
    l = 21,
    u = -1e7,
    f = 1e7,
    h = !1,
    g = 1,
    y = 0,
    x = {
      prefix: "",
      groupSize: 3,
      secondaryGroupSize: 0,
      groupSeparator: ",",
      decimalSeparator: ".",
      fractionGroupSize: 0,
      fractionGroupSeparator: " ",
      suffix: ""
    },
    k = "0123456789abcdefghijklmnopqrstuvwxyz",
    _ = !0;

  function p(E, D) {
    var $, V, G, L, b, T, R, N, O = this;
    if (!(O instanceof p)) return new p(E, D);
    if (D == null) {
      if (E && E._isBigNumber === !0) {
        O.s = E.s, !E.c || E.e > f ? O.c = O.e = null : E.e < u ? O.c = [O.e = 0] : (O.e = E.e, O.c = E.c.slice());
        return
      }
      if ((T = typeof E == "number") && E * 0 == 0) {
        if (O.s = 1 / E < 0 ? (E = -E, -1) : 1, E === ~~E) {
          for (L = 0, b = E; b >= 10; b /= 10, L++);
          L > f ? O.c = O.e = null : (O.e = L, O.c = [E]);
          return
        }
        N = String(E)
      } else {
        if (!DSe.test(N = String(E))) return r(O, N, T);
        O.s = N.charCodeAt(0) == 45 ? (N = N.slice(1), -1) : 1
      }(L = N.indexOf(".")) > -1 && (N = N.replace(".", "")), (b = N.search(/e/i)) > 0 ? (L < 0 && (L = b), L += +N.slice(b + 1), N = N.substring(0, b)) : L < 0 && (L = N.length)
    } else {
      if (_r(D, 2, k.length, "Base"), D == 10 && _) return O = new p(E), A(O, o + O.e + 1, a);
      if (N = String(E), T = typeof E == "number") {
        if (E * 0 != 0) return r(O, N, T, D);
        if (O.s = 1 / E < 0 ? (N = N.slice(1), -1) : 1, p.DEBUG && N.replace(/^0\.0*|\./, "").length > 15) throw Error(KM + E)
      } else O.s = N.charCodeAt(0) === 45 ? (N = N.slice(1), -1) : 1;
      for ($ = k.slice(0, D), L = b = 0, R = N.length; b < R; b++)
        if ($.indexOf(V = N.charAt(b)) < 0) {
          if (V == ".") {
            if (b > L) {
              L = R;
              continue
            }
          } else if (!G && (N == N.toUpperCase() && (N = N.toLowerCase()) || N == N.toLowerCase() && (N = N.toUpperCase()))) {
            G = !0, b = -1, L = 0;
            continue
          }
          return r(O, String(E), T, D)
        } T = !1, N = n(N, D, 10, O.s), (L = N.indexOf(".")) > -1 ? N = N.replace(".", "") : L = N.length
    }
    for (b = 0; N.charCodeAt(b) === 48; b++);
    for (R = N.length; N.charCodeAt(--R) === 48;);
    if (N = N.slice(b, ++R)) {
      if (R -= b, T && p.DEBUG && R > 15 && (E > zS || E !== ua(E))) throw Error(KM + O.s * E);
      if ((L = L - b - 1) > f) O.c = O.e = null;
      else if (L < u) O.c = [O.e = 0];
      else {
        if (O.e = L, O.c = [], b = (L + 1) % Yt, L < 0 && (b += Yt), b < R) {
          for (b && O.c.push(+N.slice(0, b)), R -= Yt; b < R;) O.c.push(+N.slice(b, b += Yt));
          b = Yt - (N = N.slice(b)).length
        } else b -= R;
        for (; b--; N += "0");
        O.c.push(+N)
      }
    } else O.c = [O.e = 0]
  }
  p.clone = FW, p.ROUND_UP = 0, p.ROUND_DOWN = 1, p.ROUND_CEIL = 2, p.ROUND_FLOOR = 3, p.ROUND_HALF_UP = 4, p.ROUND_HALF_DOWN = 5, p.ROUND_HALF_EVEN = 6, p.ROUND_HALF_CEIL = 7, p.ROUND_HALF_FLOOR = 8, p.EUCLID = 9, p.config = p.set = function (E) {
    var D, $;
    if (E != null)
      if (typeof E == "object") {
        if (E.hasOwnProperty(D = "DECIMAL_PLACES") && ($ = E[D], _r($, 0, yi, D), o = $), E.hasOwnProperty(D = "ROUNDING_MODE") && ($ = E[D], _r($, 0, 8, D), a = $), E.hasOwnProperty(D = "EXPONENTIAL_AT") && ($ = E[D], $ && $.pop ? (_r($[0], -yi, 0, D), _r($[1], 0, yi, D), c = $[0], l = $[1]) : (_r($, -yi, yi, D), c = -(l = $ < 0 ? -$ : $))), E.hasOwnProperty(D = "RANGE"))
          if ($ = E[D], $ && $.pop) _r($[0], -yi, -1, D), _r($[1], 1, yi, D), u = $[0], f = $[1];
          else if (_r($, -yi, yi, D), $) u = -(f = $ < 0 ? -$ : $);
        else throw Error(Ys + D + " cannot be zero: " + $);
        if (E.hasOwnProperty(D = "CRYPTO"))
          if ($ = E[D], $ === !!$)
            if ($)
              if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes)) h = $;
              else throw h = !$, Error(Ys + "crypto unavailable");
        else h = $;
        else throw Error(Ys + D + " not true or false: " + $);
        if (E.hasOwnProperty(D = "MODULO_MODE") && ($ = E[D], _r($, 0, 9, D), g = $), E.hasOwnProperty(D = "POW_PRECISION") && ($ = E[D], _r($, 0, yi, D), y = $), E.hasOwnProperty(D = "FORMAT"))
          if ($ = E[D], typeof $ == "object") x = $;
          else throw Error(Ys + D + " not an object: " + $);
        if (E.hasOwnProperty(D = "ALPHABET"))
          if ($ = E[D], typeof $ == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test($)) _ = $.slice(0, 10) == "0123456789", k = $;
          else throw Error(Ys + D + " invalid: " + $)
      } else throw Error(Ys + "Object expected: " + E);
    return {
      DECIMAL_PLACES: o,
      ROUNDING_MODE: a,
      EXPONENTIAL_AT: [c, l],
      RANGE: [u, f],
      CRYPTO: h,
      MODULO_MODE: g,
      POW_PRECISION: y,
      FORMAT: x,
      ALPHABET: k
    }
  }, p.isBigNumber = function (E) {
    if (!E || E._isBigNumber !== !0) return !1;
    if (!p.DEBUG) return !0;
    var D, $, V = E.c,
      G = E.e,
      L = E.s;
    e: if ({}.toString.call(V) == "[object Array]") {
      if ((L === 1 || L === -1) && G >= -yi && G <= yi && G === ua(G)) {
        if (V[0] === 0) {
          if (G === 0 && V.length === 1) return !0;
          break e
        }
        if (D = (G + 1) % Yt, D < 1 && (D += Yt), String(V[0]).length == D) {
          for (D = 0; D < V.length; D++)
            if ($ = V[D], $ < 0 || $ >= Xa || $ !== ua($)) break e;
          if ($ !== 0) return !0
        }
      }
    } else if (V === null && G === null && (L === null || L === 1 || L === -1)) return !0;
    throw Error(Ys + "Invalid BigNumber: " + E)
  }, p.maximum = p.max = function () {
    return S(arguments, -1)
  }, p.minimum = p.min = function () {
    return S(arguments, 1)
  }, p.random = function () {
    var E = 9007199254740992,
      D = Math.random() * E & 2097151 ? function () {
        return ua(Math.random() * E)
      } : function () {
        return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0)
      };
    return function ($) {
      var V, G, L, b, T, R = 0,
        N = [],
        O = new p(s);
      if ($ == null ? $ = o : _r($, 0, yi), b = US($ / Yt), h)
        if (crypto.getRandomValues) {
          for (V = crypto.getRandomValues(new Uint32Array(b *= 2)); R < b;) T = V[R] * 131072 + (V[R + 1] >>> 11), T >= 9e15 ? (G = crypto.getRandomValues(new Uint32Array(2)), V[R] = G[0], V[R + 1] = G[1]) : (N.push(T % 1e14), R += 2);
          R = b / 2
        } else if (crypto.randomBytes) {
        for (V = crypto.randomBytes(b *= 7); R < b;) T = (V[R] & 31) * 281474976710656 + V[R + 1] * 1099511627776 + V[R + 2] * 4294967296 + V[R + 3] * 16777216 + (V[R + 4] << 16) + (V[R + 5] << 8) + V[R + 6], T >= 9e15 ? crypto.randomBytes(7).copy(V, R) : (N.push(T % 1e14), R += 7);
        R = b / 7
      } else throw h = !1, Error(Ys + "crypto unavailable");
      if (!h)
        for (; R < b;) T = D(), T < 9e15 && (N[R++] = T % 1e14);
      for (b = N[--R], $ %= Yt, b && $ && (T = HS[Yt - $], N[R] = ua(b / T) * T); N[R] === 0; N.pop(), R--);
      if (R < 0) N = [L = 0];
      else {
        for (L = -1; N[0] === 0; N.splice(0, 1), L -= Yt);
        for (R = 1, T = N[0]; T >= 10; T /= 10, R++);
        R < Yt && (L -= Yt - R)
      }
      return O.e = L, O.c = N, O
    }
  }(), p.sum = function () {
    for (var E = 1, D = arguments, $ = new p(D[0]); E < D.length;) $ = $.plus(D[E++]);
    return $
  }, n = function () {
    var E = "0123456789";

    function D($, V, G, L) {
      for (var b, T = [0], R, N = 0, O = $.length; N < O;) {
        for (R = T.length; R--; T[R] *= V);
        for (T[0] += L.indexOf($.charAt(N++)), b = 0; b < T.length; b++) T[b] > G - 1 && (T[b + 1] == null && (T[b + 1] = 0), T[b + 1] += T[b] / G | 0, T[b] %= G)
      }
      return T.reverse()
    }
    return function ($, V, G, L, b) {
      var T, R, N, O, U, q, W, M, Q = $.indexOf("."),
        he = o,
        H = a;
      for (Q >= 0 && (O = y, y = 0, $ = $.replace(".", ""), M = new p(V), q = M.pow($.length - Q), y = O, M.c = D(Ml(sa(q.c), q.e, "0"), 10, G, E), M.e = M.c.length), W = D($, V, G, b ? (T = k, E) : (T = E, k)), N = O = W.length; W[--O] == 0; W.pop());
      if (!W[0]) return T.charAt(0);
      if (Q < 0 ? --N : (q.c = W, q.e = N, q.s = L, q = t(q, M, he, H, G), W = q.c, U = q.r, N = q.e), R = N + he + 1, Q = W[R], O = G / 2, U = U || R < 0 || W[R + 1] != null, U = H < 4 ? (Q != null || U) && (H == 0 || H == (q.s < 0 ? 3 : 2)) : Q > O || Q == O && (H == 4 || U || H == 6 && W[R - 1] & 1 || H == (q.s < 0 ? 8 : 7)), R < 1 || !W[0]) $ = U ? Ml(T.charAt(1), -he, T.charAt(0)) : T.charAt(0);
      else {
        if (W.length = R, U)
          for (--G; ++W[--R] > G;) W[R] = 0, R || (++N, W = [1].concat(W));
        for (O = W.length; !W[--O];);
        for (Q = 0, $ = ""; Q <= O; $ += T.charAt(W[Q++]));
        $ = Ml($, N, T.charAt(0))
      }
      return $
    }
  }(), t = function () {
    function E(V, G, L) {
      var b, T, R, N, O = 0,
        U = V.length,
        q = G % Wu,
        W = G / Wu | 0;
      for (V = V.slice(); U--;) R = V[U] % Wu, N = V[U] / Wu | 0, b = W * R + N * q, T = q * R + b % Wu * Wu + O, O = (T / L | 0) + (b / Wu | 0) + W * N, V[U] = T % L;
      return O && (V = [O].concat(V)), V
    }

    function D(V, G, L, b) {
      var T, R;
      if (L != b) R = L > b ? 1 : -1;
      else
        for (T = R = 0; T < L; T++)
          if (V[T] != G[T]) {
            R = V[T] > G[T] ? 1 : -1;
            break
          } return R
    }

    function $(V, G, L, b) {
      for (var T = 0; L--;) V[L] -= T, T = V[L] < G[L] ? 1 : 0, V[L] = T * b + V[L] - G[L];
      for (; !V[0] && V.length > 1; V.splice(0, 1));
    }
    return function (V, G, L, b, T) {
      var R, N, O, U, q, W, M, Q, he, H, ne, X, Z, te, F, J, ie, ce = V.s == G.s ? 1 : -1,
        ue = V.c,
        ge = G.c;
      if (!ue || !ue[0] || !ge || !ge[0]) return new p(!V.s || !G.s || (ue ? ge && ue[0] == ge[0] : !ge) ? NaN : ue && ue[0] == 0 || !ge ? ce * 0 : ce / 0);
      for (Q = new p(ce), he = Q.c = [], N = V.e - G.e, ce = L + N + 1, T || (T = Xa, N = da(V.e / Yt) - da(G.e / Yt), ce = ce / Yt | 0), O = 0; ge[O] == (ue[O] || 0); O++);
      if (ge[O] > (ue[O] || 0) && N--, ce < 0) he.push(1), U = !0;
      else {
        for (te = ue.length, J = ge.length, O = 0, ce += 2, q = ua(T / (ge[0] + 1)), q > 1 && (ge = E(ge, q, T), ue = E(ue, q, T), J = ge.length, te = ue.length), Z = J, H = ue.slice(0, J), ne = H.length; ne < J; H[ne++] = 0);
        ie = ge.slice(), ie = [0].concat(ie), F = ge[0], ge[1] >= T / 2 && F++;
        do {
          if (q = 0, R = D(ge, H, J, ne), R < 0) {
            if (X = H[0], J != ne && (X = X * T + (H[1] || 0)), q = ua(X / F), q > 1)
              for (q >= T && (q = T - 1), W = E(ge, q, T), M = W.length, ne = H.length; D(W, H, M, ne) == 1;) q--, $(W, J < M ? ie : ge, M, T), M = W.length, R = 1;
            else q == 0 && (R = q = 1), W = ge.slice(), M = W.length;
            if (M < ne && (W = [0].concat(W)), $(H, W, ne, T), ne = H.length, R == -1)
              for (; D(ge, H, J, ne) < 1;) q++, $(H, J < ne ? ie : ge, ne, T), ne = H.length
          } else R === 0 && (q++, H = [0]);
          he[O++] = q, H[0] ? H[ne++] = ue[Z] || 0 : (H = [ue[Z]], ne = 1)
        } while ((Z++ < te || H[0] != null) && ce--);
        U = H[0] != null, he[0] || he.splice(0, 1)
      }
      if (T == Xa) {
        for (O = 1, ce = he[0]; ce >= 10; ce /= 10, O++);
        A(Q, L + (Q.e = O + N * Yt - 1) + 1, b, U)
      } else Q.e = N, Q.r = +U;
      return Q
    }
  }();

  function v(E, D, $, V) {
    var G, L, b, T, R;
    if ($ == null ? $ = a : _r($, 0, 8), !E.c) return E.toString();
    if (G = E.c[0], b = E.e, D == null) R = sa(E.c), R = V == 1 || V == 2 && (b <= c || b >= l) ? Sb(R, b) : Ml(R, b, "0");
    else if (E = A(new p(E), D, $), L = E.e, R = sa(E.c), T = R.length, V == 1 || V == 2 && (D <= L || L <= c)) {
      for (; T < D; R += "0", T++);
      R = Sb(R, L)
    } else if (D -= b, R = Ml(R, L, "0"), L + 1 > T) {
      if (--D > 0)
        for (R += "."; D--; R += "0");
    } else if (D += L - T, D > 0)
      for (L + 1 == T && (R += "."); D--; R += "0");
    return E.s < 0 && G ? "-" + R : R
  }

  function S(E, D) {
    for (var $, V, G = 1, L = new p(E[0]); G < E.length; G++) V = new p(E[G]), (!V.s || ($ = pf(L, V)) === D || $ === 0 && L.s === D) && (L = V);
    return L
  }

  function I(E, D, $) {
    for (var V = 1, G = D.length; !D[--G]; D.pop());
    for (G = D[0]; G >= 10; G /= 10, V++);
    return ($ = V + $ * Yt - 1) > f ? E.c = E.e = null : $ < u ? E.c = [E.e = 0] : (E.e = $, E.c = D), E
  }
  r = function () {
    var E = /^(-?)0([xbo])(?=\w[\w.]*$)/i,
      D = /^([^.]+)\.$/,
      $ = /^\.([^.]+)$/,
      V = /^-?(Infinity|NaN)$/,
      G = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
    return function (L, b, T, R) {
      var N, O = T ? b : b.replace(G, "");
      if (V.test(O)) L.s = isNaN(O) ? null : O < 0 ? -1 : 1;
      else {
        if (!T && (O = O.replace(E, function (U, q, W) {
            return N = (W = W.toLowerCase()) == "x" ? 16 : W == "b" ? 2 : 8, !R || R == N ? q : U
          }), R && (N = R, O = O.replace(D, "$1").replace($, "0.$1")), b != O)) return new p(O, N);
        if (p.DEBUG) throw Error(Ys + "Not a" + (R ? " base " + R : "") + " number: " + b);
        L.s = null
      }
      L.c = L.e = null
    }
  }();

  function A(E, D, $, V) {
    var G, L, b, T, R, N, O, U = E.c,
      q = HS;
    if (U) {
      e: {
        for (G = 1, T = U[0]; T >= 10; T /= 10, G++);
        if (L = D - G, L < 0) L += Yt,
        b = D,
        R = U[N = 0],
        O = ua(R / q[G - b - 1] % 10);
        else if (N = US((L + 1) / Yt), N >= U.length)
          if (V) {
            for (; U.length <= N; U.push(0));
            R = O = 0, G = 1, L %= Yt, b = L - Yt + 1
          } else break e;
        else {
          for (R = T = U[N], G = 1; T >= 10; T /= 10, G++);
          L %= Yt, b = L - Yt + G, O = b < 0 ? 0 : ua(R / q[G - b - 1] % 10)
        }
        if (V = V || D < 0 || U[N + 1] != null || (b < 0 ? R : R % q[G - b - 1]), V = $ < 4 ? (O || V) && ($ == 0 || $ == (E.s < 0 ? 3 : 2)) : O > 5 || O == 5 && ($ == 4 || V || $ == 6 && (L > 0 ? b > 0 ? R / q[G - b] : 0 : U[N - 1]) % 10 & 1 || $ == (E.s < 0 ? 8 : 7)), D < 1 || !U[0]) return U.length = 0,
        V ? (D -= E.e + 1, U[0] = q[(Yt - D % Yt) % Yt], E.e = -D || 0) : U[0] = E.e = 0,
        E;
        if (L == 0 ? (U.length = N, T = 1, N--) : (U.length = N + 1, T = q[Yt - L], U[N] = b > 0 ? ua(R / q[G - b] % q[b]) * T : 0), V)
          for (;;)
            if (N == 0) {
              for (L = 1, b = U[0]; b >= 10; b /= 10, L++);
              for (b = U[0] += T, T = 1; b >= 10; b /= 10, T++);
              L != T && (E.e++, U[0] == Xa && (U[0] = 1));
              break
            } else {
              if (U[N] += T, U[N] != Xa) break;
              U[N--] = 0, T = 1
            } for (L = U.length; U[--L] === 0; U.pop());
      }
      E.e > f ? E.c = E.e = null : E.e < u && (E.c = [E.e = 0])
    }
    return E
  }

  function w(E) {
    var D, $ = E.e;
    return $ === null ? E.toString() : (D = sa(E.c), D = $ <= c || $ >= l ? Sb(D, $) : Ml(D, $, "0"), E.s < 0 ? "-" + D : D)
  }
  return i.absoluteValue = i.abs = function () {
    var E = new p(this);
    return E.s < 0 && (E.s = 1), E
  }, i.comparedTo = function (E, D) {
    return pf(this, new p(E, D))
  }, i.decimalPlaces = i.dp = function (E, D) {
    var $, V, G, L = this;
    if (E != null) return _r(E, 0, yi), D == null ? D = a : _r(D, 0, 8), A(new p(L), E + L.e + 1, D);
    if (!($ = L.c)) return null;
    if (V = ((G = $.length - 1) - da(this.e / Yt)) * Yt, G = $[G])
      for (; G % 10 == 0; G /= 10, V--);
    return V < 0 && (V = 0), V
  }, i.dividedBy = i.div = function (E, D) {
    return t(this, new p(E, D), o, a)
  }, i.dividedToIntegerBy = i.idiv = function (E, D) {
    return t(this, new p(E, D), 0, 1)
  }, i.exponentiatedBy = i.pow = function (E, D) {
    var $, V, G, L, b, T, R, N, O, U = this;
    if (E = new p(E), E.c && !E.isInteger()) throw Error(Ys + "Exponent not an integer: " + w(E));
    if (D != null && (D = new p(D)), T = E.e > 14, !U.c || !U.c[0] || U.c[0] == 1 && !U.e && U.c.length == 1 || !E.c || !E.c[0]) return O = new p(Math.pow(+w(U), T ? E.s * (2 - Eb(E)) : +w(E))), D ? O.mod(D) : O;
    if (R = E.s < 0, D) {
      if (D.c ? !D.c[0] : !D.s) return new p(NaN);
      V = !R && U.isInteger() && D.isInteger(), V && (U = U.mod(D))
    } else {
      if (E.e > 9 && (U.e > 0 || U.e < -1 || (U.e == 0 ? U.c[0] > 1 || T && U.c[1] >= 24e7 : U.c[0] < 8e13 || T && U.c[0] <= 9999975e7))) return L = U.s < 0 && Eb(E) ? -0 : 0, U.e > -1 && (L = 1 / L), new p(R ? 1 / L : L);
      y && (L = US(y / Yt + 2))
    }
    for (T ? ($ = new p(.5), R && (E.s = 1), N = Eb(E)) : (G = Math.abs(+w(E)), N = G % 2), O = new p(s);;) {
      if (N) {
        if (O = O.times(U), !O.c) break;
        L ? O.c.length > L && (O.c.length = L) : V && (O = O.mod(D))
      }
      if (G) {
        if (G = ua(G / 2), G === 0) break;
        N = G % 2
      } else if (E = E.times($), A(E, E.e + 1, 1), E.e > 14) N = Eb(E);
      else {
        if (G = +w(E), G === 0) break;
        N = G % 2
      }
      U = U.times(U), L ? U.c && U.c.length > L && (U.c.length = L) : V && (U = U.mod(D))
    }
    return V ? O : (R && (O = s.div(O)), D ? O.mod(D) : L ? A(O, y, a, b) : O)
  }, i.integerValue = function (E) {
    var D = new p(this);
    return E == null ? E = a : _r(E, 0, 8), A(D, D.e + 1, E)
  }, i.isEqualTo = i.eq = function (E, D) {
    return pf(this, new p(E, D)) === 0
  }, i.isFinite = function () {
    return !!this.c
  }, i.isGreaterThan = i.gt = function (E, D) {
    return pf(this, new p(E, D)) > 0
  }, i.isGreaterThanOrEqualTo = i.gte = function (E, D) {
    return (D = pf(this, new p(E, D))) === 1 || D === 0
  }, i.isInteger = function () {
    return !!this.c && da(this.e / Yt) > this.c.length - 2
  }, i.isLessThan = i.lt = function (E, D) {
    return pf(this, new p(E, D)) < 0
  }, i.isLessThanOrEqualTo = i.lte = function (E, D) {
    return (D = pf(this, new p(E, D))) === -1 || D === 0
  }, i.isNaN = function () {
    return !this.s
  }, i.isNegative = function () {
    return this.s < 0
  }, i.isPositive = function () {
    return this.s > 0
  }, i.isZero = function () {
    return !!this.c && this.c[0] == 0
  }, i.minus = function (E, D) {
    var $, V, G, L, b = this,
      T = b.s;
    if (E = new p(E, D), D = E.s, !T || !D) return new p(NaN);
    if (T != D) return E.s = -D, b.plus(E);
    var R = b.e / Yt,
      N = E.e / Yt,
      O = b.c,
      U = E.c;
    if (!R || !N) {
      if (!O || !U) return O ? (E.s = -D, E) : new p(U ? b : NaN);
      if (!O[0] || !U[0]) return U[0] ? (E.s = -D, E) : new p(O[0] ? b : a == 3 ? -0 : 0)
    }
    if (R = da(R), N = da(N), O = O.slice(), T = R - N) {
      for ((L = T < 0) ? (T = -T, G = O) : (N = R, G = U), G.reverse(), D = T; D--; G.push(0));
      G.reverse()
    } else
      for (V = (L = (T = O.length) < (D = U.length)) ? T : D, T = D = 0; D < V; D++)
        if (O[D] != U[D]) {
          L = O[D] < U[D];
          break
        } if (L && (G = O, O = U, U = G, E.s = -E.s), D = (V = U.length) - ($ = O.length), D > 0)
      for (; D--; O[$++] = 0);
    for (D = Xa - 1; V > T;) {
      if (O[--V] < U[V]) {
        for ($ = V; $ && !O[--$]; O[$] = D);
        --O[$], O[V] += Xa
      }
      O[V] -= U[V]
    }
    for (; O[0] == 0; O.splice(0, 1), --N);
    return O[0] ? I(E, O, N) : (E.s = a == 3 ? -1 : 1, E.c = [E.e = 0], E)
  }, i.modulo = i.mod = function (E, D) {
    var $, V, G = this;
    return E = new p(E, D), !G.c || !E.s || E.c && !E.c[0] ? new p(NaN) : !E.c || G.c && !G.c[0] ? new p(G) : (g == 9 ? (V = E.s, E.s = 1, $ = t(G, E, 0, 3), E.s = V, $.s *= V) : $ = t(G, E, 0, g), E = G.minus($.times(E)), !E.c[0] && g == 1 && (E.s = G.s), E)
  }, i.multipliedBy = i.times = function (E, D) {
    var $, V, G, L, b, T, R, N, O, U, q, W, M, Q, he, H = this,
      ne = H.c,
      X = (E = new p(E, D)).c;
    if (!ne || !X || !ne[0] || !X[0]) return !H.s || !E.s || ne && !ne[0] && !X || X && !X[0] && !ne ? E.c = E.e = E.s = null : (E.s *= H.s, !ne || !X ? E.c = E.e = null : (E.c = [0], E.e = 0)), E;
    for (V = da(H.e / Yt) + da(E.e / Yt), E.s *= H.s, R = ne.length, U = X.length, R < U && (M = ne, ne = X, X = M, G = R, R = U, U = G), G = R + U, M = []; G--; M.push(0));
    for (Q = Xa, he = Wu, G = U; --G >= 0;) {
      for ($ = 0, q = X[G] % he, W = X[G] / he | 0, b = R, L = G + b; L > G;) N = ne[--b] % he, O = ne[b] / he | 0, T = W * N + O * q, N = q * N + T % he * he + M[L] + $, $ = (N / Q | 0) + (T / he | 0) + W * O, M[L--] = N % Q;
      M[L] = $
    }
    return $ ? ++V : M.splice(0, 1), I(E, M, V)
  }, i.negated = function () {
    var E = new p(this);
    return E.s = -E.s || null, E
  }, i.plus = function (E, D) {
    var $, V = this,
      G = V.s;
    if (E = new p(E, D), D = E.s, !G || !D) return new p(NaN);
    if (G != D) return E.s = -D, V.minus(E);
    var L = V.e / Yt,
      b = E.e / Yt,
      T = V.c,
      R = E.c;
    if (!L || !b) {
      if (!T || !R) return new p(G / 0);
      if (!T[0] || !R[0]) return R[0] ? E : new p(T[0] ? V : G * 0)
    }
    if (L = da(L), b = da(b), T = T.slice(), G = L - b) {
      for (G > 0 ? (b = L, $ = R) : (G = -G, $ = T), $.reverse(); G--; $.push(0));
      $.reverse()
    }
    for (G = T.length, D = R.length, G - D < 0 && ($ = R, R = T, T = $, D = G), G = 0; D;) G = (T[--D] = T[D] + R[D] + G) / Xa | 0, T[D] = Xa === T[D] ? 0 : T[D] % Xa;
    return G && (T = [G].concat(T), ++b), I(E, T, b)
  }, i.precision = i.sd = function (E, D) {
    var $, V, G, L = this;
    if (E != null && E !== !!E) return _r(E, 1, yi), D == null ? D = a : _r(D, 0, 8), A(new p(L), E, D);
    if (!($ = L.c)) return null;
    if (G = $.length - 1, V = G * Yt + 1, G = $[G]) {
      for (; G % 10 == 0; G /= 10, V--);
      for (G = $[0]; G >= 10; G /= 10, V++);
    }
    return E && L.e + 1 > V && (V = L.e + 1), V
  }, i.shiftedBy = function (E) {
    return _r(E, -zS, zS), this.times("1e" + E)
  }, i.squareRoot = i.sqrt = function () {
    var E, D, $, V, G, L = this,
      b = L.c,
      T = L.s,
      R = L.e,
      N = o + 4,
      O = new p("0.5");
    if (T !== 1 || !b || !b[0]) return new p(!T || T < 0 && (!b || b[0]) ? NaN : b ? L : 1 / 0);
    if (T = Math.sqrt(+w(L)), T == 0 || T == 1 / 0 ? (D = sa(b), (D.length + R) % 2 == 0 && (D += "0"), T = Math.sqrt(+D), R = da((R + 1) / 2) - (R < 0 || R % 2), T == 1 / 0 ? D = "5e" + R : (D = T.toExponential(), D = D.slice(0, D.indexOf("e") + 1) + R), $ = new p(D)) : $ = new p(T + ""), $.c[0]) {
      for (R = $.e, T = R + N, T < 3 && (T = 0);;)
        if (G = $, $ = O.times(G.plus(t(L, G, N, 1))), sa(G.c).slice(0, T) === (D = sa($.c)).slice(0, T))
          if ($.e < R && --T, D = D.slice(T - 3, T + 1), D == "9999" || !V && D == "4999") {
            if (!V && (A(G, G.e + o + 2, 0), G.times(G).eq(L))) {
              $ = G;
              break
            }
            N += 4, T += 4, V = 1
          } else {
            (!+D || !+D.slice(1) && D.charAt(0) == "5") && (A($, $.e + o + 2, 1), E = !$.times($).eq(L));
            break
          }
    }
    return A($, $.e + o + 1, a, E)
  }, i.toExponential = function (E, D) {
    return E != null && (_r(E, 0, yi), E++), v(this, E, D, 1)
  }, i.toFixed = function (E, D) {
    return E != null && (_r(E, 0, yi), E = E + this.e + 1), v(this, E, D)
  }, i.toFormat = function (E, D, $) {
    var V, G = this;
    if ($ == null) E != null && D && typeof D == "object" ? ($ = D, D = null) : E && typeof E == "object" ? ($ = E, E = D = null) : $ = x;
    else if (typeof $ != "object") throw Error(Ys + "Argument not an object: " + $);
    if (V = G.toFixed(E, D), G.c) {
      var L, b = V.split("."),
        T = +$.groupSize,
        R = +$.secondaryGroupSize,
        N = $.groupSeparator || "",
        O = b[0],
        U = b[1],
        q = G.s < 0,
        W = q ? O.slice(1) : O,
        M = W.length;
      if (R && (L = T, T = R, R = L, M -= L), T > 0 && M > 0) {
        for (L = M % T || T, O = W.substr(0, L); L < M; L += T) O += N + W.substr(L, T);
        R > 0 && (O += N + W.slice(L)), q && (O = "-" + O)
      }
      V = U ? O + ($.decimalSeparator || "") + ((R = +$.fractionGroupSize) ? U.replace(new RegExp("\\d{" + R + "}\\B", "g"), "$&" + ($.fractionGroupSeparator || "")) : U) : O
    }
    return ($.prefix || "") + V + ($.suffix || "")
  }, i.toFraction = function (E) {
    var D, $, V, G, L, b, T, R, N, O, U, q, W = this,
      M = W.c;
    if (E != null && (T = new p(E), !T.isInteger() && (T.c || T.s !== 1) || T.lt(s))) throw Error(Ys + "Argument " + (T.isInteger() ? "out of range: " : "not an integer: ") + w(T));
    if (!M) return new p(W);
    for (D = new p(s), N = $ = new p(s), V = R = new p(s), q = sa(M), L = D.e = q.length - W.e - 1, D.c[0] = HS[(b = L % Yt) < 0 ? Yt + b : b], E = !E || T.comparedTo(D) > 0 ? L > 0 ? D : N : T, b = f, f = 1 / 0, T = new p(q), R.c[0] = 0; O = t(T, D, 0, 1), G = $.plus(O.times(V)), G.comparedTo(E) != 1;) $ = V, V = G, N = R.plus(O.times(G = N)), R = G, D = T.minus(O.times(G = D)), T = G;
    return G = t(E.minus($), V, 0, 1), R = R.plus(G.times(N)), $ = $.plus(G.times(V)), R.s = N.s = W.s, L = L * 2, U = t(N, V, L, a).minus(W).abs().comparedTo(t(R, $, L, a).minus(W).abs()) < 1 ? [N, V] : [R, $], f = b, U
  }, i.toNumber = function () {
    return +w(this)
  }, i.toPrecision = function (E, D) {
    return E != null && _r(E, 1, yi), v(this, E, D, 2)
  }, i.toString = function (E) {
    var D, $ = this,
      V = $.s,
      G = $.e;
    return G === null ? V ? (D = "Infinity", V < 0 && (D = "-" + D)) : D = "NaN" : (E == null ? D = G <= c || G >= l ? Sb(sa($.c), G) : Ml(sa($.c), G, "0") : E === 10 && _ ? ($ = A(new p($), o + G + 1, a), D = Ml(sa($.c), $.e, "0")) : (_r(E, 2, k.length, "Base"), D = n(Ml(sa($.c), G, "0"), 10, E, V, !0)), V < 0 && $.c[0] && (D = "-" + D)), D
  }, i.valueOf = i.toJSON = function () {
    return w(this)
  }, i._isBigNumber = !0, i[Symbol.toStringTag] = "BigNumber", i[Symbol.for("nodejs.util.inspect.custom")] = i.valueOf, e != null && p.set(e), p
}

function da(e) {
  var t = e | 0;
  return e > 0 || e === t ? t : t - 1
}

function sa(e) {
  for (var t, n, r = 1, i = e.length, s = e[0] + ""; r < i;) {
    for (t = e[r++] + "", n = Yt - t.length; n--; t = "0" + t);
    s += t
  }
  for (i = s.length; s.charCodeAt(--i) === 48;);
  return s.slice(0, i + 1 || 1)
}

function pf(e, t) {
  var n, r, i = e.c,
    s = t.c,
    o = e.s,
    a = t.s,
    c = e.e,
    l = t.e;
  if (!o || !a) return null;
  if (n = i && !i[0], r = s && !s[0], n || r) return n ? r ? 0 : -a : o;
  if (o != a) return o;
  if (n = o < 0, r = c == l, !i || !s) return r ? 0 : !i ^ n ? 1 : -1;
  if (!r) return c > l ^ n ? 1 : -1;
  for (a = (c = i.length) < (l = s.length) ? c : l, o = 0; o < a; o++)
    if (i[o] != s[o]) return i[o] > s[o] ^ n ? 1 : -1;
  return c == l ? 0 : c > l ^ n ? 1 : -1
}

function _r(e, t, n, r) {
  if (e < t || e > n || e !== ua(e)) throw Error(Ys + (r || "Argument") + (typeof e == "number" ? e < t || e > n ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(e))
}

function Eb(e) {
  var t = e.c.length - 1;
  return da(e.e / Yt) == t && e.c[t] % 2 != 0
}

function Sb(e, t) {
  return (e.length > 1 ? e.charAt(0) + "." + e.slice(1) : e) + (t < 0 ? "e" : "e+") + t
}

function Ml(e, t, n) {
  var r, i;
  if (t < 0) {
    for (i = n + "."; ++t; i += n);
    e = i + e
  } else if (r = e.length, ++t > r) {
    for (i = n, t -= r; --t; i += n);
    e += i
  } else t < r && (e = e.slice(0, t) + "." + e.slice(t));
  return e
}
var Ss = FW();
const NSe = {
  updateRouteHook: () => {},
  switchChainHook: () => Promise.resolve(void 0),
  acceptExchangeRateUpdateHook: () => Promise.resolve(void 0),
  infiniteApproval: !1,
  executeInBackground: !1
};
class dr {
  constructor() {
    this.resolveSetupPromise = void 0, this.getConfig = () => this.config, this.getConfigAsync = async () => (await this.setupPromise, this.config), this.updateConfig = t => {
      var n;
      return this.config.apiUrl = t.apiUrl || this.config.apiUrl, this.config.rpcs = Object.assign(this.config.rpcs, t.rpcs), this.config.multicallAddresses = Object.assign(this.config.multicallAddresses, t.multicallAddresses), this.config.defaultExecutionSettings = Object.assign(this.config.defaultExecutionSettings, t.defaultExecutionSettings), this.config.defaultRouteOptions = Object.assign(this.config.defaultRouteOptions, t.defaultRouteOptions), this.config.apiKey = t.apiKey || this.config.apiKey, this.config.userId = t.userId || this.config.userId, this.config.integrator = t.integrator || this.config.integrator, this.config.defaultRouteOptions.integrator = t.integrator || ((n = t.defaultRouteOptions) == null ? void 0 : n.integrator) || this.config.integrator, this.config.widgetVersion = t.widgetVersion || this.config.widgetVersion, this.config.multisigConfig = t.multisigConfig || this.config.multisigConfig, this.config
    }, this.updateChains = t => {
      var n, r;
      for (const i of t) {
        const s = i.id;
        (n = this.config.rpcs[s]) != null && n.length || (this.config.rpcs[s] = i.metamask.rpcUrls), i.multicallAddress && !this.config.multicallAddresses[s] && (this.config.multicallAddresses[s] = i.multicallAddress)
      }
      return (r = this.resolveSetupPromise) == null || r.call(this), this.config
    }, this.config = dr.getDefaultConfig(), this.setupPromise = new Promise(t => {
      this.resolveSetupPromise = t
    })
  }
  static chainIdToObject(t) {
    const n = {};
    return Object.values(B).forEach(i => {
      typeof i != "string" && (n[i] = t && JSON.parse(JSON.stringify(t)))
    }), n
  }
  static getInstance() {
    return this.instance || (this.instance = new dr), this.instance
  }
}
dr.getDefaultConfig = () => ({
  apiUrl: "https://li.quest/v1",
  rpcs: dr.chainIdToObject([]),
  multicallAddresses: dr.chainIdToObject(void 0),
  defaultExecutionSettings: NSe,
  defaultRouteOptions: {
    integrator: "lifi-sdk"
  },
  integrator: "lifi-sdk"
});
const jW = "@lifi/sdk",
  L3 = "2.5.0",
  MSe = (e, t) => Math.floor(Math.random() * (t - e + 1) + e),
  $Se = (e, t) => e.chainId === t.chainId && e.address.toLowerCase() === t.address.toLowerCase();

function LSe(e, t) {
  return e.startsWith(t + "-") ? -1 : t.startsWith(e + "-") ? 1 : e.localeCompare(t, void 0, {
    numeric: !0,
    sensitivity: "case",
    caseFirst: "upper"
  })
}
const UW = async (e, t, n) => {
  return;
  try {
    const r = e ?? jW,
      s = (await Wi(`https://registry.npmjs.org/${r}/latest`, {
        skipTrackingHeaders: !0
      })).version,
      o = t ?? L3;
    LSe(s, o) && console.warn(`${r}: new package version is available. Please update as soon as possible to enjoy the newest features. Current version: ${o}. Latest version: ${s}.`)
  } catch {}
}, BSe = async (e, t) => await Wi(`https://api.tenderly.co/api/v1/public-contract/${t}/tx/${e}`), Ng = {}, vA = {
  [B.ETH]: "https://speedy-nodes-nyc.moralis.io/5ed6053dc39eba789ff466c9/eth/mainnet/archive",
  [B.BSC]: "https://speedy-nodes-nyc.moralis.io/5ed6053dc39eba789ff466c9/bsc/mainnet/archive",
  [B.POL]: "https://speedy-nodes-nyc.moralis.io/5ed6053dc39eba789ff466c9/polygon/mainnet/archive",
  [B.FTM]: "https://speedy-nodes-nyc.moralis.io/5ed6053dc39eba789ff466c9/fantom/mainnet"
}, FSe = async (e, t = !1) => (await zW(e, t))[0], zW = async (e, t = !1) => t && vA[e] ? [vA[e]] : (await dr.getInstance().getConfigAsync()).rpcs[e], jSe = e => {
  const t = MSe(0, e.length - 1);
  return e[t]
}, J5 = async (e, t = !1) => {
  var n;
  if (t && vA[e]) return new jM([new $M(await FSe(e, t), e)]);
  if ((n = Ng[e]) != null && n.length || (Ng[e] = [], (await zW(e, t)).forEach(i => {
      Ng[e].push(new jM([new $M(i, e)]))
    })), !Ng[e].length) throw new Fp(`Unable to configure provider for chain ${e}`);
  return jSe(Ng[e])
}, HW = async e => (await dr.getInstance().getConfigAsync()).multicallAddresses[e], VW = e => new Promise(t => {
  setTimeout(t, e)
}), USe = async (e, t) => {
  if (t.action.toAddress && t.action.fromAddress) return t;
  const n = await e.getAddress(),
    r = t.action.fromAddress || n,
    i = t.action.toAddress || n;
  return {
    ...t,
    action: {
      ...t.action,
      fromAddress: r,
      toAddress: i
    }
  }
}, zSe = (e, t) => e.reduce((n, r, i) => {
  const s = Math.floor(i / t);
  return n[s] || (n[s] = []), n[s].push(r), n
}, []), HSe = (e, t) => {
  if (!t) return "0.0";
  let n;
  if (typeof t == "string") {
    if (t === "0") return "0.0";
    n = new Ss(t).shiftedBy(-e.decimals)
  } else if (n = t, n.isZero()) return "0.0";
  let r = 3;
  for (; n.lt(1 / 10 ** r);) r++;
  return n.toFixed(r + 1, 1)
}, VSe = async (e, t = 5e3) => {
  let n;
  for (; !n;) n = await e(), n || await VW(t);
  return n
}, _k = e => e === bk || e === "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee", d2 = e => e === bk || e === "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee" || e === "0x471ece3750da237f93b8e339c536989b8978a438", QM = {
  retries: 1
}, Wi = async (e, t = {
  retries: QM.retries
}) => {
  const {
    userId: n,
    integrator: r,
    widgetVersion: i,
    apiKey: s
  } = dr.getInstance().getConfig();
  t.retries = t.retries ?? QM.retries;
  try {
    t.skipTrackingHeaders || (s && (t.headers = {
      ...t.headers,
      "x-lifi-api-key": s
    }), n && (t.headers = {
      ...t.headers,
      "x-lifi-userid": n
    }), i && (t.headers = {
      ...t.headers,
      "x-lifi-widget": i
    }), L3 && (t.headers = {
      ...t.headers,
      "x-lifi-sdk": L3
    }), t.headers = {
      ...t.headers,
      "x-lifi-integrator": r
    });
    const o = await fetch(e, t);
    if (!o.ok) throw new OSe(o);
    return await o.json()
  } catch (o) {
    if (t.retries > 0 && (o == null ? void 0 : o.status) === 500) return await VW(500), Wi(e, {
      ...t,
      retries: t.retries - 1
    });
    throw o
  }
}, WSe = e => {
  const {
    fromChainId: t,
    fromAmount: n,
    fromTokenAddress: r,
    toChainId: i,
    toTokenAddress: s,
    options: o
  } = e;
  return typeof t == "number" && typeof n == "string" && n !== "" && typeof r == "string" && r !== "" && typeof i == "number" && typeof s == "string" && s !== "" && (!o || qSe(o))
}, qSe = e => !(e != null && e.slippage) || typeof e.slippage == "number", GSe = e => {
  const {
    id: t,
    type: n,
    tool: r,
    action: i,
    estimate: s
  } = e;
  return typeof t == "string" && ["swap", "cross", "lifi"].includes(n) && typeof r == "string" && KSe(i) && QSe(s)
}, KSe = e => {
  const {
    fromChainId: t,
    fromAmount: n,
    fromToken: r,
    toChainId: i,
    toToken: s,
    slippage: o
  } = e;
  return typeof t == "number" && typeof n == "string" && n !== "" && C1(r) && typeof i == "number" && C1(s) && typeof o == "number"
}, QSe = e => {
  const {
    fromAmount: t,
    toAmount: n,
    toAmountMin: r,
    approvalAddress: i
  } = e;
  return typeof t == "string" && t !== "" && typeof n == "string" && n !== "" && typeof r == "string" && r !== "" && typeof i == "string"
}, C1 = e => {
  const {
    address: t,
    decimals: n,
    chainId: r
  } = e;
  return typeof t == "string" && typeof n == "number" && typeof r == "number"
};
var _0 = {},
  Cd = {},
  YSe = f2;
f2.default = f2;
f2.stable = GW;
f2.stableStringify = GW;
var B3 = "[...]",
  WW = "[Circular]",
  uh = [],
  Mf = [];

function qW() {
  return {
    depthLimit: Number.MAX_SAFE_INTEGER,
    edgesLimit: Number.MAX_SAFE_INTEGER
  }
}

function f2(e, t, n, r) {
  typeof r > "u" && (r = qW()), bA(e, "", 0, [], void 0, 0, r);
  var i;
  try {
    Mf.length === 0 ? i = JSON.stringify(e, t, n) : i = JSON.stringify(e, KW(t), n)
  } catch {
    return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]")
  } finally {
    for (; uh.length !== 0;) {
      var s = uh.pop();
      s.length === 4 ? Object.defineProperty(s[0], s[1], s[3]) : s[0][s[1]] = s[2]
    }
  }
  return i
}

function hp(e, t, n, r) {
  var i = Object.getOwnPropertyDescriptor(r, n);
  i.get !== void 0 ? i.configurable ? (Object.defineProperty(r, n, {
    value: e
  }), uh.push([r, n, t, i])) : Mf.push([t, n, e]) : (r[n] = e, uh.push([r, n, t]))
}

function bA(e, t, n, r, i, s, o) {
  s += 1;
  var a;
  if (typeof e == "object" && e !== null) {
    for (a = 0; a < r.length; a++)
      if (r[a] === e) {
        hp(WW, e, t, i);
        return
      } if (typeof o.depthLimit < "u" && s > o.depthLimit) {
      hp(B3, e, t, i);
      return
    }
    if (typeof o.edgesLimit < "u" && n + 1 > o.edgesLimit) {
      hp(B3, e, t, i);
      return
    }
    if (r.push(e), Array.isArray(e))
      for (a = 0; a < e.length; a++) bA(e[a], a, a, r, e, s, o);
    else {
      var c = Object.keys(e);
      for (a = 0; a < c.length; a++) {
        var l = c[a];
        bA(e[l], l, a, r, e, s, o)
      }
    }
    r.pop()
  }
}

function JSe(e, t) {
  return e < t ? -1 : e > t ? 1 : 0
}

function GW(e, t, n, r) {
  typeof r > "u" && (r = qW());
  var i = wA(e, "", 0, [], void 0, 0, r) || e,
    s;
  try {
    Mf.length === 0 ? s = JSON.stringify(i, t, n) : s = JSON.stringify(i, KW(t), n)
  } catch {
    return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]")
  } finally {
    for (; uh.length !== 0;) {
      var o = uh.pop();
      o.length === 4 ? Object.defineProperty(o[0], o[1], o[3]) : o[0][o[1]] = o[2]
    }
  }
  return s
}

function wA(e, t, n, r, i, s, o) {
  s += 1;
  var a;
  if (typeof e == "object" && e !== null) {
    for (a = 0; a < r.length; a++)
      if (r[a] === e) {
        hp(WW, e, t, i);
        return
      } try {
      if (typeof e.toJSON == "function") return
    } catch {
      return
    }
    if (typeof o.depthLimit < "u" && s > o.depthLimit) {
      hp(B3, e, t, i);
      return
    }
    if (typeof o.edgesLimit < "u" && n + 1 > o.edgesLimit) {
      hp(B3, e, t, i);
      return
    }
    if (r.push(e), Array.isArray(e))
      for (a = 0; a < e.length; a++) wA(e[a], a, a, r, e, s, o);
    else {
      var c = {},
        l = Object.keys(e).sort(JSe);
      for (a = 0; a < l.length; a++) {
        var u = l[a];
        wA(e[u], u, a, r, e, s, o), c[u] = e[u]
      }
      if (typeof i < "u") uh.push([i, t, e]), i[t] = c;
      else return c
    }
    r.pop()
  }
}

function KW(e) {
  return e = typeof e < "u" ? e : function (t, n) {
      return n
    },
    function (t, n) {
      if (Mf.length > 0)
        for (var r = 0; r < Mf.length; r++) {
          var i = Mf[r];
          if (i[1] === t && i[0] === n) {
            n = i[2], Mf.splice(r, 1);
            break
          }
        }
      return e.call(this, t, n)
    }
}
Object.defineProperty(Cd, "__esModule", {
  value: !0
});
Cd.EthereumProviderError = Cd.EthereumRpcError = void 0;
const XSe = YSe;
class QW extends Error {
  constructor(t, n, r) {
    if (!Number.isInteger(t)) throw new Error('"code" must be an integer.');
    if (!n || typeof n != "string") throw new Error('"message" must be a nonempty string.');
    super(n), this.code = t, r !== void 0 && (this.data = r)
  }
  serialize() {
    const t = {
      code: this.code,
      message: this.message
    };
    return this.data !== void 0 && (t.data = this.data), this.stack && (t.stack = this.stack), t
  }
  toString() {
    return XSe.default(this.serialize(), t8e, 2)
  }
}
Cd.EthereumRpcError = QW;
class ZSe extends QW {
  constructor(t, n, r) {
    if (!e8e(t)) throw new Error('"code" must be an integer such that: 1000 <= code <= 4999');
    super(t, n, r)
  }
}
Cd.EthereumProviderError = ZSe;

function e8e(e) {
  return Number.isInteger(e) && e >= 1e3 && e <= 4999
}

function t8e(e, t) {
  if (t !== "[Circular]") return t
}
var Ik = {},
  Ad = {};
Object.defineProperty(Ad, "__esModule", {
  value: !0
});
Ad.errorValues = Ad.errorCodes = void 0;
Ad.errorCodes = {
  rpc: {
    invalidInput: -32e3,
    resourceNotFound: -32001,
    resourceUnavailable: -32002,
    transactionRejected: -32003,
    methodNotSupported: -32004,
    limitExceeded: -32005,
    parse: -32700,
    invalidRequest: -32600,
    methodNotFound: -32601,
    invalidParams: -32602,
    internal: -32603
  },
  provider: {
    userRejectedRequest: 4001,
    unauthorized: 4100,
    unsupportedMethod: 4200,
    disconnected: 4900,
    chainDisconnected: 4901
  }
};
Ad.errorValues = {
  "-32700": {
    standard: "JSON RPC 2.0",
    message: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
  },
  "-32600": {
    standard: "JSON RPC 2.0",
    message: "The JSON sent is not a valid Request object."
  },
  "-32601": {
    standard: "JSON RPC 2.0",
    message: "The method does not exist / is not available."
  },
  "-32602": {
    standard: "JSON RPC 2.0",
    message: "Invalid method parameter(s)."
  },
  "-32603": {
    standard: "JSON RPC 2.0",
    message: "Internal JSON-RPC error."
  },
  "-32000": {
    standard: "EIP-1474",
    message: "Invalid input."
  },
  "-32001": {
    standard: "EIP-1474",
    message: "Resource not found."
  },
  "-32002": {
    standard: "EIP-1474",
    message: "Resource unavailable."
  },
  "-32003": {
    standard: "EIP-1474",
    message: "Transaction rejected."
  },
  "-32004": {
    standard: "EIP-1474",
    message: "Method not supported."
  },
  "-32005": {
    standard: "EIP-1474",
    message: "Request limit exceeded."
  },
  4001: {
    standard: "EIP-1193",
    message: "User rejected the request."
  },
  4100: {
    standard: "EIP-1193",
    message: "The requested account and/or method has not been authorized by the user."
  },
  4200: {
    standard: "EIP-1193",
    message: "The requested method is not supported by this Ethereum provider."
  },
  4900: {
    standard: "EIP-1193",
    message: "The provider is disconnected from all chains."
  },
  4901: {
    standard: "EIP-1193",
    message: "The provider is disconnected from the specified chain."
  }
};
(function (e) {
  Object.defineProperty(e, "__esModule", {
    value: !0
  }), e.serializeError = e.isValidCode = e.getMessageFromCode = e.JSON_RPC_SERVER_ERROR_MESSAGE = void 0;
  const t = Ad,
    n = Cd,
    r = t.errorCodes.rpc.internal,
    i = "Unspecified error message. This is a bug, please report it.",
    s = {
      code: r,
      message: o(r)
    };
  e.JSON_RPC_SERVER_ERROR_MESSAGE = "Unspecified server error.";

  function o(h, g = i) {
    if (Number.isInteger(h)) {
      const y = h.toString();
      if (f(t.errorValues, y)) return t.errorValues[y].message;
      if (l(h)) return e.JSON_RPC_SERVER_ERROR_MESSAGE
    }
    return g
  }
  e.getMessageFromCode = o;

  function a(h) {
    if (!Number.isInteger(h)) return !1;
    const g = h.toString();
    return !!(t.errorValues[g] || l(h))
  }
  e.isValidCode = a;

  function c(h, {
    fallbackError: g = s,
    shouldIncludeStack: y = !1
  } = {}) {
    var x, k;
    if (!g || !Number.isInteger(g.code) || typeof g.message != "string") throw new Error("Must provide fallback error with integer number code and string message.");
    if (h instanceof n.EthereumRpcError) return h.serialize();
    const _ = {};
    if (h && typeof h == "object" && !Array.isArray(h) && f(h, "code") && a(h.code)) {
      const v = h;
      _.code = v.code, v.message && typeof v.message == "string" ? (_.message = v.message, f(v, "data") && (_.data = v.data)) : (_.message = o(_.code), _.data = {
        originalError: u(h)
      })
    } else {
      _.code = g.code;
      const v = (x = h) === null || x === void 0 ? void 0 : x.message;
      _.message = v && typeof v == "string" ? v : g.message, _.data = {
        originalError: u(h)
      }
    }
    const p = (k = h) === null || k === void 0 ? void 0 : k.stack;
    return y && h && p && typeof p == "string" && (_.stack = p), _
  }
  e.serializeError = c;

  function l(h) {
    return h >= -32099 && h <= -32e3
  }

  function u(h) {
    return h && typeof h == "object" && !Array.isArray(h) ? Object.assign({}, h) : h
  }

  function f(h, g) {
    return Object.prototype.hasOwnProperty.call(h, g)
  }
})(Ik);
var X5 = {};
Object.defineProperty(X5, "__esModule", {
  value: !0
});
X5.ethErrors = void 0;
const Pk = Cd,
  YW = Ik,
  Xi = Ad;
X5.ethErrors = {
  rpc: {
    parse: e => oa(Xi.errorCodes.rpc.parse, e),
    invalidRequest: e => oa(Xi.errorCodes.rpc.invalidRequest, e),
    invalidParams: e => oa(Xi.errorCodes.rpc.invalidParams, e),
    methodNotFound: e => oa(Xi.errorCodes.rpc.methodNotFound, e),
    internal: e => oa(Xi.errorCodes.rpc.internal, e),
    server: e => {
      if (!e || typeof e != "object" || Array.isArray(e)) throw new Error("Ethereum RPC Server errors must provide single object argument.");
      const {
        code: t
      } = e;
      if (!Number.isInteger(t) || t > -32005 || t < -32099) throw new Error('"code" must be an integer such that: -32099 <= code <= -32005');
      return oa(t, e)
    },
    invalidInput: e => oa(Xi.errorCodes.rpc.invalidInput, e),
    resourceNotFound: e => oa(Xi.errorCodes.rpc.resourceNotFound, e),
    resourceUnavailable: e => oa(Xi.errorCodes.rpc.resourceUnavailable, e),
    transactionRejected: e => oa(Xi.errorCodes.rpc.transactionRejected, e),
    methodNotSupported: e => oa(Xi.errorCodes.rpc.methodNotSupported, e),
    limitExceeded: e => oa(Xi.errorCodes.rpc.limitExceeded, e)
  },
  provider: {
    userRejectedRequest: e => Mg(Xi.errorCodes.provider.userRejectedRequest, e),
    unauthorized: e => Mg(Xi.errorCodes.provider.unauthorized, e),
    unsupportedMethod: e => Mg(Xi.errorCodes.provider.unsupportedMethod, e),
    disconnected: e => Mg(Xi.errorCodes.provider.disconnected, e),
    chainDisconnected: e => Mg(Xi.errorCodes.provider.chainDisconnected, e),
    custom: e => {
      if (!e || typeof e != "object" || Array.isArray(e)) throw new Error("Ethereum Provider custom errors must provide single object argument.");
      const {
        code: t,
        message: n,
        data: r
      } = e;
      if (!n || typeof n != "string") throw new Error('"message" must be a nonempty string');
      return new Pk.EthereumProviderError(t, n, r)
    }
  }
};

function oa(e, t) {
  const [n, r] = JW(t);
  return new Pk.EthereumRpcError(e, n || YW.getMessageFromCode(e), r)
}

function Mg(e, t) {
  const [n, r] = JW(t);
  return new Pk.EthereumProviderError(e, n || YW.getMessageFromCode(e), r)
}

function JW(e) {
  if (e) {
    if (typeof e == "string") return [e];
    if (typeof e == "object" && !Array.isArray(e)) {
      const {
        message: t,
        data: n
      } = e;
      if (t && typeof t != "string") throw new Error("Must specify string message.");
      return [t || void 0, n]
    }
  }
  return []
}(function (e) {
  Object.defineProperty(e, "__esModule", {
    value: !0
  }), e.getMessageFromCode = e.serializeError = e.EthereumProviderError = e.EthereumRpcError = e.ethErrors = e.errorCodes = void 0;
  const t = Cd;
  Object.defineProperty(e, "EthereumRpcError", {
    enumerable: !0,
    get: function () {
      return t.EthereumRpcError
    }
  }), Object.defineProperty(e, "EthereumProviderError", {
    enumerable: !0,
    get: function () {
      return t.EthereumProviderError
    }
  });
  const n = Ik;
  Object.defineProperty(e, "serializeError", {
    enumerable: !0,
    get: function () {
      return n.serializeError
    }
  }), Object.defineProperty(e, "getMessageFromCode", {
    enumerable: !0,
    get: function () {
      return n.getMessageFromCode
    }
  });
  const r = X5;
  Object.defineProperty(e, "ethErrors", {
    enumerable: !0,
    get: function () {
      return r.ethErrors
    }
  });
  const i = Ad;
  Object.defineProperty(e, "errorCodes", {
    enumerable: !0,
    get: function () {
      return i.errorCodes
    }
  })
})(_0);
class Th {
  constructor() {
    this.chains = [], this.loadingPromise = this.loadAvailableChains()
  }
  async loadAvailableChains() {
    try {
      this.chains = await ts.getChains()
    } catch {}
  }
  async checkLoading() {
    this.loadingPromise && await this.loadingPromise, this.chains.length || await this.loadAvailableChains()
  }
  static getInstance() {
    return this.instance || (this.instance = new Th), this.instance
  }
  async getChainById(t) {
    await this.checkLoading();
    const n = this.chains.find(r => r.id === t);
    if (!n) throw new Rr(`Unknown chainId passed: ${t}.`);
    return n
  }
  async getChains() {
    return await this.checkLoading(), this.chains
  }
}
const qu = async (e, t) => {
  let n = "Transaction was not sent, your funds are still in your wallet";
  if (e) {
    const i = await Th.getInstance().getChainById(e.action.fromChainId);
    n += ` (${HSe(e.action.fromToken,e.action.fromAmount)} ${e.action.fromToken.symbol} on ${i.name})`
  }
  return n += ", please retry.<br/>If it still doesn't work, it is safe to delete this transfer and start a new one.", n += t && t.txLink ? `<br>You can check the failed transaction&nbsp;<a href="${t.txLink}" target="_blank" rel="nofollow noreferrer">here</a>.` : "", n
}, n8e = async (e, t) => {
  const i = `It appears that your transaction may not have been successful.
  However, to confirm this, please check your ${(await Th.getInstance().getChainById(e.action.toChainId)).name} wallet for ${e.action.toToken.symbol}.`;
  return t ? `${i}
    You can also check the&nbsp;<a href="${t}" target="_blank" rel="nofollow noreferrer">block explorer</a> for more information.` : i
}, XW = async (e, t, n) => {
  var r, i, s, o, a, c;
  if (e instanceof Ua) return e;
  if (e.code && typeof e.code == "number") {
    if (Object.values(_0.errorCodes.rpc).includes(e.code)) return e.code === _0.errorCodes.rpc.internal && ((r = e.message) != null && r.includes(ed.Underpriced) || (i = e.message) != null && i.includes(ed.LowReplacementFee)) ? new GM(nn.TransactionUnderpriced, qf.TransactionUnderpriced, await qu(t, n), e.stack) : (s = e.message) != null && s.includes(ed.LowGas) || (o = e.message) != null && o.includes(ed.OutOfGas) ? new lc(nn.GasLimitError, qf.GasLimitLow, await qu(t, n), e.stack) : new GM(e.code, _0.getMessageFromCode(e.code), await qu(t, n), e.stack);
    if (Object.values(_0.errorCodes.provider).includes(e.code)) return new $3(e.code, _0.getMessageFromCode(e.code), await qu(t, n), e.stack)
  }
  switch (e.code) {
    case S1.CallExecption:
      const l = await qu(t, n);
      try {
        if (!(t != null && t.action.fromChainId)) throw new Error("Signer is not defined.");
        const u = await BSe(e.transactionHash, t == null ? void 0 : t.action.fromChainId),
          f = (u == null ? void 0 : u.error_message) ?? e.reason;
        if (((a = u == null ? void 0 : u.error_message) == null ? void 0 : a.includes(ed.ERC20Allowance)) || ((c = e.reason) == null ? void 0 : c.includes(ed.ERC20Allowance))) return new lc(nn.AllowanceRequired, e.reason, f, e.stack);
        throw new Error(e)
      } catch {
        return new $3(nn.TransactionFailed, e.reason, l, e.stack)
      }
      case S1.InsufficientFunds:
        return new lc(nn.InsufficientFunds, e.message, await qu(t, n), e.stack);
      case S1.ActionRejected:
      case M3.userRejectedRequest:
        return new lc(nn.TransactionRejected, e.message, await qu(t, n), e.stack);
      case nn.TransactionUnprepared:
        return new lc(nn.TransactionUnprepared, e.message, await qu(t, n), e.stack);
      case nn.ValidationError:
        return new lc(nn.ValidationError, e.message, e.htmlMessage);
      default:
        return new RSe(nn.InternalError, e.message || qf.UnknownError, void 0, e.stack)
  }
}, Tc = async e => {
  var n, r, i, s, o, a, c, l, u;
  let t;
  try {
    t = await ((n = e.response) == null ? void 0 : n.json())
  } catch {}
  return ((r = e.response) == null ? void 0 : r.status) === 400 ? new Rr((t == null ? void 0 : t.message) || ((i = e.response) == null ? void 0 : i.statusText), void 0, e.stack) : ((s = e.response) == null ? void 0 : s.status) === 404 ? new PSe((t == null ? void 0 : t.message) || ((o = e.response) == null ? void 0 : o.statusText), void 0, e.stack) : ((a = e.response) == null ? void 0 : a.status) === 409 ? new _Se((t == null ? void 0 : t.message) || ((c = e.response) == null ? void 0 : c.statusText), qf.SlippageError, e.stack) : ((l = e.response) == null ? void 0 : l.status) === 500 ? new Fp((t == null ? void 0 : t.message) || ((u = e.response) == null ? void 0 : u.statusText), void 0, e.stack) : new Fp(qf.Default, void 0, e.stack)
}, r8e = async (e, t) => {
  e || (e = {});
  const n = dr.getInstance().getConfig();
  (e.bridges || n.defaultRouteOptions.bridges) && (e.bridges = e.bridges || n.defaultRouteOptions.bridges), (e.exchanges || n.defaultRouteOptions.exchanges) && (e.exchanges = e.exchanges || n.defaultRouteOptions.exchanges);
  try {
    return await Wi(`${n.apiUrl}/advanced/possibilities`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify(e),
      signal: t == null ? void 0 : t.signal
    })
  } catch (r) {
    throw await Tc(r)
  }
}, i8e = async (e, t, n) => {
  if (!e) throw new Rr('Required parameter "chain" is missing.');
  if (!t) throw new Rr('Required parameter "token" is missing.');
  const r = dr.getInstance().getConfig();
  try {
    return await Wi(`${r.apiUrl}/token?${new URLSearchParams({chain:e,token:t})}`, {
      signal: n == null ? void 0 : n.signal
    })
  } catch (i) {
    throw await Tc(i)
  }
}, s8e = async (e, t) => {
  var i, s, o, a, c, l;
  const n = dr.getInstance().getConfig();
  ["fromChain", "fromToken", "fromAddress", "fromAmount", "toChain", "toToken"].forEach(u => {
    if (!e[u]) throw new Rr(`Required parameter "${u}" is missing.`)
  }), e.order || (e.order = n.defaultRouteOptions.order), e.slippage || (e.slippage = n.defaultRouteOptions.slippage), e.integrator || (e.integrator = n.defaultRouteOptions.integrator), e.referrer || (e.referrer = n.defaultRouteOptions.referrer), e.fee || (e.fee = n.defaultRouteOptions.fee), e.allowBridges || (e.allowBridges = (i = n.defaultRouteOptions.bridges) == null ? void 0 : i.allow), e.denyBridges || (e.denyBridges = (s = n.defaultRouteOptions.bridges) == null ? void 0 : s.deny), e.preferBridges || (e.preferBridges = (o = n.defaultRouteOptions.bridges) == null ? void 0 : o.prefer), e.allowExchanges || (e.allowExchanges = (a = n.defaultRouteOptions.exchanges) == null ? void 0 : a.allow), e.denyExchanges || (e.denyExchanges = (c = n.defaultRouteOptions.exchanges) == null ? void 0 : c.deny), e.preferExchanges || (e.preferExchanges = (l = n.defaultRouteOptions.exchanges) == null ? void 0 : l.prefer), Object.keys(e).forEach(u => !e[u] && delete e[u]);
  try {
    return await Wi(`${n.apiUrl}/quote?${new URLSearchParams(e)}`, {
      signal: t == null ? void 0 : t.signal
    })
  } catch (u) {
    throw await Tc(u)
  }
}, o8e = async (e, t) => {
  var i, s, o, a, c, l;
  const n = dr.getInstance().getConfig();
  ["fromChain", "fromToken", "fromAddress", "toChain", "toToken", "toAmount", "toContractAddress", "toContractCallData", "toContractGasLimit"].forEach(u => {
    if (!e[u]) throw new Rr(`Required parameter "${u}" is missing.`)
  }), e.slippage || (e.slippage = n.defaultRouteOptions.slippage), e.integrator || (e.integrator = n.defaultRouteOptions.integrator), e.referrer || (e.referrer = n.defaultRouteOptions.referrer), e.fee || (e.fee = n.defaultRouteOptions.fee), e.allowBridges || (e.allowBridges = (i = n.defaultRouteOptions.bridges) == null ? void 0 : i.allow), e.denyBridges || (e.denyBridges = (s = n.defaultRouteOptions.bridges) == null ? void 0 : s.deny), e.preferBridges || (e.preferBridges = (o = n.defaultRouteOptions.bridges) == null ? void 0 : o.prefer), e.allowExchanges || (e.allowExchanges = (a = n.defaultRouteOptions.exchanges) == null ? void 0 : a.allow), e.denyExchanges || (e.denyExchanges = (c = n.defaultRouteOptions.exchanges) == null ? void 0 : c.deny), e.preferExchanges || (e.preferExchanges = (l = n.defaultRouteOptions.exchanges) == null ? void 0 : l.prefer);
  try {
    return await Wi(`${n.apiUrl}/quote/contractCall`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify(e),
      signal: t == null ? void 0 : t.signal
    })
  } catch (u) {
    throw await Tc(u)
  }
}, a8e = async (e, t) => {
  var i, s, o, a, c, l;
  const n = dr.getInstance().getConfig(),
    r = ["fromChain", "fromToken", "fromAddress", "toChain", "toToken", "toAmount", "contractCalls"];
  if (e.contractCalls.length === 0) throw new Rr('Parameter "contractCalls" is empty.');
  r.forEach(u => {
    if (!e[u]) throw new Rr(`Required parameter "${u}" is missing.`)
  }), e.slippage || (e.slippage = n.defaultRouteOptions.slippage), e.integrator || (e.integrator = n.defaultRouteOptions.integrator), e.referrer || (e.referrer = n.defaultRouteOptions.referrer), e.allowBridges || (e.allowBridges = (i = n.defaultRouteOptions.bridges) == null ? void 0 : i.allow), e.denyBridges || (e.denyBridges = (s = n.defaultRouteOptions.bridges) == null ? void 0 : s.deny), e.preferBridges || (e.preferBridges = (o = n.defaultRouteOptions.bridges) == null ? void 0 : o.prefer), e.allowExchanges || (e.allowExchanges = (a = n.defaultRouteOptions.exchanges) == null ? void 0 : a.allow), e.denyExchanges || (e.denyExchanges = (c = n.defaultRouteOptions.exchanges) == null ? void 0 : c.deny), e.preferExchanges || (e.preferExchanges = (l = n.defaultRouteOptions.exchanges) == null ? void 0 : l.prefer);
  try {
    return await Wi(`${n.apiUrl}/quote/contractCalls`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify(e),
      signal: t == null ? void 0 : t.signal
    })
  } catch (u) {
    throw await Tc(u)
  }
}, c8e = async (e, t) => {
  if (!e.txHash) throw new Rr('Required parameter "txHash" is missing.');
  const n = dr.getInstance().getConfig(),
    r = new URLSearchParams(e);
  try {
    return await Wi(`${n.apiUrl}/status?${r}`, {
      signal: t == null ? void 0 : t.signal
    })
  } catch (i) {
    throw await Tc(i)
  }
}, l8e = async e => {
  const t = dr.getInstance().getConfig();
  try {
    return (await Wi(`${t.apiUrl}/chains`, {
      signal: e == null ? void 0 : e.signal
    })).chains
  } catch (n) {
    throw await Tc(n)
  }
}, u8e = async (e, t) => {
  if (!WSe(e)) throw new Rr("Invalid routes request.");
  const n = dr.getInstance().getConfig();
  e.options = {
    ...n.defaultRouteOptions,
    ...e.options
  };
  try {
    return await Wi(`${n.apiUrl}/advanced/routes`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify(e),
      signal: t == null ? void 0 : t.signal
    })
  } catch (r) {
    throw await Tc(r)
  }
}, d8e = async (e, t) => {
  GSe(e) || console.warn("SDK Validation: Invalid Step", e);
  const n = dr.getInstance().getConfig();
  try {
    return await Wi(`${n.apiUrl}/advanced/stepTransaction`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify(e),
      signal: t == null ? void 0 : t.signal
    })
  } catch (r) {
    throw await Tc(r)
  }
}, f8e = async (e, t) => {
  const n = dr.getInstance().getConfig();
  return e && Object.keys(e).forEach(i => !e[i] && delete e[i]), await Wi(`${n.apiUrl}/tools?${new URLSearchParams(e)}`, {
    signal: t == null ? void 0 : t.signal
  })
}, h8e = async (e, t) => {
  const n = dr.getInstance().getConfig();
  return e && Object.keys(e).forEach(i => !e[i] && delete e[i]), await Wi(`${n.apiUrl}/tokens?${new URLSearchParams(e)}`, {
    signal: t == null ? void 0 : t.signal
  })
}, p8e = async ({
  chainId: e,
  fromChain: t,
  fromToken: n
}, r) => {
  const i = dr.getInstance().getConfig();
  if (!e) throw new Rr('Required parameter "chainId" is missing.');
  const s = new URL(`${i.apiUrl}/gas/suggestion/${e}`);
  t && s.searchParams.append("fromChain", t), n && s.searchParams.append("fromToken", n);
  try {
    return await Wi(s, {
      signal: r == null ? void 0 : r.signal
    })
  } catch (o) {
    throw await Tc(o)
  }
}, m8e = async e => {
  const t = dr.getInstance().getConfig(),
    n = new URL(`${t.apiUrl}/connections`),
    {
      fromChain: r,
      fromToken: i,
      toChain: s,
      toToken: o
    } = e;
  r && n.searchParams.append("fromChain", r), i && n.searchParams.append("fromToken", i), s && n.searchParams.append("toChain", s), o && n.searchParams.append("toToken", o), ["allowBridges", "denyBridges", "preferBridges", "allowExchanges", "denyExchanges", "preferExchanges"].forEach(c => {
    const l = e[c];
    l != null && l.length && (l == null || l.forEach(u => {
      n.searchParams.append(c, u)
    }))
  });
  try {
    return await Wi(n)
  } catch (c) {
    throw await Tc(c)
  }
}, g8e = async e => {
  const t = dr.getInstance().getConfig();
  if (!e.fromTimestamp) throw new Rr('Required parameter "fromTimestamp" is missing.');
  if (!e.toTimestamp) throw new Rr('Required parameter "toTimestamp" is missing.');
  const n = new URL(`${t.apiUrl}/analytics/wallets/${e.walletAddress}`);
  return n.searchParams.append("fromTimestamp", e.fromTimestamp.toString()), n.searchParams.append("toTimestamp", e.toTimestamp.toString()), await Wi(n)
}, ts = {
  getChains: l8e,
  getContractCallQuote: o8e,
  getContractCallsQuote: a8e,
  getGasRecommendation: p8e,
  getPossibilities: r8e,
  getQuote: s8e,
  getRoutes: u8e,
  getStatus: c8e,
  getStepTransaction: d8e,
  getToken: i8e,
  getTokens: h8e,
  getTools: f8e,
  getAvailableConnections: m8e,
  getTransactionHistory: g8e
}, Cb = {};
async function y8e(e, t, n, r) {
  const i = () => new Promise(async (o, a) => {
    let c;
    try {
      c = await ts.getStatus({
        bridge: r.tool,
        fromChain: r.action.fromChainId,
        toChain: r.action.toChainId,
        txHash: e
      })
    } catch (l) {
      return console.debug("Fetching status from backend failed.", l), o(void 0)
    }
    switch (c.status) {
      case "DONE":
        return o(c);
      case "PENDING":
        return t == null || t.updateProcess(r, n, "PENDING", {
          substatus: c.substatus,
          substatusMessage: c.substatusMessage || ZW(c.status, c.substatus),
          txLink: c.bridgeExplorerLink
        }), o(void 0);
      case "NOT_FOUND":
        return o(void 0);
      case "FAILED":
      default:
        return a()
    }
  });
  let s;
  if (e in Cb ? s = await Cb[e] : (Cb[e] = VSe(i, 5e3), s = await Cb[e]), !s.receiving) throw new Fp("Status doesn't contain receiving information.");
  return s
}
const v8e = {
    TOKEN_ALLOWANCE: {
      STARTED: "Setting token allowance.",
      PENDING: "Waiting for token allowance.",
      DONE: "Token allowance set."
    },
    SWITCH_CHAIN: {
      PENDING: "Chain switch required.",
      DONE: "Chain switched successfully."
    },
    SWAP: {
      STARTED: "Preparing swap transaction.",
      ACTION_REQUIRED: "Please sign the transaction.",
      PENDING: "Waiting for swap transaction.",
      DONE: "Swap completed."
    },
    CROSS_CHAIN: {
      STARTED: "Preparing bridge transaction.",
      ACTION_REQUIRED: "Please sign the transaction.",
      PENDING: "Waiting for bridge transaction.",
      DONE: "Bridge transaction confirmed."
    },
    RECEIVING_CHAIN: {
      PENDING: "Waiting for destination chain.",
      DONE: "Bridge completed."
    },
    TRANSACTION: {}
  },
  b8e = {
    PENDING: {
      BRIDGE_NOT_AVAILABLE: "Bridge communication is temporarily unavailable.",
      CHAIN_NOT_AVAILABLE: "RPC communication is temporarily unavailable.",
      NOT_PROCESSABLE_REFUND_NEEDED: "The transfer cannot be completed successfully. A refund operation is required.",
      UNKNOWN_ERROR: "An unexpected error occurred. Please seek assistance in the LI.FI discord server.",
      WAIT_SOURCE_CONFIRMATIONS: "The bridge deposit has been received. The bridge is waiting for more confirmations to start the off-chain logic.",
      WAIT_DESTINATION_TRANSACTION: "The bridge off-chain logic is being executed. Wait for the transaction to appear on the destination chain."
    },
    DONE: {
      PARTIAL: "Some of the received tokens are not the requested destination tokens.",
      REFUNDED: "The tokens were refunded to the sender address.",
      COMPLETED: "The transfer is complete."
    },
    FAILED: {},
    INVALID: {},
    NOT_FOUND: {}
  };

function YM(e, t) {
  return v8e[e][t]
}

function ZW(e, t) {
  return t ? b8e[e][t] : void 0
}

function w8e(e, t) {
  const n = new Ss(e.action.slippage),
    r = new Ss(e.estimate.toAmountMin),
    i = new Ss(t.estimate.toAmountMin),
    s = r.minus(i);
  let o = new Ss(0);
  return r.gt(0) && (o = s.dividedBy(r)), i.gte(r) && o.lte(n)
}
class x8e {
  constructor(t, n, r) {
    this.shouldUpdate = !0, this.initExecutionObject = i => {
      const s = i.execution || structuredClone(TSe);
      return i.execution || (i.execution = s, i.execution.status = "PENDING", this.updateStepInRoute(i)), s.status === "FAILED" && (s.status = "PENDING", this.updateStepInRoute(i)), s
    }, this.findOrCreateProcess = (i, s, o) => {
      var l;
      if (!((l = i.execution) != null && l.process)) throw new Error("Execution hasn't been initialized.");
      const a = i.execution.process.find(u => u.type === s);
      if (a) return o && a.status !== o && (a.status = o, this.updateStepInRoute(i)), a;
      const c = {
        type: s,
        startedAt: Date.now(),
        message: YM(s, o ?? "STARTED"),
        status: o ?? "STARTED"
      };
      return i.execution.process.push(c), this.updateStepInRoute(i), c
    }, this.updateProcess = (i, s, o, a) => {
      var l, u, f;
      if (!i.execution) throw new Error("Can't update an empty step execution.");
      const c = (l = i == null ? void 0 : i.execution) == null ? void 0 : l.process.find(h => h.type === s);
      if (!c) throw new Error("Can't find a process for the given type.");
      switch (o) {
        case "CANCELLED":
          c.doneAt = Date.now();
          break;
        case "FAILED":
          c.doneAt = Date.now(), i.execution.status = "FAILED";
          break;
        case "DONE":
          c.doneAt = Date.now();
          break;
        case "PENDING":
          i.execution.status = "PENDING";
          break;
        case "ACTION_REQUIRED":
          i.execution.status = "ACTION_REQUIRED";
          break
      }
      if (c.status = o, c.message = YM(s, o), a)
        for (const [h, g] of Object.entries(a)) c[h] = g;
      return i.execution.process = [...(u = i == null ? void 0 : i.execution) == null ? void 0 : u.process.filter(h => h.status === "DONE"), ...(f = i == null ? void 0 : i.execution) == null ? void 0 : f.process.filter(h => h.status !== "DONE")], this.updateStepInRoute(i), c
    }, this.removeProcess = (i, s) => {
      if (!i.execution) throw new Error("Execution hasn't been initialized.");
      const o = i.execution.process.findIndex(a => a.type === s);
      i.execution.process.splice(o, 1), this.updateStepInRoute(i)
    }, this.updateStepInRoute = i => {
      if (!this.shouldUpdate) return i;
      const s = this.route.steps.findIndex(o => o.id === i.id);
      if (s === -1) throw new Error("Couldn't find a step to update.");
      return this.route.steps[s] = Object.assign(this.route.steps[s], i), this.settings.updateRouteHook(this.route), this.internalUpdateRouteCallback(this.route), this.route.steps[s]
    }, this.route = t, this.settings = n, this.internalUpdateRouteCallback = r
  }
  updateExecution(t, n, r) {
    if (!t.execution) throw Error("Can't update empty execution.");
    return t.execution.status = n, r && (t.execution = {
      ...t.execution,
      ...r
    }), this.updateStepInRoute(t), t
  }
  allowUpdates(t) {
    this.shouldUpdate = t
  }
}
const E8e = [{
    inputs: [{
      components: [{
        internalType: "address",
        name: "target",
        type: "address"
      }, {
        internalType: "bytes",
        name: "callData",
        type: "bytes"
      }],
      internalType: "struct Multicall2.Call[]",
      name: "calls",
      type: "tuple[]"
    }],
    name: "aggregate",
    outputs: [{
      internalType: "uint256",
      name: "blockNumber",
      type: "uint256"
    }, {
      internalType: "bytes[]",
      name: "returnData",
      type: "bytes[]"
    }],
    stateMutability: "view",
    type: "function"
  }, {
    inputs: [{
      components: [{
        internalType: "address",
        name: "target",
        type: "address"
      }, {
        internalType: "bytes",
        name: "callData",
        type: "bytes"
      }],
      internalType: "struct Multicall2.Call[]",
      name: "calls",
      type: "tuple[]"
    }],
    name: "blockAndAggregate",
    outputs: [{
      internalType: "uint256",
      name: "blockNumber",
      type: "uint256"
    }, {
      internalType: "bytes32",
      name: "blockHash",
      type: "bytes32"
    }, {
      components: [{
        internalType: "bool",
        name: "success",
        type: "bool"
      }, {
        internalType: "bytes",
        name: "returnData",
        type: "bytes"
      }],
      internalType: "struct Multicall2.Result[]",
      name: "returnData",
      type: "tuple[]"
    }],
    stateMutability: "nonpayable",
    type: "function"
  }, {
    inputs: [{
      internalType: "uint256",
      name: "blockNumber",
      type: "uint256"
    }],
    name: "getBlockHash",
    outputs: [{
      internalType: "bytes32",
      name: "blockHash",
      type: "bytes32"
    }],
    stateMutability: "view",
    type: "function"
  }, {
    inputs: [],
    name: "getBlockNumber",
    outputs: [{
      internalType: "uint256",
      name: "blockNumber",
      type: "uint256"
    }],
    stateMutability: "view",
    type: "function"
  }, {
    inputs: [],
    name: "getCurrentBlockCoinbase",
    outputs: [{
      internalType: "address",
      name: "coinbase",
      type: "address"
    }],
    stateMutability: "view",
    type: "function"
  }, {
    inputs: [],
    name: "getCurrentBlockDifficulty",
    outputs: [{
      internalType: "uint256",
      name: "difficulty",
      type: "uint256"
    }],
    stateMutability: "view",
    type: "function"
  }, {
    inputs: [],
    name: "getCurrentBlockGasLimit",
    outputs: [{
      internalType: "uint256",
      name: "gaslimit",
      type: "uint256"
    }],
    stateMutability: "view",
    type: "function"
  }, {
    inputs: [],
    name: "getCurrentBlockTimestamp",
    outputs: [{
      internalType: "uint256",
      name: "timestamp",
      type: "uint256"
    }],
    stateMutability: "view",
    type: "function"
  }, {
    inputs: [{
      internalType: "address",
      name: "addr",
      type: "address"
    }],
    name: "getEthBalance",
    outputs: [{
      internalType: "uint256",
      name: "balance",
      type: "uint256"
    }],
    stateMutability: "view",
    type: "function"
  }, {
    inputs: [],
    name: "getLastBlockHash",
    outputs: [{
      internalType: "bytes32",
      name: "blockHash",
      type: "bytes32"
    }],
    stateMutability: "view",
    type: "function"
  }, {
    inputs: [{
      internalType: "bool",
      name: "requireSuccess",
      type: "bool"
    }, {
      components: [{
        internalType: "address",
        name: "target",
        type: "address"
      }, {
        internalType: "bytes",
        name: "callData",
        type: "bytes"
      }],
      internalType: "struct Multicall2.Call[]",
      name: "calls",
      type: "tuple[]"
    }],
    name: "tryAggregate",
    outputs: [{
      components: [{
        internalType: "bool",
        name: "success",
        type: "bool"
      }, {
        internalType: "bytes",
        name: "returnData",
        type: "bytes"
      }],
      internalType: "struct Multicall2.Result[]",
      name: "returnData",
      type: "tuple[]"
    }],
    stateMutability: "view",
    type: "function"
  }, {
    inputs: [{
      internalType: "bool",
      name: "requireSuccess",
      type: "bool"
    }, {
      components: [{
        internalType: "address",
        name: "target",
        type: "address"
      }, {
        internalType: "bytes",
        name: "callData",
        type: "bytes"
      }],
      internalType: "struct Multicall2.Call[]",
      name: "calls",
      type: "tuple[]"
    }],
    name: "tryBlockAndAggregate",
    outputs: [{
      internalType: "uint256",
      name: "blockNumber",
      type: "uint256"
    }, {
      internalType: "bytes32",
      name: "blockHash",
      type: "bytes32"
    }, {
      components: [{
        internalType: "bool",
        name: "success",
        type: "bool"
      }, {
        internalType: "bytes",
        name: "returnData",
        type: "bytes"
      }],
      internalType: "struct Multicall2.Result[]",
      name: "returnData",
      type: "tuple[]"
    }],
    stateMutability: "view",
    type: "function"
  }],
  S8e = 100,
  eq = async (e, t, n, r, i = !1) => {
    const s = await J5(n),
      o = new K5(r, E8e, s),
      a = new lA(t),
      c = zSe(e, S8e);
    return (await Promise.all(c.map(async u => {
      const f = u.map(h => [h.address.toLowerCase(), a.encodeFunctionData(h.name, h.params)]);
      try {
        const {
          blockNumber: h,
          returnData: g
        } = await o.tryBlockAndAggregate(i, f);
        return g.map(({
          success: y,
          returnData: x
        }, k) => {
          if (!y) return console.error(`Multicall unsuccessful for address "${u[k].address}", function "${u[k].name}", chainId "${n}"`), [];
          if (x.toString() === "0x") return console.error(`Multicall no response for address "${u[k].address}", function "${u[k].name}", chainId "${n}"`), [];
          try {
            return a.decodeFunctionResult(u[k].name, x)
          } catch {
            return console.error(`Multicall parsing unsuccessful for address "${u[k].address}", function "${u[k].name}", chainId "${n}"`), []
          }
        }).map(y => ({
          data: y[0],
          blockNumber: h.toNumber()
        }))
      } catch (h) {
        return console.error(`Multicall failed on chainId "${n}"`, c, h), []
      }
    }))).flat()
  }, Z5 = async (e, t, n) => {
    const r = await e.getAddress(),
      i = new K5(t, kk, e);
    try {
      const s = await i.allowance(r, n);
      return new Ss(s.toString())
    } catch {
      return new Ss(0)
    }
  }, F3 = async (e, t, n, r, i) => {
    const s = new K5(t, kk, e);
    if (i) return s.populateTransaction.approve(n, r);
    const o = await s.populateTransaction.approve(n, r);
    try {
      const a = await e.estimateGas(o);
      if (a) {
        const c = st.from(`${BigInt(a.toString())*125n/100n}`);
        o.gasLimit = c
      }
    } catch {}
    return e.sendTransaction(o)
  }, C8e = async (e, t, n) => {
    const i = await Th.getInstance().getChainById(t);
    if (!i.multicallAddress) throw new Fp(`No multicall address configured for chainId ${t}.`);
    const s = await e.getAddress(),
      o = [];
    n.map(({
      token: l,
      approvalAddress: u
    }) => {
      o.push({
        address: l.address,
        name: "allowance",
        params: [s, u]
      })
    });
    const a = await eq(o, kk, t, i.multicallAddress);
    if (!a.length) throw new Fp(`Couldn't load allowance from chainId ${t} using multicall.`);
    const c = a.map(({
      data: l
    }) => ({
      approvalAmount: l ?? new Ss(0)
    }));
    return n.map(({
      token: l,
      approvalAddress: u
    }, f) => ({
      token: l,
      approvalAddress: u,
      approvedAmount: c[f].approvalAmount
    }))
  }, A8e = e => {
    const t = {};
    return e.forEach(n => {
      t[n.token.chainId] || (t[n.token.chainId] = []), t[n.token.chainId].push(n)
    }), t
  }, tq = e => {
    if (!e.provider) throw new $3(nn.ProviderUnavailable, "No provider available in signer.");
    return e.provider
  }, T8e = async (e, t, n, r, i, s = !1, o = !1) => {
    let a = n.findOrCreateProcess(t, "TOKEN_ALLOWANCE");
    try {
      if (a.txHash && a.status !== "DONE") a.status !== "PENDING" && (a = n.updateProcess(t, a.type, "PENDING")), await tq(e).waitForTransaction(a.txHash), a = n.updateProcess(t, a.type, "DONE");
      else {
        const c = {
          from: t.action.fromToken.address,
          to: t.estimate.approvalAddress
        };
        if (r.updateTransactionRequestHook) {
          const u = await r.updateTransactionRequestHook(c);
          c.gasLimit = u.gasLimit, c.gasPrice = u.gasPrice, c.maxFeePerGas = u.maxFeePerGas, c.maxPriorityFeePerGas = u.maxPriorityFeePerGas
        }
        if (!c.from) throw new Error("Missing Signer address");
        if (!c.to) throw new Error("Missing ERC20 contract address");
        const l = await Z5(e, c.from, c.to);
        if (new Ss(t.action.fromAmount).gt(l)) {
          if (!s) return;
          const u = r.infiniteApproval ? wk.toString() : t.action.fromAmount;
          if (o) {
            const h = await F3(e, t.action.fromToken.address, t.estimate.approvalAddress, u, !0);
            return a = n.updateProcess(t, a.type, "DONE"), h
          }
          const f = await F3(e, t.action.fromToken.address, t.estimate.approvalAddress, u);
          a = n.updateProcess(t, a.type, "PENDING", {
            txHash: f.hash,
            txLink: i.metamask.blockExplorerUrls[0] + "tx/" + f.hash
          }), await f.wait(), a = n.updateProcess(t, a.type, "DONE")
        } else a = n.updateProcess(t, a.type, "DONE")
      }
    } catch (c) {
      if (c.code === "TRANSACTION_REPLACED" && c.replacement) await nq(c.replacement, a, t, i, n);
      else {
        const l = await XW(c, t, a);
        throw a = n.updateProcess(t, a.type, "FAILED", {
          error: {
            message: l.message,
            htmlMessage: l.htmlMessage,
            code: l.code
          }
        }), n.updateExecution(t, "FAILED"), l
      }
    }
  }, nq = async (e, t, n, r, i) => {
    try {
      t = i.updateProcess(n, t.type, "PENDING", {
        txHash: e.hash,
        txLink: r.metamask.blockExplorerUrls[0] + "tx/" + e.hash
      }), await e.wait(), t = i.updateProcess(n, t.type, "DONE")
    } catch (s) {
      throw s.code === "TRANSACTION_REPLACED" && s.replacement && await nq(s.replacement, t, n, r, i), s
    }
  }, k8e = async (e, t, n) => d2(t.address) ? void 0 : (await Z5(e, t.address, n)).toFixed(0), _8e = async (e, t) => {
    const n = t.filter(({
        token: a
      }) => !d2(a.address)),
      r = A8e(n),
      i = Object.keys(r).map(async a => {
        const c = Number.parseInt(a);
        return C8e(e, c, r[c])
      }),
      o = (await Promise.all(i)).flat();
    return t.map(({
      token: a
    }) => {
      if (d2(a.address)) return {
        token: a,
        approval: void 0
      };
      const c = o.find(l => $Se(l.token, a));
      return {
        token: a,
        approval: c == null ? void 0 : c.approvedAmount.toString()
      }
    })
  }, I8e = async ({
    signer: e,
    token: t,
    approvalAddress: n,
    amount: r,
    infiniteApproval: i = !1
  }) => {
    if (d2(t.address)) return;
    const s = await Z5(e, t.address, n);
    if (new Ss(r).gt(s)) {
      const o = i ? wk.toString() : r;
      await (await F3(e, t.address, n, o)).wait()
    }
  }, P8e = async ({
    signer: e,
    token: t,
    approvalAddress: n
  }) => {
    if (d2(t.address)) return;
    (await Z5(e, t.address, n)).isZero() || await (await F3(e, t.address, n, "0")).wait()
  }, R8e = [{
    constant: !0,
    inputs: [{
      name: "who",
      type: "address"
    }],
    name: "balanceOf",
    outputs: [{
      name: "",
      type: "uint256"
    }],
    payable: !1,
    stateMutability: "view",
    type: "function"
  }, {
    constant: !0,
    inputs: [{
      name: "addr",
      type: "address"
    }],
    name: "getEthBalance",
    outputs: [{
      name: "balance",
      type: "uint256"
    }],
    payable: !1,
    stateMutability: "view",
    type: "function"
  }], O8e = async (e, t) => {
    if (t.length === 0) return [];
    const {
      chainId: n
    } = t[0];
    return t.forEach(r => {
      if (r.chainId !== n) return console.warn("Requested tokens have to be on the same chain."), []
    }), await HW(n) && t.length > 1 ? D8e(e, t) : $8e(e, t)
  }, D8e = async (e, t) => {
    const {
      chainId: n
    } = t[0], r = await HW(n);
    if (!r) throw new Error("No multicallAddress found for the given chain.");
    return N8e(e, t, r, n)
  }, N8e = async (e, t, n, r) => {
    const i = [];
    t.map(o => {
      _k(o.address) ? i.push({
        address: n,
        name: "getEthBalance",
        params: [e]
      }) : i.push({
        address: o.address,
        name: "balanceOf",
        params: [e]
      })
    });
    const s = await M8e(i, R8e, r, n);
    return s.length ? t.map((o, a) => {
      const c = new Ss(s[a].amount.toString() || "0").shiftedBy(-o.decimals).toFixed();
      return {
        ...o,
        amount: c || "0",
        blockNumber: s[a].blockNumber
      }
    }) : []
  }, M8e = async (e, t, n, r) => (await eq(e, t, n, r)).map(({
    data: s,
    blockNumber: o
  }) => ({
    amount: s || new Ss(0),
    blockNumber: o
  })), $8e = async (e, t) => {
    const n = t[0].chainId,
      r = await J5(n),
      i = t.map(async s => {
        let o = "0",
          a;
        try {
          const c = await L8e(e, s.address, n, r);
          o = new Ss(c.amount.toString()).shiftedBy(-s.decimals).toString(), a = c.blockNumber
        } catch (c) {
          console.warn(c)
        }
        return {
          ...s,
          amount: o,
          blockNumber: a
        }
      });
    return Promise.all(i)
  }, L8e = async (e, t, n, r) => {
    const i = await B8e(n);
    let s;
    return _k(t) ? s = await r.getBalance(e, i) : s = await new K5(t, ["function balanceOf(address owner) view returns (uint256)"], r).balanceOf(e, {
      blockTag: i
    }), {
      amount: s,
      blockNumber: i
    }
  }, B8e = async e => (await J5(e)).getBlockNumber(), F8e = {
    getBalances: O8e
  }, rq = async (e, t) => {
    const n = await iq(e, [t]);
    return n.length ? n[0] : null
  }, iq = async (e, t) => {
    const n = {};
    t.forEach(i => {
      n[i.chainId] || (n[i.chainId] = []), n[i.chainId].push(i)
    });
    const r = await sq(e, n);
    return Object.values(r).flat()
  }, sq = async (e, t) => {
    const n = {},
      r = Object.keys(t).map(async i => {
        const s = parseInt(i),
          o = await F8e.getBalances(e, t[s]);
        n[s] = o
      });
    return await Promise.allSettled(r), n
  }, oq = async (e, t, n = 0) => {
    const r = await rq(await e.getAddress(), t.action.fromToken);
    if (r) {
      const i = new Ss(r.amount).shiftedBy(r.decimals),
        s = new Ss(t.action.fromAmount);
      if (i.lt(s))
        if (n <= 3) await new Promise(o => {
          setTimeout(o, 200)
        }), await oq(e, t, n + 1);
        else if (s.multipliedBy(1 - t.action.slippage).lte(i)) t.action.fromAmount = i.toFixed(0);
      else {
        const o = s.shiftedBy(-r.decimals).toFixed(),
          a = i.shiftedBy(-r.decimals).toFixed();
        let c = `Your ${r.symbol} balance is too low, you try to transfer ${o} ${r.symbol}, but your wallet only holds ${a} ${r.symbol}. No funds have been sent. `;
        throw i.isZero() || (c += `If the problem consists, please delete this transfer and start a new one with a maximum of ${a} ${r.symbol}.`), new ISe("The balance is too low.", c)
      }
    }
  }, j8e = async (e, t) => {
    var n;
    for (let r = 0; r < e.steps.length; r++)((n = e.steps[r].execution) == null ? void 0 : n.status) === "FAILED" && (await U8e(e, r, t), z8e(e, r), H8e(e, r))
  }, U8e = async (e, t, n) => {
    var o, a, c, l;
    const r = (o = e.steps[t].execution) == null ? void 0 : o.process.some(u => {
        var f;
        return ((f = u.error) == null ? void 0 : f.code) === nn.GasLimitError
      }),
      i = (a = e.steps[t].execution) == null ? void 0 : a.process.some(u => {
        var f;
        return ((f = u.error) == null ? void 0 : f.code) === nn.TransactionUnderpriced
      }),
      {
        transactionRequest: s
      } = e.steps[t];
    if (r) {
      if (s) {
        let u = s.gasLimit;
        try {
          u = await n.estimateGas(s)
        } catch {}
        u && (s.gasLimit = st.from(`${BigInt(u.toString())*125n/100n}`))
      }(c = e.steps[t].estimate.gasCosts) == null || c.forEach(u => u.limit = `${Math.round(Number(u.limit)*1.25)}`)
    }
    if (i) {
      if (s) {
        let u = s.gasPrice;
        try {
          u = await n.getGasPrice()
        } catch {}
        u && (s.gasPrice = st.from(`${BigInt(u.toString())*125n/100n}`))
      }(l = e.steps[t].estimate.gasCosts) == null || l.forEach(u => u.price = `${Math.round(Number(u.price)*1.25)}`)
    }
  }, z8e = (e, t) => {
    e.steps[t].execution && (e.steps[t].execution.process = e.steps[t].execution.process.filter(n => n.status === "DONE"))
  }, H8e = (e, t) => {
    e.steps[t].transactionRequest = void 0
  }, V8e = async (e, t, n, r, i) => {
    if (w8e(t, n)) return e.updateStepInRoute(n);
    let s;
    if (i && (s = await r.acceptExchangeRateUpdateHook({
        oldToAmount: t.estimate.toAmount,
        newToAmount: n.estimate.toAmount,
        toToken: n.action.toToken
      })), !s) throw new lc(nn.TransactionCanceled, "Exchange rate has changed!", `Transaction was not sent, your funds are still in your wallet.
      The exchange rate has changed and the previous estimation can not be fulfilled due to value loss.`);
    return e.updateStepInRoute(n)
  }, xA = async (e, t, n, r, i) => {
    if (await e.getChainId() === n.action.fromChainId) return e;
    n.execution = t.initExecutionObject(n), t.updateExecution(n, "ACTION_REQUIRED");
    let s = t.findOrCreateProcess(n, "SWITCH_CHAIN", "ACTION_REQUIRED");
    if (i) try {
      const o = await r(n.action.fromChainId);
      if (await (o == null ? void 0 : o.getChainId()) !== n.action.fromChainId) throw new $3(nn.ChainSwitchError, "Chain switch required.");
      return s = t.updateProcess(n, s.type, "DONE"), t.updateExecution(n, "PENDING"), o
    } catch (o) {
      throw t.updateProcess(n, s.type, "FAILED", {
        error: {
          message: o.message,
          code: nn.ChainSwitchError
        }
      }), t.updateExecution(n, "FAILED"), o
    }
  }, JM = async (e, t, n, r, i) => {
    var c, l;
    const s = dr.getInstance().getConfig();
    if (!((c = s.multisigConfig) != null && c.getMultisigTransactionDetails)) throw new Error('"getMultisigTransactionDetails()" is missing in Multisig config.');
    const o = () => {
        r = n.updateProcess(t, r.type, "PENDING")
      },
      a = await ((l = s.multisigConfig) == null ? void 0 : l.getMultisigTransactionDetails(e, i.id, o));
    if (a.status === "DONE" && (r = n.updateProcess(t, r.type, "PENDING", {
        txHash: a.txHash,
        multisigTxHash: void 0,
        txLink: i.metamask.blockExplorerUrls[0] + "tx/" + a.txHash
      })), a.status === "FAILED") throw new lc(nn.TransactionFailed, "Multisig transaction failed.");
    if (a.status === "CANCELLED") throw new lc(nn.TransactionRejected, "Transaction was rejected by users.")
  };
class W8e {
  constructor() {
    this.allowUserInteraction = !0, this.allowInteraction = t => {
      this.allowUserInteraction = t
    }, this.execute = async ({
      signer: t,
      step: n,
      statusManager: r,
      settings: i
    }) => {
      var v, S, I, A, w, E;
      const s = dr.getInstance().getConfig(),
        o = !!((v = s.multisigConfig) != null && v.isMultisigSigner),
        a = [],
        c = ((S = s.multisigConfig) == null ? void 0 : S.shouldBatchTransactions) && !!s.multisigConfig.sendBatchTransaction;
      n.execution = r.initExecutionObject(n);
      const l = Th.getInstance(),
        u = await l.getChainById(n.action.fromChainId),
        f = await l.getChainById(n.action.toChainId),
        h = u.id !== f.id,
        g = h ? "CROSS_CHAIN" : "SWAP",
        y = n.execution.process.find(D => D.type === g);
      if (!(y != null && y.txHash) && !_k(n.action.fromToken.address) && (c || !o)) {
        const D = await T8e(t, n, r, i, u, this.allowUserInteraction, c);
        if (D) {
          const {
            to: $,
            data: V
          } = D;
          if ($ && V) {
            const G = {
              value: st.from(0).toString(),
              to: $,
              data: V
            };
            a.push(G)
          }
        }
      }
      let k = r.findOrCreateProcess(n, g);
      if (k.status !== "DONE") {
        const D = n.execution.process.find($ => !!$.multisigTxHash);
        try {
          if (o && D) {
            if (!D) throw new Rr("Multisig process is undefined.");
            if (!((I = s.multisigConfig) != null && I.getMultisigTransactionDetails)) throw new Rr('"getMultisigTransactionDetails()" is missing in Multisig config.');
            const V = D.multisigTxHash;
            if (!V) throw new Rr("Multisig internal transaction hash is undefined.");
            await JM(V, n, r, k, u)
          }
          let $;
          if (k.txHash) {
            const V = await xA(t, r, n, i.switchChainHook, this.allowUserInteraction);
            if (!V) return n.execution;
            t = V, $ = await tq(t).getTransaction(k.txHash)
          } else {
            if (k = r.updateProcess(n, k.type, "STARTED"), await oq(t, n), !n.transactionRequest) {
              const L = await USe(t, n),
                b = await ts.getStepTransaction(L);
              n = {
                ...await V8e(r, L, b, i, this.allowUserInteraction),
                execution: n.execution
              }
            }
            const {
              transactionRequest: V
            } = n;
            if (!V) throw new lc(nn.TransactionUnprepared, "Unable to prepare transaction.");
            const G = await xA(t, r, n, i.switchChainHook, this.allowUserInteraction);
            if (!G || (t = G, k = r.updateProcess(n, k.type, "ACTION_REQUIRED"), !this.allowUserInteraction)) return n.execution;
            if (i.updateTransactionRequestHook) {
              const L = await i.updateTransactionRequestHook(V);
              V.gasLimit = L.gasLimit, V.gasPrice = L.gasPrice, V.maxPriorityFeePerGas = L.maxPriorityFeePerGas, V.maxFeePerGas = L.maxFeePerGas
            } else try {
              const L = await t.estimateGas(V);
              L && (V.gasLimit = st.from(`${BigInt(L.toString())*125n/100n}`));
              const b = await t.getGasPrice();
              b && (V.gasPrice = b)
            } catch {}
            if (c && ((A = s.multisigConfig) != null && A.sendBatchTransaction)) {
              const {
                to: L,
                data: b,
                value: T
              } = await t.populateTransaction(V);
              if (L && b) {
                const N = {
                  value: (T == null ? void 0 : T.toString()) ?? st.from(0).toString(),
                  to: L,
                  data: b.toString()
                };
                a.push(N), $ = await ((w = s.multisigConfig) == null ? void 0 : w.sendBatchTransaction(a))
              } else throw new lc(nn.TransactionUnprepared, "Unable to prepare transaction.")
            } else $ = await t.sendTransaction(V);
            o ? k = r.updateProcess(n, k.type, "ACTION_REQUIRED", {
              multisigTxHash: $.hash
            }) : k = r.updateProcess(n, k.type, "PENDING", {
              txHash: $.hash,
              txLink: u.metamask.blockExplorerUrls[0] + "tx/" + $.hash
            })
          }
          await ((E = $.wait) == null ? void 0 : E.call($)), o && k.status === "ACTION_REQUIRED" && $.hash && await JM($.hash, n, r, k, u), o || (k = r.updateProcess(n, k.type, "PENDING", {
            txHash: $.hash,
            txLink: u.metamask.blockExplorerUrls[0] + "tx/" + $.hash
          })), h && (k = r.updateProcess(n, k.type, "DONE"))
        } catch ($) {
          if ($.code === "TRANSACTION_REPLACED" && $.replacement) k = r.updateProcess(n, k.type, "DONE", {
            txHash: $.replacement.hash,
            txLink: u.metamask.blockExplorerUrls[0] + "tx/" + $.replacement.hash
          });
          else {
            const V = await XW($, n, k);
            throw k = r.updateProcess(n, k.type, "FAILED", {
              error: {
                message: V.message,
                htmlMessage: V.htmlMessage,
                code: V.code
              }
            }), r.updateExecution(n, "FAILED"), V
          }
        }
      }
      const _ = k.txHash;
      h && (k = r.findOrCreateProcess(n, "RECEIVING_CHAIN", "PENDING"));
      let p;
      try {
        if (!_) throw new Error("Transaction hash is undefined.");
        p = await y8e(_, r, k.type, n);
        const D = p.receiving;
        k = r.updateProcess(n, k.type, "DONE", {
          substatus: p.substatus,
          substatusMessage: p.substatusMessage || ZW(p.status, p.substatus),
          txHash: D == null ? void 0 : D.txHash,
          txLink: f.metamask.blockExplorerUrls[0] + "tx/" + (D == null ? void 0 : D.txHash)
        }), r.updateExecution(n, "DONE", {
          fromAmount: p.sending.amount,
          toAmount: D == null ? void 0 : D.amount,
          toToken: D == null ? void 0 : D.token,
          gasAmount: p.sending.gasAmount,
          gasAmountUSD: p.sending.gasAmountUSD,
          gasPrice: p.sending.gasPrice,
          gasToken: p.sending.gasToken,
          gasUsed: p.sending.gasUsed
        })
      } catch (D) {
        const $ = await n8e(n, k.txLink);
        throw k = r.updateProcess(n, k.type, "FAILED", {
          error: {
            code: nn.TransactionFailed,
            message: "Failed while waiting for receiving chain.",
            htmlMessage: $
          }
        }), r.updateExecution(n, "FAILED"), console.warn(D), D
      }
      return n.execution
    }
  }
}
const q8e = {
  allowInteraction: !0,
  allowUpdates: !0,
  stopExecution: !1
};
class G8e {
  constructor(t, n) {
    this.allowUserInteraction = !0, this.executionStopped = !1, this.setInteraction = r => {
      const i = {
        ...q8e,
        ...r
      };
      this.allowUserInteraction = i.allowInteraction, this.stepExecutionManager.allowInteraction(i.allowInteraction), this.statusManager.allowUpdates(i.allowUpdates), this.executionStopped = i.stopExecution
    }, this.checkChain = () => {
      throw new Error("checkChain is not implemented.")
    }, this.executeStep = async (r, i) => {
      var a;
      const s = (a = i.execution) == null ? void 0 : a.process.find(c => c.type === "RECEIVING_CHAIN");
      if ((s == null ? void 0 : s.substatus) !== "WAIT_DESTINATION_TRANSACTION" || !s) {
        const c = await xA(r, this.statusManager, i, this.settings.switchChainHook, this.allowUserInteraction);
        if (!c) return i;
        r = c
      }
      const o = {
        signer: r,
        step: i,
        settings: this.settings,
        statusManager: this.statusManager
      };
      return await this.stepExecutionManager.execute(o), i
    }, this.stepExecutionManager = new W8e, this.statusManager = t, this.settings = n
  }
}
class K8e {
  constructor(t) {
    this.executionDictionary = {}, this.executionPromiseDictionary = {}, this.executeRoute = async (n, r, i) => {
      const s = structuredClone(r);
      let o = this.executionPromiseDictionary[s.id];
      return o || (o = this.executeSteps(n, s, i), this.executionPromiseDictionary[s.id] = o, o)
    }, this.resumeRoute = async (n, r, i) => {
      const s = structuredClone(r),
        o = this.executionDictionary[s.id];
      if (o && !o.executors.some(l => l.executionStopped)) return this.updateRouteExecution(r, {
        executeInBackground: i == null ? void 0 : i.executeInBackground
      }), this.executionPromiseDictionary[s.id] ?? s;
      await j8e(s, n);
      const a = this.executeSteps(n, s, i);
      return this.executionPromiseDictionary[s.id] = a, a
    }, this.executeSteps = async (n, r, i) => {
      var c, l, u;
      const s = this.configService.getConfig(),
        o = {
          route: r,
          executors: [],
          settings: {
            ...s.defaultExecutionSettings,
            ...i
          }
        };
      this.executionDictionary[r.id] = o;
      const a = new x8e(r, o.settings, f => {
        this.executionDictionary[f.id] && (o.route = f)
      });
      for (let f = 0; f < r.steps.length; f++) {
        const h = this.executionDictionary[r.id];
        if (!h) break;
        const g = r.steps[f],
          y = r.steps[f - 1];
        if (((c = g.execution) == null ? void 0 : c.status) !== "DONE") {
          (l = y == null ? void 0 : y.execution) != null && l.toAmount && (g.action.fromAmount = y.execution.toAmount);
          try {
            const x = new G8e(a, h.settings);
            if (h.executors.push(x), this.updateRouteExecution(r, h.settings), ((u = (await x.executeStep(n, g)).execution) == null ? void 0 : u.status) !== "DONE" && this.stopExecution(r), x.executionStopped) return r
          } catch (x) {
            throw this.stopExecution(r), x
          }
        }
      }
      return delete this.executionDictionary[r.id], r
    }, this.updateRouteExecution = (n, r) => {
      const i = this.executionDictionary[n.id];
      if (i) {
        for (const s of i.executors) s.setInteraction({
          allowInteraction: !r.executeInBackground,
          allowUpdates: !0
        });
        i.settings = {
          ...i.settings,
          ...r
        }
      }
    }, this.updateExecutionSettings = (n, r) => {
      const i = this.executionDictionary[r.id];
      if (!i) throw new Rr("Can't set ExecutionSettings for the inactive route.");
      const s = this.configService.getConfig();
      i.settings = {
        ...s.defaultExecutionSettings,
        ...n
      }
    }, this.moveExecutionToBackground = n => {
      const r = this.executionDictionary[n.id];
      if (r) {
        for (const i of r.executors) i.setInteraction({
          allowInteraction: !1,
          allowUpdates: !0
        });
        r.settings = {
          ...r.settings,
          executeInBackground: !0
        }
      }
    }, this.stopExecution = n => {
      const r = this.executionDictionary[n.id];
      if (!r) return n;
      for (const i of r.executors) i.setInteraction({
        allowInteraction: !1,
        allowUpdates: !1,
        stopExecution: !0
      });
      return delete this.executionDictionary[n.id], n
    }, this.getActiveRoutes = () => Object.values(this.executionDictionary).map(n => n == null ? void 0 : n.route).filter(Boolean), this.getActiveRoute = n => {
      var r;
      return (r = this.executionDictionary[n.id]) == null ? void 0 : r.route
    }, this.configService = dr.getInstance(), t && this.configService.updateConfig(t)
  }
}
class Q8e extends K8e {
  constructor(t) {
    super(t), this.getConfig = () => this.configService.getConfig(), this.getConfigAsync = () => this.configService.getConfigAsync(), this.getRpcProvider = (n, r = !1) => J5(n, r), this.setConfig = n => this.configService.updateConfig(n), this.getPossibilities = async (n, r) => ts.getPossibilities(n, r), this.getToken = async (n, r, i) => ts.getToken(n, r, i), this.getQuote = async (n, r) => ts.getQuote(n, r), this.getContractCallQuote = async (n, r) => ts.getContractCallQuote(n, r), this.getContractCallsQuote = async (n, r) => ts.getContractCallsQuote(n, r), this.getStatus = async (n, r) => ts.getStatus(n, r), this.getTools = async (n, r) => ts.getTools(n || {}, r), this.getTokens = async (n, r) => ts.getTokens(n || {}, r), this.getChains = async () => this.chainsService.getChains(), this.getRoutes = async (n, r) => ts.getRoutes(n, r), this.getStepTransaction = async (n, r) => ts.getStepTransaction(n, r), this.getGasRecommendation = async (n, r) => ts.getGasRecommendation(n, r), this.getTokenBalance = async (n, r) => {
      if (!n) throw new Rr("Missing walletAddress.");
      if (!C1(r)) throw new Rr(`Invalid token passed: address "${r.address}" on chainId "${r.chainId}"`);
      return rq(n, r)
    }, this.getTokenBalances = async (n, r) => {
      if (!n) throw new Rr("Missing walletAddress.");
      const i = r.filter(s => !C1(s));
      if (i.length) throw new Rr(`Invalid token passed: address "${i[0].address}" on chainId "${i[0].chainId}"`);
      return iq(n, r)
    }, this.getTokenBalancesForChains = async (n, r) => {
      if (!n) throw new Rr("Missing walletAddress.");
      const s = Object.values(r).flat().filter(o => !C1(o));
      if (s.length) throw new Rr(`Invalid token passed: address "${s[0].address}" on chainId "${s[0].chainId}"`);
      return sq(n, r)
    }, this.getTokenApproval = async (n, r, i) => k8e(n, r, i), this.bulkGetTokenApproval = async (n, r) => _8e(n, r), this.approveToken = n => I8e(n), this.revokeTokenApproval = n => P8e(n), this.getConnections = async n => await ts.getAvailableConnections(n), this.getTransactionHistory = async n => await ts.getTransactionHistory(n), this.chainsService = Th.getInstance(), this.chainsService.getChains().then(n => {
      this.configService.updateChains(n)
    }), UW(jW, L3, t.disableVersionCheck)
  }
}
const vo = () => {
    const {
      chains: e
    } = Wt(), t = ku(), {
      data: n,
      isLoading: r
    } = wl(["chains"], async () => t.getChains(), {
      refetchInterval: 3e5,
      staleTime: 3e5
    }), i = j.useMemo(() => n == null ? void 0 : n.filter(a => Np(a.id, e)), [n, e]), s = j.useCallback(o => n == null ? void 0 : n.find(c => c.id === o), [n]);
    return {
      chains: i,
      getChainById: s,
      isLoading: r
    }
  },
  _m = e => {
    const {
      chains: t,
      isLoading: n
    } = vo();
    return {
      chain: j.useMemo(() => t == null ? void 0 : t.find(s => s.id === e), [e, t]),
      isLoading: n
    }
  },
  j3 = (e, t) => e === "light" ? `rgb(0 0 0 / ${t})` : `rgb(255 255 255 / ${t})`,
  XM = e => e && typeof e == "object",
  aq = (...e) => e.reduce((t, n) => {
    for (const r in n) XM(t[r]) && XM(n[r]) ? t[r] = aq(t[r], n[r]) : t[r] = n[r];
    return t
  }, {});
var pc;
(function (e) {
  e.AppExpandedContainer = "widget-app-expanded-container", e.Header = "widget-header", e.RelativeContainer = "widget-relative-container", e.ScrollableContainer = "widget-scrollable-container"
})(pc || (pc = {}));
const dh = (e, t) => t ? `${e}-${t}` : e,
  ha = (e, t) => (e & t) === t;
var Y8e = 20,
  J8e = 1,
  fh = 1e6,
  ZM = 1e6,
  X8e = -7,
  Z8e = 21,
  eCe = !1,
  ay = "[big.js] ",
  kh = ay + "Invalid ",
  e6 = kh + "decimal places",
  tCe = kh + "rounding mode",
  cq = ay + "Division by zero",
  Gn = {},
  ll = void 0,
  nCe = /^-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;

function lq() {
  function e(t) {
    var n = this;
    if (!(n instanceof e)) return t === ll ? lq() : new e(t);
    if (t instanceof e) n.s = t.s, n.e = t.e, n.c = t.c.slice();
    else {
      if (typeof t != "string") {
        if (e.strict === !0 && typeof t != "bigint") throw TypeError(kh + "value");
        t = t === 0 && 1 / t < 0 ? "-0" : String(t)
      }
      rCe(n, t)
    }
    n.constructor = e
  }
  return e.prototype = Gn, e.DP = Y8e, e.RM = J8e, e.NE = X8e, e.PE = Z8e, e.strict = eCe, e.roundDown = 0, e.roundHalfUp = 1, e.roundHalfEven = 2, e.roundUp = 3, e
}

function rCe(e, t) {
  var n, r, i;
  if (!nCe.test(t)) throw Error(kh + "number");
  for (e.s = t.charAt(0) == "-" ? (t = t.slice(1), -1) : 1, (n = t.indexOf(".")) > -1 && (t = t.replace(".", "")), (r = t.search(/e/i)) > 0 ? (n < 0 && (n = r), n += +t.slice(r + 1), t = t.substring(0, r)) : n < 0 && (n = t.length), i = t.length, r = 0; r < i && t.charAt(r) == "0";) ++r;
  if (r == i) e.c = [e.e = 0];
  else {
    for (; i > 0 && t.charAt(--i) == "0";);
    for (e.e = n - r - 1, e.c = [], n = 0; r <= i;) e.c[n++] = +t.charAt(r++)
  }
  return e
}

function _h(e, t, n, r) {
  var i = e.c;
  if (n === ll && (n = e.constructor.RM), n !== 0 && n !== 1 && n !== 2 && n !== 3) throw Error(tCe);
  if (t < 1) r = n === 3 && (r || !!i[0]) || t === 0 && (n === 1 && i[0] >= 5 || n === 2 && (i[0] > 5 || i[0] === 5 && (r || i[1] !== ll))), i.length = 1, r ? (e.e = e.e - t + 1, i[0] = 1) : i[0] = e.e = 0;
  else if (t < i.length) {
    if (r = n === 1 && i[t] >= 5 || n === 2 && (i[t] > 5 || i[t] === 5 && (r || i[t + 1] !== ll || i[t - 1] & 1)) || n === 3 && (r || !!i[0]), i.length = t, r) {
      for (; ++i[--t] > 9;)
        if (i[t] = 0, t === 0) {
          ++e.e, i.unshift(1);
          break
        }
    }
    for (t = i.length; !i[--t];) i.pop()
  }
  return e
}

function Im(e, t, n) {
  var r = e.e,
    i = e.c.join(""),
    s = i.length;
  if (t) i = i.charAt(0) + (s > 1 ? "." + i.slice(1) : "") + (r < 0 ? "e" : "e+") + r;
  else if (r < 0) {
    for (; ++r;) i = "0" + i;
    i = "0." + i
  } else if (r > 0)
    if (++r > s)
      for (r -= s; r--;) i += "0";
    else r < s && (i = i.slice(0, r) + "." + i.slice(r));
  else s > 1 && (i = i.charAt(0) + "." + i.slice(1));
  return e.s < 0 && n ? "-" + i : i
}
Gn.abs = function () {
  var e = new this.constructor(this);
  return e.s = 1, e
};
Gn.cmp = function (e) {
  var t, n = this,
    r = n.c,
    i = (e = new n.constructor(e)).c,
    s = n.s,
    o = e.s,
    a = n.e,
    c = e.e;
  if (!r[0] || !i[0]) return r[0] ? s : i[0] ? -o : 0;
  if (s != o) return s;
  if (t = s < 0, a != c) return a > c ^ t ? 1 : -1;
  for (o = (a = r.length) < (c = i.length) ? a : c, s = -1; ++s < o;)
    if (r[s] != i[s]) return r[s] > i[s] ^ t ? 1 : -1;
  return a == c ? 0 : a > c ^ t ? 1 : -1
};
Gn.div = function (e) {
  var t = this,
    n = t.constructor,
    r = t.c,
    i = (e = new n(e)).c,
    s = t.s == e.s ? 1 : -1,
    o = n.DP;
  if (o !== ~~o || o < 0 || o > fh) throw Error(e6);
  if (!i[0]) throw Error(cq);
  if (!r[0]) return e.s = s, e.c = [e.e = 0], e;
  var a, c, l, u, f, h = i.slice(),
    g = a = i.length,
    y = r.length,
    x = r.slice(0, a),
    k = x.length,
    _ = e,
    p = _.c = [],
    v = 0,
    S = o + (_.e = t.e - e.e) + 1;
  for (_.s = s, s = S < 0 ? 0 : S, h.unshift(0); k++ < a;) x.push(0);
  do {
    for (l = 0; l < 10; l++) {
      if (a != (k = x.length)) u = a > k ? 1 : -1;
      else
        for (f = -1, u = 0; ++f < a;)
          if (i[f] != x[f]) {
            u = i[f] > x[f] ? 1 : -1;
            break
          } if (u < 0) {
        for (c = k == a ? i : h; k;) {
          if (x[--k] < c[k]) {
            for (f = k; f && !x[--f];) x[f] = 9;
            --x[f], x[k] += 10
          }
          x[k] -= c[k]
        }
        for (; !x[0];) x.shift()
      } else break
    }
    p[v++] = u ? l : ++l, x[0] && u ? x[k] = r[g] || 0 : x = [r[g]]
  } while ((g++ < y || x[0] !== ll) && s--);
  return !p[0] && v != 1 && (p.shift(), _.e--, S--), v > S && _h(_, S, n.RM, x[0] !== ll), _
};
Gn.eq = function (e) {
  return this.cmp(e) === 0
};
Gn.gt = function (e) {
  return this.cmp(e) > 0
};
Gn.gte = function (e) {
  return this.cmp(e) > -1
};
Gn.lt = function (e) {
  return this.cmp(e) < 0
};
Gn.lte = function (e) {
  return this.cmp(e) < 1
};
Gn.minus = Gn.sub = function (e) {
  var t, n, r, i, s = this,
    o = s.constructor,
    a = s.s,
    c = (e = new o(e)).s;
  if (a != c) return e.s = -c, s.plus(e);
  var l = s.c.slice(),
    u = s.e,
    f = e.c,
    h = e.e;
  if (!l[0] || !f[0]) return f[0] ? e.s = -c : l[0] ? e = new o(s) : e.s = 1, e;
  if (a = u - h) {
    for ((i = a < 0) ? (a = -a, r = l) : (h = u, r = f), r.reverse(), c = a; c--;) r.push(0);
    r.reverse()
  } else
    for (n = ((i = l.length < f.length) ? l : f).length, a = c = 0; c < n; c++)
      if (l[c] != f[c]) {
        i = l[c] < f[c];
        break
      } if (i && (r = l, l = f, f = r, e.s = -e.s), (c = (n = f.length) - (t = l.length)) > 0)
    for (; c--;) l[t++] = 0;
  for (c = t; n > a;) {
    if (l[--n] < f[n]) {
      for (t = n; t && !l[--t];) l[t] = 9;
      --l[t], l[n] += 10
    }
    l[n] -= f[n]
  }
  for (; l[--c] === 0;) l.pop();
  for (; l[0] === 0;) l.shift(), --h;
  return l[0] || (e.s = 1, l = [h = 0]), e.c = l, e.e = h, e
};
Gn.mod = function (e) {
  var t, n = this,
    r = n.constructor,
    i = n.s,
    s = (e = new r(e)).s;
  if (!e.c[0]) throw Error(cq);
  return n.s = e.s = 1, t = e.cmp(n) == 1, n.s = i, e.s = s, t ? new r(n) : (i = r.DP, s = r.RM, r.DP = r.RM = 0, n = n.div(e), r.DP = i, r.RM = s, this.minus(n.times(e)))
};
Gn.neg = function () {
  var e = new this.constructor(this);
  return e.s = -e.s, e
};
Gn.plus = Gn.add = function (e) {
  var t, n, r, i = this,
    s = i.constructor;
  if (e = new s(e), i.s != e.s) return e.s = -e.s, i.minus(e);
  var o = i.e,
    a = i.c,
    c = e.e,
    l = e.c;
  if (!a[0] || !l[0]) return l[0] || (a[0] ? e = new s(i) : e.s = i.s), e;
  if (a = a.slice(), t = o - c) {
    for (t > 0 ? (c = o, r = l) : (t = -t, r = a), r.reverse(); t--;) r.push(0);
    r.reverse()
  }
  for (a.length - l.length < 0 && (r = l, l = a, a = r), t = l.length, n = 0; t; a[t] %= 10) n = (a[--t] = a[t] + l[t] + n) / 10 | 0;
  for (n && (a.unshift(n), ++c), t = a.length; a[--t] === 0;) a.pop();
  return e.c = a, e.e = c, e
};
Gn.pow = function (e) {
  var t = this,
    n = new t.constructor("1"),
    r = n,
    i = e < 0;
  if (e !== ~~e || e < -ZM || e > ZM) throw Error(kh + "exponent");
  for (i && (e = -e); e & 1 && (r = r.times(t)), e >>= 1, !!e;) t = t.times(t);
  return i ? n.div(r) : r
};
Gn.prec = function (e, t) {
  if (e !== ~~e || e < 1 || e > fh) throw Error(kh + "precision");
  return _h(new this.constructor(this), e, t)
};
Gn.round = function (e, t) {
  if (e === ll) e = 0;
  else if (e !== ~~e || e < -fh || e > fh) throw Error(e6);
  return _h(new this.constructor(this), e + this.e + 1, t)
};
Gn.sqrt = function () {
  var e, t, n, r = this,
    i = r.constructor,
    s = r.s,
    o = r.e,
    a = new i("0.5");
  if (!r.c[0]) return new i(r);
  if (s < 0) throw Error(ay + "No square root");
  s = Math.sqrt(r + ""), s === 0 || s === 1 / 0 ? (t = r.c.join(""), t.length + o & 1 || (t += "0"), s = Math.sqrt(t), o = ((o + 1) / 2 | 0) - (o < 0 || o & 1), e = new i((s == 1 / 0 ? "5e" : (s = s.toExponential()).slice(0, s.indexOf("e") + 1)) + o)) : e = new i(s + ""), o = e.e + (i.DP += 4);
  do n = e, e = a.times(n.plus(r.div(n))); while (n.c.slice(0, o).join("") !== e.c.slice(0, o).join(""));
  return _h(e, (i.DP -= 4) + e.e + 1, i.RM)
};
Gn.times = Gn.mul = function (e) {
  var t, n = this,
    r = n.constructor,
    i = n.c,
    s = (e = new r(e)).c,
    o = i.length,
    a = s.length,
    c = n.e,
    l = e.e;
  if (e.s = n.s == e.s ? 1 : -1, !i[0] || !s[0]) return e.c = [e.e = 0], e;
  for (e.e = c + l, o < a && (t = i, i = s, s = t, l = o, o = a, a = l), t = new Array(l = o + a); l--;) t[l] = 0;
  for (c = a; c--;) {
    for (a = 0, l = o + c; l > c;) a = t[l] + s[c] * i[l - c - 1] + a, t[l--] = a % 10, a = a / 10 | 0;
    t[l] = a
  }
  for (a ? ++e.e : t.shift(), c = t.length; !t[--c];) t.pop();
  return e.c = t, e
};
Gn.toExponential = function (e, t) {
  var n = this,
    r = n.c[0];
  if (e !== ll) {
    if (e !== ~~e || e < 0 || e > fh) throw Error(e6);
    for (n = _h(new n.constructor(n), ++e, t); n.c.length < e;) n.c.push(0)
  }
  return Im(n, !0, !!r)
};
Gn.toFixed = function (e, t) {
  var n = this,
    r = n.c[0];
  if (e !== ll) {
    if (e !== ~~e || e < 0 || e > fh) throw Error(e6);
    for (n = _h(new n.constructor(n), e + n.e + 1, t), e = e + n.e + 1; n.c.length < e;) n.c.push(0)
  }
  return Im(n, !1, !!r)
};
Gn[Symbol.for("nodejs.util.inspect.custom")] = Gn.toJSON = Gn.toString = function () {
  var e = this,
    t = e.constructor;
  return Im(e, e.e <= t.NE || e.e >= t.PE, !!e.c[0])
};
Gn.toNumber = function () {
  var e = Number(Im(this, !0, !0));
  if (this.constructor.strict === !0 && !this.eq(e.toString())) throw Error(ay + "Imprecise conversion");
  return e
};
Gn.toPrecision = function (e, t) {
  var n = this,
    r = n.constructor,
    i = n.c[0];
  if (e !== ll) {
    if (e !== ~~e || e < 1 || e > fh) throw Error(kh + "precision");
    for (n = _h(new r(n), e, t); n.c.length < e;) n.c.push(0)
  }
  return Im(n, e <= n.e || n.e <= r.NE || n.e >= r.PE, !!i)
};
Gn.valueOf = function () {
  var e = this,
    t = e.constructor;
  if (t.strict === !0) throw Error(ay + "valueOf disallowed");
  return Im(e, e.e <= t.NE || e.e >= t.PE, !0)
};
var Dn = lq();
Dn.PE = 42;
Dn.NE = -42;
const Ei = (e = "0", t = 0, n = 3) => {
    let r = e;
    t && (r = (Number(e) / 10 ** t).toString());
    const i = parseFloat(r);
    if (i === 0 || isNaN(Number(r))) return "0";
    const s = Math.abs(i);
    for (; s < 1 / 10 ** n;) n++;
    return i.toFixed(n + 1)
  },
  e$ = (e = "", t = "", n = !1) => {
    if (!e) return e;
    const r = parseFloat(e);
    return isNaN(Number(e)) && !isNaN(r) ? r.toString() : isNaN(r) ? t : r > 100 ? "100" : r < 0 ? Math.abs(r).toString() : n ? e : r.toString()
  },
  EA = (e, t = null, n = !1) => {
    if (!e) return e;
    let r = e.replaceAll(",", ".");
    r.startsWith(".") && (r = "0" + r);
    const i = parseFloat(r);
    if (isNaN(Number(r)) && !isNaN(i)) return i.toString();
    if (isNaN(Math.abs(Number(r)))) return "";
    if (n) return r;
    let [s, o = ""] = r.split(".");
    return t !== null && o.length > t && (o = o.slice(0, t)), s = s.replace(/^0+|-/, ""), o = o.replace(/(0+)$/, ""), `${s||(o?"0":"")}${o?`.${o}`:""}`
  },
  Rk = (e, t) => !e || !t || isNaN(Number(e)) || isNaN(Number(t)) ? 0 : parseFloat(e) * parseFloat(t),
  iCe = (e, t, n) => {
    if (!n) return;
    let r = e,
      i = t,
      s = t,
      o = 0;
    for (; i <= r;) {
      o = r + i >> 1;
      const c = `${o+1}px`;
      n.style.fontSize = c, n.scrollWidth - 1 <= n.clientWidth ? (s = o, i = o + 1) : r = o - 1
    }
    const a = `${s}px`;
    n.style.fontSize = a
  },
  Je = {
    home: "/",
    activeTransactions: "active-transactions",
    bridges: "bridges",
    exchanges: "exchanges",
    fromChain: "from-chain",
    fromToken: "from-token",
    routes: "routes",
    selectWallet: "wallet",
    settings: "settings",
    toChain: "to-chain",
    toToken: "to-token",
    toTokenNative: "to-token-native",
    transactionDetails: "transaction-details",
    transactionExecution: "transaction-execution",
    transactionHistory: "transaction-history"
  },
  sCe = Object.values(Je),
  oCe = [Je.activeTransactions, Je.bridges, Je.exchanges, Je.fromChain, Je.home, Je.routes, Je.selectWallet, Je.settings, Je.toChain, Je.toTokenNative, Je.transactionDetails, Je.transactionExecution, Je.transactionHistory],
  aCe = [Je.activeTransactions, Je.bridges, Je.exchanges, Je.fromChain, Je.fromToken, Je.routes, Je.selectWallet, Je.settings, Je.toChain, Je.toToken, Je.toTokenNative, Je.transactionDetails, Je.transactionExecution, Je.transactionHistory],
  pp = e => e ? `${e.substring(0,5)}...${e.substring(e.length-4)}` : null,
  cy = () => {
    const {
      elementId: e
    } = Wt();
    return e
  },
  Ok = e => document.getElementById(dh(pc.ScrollableContainer, e)),
  uq = () => {
    const e = cy();
    return j.useCallback(() => Ok(e), [e])
  },
  cCe = () => {
    const e = cy();
    j.useLayoutEffect(() => {
      const t = Ok(e);
      return t && (t.style.overflowY = "hidden"), () => {
        t && (t.style.overflowY = "auto")
      }
    }, [e])
  },
  lCe = e => {
    const t = document.getElementById(dh(pc.ScrollableContainer, e)),
      n = document.getElementById(dh(pc.Header, e));
    if (!t || !n) return console.warn(`Can't find ${pc.ScrollableContainer} or ${pc.Header} id.`), 0;
    const {
      height: r
    } = t.getBoundingClientRect(), {
      height: i
    } = n.getBoundingClientRect();
    return r - i
  },
  uCe = () => {
    const e = cy(),
      [t, n] = j.useState(0);
    return j.useLayoutEffect(() => {
      n(lCe(e))
    }, []), t
  },
  dq = e => {
    const t = cy();
    j.useLayoutEffect(() => {
      var r;
      const n = Ok(t);
      if (!(!n || !e.current || ((r = e.current) == null ? void 0 : r.clientHeight) <= (n == null ? void 0 : n.clientHeight))) return n.style.height = `${e.current.clientHeight}px`, () => {
        n.style.removeProperty("height")
      }
    }, [t, e])
  },
  fq = (e, t) => {
    const n = ds({
        name: e
      }),
      [r, i] = j.useState(n),
      s = j.useRef(),
      o = j.useRef(!1);
    return j.useEffect(() => {
      if (o.current) {
        if (Array.isArray(n) ? n.some(c => c) : !!n) {
          const c = setTimeout(() => {
            i(n)
          }, t);
          return () => clearTimeout(c)
        }
        s.current = n, i(n);
        return
      }
      o.current = !0
    }, [t, n]), r
  },
  dCe = 852,
  hq = () => {
    const {
      variant: e,
      useRecommendedRoute: t
    } = Wt(), n = x5(r => r.breakpoints.up(dCe));
    return e === "expandable" && n && !t
  },
  pq = e => {
    const {
      tokens: t
    } = Wt();
    return j.useMemo(() => {
      var n;
      return (n = t == null ? void 0 : t.featured) == null ? void 0 : n.filter(r => r.chainId === e)
    }, [e, t == null ? void 0 : t.featured])
  },
  Dk = e => {
    const t = ku(),
      n = j.useCallback(async (r, i, s = 0) => {
        try {
          const o = k3(r) ? r : await (e == null ? void 0 : e.resolveName(r)),
            a = await t.getTokenBalances(o, i);
          if (!a.every(c => c.blockNumber)) {
            if (s > 10) {
              console.warn("Token balance backoff depth exceeded.");
              return
            }
            return await new Promise(c => {
              setTimeout(c, 1.5 ** s * 100)
            }), n(r, i, s + 1)
          }
          return a
        } catch {}
      }, [t, e]);
    return n
  },
  mq = e => {
    const t = ku(),
      {
        data: n,
        isLoading: r
      } = wl(["tokens"], () => t.getTokens(), {
        refetchInterval: 36e5
      }),
      {
        getChainById: i,
        isLoading: s
      } = vo(),
      o = pq(e),
      {
        tokens: a,
        chains: c
      } = Wt();
    return {
      tokens: j.useMemo(() => {
        var _, p, v;
        if (s) return [];
        if (!(e && i(e) && Np(e, c))) return [];
        let f = n == null ? void 0 : n.tokens[e];
        const h = (_ = a == null ? void 0 : a.include) == null ? void 0 : _.filter(S => S.chainId === e);
        h != null && h.length && (f = f ? [...h, ...f] : h);
        const g = (p = a == null ? void 0 : a.allow) == null ? void 0 : p.filter(S => S.chainId === e).map(S => S.address);
        g != null && g.length && (f = f == null ? void 0 : f.filter(S => g.includes(S.address)));
        const y = (v = a == null ? void 0 : a.deny) == null ? void 0 : v.filter(S => S.chainId === e).map(S => S.address);
        y != null && y.length && (f = f == null ? void 0 : f.filter(S => !y.includes(S.address)));
        const x = new Set(o == null ? void 0 : o.map(S => S.address));
        return [...(o == null ? void 0 : o.map(S => (S.featured = !0, S))) ?? [], ...(f == null ? void 0 : f.filter(S => !x.has(S.address))) ?? []]
      }, [c, a == null ? void 0 : a.allow, a == null ? void 0 : a.deny, a == null ? void 0 : a.include, n == null ? void 0 : n.tokens, n, o, i, s, e]),
      isLoading: r
    }
  },
  t$ = 32e3,
  gq = e => {
    const t = ku(),
      {
        account: n
      } = Ri(),
      r = pq(e),
      {
        tokens: i,
        isLoading: s
      } = mq(e),
      o = !!n.address && !!(i != null && i.length) && !!e,
      {
        data: a,
        isLoading: c,
        refetch: l
      } = wl(["token-balances", n.address, e, i == null ? void 0 : i.length], async ({
        queryKey: [, u]
      }) => {
        const f = await t.getTokenBalances(u, i),
          h = new Set(r == null ? void 0 : r.map(k => k.address)),
          g = (k, _) => parseFloat(_.amount ?? "0") * parseFloat(_.priceUSD ?? "0") - parseFloat(k.amount ?? "0") * parseFloat(k.priceUSD ?? "0"),
          y = f.length === 0 ? i : f;
        return [...y.filter(k => k.amount !== "0" && h.has(k.address)).sort(g), ...y.filter(k => k.amount === "0" && h.has(k.address)), ...y.filter(k => k.amount !== "0" && !h.has(k.address)).sort(g), ...y.filter(k => k.amount === "0" && !h.has(k.address))]
      }, {
        enabled: o,
        refetchInterval: t$,
        staleTime: t$
      });
    return {
      tokens: i,
      tokensWithBalance: a,
      featuredTokens: r,
      isLoading: s,
      isBalanceLoading: c && o,
      refetch: l
    }
  },
  Nk = (e, t) => {
    const {
      tokens: n,
      tokensWithBalance: r,
      isBalanceLoading: i,
      refetch: s
    } = gq(e);
    return {
      token: j.useMemo(() => {
        var a;
        if (t && e) return (a = r ?? n) == null ? void 0 : a.find(l => l.address === t && l.chainId === e)
      }, [e, t, n, r]),
      isLoading: i,
      refetch: s
    }
  },
  VS = 3e4,
  yq = e => {
    var h;
    const {
      account: t
    } = Ri(), n = Dk((h = t.signer) == null ? void 0 : h.provider), [r, i, s] = ds({
      name: [Qe.FromChain, Qe.FromToken, Qe.FromAmount]
    });
    let o = r,
      a = i;
    e && (o = e.fromToken.chainId, a = e.fromToken.address);
    const {
      token: c,
      isLoading: l
    } = Nk(o, a), {
      data: u,
      isInitialLoading: f
    } = wl(["from-token-sufficiency-check", t.address, o, a, (e == null ? void 0 : e.id) ?? s], async () => {
      var _, p;
      if (!t.address || !c) return;
      let g = Dn((c == null ? void 0 : c.amount) || 0);
      if (!e || p2(e)) return g.lt(Dn(s || 0));
      const y = (_ = e.steps.filter(v => !v.execution || v.execution.status !== "DONE")[0]) == null ? void 0 : _.action;
      if (c.chainId === y.fromToken.chainId && c.address === y.fromToken.address && g.gt(0)) return Dn(e.fromAmount).div(10 ** e.fromToken.decimals).gt(g);
      const x = await n(t.address, [y.fromToken]);
      return g = Dn(((p = x == null ? void 0 : x[0]) == null ? void 0 : p.amount) || 0), Dn(y.fromAmount).div(10 ** y.fromToken.decimals).gt(g)
    }, {
      enabled: !!(t.address && c && !l),
      refetchInterval: VS,
      staleTime: VS,
      cacheTime: VS,
      keepPreviousData: !0
    });
    return {
      insufficientFromToken: u,
      isInitialLoading: f
    }
  },
  WS = 6e4,
  vq = (e, t, n) => {
    const r = ku(),
      {
        chains: i
      } = vo();
    return wl(["gas-recommendation", e, t, n], async ({
      queryKey: [s, o, a, c]
    }) => i != null && i.some(u => u.id === o) ? await r.getGasRecommendation({
      chainId: o,
      fromChain: a,
      fromToken: c
    }) : null, {
      enabled: !!e,
      refetchInterval: WS,
      staleTime: WS,
      cacheTime: WS
    })
  },
  Ab = 3e4,
  bq = (e, t) => {
    var h;
    const {
      account: n
    } = Ri(), r = bm(), i = t || n.address, s = Dk((h = n.signer) == null ? void 0 : h.provider), o = j.useMemo(() => ["token-balance", i, e == null ? void 0 : e.chainId, e == null ? void 0 : e.address], [e == null ? void 0 : e.address, e == null ? void 0 : e.chainId, i]), {
      data: a,
      isLoading: c,
      refetch: l
    } = wl(o, async ({
      queryKey: [, g]
    }) => {
      var p;
      const y = (p = r.getQueryData(["token-balances", g, e.chainId])) == null ? void 0 : p.find(v => v.address === e.address);
      if (y) return y;
      const x = await s(g, [e]);
      if (!(x != null && x.length)) throw Error("Could not get tokens balance.");
      const k = r.getQueryData(o),
        _ = x[0].amount;
      return (k == null ? void 0 : k.amount) !== _ && r.setQueryDefaults(o, {
        refetchInterval: Ab,
        staleTime: Ab
      }), r.setQueriesData(["token-balances", g, e.chainId], v => {
        if (v) {
          const S = [...v],
            I = S.findIndex(A => A.address === e.address);
          return S[I] = {
            ...S[I],
            amount: _
          }, S
        }
      }), {
        ...x[0],
        amount: _
      }
    }, {
      enabled: !!(i && e),
      refetchInterval: Ab,
      staleTime: Ab
    }), u = () => {
      r.refetchQueries(["token-balances", t, e == null ? void 0 : e.chainId], {
        exact: !1
      })
    }, f = j.useCallback(() => {
      r.setQueryDefaults(o, {
        refetchInterval: 250,
        staleTime: 250
      })
    }, [r, o]);
    return {
      token: a,
      isLoading: c,
      refetch: l,
      refetchNewBalance: f,
      refetchAllBalances: u,
      getTokenBalancesWithRetry: s
    }
  },
  Mk = () => {
    const {
      getChainById: e
    } = vo(), [t, n, r, i] = ds({
      name: [Qe.FromChain, Qe.FromToken, Qe.ToChain, Qe.ToAddress]
    }), s = e(r), {
      token: o
    } = bq(r && (s == null ? void 0 : s.nativeToken), i), {
      data: a,
      isLoading: c
    } = vq(r, t, n);
    return {
      enabled: j.useMemo(() => {
        if (t === r || !(a != null && a.available) || !o) return !1;
        const u = Dn(o.amount ?? 0),
          f = Dn(a.recommended.amount).div(10 ** a.recommended.token.decimals).div(2);
        return u.lt(f)
      }, [t, a, o, r]),
      availble: a == null ? void 0 : a.available,
      isLoading: c,
      chain: s,
      fromAmount: a != null && a.available ? a.fromAmount : void 0
    }
  },
  qS = 3e4,
  wq = e => {
    var g, y;
    const {
      account: t
    } = Ri(), {
      getChainById: n
    } = vo(), r = Dk((g = t.signer) == null ? void 0 : g.provider), {
      sdkConfig: i
    } = Wt(), s = (y = i == null ? void 0 : i.multisigConfig) == null ? void 0 : y.isMultisigSigner, {
      enabledAutoRefuel: o
    } = kc(["enabledAutoRefuel"]), {
      enabled: a,
      isLoading: c
    } = Mk(), l = a && o, {
      data: u,
      isInitialLoading: f
    } = wl(["gas-sufficiency-check", t.address, e == null ? void 0 : e.id], async () => {
      var p;
      if (!t.address || !e) return;
      const x = e.steps.filter(v => !v.execution || v.execution.status !== "DONE").reduce((v, S) => {
        var A, w, E;
        if (S.estimate.gasCosts && !s) {
          const {
            token: D
          } = S.estimate.gasCosts[0], $ = S.estimate.gasCosts.reduce((V, G) => V.plus(Dn(G.amount || 0)), Dn(0)).div(10 ** D.decimals);
          v[D.chainId] = {
            gasAmount: ((A = v[D.chainId]) == null ? void 0 : A.gasAmount.plus($)) ?? $,
            token: D
          }
        }
        const I = (w = S.estimate.feeCosts) == null ? void 0 : w.filter(D => !D.included);
        if (I != null && I.length) {
          const {
            token: D
          } = I[0], $ = I.reduce((V, G) => V.plus(Dn(G.amount || 0)), Dn(0)).div(10 ** D.decimals);
          v[D.chainId] = {
            gasAmount: ((E = v[D.chainId]) == null ? void 0 : E.gasAmount.plus($)) ?? $,
            token: D
          }
        }
        return v
      }, {});
      e.fromToken.address === ((p = x[e.fromChainId]) == null ? void 0 : p.token.address) && (x[e.fromChainId].tokenAmount = x[e.fromChainId].gasAmount.plus(Dn(e.fromAmount).div(10 ** e.fromToken.decimals)));
      const k = await r(t.address, Object.values(x).map(v => v.token));
      return k != null && k.length ? ([e.fromChainId, e.toChainId].forEach(v => {
        var S, I;
        if (x[v]) {
          const A = Dn(((S = k == null ? void 0 : k.find(D => D.chainId === x[v].token.chainId && D.address === x[v].token.address)) == null ? void 0 : S.amount) ?? 0),
            w = A.lte(0) || A.lt(x[v].gasAmount ?? Dn(0)) || A.lt(x[v].tokenAmount ?? Dn(0)),
            E = w ? ((I = x[v].tokenAmount) == null ? void 0 : I.minus(A)) ?? x[v].gasAmount.minus(A) : void 0;
          x[v] = {
            ...x[v],
            insufficient: w,
            insufficientAmount: E == null ? void 0 : E.round(5, Dn.roundUp),
            chain: w ? n(v) : void 0
          }
        }
      }), Object.values(x).filter(v => v.insufficient)) : void 0
    }, {
      enabled: !!(t.address && e),
      refetchInterval: qS,
      staleTime: qS,
      cacheTime: qS
    });
    return {
      insufficientGas: !!(u != null && u.length) && !c && !l ? u : void 0,
      isInitialLoading: f
    }
  },
  fCe = "@lifi/widget",
  $k = "2.10.1",
  Lk = () => {
    const e = ku(),
      {
        bridges: t,
        exchanges: n
      } = Wt(),
      {
        data: r
      } = wl(["tools"], async () => {
        const i = await e.getTools();
        return {
          bridges: i.bridges.filter(s => Np(s.key, t)),
          exchanges: i.exchanges.filter(s => Np(s.key, n))
        }
      }, {
        onSuccess(i) {
          const {
            initializeTools: s
          } = po.getState();
          s("Bridges", i.bridges.map(o => o.key)), s("Exchanges", i.exchanges.map(o => o.key))
        },
        refetchInterval: 18e4,
        staleTime: 18e4
      });
    return {
      tools: r
    }
  };
let n$ = !1;
const hCe = () => {
    Lk(), j.useEffect(() => {
      n$ || (n$ = !0, UW(fCe, $k))
    }, [])
  },
  Ud = () => {
    const e = Ba();
    return {
      navigateBack: j.useCallback(() => {
        e(-1)
      }, [e]),
      navigate: e
    }
  },
  xq = (e, t) => {
    const {
      subvariant: n
    } = Wt(), {
      t: r
    } = ft(), {
      getChainById: i
    } = vo();
    return !e || !t ? {} : Eq(r, i, e, t, n)
  },
  pCe = {
    TOKEN_ALLOWANCE: {
      STARTED: e => e("main.process.tokenAllowance.started"),
      ACTION_REQUIRED: e => e("main.process.tokenAllowance.pending"),
      PENDING: e => e("main.process.tokenAllowance.pending"),
      DONE: e => e("main.process.tokenAllowance.done")
    },
    SWITCH_CHAIN: {
      ACTION_REQUIRED: e => e("main.process.switchChain.actionRequired"),
      DONE: e => e("main.process.switchChain.done")
    },
    SWAP: {
      STARTED: e => e("main.process.swap.started"),
      ACTION_REQUIRED: e => e("main.process.swap.actionRequired"),
      PENDING: e => e("main.process.swap.pending"),
      DONE: (e, t) => e(t === "nft" ? "main.process.nft.done" : "main.process.swap.done")
    },
    CROSS_CHAIN: {
      STARTED: e => e("main.process.crossChain.started"),
      ACTION_REQUIRED: e => e("main.process.crossChain.actionRequired"),
      PENDING: e => e("main.process.crossChain.pending"),
      DONE: e => e("main.process.crossChain.done")
    },
    RECEIVING_CHAIN: {
      PENDING: e => e("main.process.receivingChain.pending"),
      DONE: (e, t) => e(t === "nft" ? "main.process.nft.done" : "main.process.receivingChain.done")
    },
    TRANSACTION: {}
  },
  mCe = {
    PENDING: {},
    DONE: {
      PARTIAL: e => e("main.process.receivingChain.partial"),
      REFUNDED: e => e("main.process.receivingChain.partial")
    },
    FAILED: {},
    INVALID: {},
    NOT_FOUND: {}
  };

function Eq(e, t, n, r, i) {
  var o, a, c, l, u;
  if (r.error && r.status === "FAILED") {
    const f = () => {
      var y;
      return e("error.message.transactionNotSent", {
        amount: Ei(n.action.fromAmount, n.action.fromToken.decimals),
        tokenSymbol: n.action.fromToken.symbol,
        chainName: ((y = t(n.action.fromChainId)) == null ? void 0 : y.name) ?? ""
      })
    };
    let h = "",
      g = "";
    switch (r.error.code) {
      case nn.AllowanceRequired:
        h = e("error.title.allowanceRequired"), g = e("error.message.allowanceRequired", {
          tokenSymbol: n.action.fromToken.symbol
        });
        break;
      case nn.BalanceError:
        h = e("error.title.balanceIsTooLow"), g = f();
        break;
      case nn.ChainSwitchError:
        h = e("error.title.chainSwitch"), g = f();
        break;
      case nn.GasLimitError:
        h = e("error.title.gasLimitIsTooLow"), g = f();
        break;
      case nn.InsufficientFunds:
        h = e("error.title.insufficientFunds"), g = `${e("error.message.insufficientFunds")} ${f()}`;
        break;
      case nn.SlippageError:
        h = e("error.title.slippageNotMet"), g = e("error.message.slippageThreshold");
        break;
      case nn.TransactionFailed:
        h = e("error.title.transactionFailed"), g = e("error.message.transactionFailed");
        break;
      case nn.TransactionUnderpriced:
        h = e("error.title.transactionUnderpriced"), g = f();
        break;
      case nn.TransactionUnprepared:
        h = e("error.title.transactionUnprepared"), g = f();
        break;
      case nn.TransactionCanceled:
        h = e("error.title.transactionCanceled"), g = f();
        break;
      case nn.TransactionRejected:
        h = e("error.title.transactionRejected"), g = e("error.message.transactionRejected", {
          amount: Ei(n.action.fromAmount, n.action.fromToken.decimals),
          tokenSymbol: n.action.fromToken.symbol,
          chainName: ((o = t(n.action.fromChainId)) == null ? void 0 : o.name) ?? ""
        });
        break;
      case nn.ProviderUnavailable:
      default:
        h = e("error.title.unknown"), r.txLink ? g = e("error.message.transactionFailed") : g = e("error.message.unknown");
        break
    }
    return {
      title: h,
      message: g
    }
  }
  return {
    title: ((c = (a = mCe[r.status]) == null ? void 0 : a[r.substatus]) == null ? void 0 : c.call(a, e)) ?? ((u = (l = pCe[r.type]) == null ? void 0 : l[r.status]) == null ? void 0 : u.call(l, e, i))
  }
}

function El(e, t) {
  if (Object.is(e, t)) return !0;
  if (typeof e != "object" || e === null || typeof t != "object" || t === null) return !1;
  if (e instanceof Map && t instanceof Map) {
    if (e.size !== t.size) return !1;
    for (const [r, i] of e)
      if (!Object.is(i, t.get(r))) return !1;
    return !0
  }
  if (e instanceof Set && t instanceof Set) {
    if (e.size !== t.size) return !1;
    for (const r of e)
      if (!t.has(r)) return !1;
    return !0
  }
  const n = Object.keys(e);
  if (n.length !== Object.keys(t).length) return !1;
  for (const r of n)
    if (!Object.prototype.hasOwnProperty.call(t, r) || !Object.is(e[r], t[r])) return !1;
  return !0
}
var Cs;
(function (e) {
  e.RouteExecutionStarted = "routeExecutionStarted", e.RouteExecutionUpdated = "routeExecutionUpdated", e.RouteExecutionCompleted = "routeExecutionCompleted", e.RouteExecutionFailed = "routeExecutionFailed", e.RouteHighValueLoss = "routeHighValueLoss", e.RouteContactSupport = "routeContactSupport", e.SourceChainTokenSelected = "sourceChainTokenSelected", e.DestinationChainTokenSelected = "destinationChainTokenSelected", e.SendToWalletToggled = "sendToWalletToggled", e.ReviewTransactionPageEntered = "reviewTransactionPageEntered", e.WalletConnected = "walletConnected"
})(Cs || (Cs = {}));

function gCe(e) {
  return {
    all: e = e || new Map,
    on: function (t, n) {
      var r = e.get(t);
      r ? r.push(n) : e.set(t, [n])
    },
    off: function (t, n) {
      var r = e.get(t);
      r && (n ? r.splice(r.indexOf(n) >>> 0, 1) : e.set(t, []))
    },
    emit: function (t, n) {
      var r = e.get(t);
      r && r.slice().map(function (i) {
        i(n)
      }), (r = e.get("*")) && r.slice().map(function (i) {
        i(t, n)
      })
    }
  }
}
const yCe = gCe(),
  Pm = () => yCe,
  Sq = ({
    routeId: e,
    executeInBackground: t,
    onAcceptExchangeRateUpdate: n
  }) => {
    const r = ku(),
      i = bm(),
      {
        account: s,
        switchChain: o
      } = Ri(),
      a = j.useRef(!1),
      c = Pm(),
      l = eAe(),
      u = gl(w => w.routes[e]),
      [f, h, g] = gl(w => [w.updateRoute, w.restartRoute, w.deleteRoute], El),
      y = w => {
        const E = l.getState().routes[w.id];
        if (!E) return;
        const D = structuredClone(w);
        f(D);
        const $ = XCe(E.route, D);
        $ && c.emit(Cs.RouteExecutionUpdated, {
          route: D,
          process: $
        }), p2(D) && c.emit(Cs.RouteExecutionCompleted, D), U3(D) && $ && c.emit(Cs.RouteExecutionFailed, {
          route: D,
          process: $
        }), console.log("Route updated.", D)
      },
      x = async w => {
        if (!s.isActive || !s.signer) return s.signer;
        if (await s.signer.getChainId() !== w) {
          const D = await o(w);
          if (!D) throw new Error("Chain was not switched.");
          return D
        }
        return s.signer
      }, k = async w => n ? await new Promise(D => n(D, w)) : !1, _ = _N(() => {
        if (!s.signer) throw Error("Account signer not found.");
        if (!(u != null && u.route)) throw Error("Execution route not found.");
        return i.removeQueries(["routes"], {
          exact: !1
        }), r.executeRoute(s.signer, u.route, {
          updateRouteHook: y,
          switchChainHook: x,
          acceptExchangeRateUpdateHook: k,
          infiniteApproval: !1,
          executeInBackground: t
        })
      }, {
        onMutate: () => {
          console.log("Execution started.", e), u && c.emit(Cs.RouteExecutionStarted, u.route)
        }
      }), p = _N(w => {
        if (!s.signer) throw Error("Account signer not found.");
        if (!(u != null && u.route)) throw Error("Execution route not found.");
        return r.resumeRoute(s.signer, w ?? u.route, {
          updateRouteHook: y,
          switchChainHook: x,
          acceptExchangeRateUpdateHook: k,
          infiniteApproval: !1,
          executeInBackground: t
        })
      }, {
        onMutate: () => {
          console.log("Resumed to execution.", e)
        }
      }), v = j.useCallback(() => {
        _.mutateAsync(void 0, {
          onError: w => {
            console.warn("Execution failed!", e, w)
          },
          onSuccess: w => {
            console.log("Executed successfully!", w)
          }
        })
      }, [_, e]), S = j.useCallback(w => {
        p.mutateAsync(w, {
          onError: E => {
            console.warn("Resumed execution failed.", e, E)
          },
          onSuccess: E => {
            console.log("Resumed execution successful.", E)
          }
        })
      }, [p, e]), I = j.useCallback(() => {
        h(e), S(u == null ? void 0 : u.route)
      }, [S, u == null ? void 0 : u.route, e]), A = j.useCallback(() => {
        g(e)
      }, [e]);
    return j.useEffect(() => {
      o$(u == null ? void 0 : u.route) && s.isActive && !a.current && (a.current = !0, S())
    }, [s.isActive]), j.useEffect(() => () => {
      var E;
      const w = (E = l.getState().routes[e]) == null ? void 0 : E.route;
      !w || !o$(w) || (r.updateRouteExecution(w, {
        executeInBackground: !0
      }), console.log("Move route execution to background.", e), a.current = !1)
    }, [r, l, e]), {
      executeRoute: v,
      restartRoute: I,
      deleteRoute: A,
      route: u == null ? void 0 : u.route,
      status: u == null ? void 0 : u.status
    }
  };
let Tb;
const vCe = new Uint8Array(16);

function bCe() {
  if (!Tb && (Tb = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !Tb)) throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return Tb(vCe)
}
const Ni = [];
for (let e = 0; e < 256; ++e) Ni.push((e + 256).toString(16).slice(1));

function wCe(e, t = 0) {
  return Ni[e[t + 0]] + Ni[e[t + 1]] + Ni[e[t + 2]] + Ni[e[t + 3]] + "-" + Ni[e[t + 4]] + Ni[e[t + 5]] + "-" + Ni[e[t + 6]] + Ni[e[t + 7]] + "-" + Ni[e[t + 8]] + Ni[e[t + 9]] + "-" + Ni[e[t + 10]] + Ni[e[t + 11]] + Ni[e[t + 12]] + Ni[e[t + 13]] + Ni[e[t + 14]] + Ni[e[t + 15]]
}
const xCe = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto),
  r$ = {
    randomUUID: xCe
  };

function ECe(e, t, n) {
  if (r$.randomUUID && !t && !e) return r$.randomUUID();
  e = e || {};
  const r = e.random || (e.rng || bCe)();
  if (r[6] = r[6] & 15 | 64, r[8] = r[8] & 63 | 128, t) {
    n = n || 0;
    for (let i = 0; i < 16; ++i) t[n + i] = r[i];
    return t
  }
  return wCe(r)
}
const t6 = () => Hk(t => t.state) === "swap",
  $g = 6e4,
  Ih = ({
    insurableRoute: e
  } = {}) => {
    var M;
    const t = ku(),
      {
        subvariant: n,
        sdkConfig: r,
        insurance: i,
        contractTool: s
      } = Wt(),
      {
        account: o
      } = Ri(),
      a = bm(),
      c = t6(),
      {
        slippage: l,
        enabledBridges: u,
        enabledAutoRefuel: f,
        enabledExchanges: h,
        routePriority: g
      } = kc(["slippage", "routePriority", "enabledAutoRefuel", "enabledBridges", "enabledExchanges"]),
      [y] = fq([Qe.FromAmount], 320),
      [x, k, _, p, v, S, I, A, w] = ds({
        name: [Qe.FromChain, Qe.FromToken, Qe.ToAddress, Qe.ToAmount, Qe.ToChain, Qe.ToContractAddress, Qe.ToContractCallData, Qe.ToContractGasLimit, Qe.ToToken]
      }),
      {
        token: E
      } = hh(x, k),
      {
        token: D
      } = hh(v, w),
      {
        enabled: $,
        fromAmount: V
      } = Mk(),
      G = !isNaN(y) && Number(y) > 0 || !isNaN(p) && Number(p) > 0,
      L = n === "nft" ? !!(S && I && A) : !0,
      b = !isNaN(x) && !isNaN(v) && !!(E != null && E.address) && !!(D != null && D.address) && !Number.isNaN(l) && G && L,
      T = ["routes", o.address, x, E == null ? void 0 : E.address, y, _, v, D == null ? void 0 : D.address, p, S, I, A, l, c ? [] : u, h, g, n, (M = r == null ? void 0 : r.defaultRouteOptions) == null ? void 0 : M.allowSwitchChain, $ && f, V, i, e == null ? void 0 : e.id],
      {
        data: R,
        isLoading: N,
        isFetching: O,
        isFetched: U,
        dataUpdatedAt: q,
        refetch: W
      } = wl(T, async ({
        queryKey: [Q, he, H, ne, X, Z, te, F, J, ie, ce, ue, ge, et, He, se, pe, de, we, Ce, be, Se],
        signal: Fe
      }) => {
        var ct, Xe, _e, Ze;
        let Ne;
        try {
          Ne = await ((Xe = (ct = o.signer) == null ? void 0 : ct.provider) == null ? void 0 : Xe.resolveName(Z)) ?? (k3(Z) ? Z : he)
        } catch {
          Ne = k3(Z) ? Z : he
        }
        const Me = Dn(X || 0).mul(10 ** ((E == null ? void 0 : E.decimals) ?? 0)).toFixed(0),
          We = parseFloat(ge) / 100,
          ke = e ? e.steps.flatMap(Ee => Ee.includedSteps.filter(Oe => Oe.type === "cross").map(Oe => Oe.toolDetails.key)) : et,
          ze = e ? e.steps.flatMap(Ee => Ee.includedSteps.filter(Oe => Oe.type === "swap").map(Oe => Oe.toolDetails.key)) : He;
        if (pe === "nft") {
          const Ee = await t.getContractCallQuote({
            fromAddress: he,
            fromChain: H,
            fromToken: ne,
            toAmount: J,
            toChain: te,
            toToken: F,
            toContractAddress: ie,
            toContractCallData: ce,
            toContractGasLimit: ue,
            allowBridges: ke,
            toFallbackAddress: Ne,
            slippage: We
          }, {
            signal: Fe
          });
          Ee.action.toToken = D;
          const Oe = pe === "nft" ? (_e = Ee.includedSteps) == null ? void 0 : _e.find(tt => tt.type === "custom") : void 0;
          if (Oe && s) {
            const tt = {
              key: s.name,
              name: s.name,
              logoURI: s.logoURI
            };
            Oe.toolDetails = tt, Ee.toolDetails = tt
          }
          return {
            routes: [{
              id: ECe(),
              fromChainId: Ee.action.fromChainId,
              fromAmountUSD: Ee.estimate.fromAmountUSD || "",
              fromAmount: Ee.action.fromAmount,
              fromToken: Ee.action.fromToken,
              fromAddress: Ee.action.fromAddress,
              toChainId: Ee.action.toChainId,
              toAmountUSD: Ee.estimate.toAmountUSD || "",
              toAmount: J,
              toAmountMin: J,
              toToken: D,
              toAddress: Ne,
              gasCostUSD: (Ze = Ee.estimate.gasCosts) == null ? void 0 : Ze[0].amountUSD,
              steps: [Ee],
              insurance: {
                state: "NOT_INSURABLE",
                feeAmountUsd: "0"
              }
            }]
          }
        }
        return t.getRoutes({
          fromChainId: H,
          fromAmount: Me,
          fromTokenAddress: ne,
          toChainId: te,
          toTokenAddress: F,
          fromAddress: he,
          toAddress: Ne,
          fromAmountForGas: we && Ce ? Ce : void 0,
          options: {
            slippage: We,
            bridges: {
              allow: ke
            },
            exchanges: {
              allow: ze
            },
            order: se,
            allowSwitchChain: pe === "refuel" ? !1 : de,
            insurance: be ? !!e : void 0
          }
        }, {
          signal: Fe
        })
      }, {
        enabled: b,
        staleTime: $g,
        cacheTime: $g,
        refetchInterval(Q, he) {
          return Math.min(Math.abs($g - (Date.now() - he.state.dataUpdatedAt)), $g)
        },
        retry(Q, he) {
          return (he == null ? void 0 : he.code) !== nn.NotFound
        },
        onSuccess(Q) {
          if (Q.routes[0]) {
            const {
              fromToken: he,
              toToken: H
            } = Q.routes[0];
            [he, H].forEach(ne => {
              a.setQueriesData(["token-balances", o.address, ne.chainId], X => {
                if (X) {
                  const Z = [...X],
                    te = Z.findIndex(F => F.address === ne.address);
                  return Z[te] = {
                    ...Z[te],
                    ...ne
                  }, Z
                }
              })
            })
          }
        }
      });
    return {
      routes: R == null ? void 0 : R.routes,
      isLoading: b && N,
      isFetching: O,
      isFetched: U,
      dataUpdatedAt: q,
      refetchTime: $g,
      refetch: W
    }
  },
  Cq = (e, t, n) => {
    const r = ku(),
      i = bm(),
      {
        data: s,
        isLoading: o
      } = wl(["token-search", e, t], async ({
        queryKey: [, a, c],
        signal: l
      }) => {
        const u = await r.getToken(a, c, {
          signal: l
        });
        return u && i.setQueriesData(["tokens"], f => {
          var h, g;
          if (f && !((h = f.tokens[a]) != null && h.some(y => y.address === u.address))) {
            const y = {
              ...f
            };
            return (g = y.tokens[a]) == null || g.push(u), y
          }
        }), u
      }, {
        enabled: !!(e && t && n),
        retry: !1
      });
    return {
      token: s,
      isLoading: o
    }
  },
  hh = (e, t) => {
    const {
      tokens: n,
      isLoading: r
    } = mq(e), i = j.useMemo(() => n == null ? void 0 : n.find(l => l.address === t && l.chainId === e), [e, t, n]), s = !r && !i, {
      token: o,
      isLoading: a
    } = Cq(e, t, s);
    return {
      token: i ?? o,
      isLoading: r || s && a
    }
  };
var SCe = {
  BASE_URL: "/",
  MODE: "production",
  DEV: !1,
  PROD: !0,
  SSR: !1
};

function CCe(e, t) {
  let n;
  try {
    n = e()
  } catch {
    return
  }
  return {
    getItem: i => {
      var s;
      const o = c => c === null ? null : JSON.parse(c, t == null ? void 0 : t.reviver),
        a = (s = n.getItem(i)) != null ? s : null;
      return a instanceof Promise ? a.then(o) : o(a)
    },
    setItem: (i, s) => n.setItem(i, JSON.stringify(s, t == null ? void 0 : t.replacer)),
    removeItem: i => n.removeItem(i)
  }
}
const h2 = e => t => {
    try {
      const n = e(t);
      return n instanceof Promise ? n : {
        then(r) {
          return h2(r)(n)
        },
        catch (r) {
          return this
        }
      }
    } catch (n) {
      return {
        then(r) {
          return this
        },
        catch (r) {
          return h2(r)(n)
        }
      }
    }
  },
  ACe = (e, t) => (n, r, i) => {
    let s = {
        getStorage: () => localStorage,
        serialize: JSON.stringify,
        deserialize: JSON.parse,
        partialize: k => k,
        version: 0,
        merge: (k, _) => ({
          ..._,
          ...k
        }),
        ...t
      },
      o = !1;
    const a = new Set,
      c = new Set;
    let l;
    try {
      l = s.getStorage()
    } catch {}
    if (!l) return e((...k) => {
      console.warn(`[zustand persist middleware] Unable to update item '${s.name}', the given storage is currently unavailable.`), n(...k)
    }, r, i);
    const u = h2(s.serialize),
      f = () => {
        const k = s.partialize({
          ...r()
        });
        let _;
        const p = u({
          state: k,
          version: s.version
        }).then(v => l.setItem(s.name, v)).catch(v => {
          _ = v
        });
        if (_) throw _;
        return p
      },
      h = i.setState;
    i.setState = (k, _) => {
      h(k, _), f()
    };
    const g = e((...k) => {
      n(...k), f()
    }, r, i);
    let y;
    const x = () => {
      var k;
      if (!l) return;
      o = !1, a.forEach(p => p(r()));
      const _ = ((k = s.onRehydrateStorage) == null ? void 0 : k.call(s, r())) || void 0;
      return h2(l.getItem.bind(l))(s.name).then(p => {
        if (p) return s.deserialize(p)
      }).then(p => {
        if (p)
          if (typeof p.version == "number" && p.version !== s.version) {
            if (s.migrate) return s.migrate(p.state, p.version);
            console.error("State loaded from storage couldn't be migrated since no migrate function was provided")
          } else return p.state
      }).then(p => {
        var v;
        return y = s.merge(p, (v = r()) != null ? v : g), n(y, !0), f()
      }).then(() => {
        _ == null || _(y, void 0), o = !0, c.forEach(p => p(y))
      }).catch(p => {
        _ == null || _(void 0, p)
      })
    };
    return i.persist = {
      setOptions: k => {
        s = {
          ...s,
          ...k
        }, k.getStorage && (l = k.getStorage())
      },
      clearStorage: () => {
        l == null || l.removeItem(s.name)
      },
      getOptions: () => s,
      rehydrate: () => x(),
      hasHydrated: () => o,
      onHydrate: k => (a.add(k), () => {
        a.delete(k)
      }),
      onFinishHydration: k => (c.add(k), () => {
        c.delete(k)
      })
    }, x(), y || g
  },
  TCe = (e, t) => (n, r, i) => {
    let s = {
        storage: CCe(() => localStorage),
        partialize: x => x,
        version: 0,
        merge: (x, k) => ({
          ...k,
          ...x
        }),
        ...t
      },
      o = !1;
    const a = new Set,
      c = new Set;
    let l = s.storage;
    if (!l) return e((...x) => {
      console.warn(`[zustand persist middleware] Unable to update item '${s.name}', the given storage is currently unavailable.`), n(...x)
    }, r, i);
    const u = () => {
        const x = s.partialize({
          ...r()
        });
        return l.setItem(s.name, {
          state: x,
          version: s.version
        })
      },
      f = i.setState;
    i.setState = (x, k) => {
      f(x, k), u()
    };
    const h = e((...x) => {
      n(...x), u()
    }, r, i);
    i.getInitialState = () => h;
    let g;
    const y = () => {
      var x, k;
      if (!l) return;
      o = !1, a.forEach(p => {
        var v;
        return p((v = r()) != null ? v : h)
      });
      const _ = ((k = s.onRehydrateStorage) == null ? void 0 : k.call(s, (x = r()) != null ? x : h)) || void 0;
      return h2(l.getItem.bind(l))(s.name).then(p => {
        if (p)
          if (typeof p.version == "number" && p.version !== s.version) {
            if (s.migrate) return s.migrate(p.state, p.version);
            console.error("State loaded from storage couldn't be migrated since no migrate function was provided")
          } else return p.state
      }).then(p => {
        var v;
        return g = s.merge(p, (v = r()) != null ? v : h), n(g, !0), u()
      }).then(() => {
        _ == null || _(g, void 0), g = r(), o = !0, c.forEach(p => p(g))
      }).catch(p => {
        _ == null || _(void 0, p)
      })
    };
    return i.persist = {
      setOptions: x => {
        s = {
          ...s,
          ...x
        }, x.storage && (l = x.storage)
      },
      clearStorage: () => {
        l == null || l.removeItem(s.name)
      },
      getOptions: () => s,
      rehydrate: () => y(),
      hasHydrated: () => o,
      onHydrate: x => (a.add(x), () => {
        a.delete(x)
      }),
      onFinishHydration: x => (c.add(x), () => {
        c.delete(x)
      })
    }, s.skipHydration || y(), g || h
  },
  kCe = (e, t) => "getStorage" in t || "serialize" in t || "deserialize" in t ? ((SCe ? "production" : void 0) !== "production" && console.warn("[DEPRECATED] `getStorage`, `serialize` and `deserialize` options are deprecated. Use `storage` option instead."), ACe(e, t)) : TCe(e, t),
  Bk = kCe;
var Aq = {
    exports: {}
  },
  Tq = {};
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var n6 = j,
  _Ce = KH;

function ICe(e, t) {
  return e === t && (e !== 0 || 1 / e === 1 / t) || e !== e && t !== t
}
var PCe = typeof Object.is == "function" ? Object.is : ICe,
  RCe = _Ce.useSyncExternalStore,
  OCe = n6.useRef,
  DCe = n6.useEffect,
  NCe = n6.useMemo,
  MCe = n6.useDebugValue;
Tq.useSyncExternalStoreWithSelector = function (e, t, n, r, i) {
  var s = OCe(null);
  if (s.current === null) {
    var o = {
      hasValue: !1,
      value: null
    };
    s.current = o
  } else o = s.current;
  s = NCe(function () {
    function c(g) {
      if (!l) {
        if (l = !0, u = g, g = r(g), i !== void 0 && o.hasValue) {
          var y = o.value;
          if (i(y, g)) return f = y
        }
        return f = g
      }
      if (y = f, PCe(u, g)) return y;
      var x = r(g);
      return i !== void 0 && i(y, x) ? y : (u = g, f = x)
    }
    var l = !1,
      u, f, h = n === void 0 ? null : n;
    return [function () {
      return c(t())
    }, h === null ? void 0 : function () {
      return c(h())
    }]
  }, [t, n, r, i]);
  var a = RCe(e, s[0], s[1]);
  return DCe(function () {
    o.hasValue = !0, o.value = a
  }, [a]), MCe(a), a
};
Aq.exports = Tq;
var $Ce = Aq.exports;
const LCe = Vo($Ce);
var BCe = {
  BASE_URL: "/",
  MODE: "production",
  DEV: !1,
  PROD: !0,
  SSR: !1
};
const i$ = e => {
    let t;
    const n = new Set,
      r = (u, f) => {
        const h = typeof u == "function" ? u(t) : u;
        if (!Object.is(h, t)) {
          const g = t;
          t = f ?? (typeof h != "object" || h === null) ? h : Object.assign({}, t, h), n.forEach(y => y(t, g))
        }
      },
      i = () => t,
      c = {
        setState: r,
        getState: i,
        getInitialState: () => l,
        subscribe: u => (n.add(u), () => n.delete(u)),
        destroy: () => {
          (BCe ? "production" : void 0) !== "production" && console.warn("[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."), n.clear()
        }
      },
      l = t = e(r, i, c);
    return c
  },
  FCe = e => e ? i$(e) : i$,
  {
    useDebugValue: jCe
  } = Jt,
  {
    useSyncExternalStoreWithSelector: UCe
  } = LCe,
  zCe = e => e;

function HCe(e, t = zCe, n) {
  const r = UCe(e.subscribe, e.getState, e.getServerState || e.getInitialState, t, n);
  return jCe(r), r
}
const s$ = (e, t) => {
    const n = FCe(e),
      r = (i, s = t) => HCe(n, i, s);
    return Object.assign(r, n), r
  },
  Rm = (e, t) => e ? s$(e, t) : s$,
  A1 = 9,
  VCe = ({
    namePrefix: e
  }) => Rm(Bk((t, n) => ({
    chainOrder: [],
    availableChains: [],
    initializeChains: r => (t(i => {
      const s = i.chainOrder.filter(c => r.includes(c)),
        o = r.filter(c => !s.includes(c));
      if (s.length === A1 || !o.length) return {
        availableChains: r,
        chainOrder: s
      };
      const a = A1 - s.length;
      for (let c = 0; c < a; c++) s.push(o[c]);
      return {
        availableChains: r,
        chainOrder: s
      }
    }), n().chainOrder),
    setChain: r => {
      const i = n();
      i.chainOrder.includes(r) || !i.availableChains.includes(r) || t(s => {
        const o = s.chainOrder.slice();
        return o.unshift(r), o.length > A1 && o.pop(), {
          chainOrder: o
        }
      })
    }
  }), {
    name: `${e||"li.fi"}-widget-chains-order`,
    version: 0,
    partialize: t => ({
      chainOrder: t.chainOrder
    })
  }), Object.is),
  kq = j.createContext(null);

function _q({
  children: e,
  ...t
}) {
  const n = j.useRef(),
    {
      chains: r
    } = vo(),
    {
      setValue: i,
      getValues: s
    } = Ls();
  return n.current || (n.current = VCe(t)), j.useEffect(() => {
    var o;
    if (r) {
      const a = (o = n.current) == null ? void 0 : o.getState().initializeChains(r.map(c => c.id));
      if (a) {
        const [c, l] = s([Qe.FromChain, Qe.ToChain]);
        c || i(Qe.FromChain, a[0]), l || i(Qe.ToChain, a[0])
      }
    }
  }, [r, s, i]), C.jsx(kq.Provider, {
    value: n.current,
    children: e
  })
}

function WCe(e, t) {
  const n = j.useContext(kq);
  if (!n) throw new Error(`You forgot to wrap your component in <${_q.name}>.`);
  return n(e, t)
}
const qCe = () => WCe(e => [e.chainOrder, e.setChain], El),
  Fk = j.createContext(null);

function jk({
  children: e,
  ...t
}) {
  const n = j.useRef();
  return n.current || (n.current = KCe(t)), C.jsx(Fk.Provider, {
    value: n.current,
    children: e
  })
}

function GCe(e, t) {
  const n = j.useContext(Fk);
  if (!n) throw new Error(`You forgot to wrap your component in <${jk.name}>.`);
  return n(e, t)
}

function Om() {
  const e = j.useContext(Fk);
  if (!e) throw new Error(`You forgot to wrap your component in <${jk.name}>.`);
  return e
}
const KCe = ({
  namePrefix: e
}) => Rm((t, n) => ({
  setAction: r => (t(() => ({
    element: r
  })), n().removeAction),
  setTitle: r => (t(() => ({
    title: r
  })), n().removeTitle),
  removeAction: () => {
    t(() => ({
      element: null
    }))
  },
  removeTitle: () => {
    t(() => ({
      title: void 0
    }))
  }
}), Object.is);
var ot;
(function (e) {
  e[e.Idle = 0] = "Idle", e[e.Pending = 1] = "Pending", e[e.Done = 2] = "Done", e[e.Failed = 4] = "Failed", e[e.Partial = 8] = "Partial", e[e.Refunded = 16] = "Refunded"
})(ot || (ot = {}));
const QCe = {
  Date: !0,
  RegExp: !0,
  String: !0,
  Number: !0
};

function Iq(e, t, n = {
  cyclesFix: !0
}, r = []) {
  var a, c;
  let i = [];
  const s = Array.isArray(e);
  for (const l in e) {
    const u = e[l],
      f = s ? +l : l;
    if (!(l in t)) {
      i.push({
        type: "REMOVE",
        path: [f],
        oldValue: e[l]
      });
      continue
    }
    const h = t[l],
      g = typeof u == "object" && typeof h == "object" && Array.isArray(u) === Array.isArray(h);
    if (u && h && g && !QCe[(c = (a = Object.getPrototypeOf(u)) == null ? void 0 : a.constructor) == null ? void 0 : c.name] && (!n.cyclesFix || !r.includes(u))) {
      const y = Iq(u, h, n, n.cyclesFix ? r.concat([u]) : []);
      i.push.apply(i, y.map(x => (x.path.unshift(f), x)))
    } else u !== h && !(Number.isNaN(u) && Number.isNaN(h)) && !(g && (isNaN(u) ? u + "" == h + "" : +u == +h)) && i.push({
      path: [f],
      type: "CHANGE",
      value: h,
      oldValue: u
    })
  }
  const o = Array.isArray(t);
  for (const l in t) l in e || i.push({
    type: "CREATE",
    path: [o ? +l : l],
    value: t[l]
  });
  return i
}
const p2 = e => e.steps.every(t => {
    var n;
    return ((n = t.execution) == null ? void 0 : n.status) === "DONE"
  }),
  YCe = e => e.steps.some(t => {
    var n;
    return (n = t.execution) == null ? void 0 : n.process.some(r => r.substatus === "PARTIAL")
  }),
  JCe = e => e.steps.some(t => {
    var n;
    return (n = t.execution) == null ? void 0 : n.process.some(r => r.substatus === "REFUNDED")
  }),
  U3 = e => e.steps.some(t => {
    var n;
    return ((n = t.execution) == null ? void 0 : n.status) === "FAILED"
  }),
  o$ = e => {
    if (!e) return !1;
    const t = p2(e),
      n = U3(e),
      r = e.steps.some(i => i.execution);
    return !t && !n && r
  },
  XCe = (e, t) => {
    const n = Iq(e, t).find(i => i.path.includes("process"));
    return n ? n.path.slice(0, n.path.findIndex(i => i === "process") + 2).reduce((i, s) => i[s], t) : void 0
  },
  ZCe = ({
    namePrefix: e
  }) => Rm(Bk((t, n) => ({
    routes: {},
    setExecutableRoute: (r, i) => {
      n().routes[r.id] || t(s => {
        const o = {
          ...s.routes
        };
        return Object.keys(o).filter(a => {
          var c;
          return a !== i && ((c = o[a]) == null ? void 0 : c.status) === ot.Idle
        }).forEach(a => delete o[a]), o[r.id] = {
          route: r,
          status: ot.Idle
        }, {
          routes: o
        }
      })
    },
    updateRoute: r => {
      n().routes[r.id] && t(i => {
        const s = {
          routes: {
            ...i.routes,
            [r.id]: {
              ...i.routes[r.id],
              route: r
            }
          }
        };
        return U3(r) ? (s.routes[r.id].status = ot.Failed, s) : p2(r) ? (s.routes[r.id].status = ot.Done, YCe(r) ? s.routes[r.id].status |= ot.Partial : JCe(r) && (s.routes[r.id].status |= ot.Refunded), s) : (r.steps.some(l => l.execution) && (s.routes[r.id].status = ot.Pending), s)
      })
    },
    restartRoute: r => {
      n().routes[r] && t(i => ({
        routes: {
          ...i.routes,
          [r]: {
            ...i.routes[r],
            status: ot.Pending
          }
        }
      }))
    },
    deleteRoute: r => {
      n().routes[r] && t(i => {
        const s = {
          ...i.routes
        };
        return delete s[r], {
          routes: s
        }
      })
    },
    deleteRoutes: r => t(i => {
      const s = {
        ...i.routes
      };
      return Object.keys(s).filter(o => {
        var a, c;
        return r === "completed" ? ha(((a = s[o]) == null ? void 0 : a.status) ?? 0, ot.Done) : !ha(((c = s[o]) == null ? void 0 : c.status) ?? 0, ot.Done)
      }).forEach(o => delete s[o]), {
        routes: s
      }
    })
  }), {
    name: `${e||"li.fi"}-widget-routes`,
    version: 1,
    partialize: t => ({
      routes: t.routes
    }),
    merge: (t, n) => {
      const r = {
        ...n,
        ...t
      };
      try {
        const i = new Date().getTime(),
          s = 1e3 * 60 * 60 * 24;
        Object.values(r.routes).forEach(a => {
          var u, f, h, g;
          const c = ((g = (h = (f = (u = a == null ? void 0 : a.route.steps) == null ? void 0 : u.find(y => {
              var x;
              return ((x = y.execution) == null ? void 0 : x.status) === "FAILED"
            })) == null ? void 0 : f.execution) == null ? void 0 : h.process.find(y => y.startedAt)) == null ? void 0 : g.startedAt) ?? 0,
            l = c > 0 && i - c > s;
          a != null && a.route && l && (a.status |= ot.Done)
        });
        const o = localStorage.getItem("routes");
        o && (JSON.parse(o).forEach(c => {
          if (r.routes[c.id]) return;
          if (r.routes[c.id] = {
              route: c,
              status: ot.Idle
            }, U3(c)) {
            r.routes[c.id].status = ot.Failed;
            return
          }
          if (p2(c)) {
            r.routes[c.id].status = ot.Done;
            return
          }
          c.steps.some(h => h.execution) && (r.routes[c.id].status = ot.Pending)
        }), localStorage.removeItem("routes"))
      } catch (i) {
        console.error(i)
      }
      return r
    },
    migrate: (t, n) => (n === 0 && Object.values(t.routes).forEach(r => {
      if (r) switch (r.status) {
        case "idle":
          r.status = ot.Idle;
          break;
        case "loading":
          r.status = ot.Pending;
          break;
        case "success":
        case "warning":
          r.status = ot.Done;
          break;
        case "error":
          r.status = ot.Failed;
          break
      }
    }), t)
  }), Object.is),
  Uk = j.createContext(null);

function zk({
  children: e,
  ...t
}) {
  const n = j.useRef();
  return n.current || (n.current = ZCe(t)), C.jsx(Uk.Provider, {
    value: n.current,
    children: e
  })
}

function gl(e, t) {
  const n = j.useContext(Uk);
  if (!n) throw new Error(`You forgot to wrap your component in <${zk.name}>.`);
  return n(e, t)
}

function eAe() {
  const e = j.useContext(Uk);
  if (!e) throw new Error(`You forgot to wrap your component in <${zk.name}>.`);
  return e
}
const Pq = e => gl(t => Object.values(t.routes).filter(n => n.route.fromAddress === e && (n.status === ot.Pending || n.status === ot.Failed)).sort((n, r) => {
    var i, s;
    return (((i = r == null ? void 0 : r.route.steps[0].execution) == null ? void 0 : i.process[0].startedAt) ?? 0) - (((s = n == null ? void 0 : n.route.steps[0].execution) == null ? void 0 : s.process[0].startedAt) ?? 0)
  }).map(({
    route: n
  }) => n.id), El),
  r6 = () => gl(e => e.setExecutableRoute),
  tAe = e => gl(t => Object.values(t.routes).filter(n => (n == null ? void 0 : n.route.fromAddress) === e && ha(n.status, ot.Done)).sort((n, r) => {
    var i, s;
    return (((i = r == null ? void 0 : r.route.steps[0].execution) == null ? void 0 : i.process[0].startedAt) ?? 0) - (((s = n == null ? void 0 : n.route.steps[0].execution) == null ? void 0 : s.process[0].startedAt) ?? 0)
  }), El),
  nAe = ["Bridges", "Exchanges"],
  ga = {
    routePriority: "RECOMMENDED",
    slippage: "0.5",
    gasPrice: "normal"
  },
  GS = {
    appearance: "auto",
    gasPrice: "normal",
    enabledAutoRefuel: !0,
    showDestinationWallet: !0,
    enabledBridges: [],
    enabledExchanges: []
  },
  po = Rm(Bk((e, t) => ({
    ...GS,
    setValue: (n, r) => e(() => ({
      [n]: r
    })),
    setValues: n => e(r => {
      const i = {
        ...r
      };
      for (const s in n) Object.hasOwn(r, s) && (i[s] = n[s]);
      return i
    }),
    initializeTools: (n, r, i) => {
      r.length && e(s => {
        const o = {
          ...s
        };
        if (o[`_enabled${n}`] && !i) {
          const a = r.filter(c => !Object.hasOwn(o[`_enabled${n}`], c)).reduce((c, l) => (c[l] = !0, c), o[`_enabled${n}`]);
          o[`_enabled${n}`] = Object.fromEntries(Object.entries(a).filter(([c]) => r.includes(c)))
        } else o[`_enabled${n}`] = r.reduce((a, c) => (a[c] = !0, a), {});
        return o[`enabled${n}`] = Object.entries(o[`_enabled${n}`]).filter(([a, c]) => c).map(([a]) => a), o
      })
    },
    setTools: (n, r, i) => e(() => ({
      [`enabled${n}`]: r,
      [`_enabled${n}`]: i.reduce((s, o) => (s[o] = r.includes(o), s), {})
    })),
    reset: (n, r, i) => {
      const {
        appearance: s,
        ...o
      } = GS;
      e(() => ({
        ...o,
        ...ga
      })), t().initializeTools("Bridges", r, !0), t().initializeTools("Exchanges", i, !0)
    }
  }), {
    name: "li.fi-widget-settings",
    version: 2,
    partialize: e => {
      const {
        enabledBridges: t,
        enabledExchanges: n,
        ...r
      } = e;
      return r
    },
    merge: (e, t) => {
      const n = {
        ...t,
        ...e
      };
      return nAe.forEach(r => {
        n[`enabled${r}`] = Object.entries(e[`_enabled${r}`]).filter(([i, s]) => s).map(([i]) => i)
      }), n
    },
    migrate: (e, t) => (t === 0 && e.appearance === "system" && (e.appearance = GS.appearance), t === 1 && (e.slippage = ga.slippage), e)
  }), Object.is),
  Rq = e => {
    var a, c, l, u, f;
    const {
      slippage: t,
      routePriority: n,
      setValue: r,
      gasPrice: i
    } = po.getState(), s = ((e == null ? void 0 : e.slippage) || ((c = (a = e == null ? void 0 : e.sdkConfig) == null ? void 0 : a.defaultRouteOptions) == null ? void 0 : c.slippage) || 0) * 100, o = (e == null ? void 0 : e.routePriority) || ((u = (l = e == null ? void 0 : e.sdkConfig) == null ? void 0 : l.defaultRouteOptions) == null ? void 0 : u.order);
    ga.slippage = (f = s || ga.slippage) == null ? void 0 : f.toString(), ga.routePriority = o || ga.routePriority, t || r("slippage", ga.slippage), n || r("routePriority", ga.routePriority), i || r("gasPrice", ga.gasPrice)
  },
  Oq = () => {
    const [e, t] = po(r => [r.appearance, r.setValue], El);
    return [e, r => {
      t("appearance", r)
    }]
  },
  z3 = Rm(e => ({
    showSendToWallet: !1,
    showSendToWalletDirty: !1,
    toggleSendToWallet: () => e(t => ({
      showSendToWallet: !t.showSendToWallet,
      showSendToWalletDirty: !0
    })),
    setSendToWallet: t => e({
      showSendToWallet: t,
      showSendToWalletDirty: !0
    })
  }), Object.is),
  kc = e => po(t => e.reduce((n, r) => (n[r] = t[r], n), {}), El),
  Dq = j.createContext(null),
  rAe = (e, t) => {
    const {
      state: n
    } = e.getState();
    return n !== t.state
  };

function Nq({
  children: e,
  ...t
}) {
  const n = j.useRef();
  return (!n.current || rAe(n.current, t)) && (n.current = iAe(t)), C.jsx(Dq.Provider, {
    value: n.current,
    children: e
  })
}

function Hk(e, t) {
  const n = j.useContext(Dq);
  if (!n) throw new Error(`You forgot to wrap your component in <${Nq.name}>.`);
  return n(e, t)
}
const iAe = ({
    state: e
  }) => Rm(t => ({
    state: e,
    setState(n) {
      t(() => ({
        state: n
      }))
    }
  }), Object.is),
  sAe = ({
    children: e,
    config: t
  }) => C.jsx(Nq, {
    state: t.subvariant === "split" ? t.subvariantOptions || "swap" : void 0,
    children: C.jsx(jk, {
      namePrefix: t == null ? void 0 : t.keyPrefix,
      children: C.jsx(_q, {
        namePrefix: t == null ? void 0 : t.keyPrefix,
        children: C.jsx(zk, {
          namePrefix: t == null ? void 0 : t.keyPrefix,
          children: e
        })
      })
    })
  }),
  oAe = {
    elementId: "",
    integrator: ""
  },
  Mq = j.createContext(oAe),
  Wt = () => j.useContext(Mq),
  aAe = ({
    children: e,
    config: {
      fromChain: t,
      fromToken: n,
      toChain: r,
      toToken: i,
      fromAmount: s,
      toAddress: o,
      integrator: a,
      ...c
    } = {}
  }) => {
    const l = j.useId();
    if (!a) throw Error('Required property "integrator" is missing.');
    const u = j.useMemo(() => {
      var f, h, g, y;
      try {
        const x = Object.fromEntries(new URLSearchParams(window == null ? void 0 : window.location.search));
        ["from", "to"].forEach(_ => {
          x[`${_}Token`] && !x[`${_}Chain`] && delete x[`${_}Token`]
        });
        const k = {
          ...c,
          fromChain: x.fromChain && isNaN(parseInt(x.fromChain, 10)) || typeof t == "string" ? (h = VM((f = x.fromChain || t) == null ? void 0 : f.toLowerCase())) == null ? void 0 : h.id : x.fromChain && !isNaN(parseInt(x.fromChain, 10)) || typeof t == "number" ? parseInt(x.fromChain, 10) || t : void 0,
          toChain: x.toChain && isNaN(parseInt(x.toChain, 10)) || typeof r == "string" ? (y = VM((g = x.toChain || r) == null ? void 0 : g.toLowerCase())) == null ? void 0 : y.id : x.toChain && !isNaN(parseInt(x.toChain, 10)) || typeof r == "number" ? parseInt(x.toChain, 10) || r : void 0,
          fromToken: x.fromToken || n,
          toToken: x.toToken || i,
          fromAmount: typeof x.fromAmount == "string" && !isNaN(parseFloat(x.fromAmount)) ? EA(x.fromAmount) : s,
          toAddress: x.toAddress || o,
          elementId: l,
          integrator: a
        };
        return Rq(k), k
      } catch (x) {
        return console.warn(x), {
          ...c,
          elementId: l,
          integrator: a
        }
      }
    }, [c, l, s, t, n, a, o, r, i]);
    return C.jsx(Mq.Provider, {
      value: u,
      children: e
    })
  };
var Vk = {
    exports: {}
  },
  mp = typeof Reflect == "object" ? Reflect : null,
  a$ = mp && typeof mp.apply == "function" ? mp.apply : function (t, n, r) {
    return Function.prototype.apply.call(t, n, r)
  },
  Aw;
mp && typeof mp.ownKeys == "function" ? Aw = mp.ownKeys : Object.getOwnPropertySymbols ? Aw = function (t) {
  return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t))
} : Aw = function (t) {
  return Object.getOwnPropertyNames(t)
};

function cAe(e) {
  console && console.warn && console.warn(e)
}
var $q = Number.isNaN || function (t) {
  return t !== t
};

function Zn() {
  Zn.init.call(this)
}
Vk.exports = Zn;
Vk.exports.once = fAe;
Zn.EventEmitter = Zn;
Zn.prototype._events = void 0;
Zn.prototype._eventsCount = 0;
Zn.prototype._maxListeners = void 0;
var c$ = 10;

function i6(e) {
  if (typeof e != "function") throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e)
}
Object.defineProperty(Zn, "defaultMaxListeners", {
  enumerable: !0,
  get: function () {
    return c$
  },
  set: function (e) {
    if (typeof e != "number" || e < 0 || $q(e)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e + ".");
    c$ = e
  }
});
Zn.init = function () {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0
};
Zn.prototype.setMaxListeners = function (t) {
  if (typeof t != "number" || t < 0 || $q(t)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + t + ".");
  return this._maxListeners = t, this
};

function Lq(e) {
  return e._maxListeners === void 0 ? Zn.defaultMaxListeners : e._maxListeners
}
Zn.prototype.getMaxListeners = function () {
  return Lq(this)
};
Zn.prototype.emit = function (t) {
  for (var n = [], r = 1; r < arguments.length; r++) n.push(arguments[r]);
  var i = t === "error",
    s = this._events;
  if (s !== void 0) i = i && s.error === void 0;
  else if (!i) return !1;
  if (i) {
    var o;
    if (n.length > 0 && (o = n[0]), o instanceof Error) throw o;
    var a = new Error("Unhandled error." + (o ? " (" + o.message + ")" : ""));
    throw a.context = o, a
  }
  var c = s[t];
  if (c === void 0) return !1;
  if (typeof c == "function") a$(c, this, n);
  else
    for (var l = c.length, u = zq(c, l), r = 0; r < l; ++r) a$(u[r], this, n);
  return !0
};

function Bq(e, t, n, r) {
  var i, s, o;
  if (i6(n), s = e._events, s === void 0 ? (s = e._events = Object.create(null), e._eventsCount = 0) : (s.newListener !== void 0 && (e.emit("newListener", t, n.listener ? n.listener : n), s = e._events), o = s[t]), o === void 0) o = s[t] = n, ++e._eventsCount;
  else if (typeof o == "function" ? o = s[t] = r ? [n, o] : [o, n] : r ? o.unshift(n) : o.push(n), i = Lq(e), i > 0 && o.length > i && !o.warned) {
    o.warned = !0;
    var a = new Error("Possible EventEmitter memory leak detected. " + o.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    a.name = "MaxListenersExceededWarning", a.emitter = e, a.type = t, a.count = o.length, cAe(a)
  }
  return e
}
Zn.prototype.addListener = function (t, n) {
  return Bq(this, t, n, !1)
};
Zn.prototype.on = Zn.prototype.addListener;
Zn.prototype.prependListener = function (t, n) {
  return Bq(this, t, n, !0)
};

function lAe() {
  if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments)
}

function Fq(e, t, n) {
  var r = {
      fired: !1,
      wrapFn: void 0,
      target: e,
      type: t,
      listener: n
    },
    i = lAe.bind(r);
  return i.listener = n, r.wrapFn = i, i
}
Zn.prototype.once = function (t, n) {
  return i6(n), this.on(t, Fq(this, t, n)), this
};
Zn.prototype.prependOnceListener = function (t, n) {
  return i6(n), this.prependListener(t, Fq(this, t, n)), this
};
Zn.prototype.removeListener = function (t, n) {
  var r, i, s, o, a;
  if (i6(n), i = this._events, i === void 0) return this;
  if (r = i[t], r === void 0) return this;
  if (r === n || r.listener === n) --this._eventsCount === 0 ? this._events = Object.create(null) : (delete i[t], i.removeListener && this.emit("removeListener", t, r.listener || n));
  else if (typeof r != "function") {
    for (s = -1, o = r.length - 1; o >= 0; o--)
      if (r[o] === n || r[o].listener === n) {
        a = r[o].listener, s = o;
        break
      } if (s < 0) return this;
    s === 0 ? r.shift() : uAe(r, s), r.length === 1 && (i[t] = r[0]), i.removeListener !== void 0 && this.emit("removeListener", t, a || n)
  }
  return this
};
Zn.prototype.off = Zn.prototype.removeListener;
Zn.prototype.removeAllListeners = function (t) {
  var n, r, i;
  if (r = this._events, r === void 0) return this;
  if (r.removeListener === void 0) return arguments.length === 0 ? (this._events = Object.create(null), this._eventsCount = 0) : r[t] !== void 0 && (--this._eventsCount === 0 ? this._events = Object.create(null) : delete r[t]), this;
  if (arguments.length === 0) {
    var s = Object.keys(r),
      o;
    for (i = 0; i < s.length; ++i) o = s[i], o !== "removeListener" && this.removeAllListeners(o);
    return this.removeAllListeners("removeListener"), this._events = Object.create(null), this._eventsCount = 0, this
  }
  if (n = r[t], typeof n == "function") this.removeListener(t, n);
  else if (n !== void 0)
    for (i = n.length - 1; i >= 0; i--) this.removeListener(t, n[i]);
  return this
};

function jq(e, t, n) {
  var r = e._events;
  if (r === void 0) return [];
  var i = r[t];
  return i === void 0 ? [] : typeof i == "function" ? n ? [i.listener || i] : [i] : n ? dAe(i) : zq(i, i.length)
}
Zn.prototype.listeners = function (t) {
  return jq(this, t, !0)
};
Zn.prototype.rawListeners = function (t) {
  return jq(this, t, !1)
};
Zn.listenerCount = function (e, t) {
  return typeof e.listenerCount == "function" ? e.listenerCount(t) : Uq.call(e, t)
};
Zn.prototype.listenerCount = Uq;

function Uq(e) {
  var t = this._events;
  if (t !== void 0) {
    var n = t[e];
    if (typeof n == "function") return 1;
    if (n !== void 0) return n.length
  }
  return 0
}
Zn.prototype.eventNames = function () {
  return this._eventsCount > 0 ? Aw(this._events) : []
};

function zq(e, t) {
  for (var n = new Array(t), r = 0; r < t; ++r) n[r] = e[r];
  return n
}

function uAe(e, t) {
  for (; t + 1 < e.length; t++) e[t] = e[t + 1];
  e.pop()
}

function dAe(e) {
  for (var t = new Array(e.length), n = 0; n < t.length; ++n) t[n] = e[n].listener || e[n];
  return t
}

function fAe(e, t) {
  return new Promise(function (n, r) {
    function i(o) {
      e.removeListener(t, s), r(o)
    }

    function s() {
      typeof e.removeListener == "function" && e.removeListener("error", i), n([].slice.call(arguments))
    }
    Hq(e, t, s, {
      once: !0
    }), t !== "error" && hAe(e, i, {
      once: !0
    })
  })
}

function hAe(e, t, n) {
  typeof e.on == "function" && Hq(e, "error", t, n)
}

function Hq(e, t, n, r) {
  if (typeof e.on == "function") r.once ? e.once(t, n) : e.on(t, n);
  else if (typeof e.addEventListener == "function") e.addEventListener(t, function i(s) {
    r.once && e.removeEventListener(t, i), n(s)
  });
  else throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof e)
}
var si = Vk.exports;
const Wk = Vo(si);

function Vq(e) {
  return typeof e.address == "string" && typeof e.name == "string"
}
const Ph = e => e.map(t => ({
    address: t.address.toLowerCase(),
    name: t.name
  })),
  s6 = (e, t) => {
    const n = Object.keys,
      r = typeof e;
    return e && t && r === "object" && r === typeof t ? n(e).length === n(t).length && n(e).every(s => s6(e[s], t[s])) : e === t
  },
  Wq = e => {
    const t = Ph(e);
    localStorage.setItem("li.fi-wallets", JSON.stringify(Array.from(new Set(t))))
  },
  qk = () => {
    const e = localStorage.getItem("li.fi-wallets");
    if (e) try {
      const t = JSON.parse(e);
      if (t.some(n => !Vq(n))) throw new Error("Malformed persisted active wallets");
      return t
    } catch {
      return localStorage.removeItem("li.fi-wallets"), []
    } else return []
  },
  qq = e => {
    const t = Ph(e);
    localStorage.setItem("li.fi-deactivated-wallets", JSON.stringify(Array.from(new Set(t))))
  },
  Gk = () => {
    const e = localStorage.getItem("li.fi-deactivated-wallets");
    if (e) try {
      const t = JSON.parse(e);
      if (t.some(n => !Vq(n))) throw new Error("Malformed persisted deactivated wallets");
      return t
    } catch {
      return localStorage.removeItem("li.fi-deactivated-wallets"), []
    } else return []
  },
  pAe = e => {
    if (!e) return;
    const t = Ph([e])[0],
      r = qk().filter(i => !s6(i, t));
    Wq(r)
  },
  mAe = e => {
    if (!e) return;
    const t = Ph([e])[0],
      n = Gk();
    n.push(t), qq(n)
  },
  gAe = e => {
    if (!e) return;
    const t = Ph([e])[0],
      n = qk();
    n.push(t), Wq(n)
  },
  yAe = e => {
    if (!e) return;
    const t = Ph([e])[0],
      r = Gk().filter(i => !s6(i, t));
    qq(r)
  },
  vAe = e => {
    if (!e) return !0;
    const t = Ph([e])[0];
    return Gk().some(r => s6(r, t))
  };
class bAe extends si.EventEmitter {
  constructor() {
    super(...arguments), this.connectedWallets = [], this.connect = async t => {
      var n, r;
      try {
        await t.connect(), t.addListener("walletAccountChanged", this.handleAccountDataChange), this.connectedWallets.unshift(t), yAe({
          address: ((n = t.account) == null ? void 0 : n.address) || "",
          name: t.name
        }), gAe({
          address: ((r = t.account) == null ? void 0 : r.address) || "",
          name: t.name
        })
      } catch (i) {
        throw i
      }
    }, this.disconnect = async t => {
      var n, r;
      t.removeAllListeners(), pAe({
        address: ((n = t.account) == null ? void 0 : n.address) || "",
        name: t.name
      }), mAe({
        address: ((r = t.account) == null ? void 0 : r.address) || "",
        name: t.name
      }), t.disconnect()
    }
  }
  async autoConnect(t) {
    for (const n of t) n.autoConnect && (await n.autoConnect(), n.addListener("walletAccountChanged", this.handleAccountDataChange), this.connectedWallets.unshift(n))
  }
  handleAccountDataChange() {
    this.emit("walletChanged", this.connectedWallets)
  }
}
var _i;
(function (e) {
  e.AlphaWallet = "isAlphaWallet", e.BlockWallet = "isBlockWallet", e.Binance = "bbcSignTx", e.Bitpie = "isBitpie", e.Coinbase = "isToshi", e.CoinbaseExtension = "isCoinbaseWallet", e.Detected = "request", e.Dcent = "isDcentWallet", e.Frame = "isFrame", e.HyperPay = "isHyperPay", e.ImToken = "isImToken", e.Liquality = "isLiquality", e.MetaMask = "isMetaMask", e.OwnBit = "isOwnbit", e.Status = "isStatus", e.TallyHo = "isTally", e.Trust = "isTrust", e.TokenPocket = "isTokenPocket", e.TP = "isTp", e.WalletIo = "isWalletIO", e.XDEFI = "__XDEFI", e.OneInch = "isOneInchIOSWallet", e.Tokenary = "isTokenary", e.MathWallet = "isMathWallet", e.Frontier = "isFrontier", e.ApexWallet = "isApexWallet", e.OkxWallet = "okxwallet", e.SafePal = "safepal"
})(_i || (_i = {}));
const o6 = async (e, t) => {
  var r;
  const n = {
    chainId: (r = BW(t).metamask) == null ? void 0 : r.chainId
  };
  try {
    return e.send ? (await e.send("wallet_switchEthereumChain", [n]), !0) : await new Promise((s, o) => {
      e.request({
        method: "wallet_switchEthereumChain",
        params: [n]
      }).catch(a => {
        console.error(a), o(a)
      }), e.once("chainChanged", a => {
        parseInt(a) === t ? s(!0) : s(!1)
      })
    })
  } catch (i) {
    return i.code !== M3.userRejectedRequest ? await a6(e, t) : (console.error(i), !1)
  }
}, a6 = async (e, t) => {
  const n = BW(t).metamask;
  try {
    return e.send ? await e.send("wallet_addEthereumChain", [n]) : await e.request({
      method: "wallet_addEthereumChain",
      params: [n]
    }), !0
  } catch (r) {
    return console.error(`Error adding chain ${t}: ${r.message}`), !1
  }
}, l$ = async (e, t) => {
  const n = {
    type: "ERC20",
    options: {
      address: t.address,
      symbol: t.symbol,
      decimals: t.decimals,
      image: t.logoURI
    }
  };
  try {
    return e.send ? await e.send("wallet_watchAsset", [n]) : await e.request({
      method: "wallet_watchAsset",
      params: [n]
    }), !0
  } catch (r) {
    return console.error(r), !1
  }
}, Kk = async (e, t, n) => {
  const r = Rt(t);
  try {
    if (r !== Rt((await e.getNetwork()).chainId)) {
      const i = await o6(e, t);
      return i && await new Promise((o, a) => {
        e.once("chainChanged", async c => {
          if (parseInt(c, 10) === t) {
            const l = await l$(e, n);
            o(l)
          }
        })
      })
    } else return await l$(e, n)
  } catch (i) {
    return console.error(i), !1
  }
}, wAe = "/assets/alphawallet-DBrx6h42.svg", xAe = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='32'%20height='32'%20viewBox='0%200%2032%2032'%20fill='none'%3e%3crect%20width='32'%20height='32'%20fill='black'/%3e%3cpath%20d='M10.3366%209.06342L15.6439%206L20.9513%209.06342L19%2010.1951L15.6439%208.26342L12.2878%2010.1951L10.3366%209.06342ZM20.9513%2012.9268L19%2011.7951L15.6439%2013.7268L12.2878%2011.7951L10.3366%2012.9268V15.1903L13.6927%2017.1219V20.9853L15.6439%2022.1171L17.5952%2020.9853V17.1219L20.9513%2015.1903V12.9268ZM20.9513%2019.0537V16.7902L19%2017.9219V20.1853L20.9513%2019.0537ZM22.3366%2019.8537L18.9805%2021.7853V24.0487L24.2878%2020.9853V14.8585L22.3366%2015.9902V19.8537ZM20.3854%2010.9951L22.3366%2012.1268V14.3903L24.2878%2013.2585V10.9951L22.3366%209.86342L20.3854%2010.9951ZM13.6927%2022.6049V24.8683L15.6439%2026L17.5952%2024.8683V22.6049L15.6439%2023.7366L13.6927%2022.6049ZM10.3366%2019.0537L12.2878%2020.1853V17.9219L10.3366%2016.7902V19.0537ZM13.6927%2010.9951L15.6439%2012.1268L17.5952%2010.9951L15.6439%209.86342L13.6927%2010.9951ZM8.95122%2012.1268L10.9024%2010.9951L8.95122%209.86342L7%2010.9951V13.2585L8.95122%2014.3903V12.1268ZM8.95122%2015.9902L7%2014.8585V20.9853L12.3073%2024.0487V21.7853L8.95122%2019.8537V15.9902Z'%20fill='%23F0B90B'/%3e%3c/svg%3e", EAe = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='512'%20height='512'%20viewBox='0%200%20512%20512'%20fill='none'%3e%3cg%20clip-path='url(%23clip0_2029_360)'%3e%3crect%20width='512'%20height='512'%20fill='%2354FFF5'/%3e%3cg%20filter='url(%23filter0_f_2029_360)'%3e%3cpath%20d='M26.9613%20397.206C-58.6549%20638.082%20399.323%20570.05%20639.014%20505.924C884.329%20424.513%20714.772%2065.6498%20538.829%2057.7076C362.886%2049.7654%20560.645%20223.645%20411.191%20273.307C261.737%20322.97%20133.982%2096.1127%2026.9613%20397.206Z'%20fill='white'/%3e%3c/g%3e%3cg%20filter='url(%23filter1_f_2029_360)'%3e%3cpath%20d='M171.024%20-91.647C126.112%20-214.354%20-33.8378%20-47.9926%20-108.199%2050.5266C-179.13%20157.694%206.01881%20250.302%2078.6417%20200.073C151.265%20149.844%2015.549%20140.071%2058.7417%2074.7551C101.934%209.43956%20227.163%2061.7371%20171.024%20-91.647Z'%20fill='%2300FFF0'%20fill-opacity='0.67'/%3e%3c/g%3e%3cg%20filter='url(%23filter2_f_2029_360)'%3e%3cpath%20d='M192.959%20450.845C131.701%20244.725%20-132.163%20353.272%20-256.438%20433.312C-375.98%20528.082%20-92.1419%20800.694%2025.7452%20786.749C143.632%20772.804%20-68.8233%20654.128%203.97422%20596.339C76.7718%20538.549%20269.533%20708.496%20192.959%20450.845Z'%20fill='%239D81FF'/%3e%3c/g%3e%3cg%20filter='url(%23filter3_f_2029_360)'%3e%3cpath%20d='M564.24%20-214.706C432.094%20-372.062%20242.925%20-241.94%20164.859%20-157.209C96.5476%20-61.2893%20448.549%20114.462%20546.243%2084.3427C643.936%2054.2231%20413.023%20-8.10076%20454.594%20-66.5759C496.164%20-125.051%20729.423%20-18.0113%20564.24%20-214.706Z'%20fill='%234D94FF'/%3e%3c/g%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M186.378%20305.672H273.347L174.417%20206.102L274.619%20106.533L301.911%2080H211.639L96.672%20195.555C90.8701%20201.379%2090.8998%20210.803%2096.7315%20216.598L186.378%20305.672ZM238.66%20206.336H237.991L238.653%20206.329L238.66%20206.336ZM238.66%20206.336L337.583%20305.898L237.381%20405.468L210.089%20432.001H300.361L415.328%20316.453C421.13%20310.629%20421.1%20301.205%20415.268%20295.41L325.622%20206.336H238.66Z'%20fill='black'/%3e%3c/g%3e%3cdefs%3e%3cfilter%20id='filter0_f_2029_360'%20x='-180.482'%20y='-139.48'%20width='1139.12'%20height='902.864'%20filterUnits='userSpaceOnUse'%20color-interpolation-filters='sRGB'%3e%3cfeFlood%20flood-opacity='0'%20result='BackgroundImageFix'/%3e%3cfeBlend%20mode='normal'%20in='SourceGraphic'%20in2='BackgroundImageFix'%20result='shape'/%3e%3cfeGaussianBlur%20stdDeviation='98.4615'%20result='effect1_foregroundBlur_2029_360'/%3e%3c/filter%3e%3cfilter%20id='filter1_f_2029_360'%20x='-321.021'%20y='-331.978'%20width='703.193'%20height='743.016'%20filterUnits='userSpaceOnUse'%20color-interpolation-filters='sRGB'%3e%3cfeFlood%20flood-opacity='0'%20result='BackgroundImageFix'/%3e%3cfeBlend%20mode='normal'%20in='SourceGraphic'%20in2='BackgroundImageFix'%20result='shape'/%3e%3cfeGaussianBlur%20stdDeviation='98.4615'%20result='effect1_foregroundBlur_2029_360'/%3e%3c/filter%3e%3cfilter%20id='filter2_f_2029_360'%20x='-482.155'%20y='135.284'%20width='889.703'%20height='848.905'%20filterUnits='userSpaceOnUse'%20color-interpolation-filters='sRGB'%3e%3cfeFlood%20flood-opacity='0'%20result='BackgroundImageFix'/%3e%3cfeBlend%20mode='normal'%20in='SourceGraphic'%20in2='BackgroundImageFix'%20result='shape'/%3e%3cfeGaussianBlur%20stdDeviation='98.4615'%20result='effect1_foregroundBlur_2029_360'/%3e%3c/filter%3e%3cfilter%20id='filter3_f_2029_360'%20x='-40.7937'%20y='-485.519'%20width='860.381'%20height='770.211'%20filterUnits='userSpaceOnUse'%20color-interpolation-filters='sRGB'%3e%3cfeFlood%20flood-opacity='0'%20result='BackgroundImageFix'/%3e%3cfeBlend%20mode='normal'%20in='SourceGraphic'%20in2='BackgroundImageFix'%20result='shape'/%3e%3cfeGaussianBlur%20stdDeviation='98.4615'%20result='effect1_foregroundBlur_2029_360'/%3e%3c/filter%3e%3cclipPath%20id='clip0_2029_360'%3e%3crect%20width='512'%20height='512'%20fill='white'/%3e%3c/clipPath%3e%3c/defs%3e%3c/svg%3e", SAe = "data:image/svg+xml,%3csvg%20width='100%25'%20height='100%25'%20viewBox='0%200%2040%2040'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M8.72147%200.714294H30.3108C35.1186%200.714294%2039.0161%204.61182%2039.0161%209.41965V31.0089C39.0161%2035.8168%2035.1186%2039.7143%2030.3108%2039.7143H8.72147C3.91363%2039.7143%200.0161133%2035.8168%200.0161133%2031.0089V9.41965C0.0161133%204.61182%203.91363%200.714294%208.72147%200.714294Z'%20fill='url(%23paint0_linear)'/%3e%3cpath%20d='M19.6902%2035.1875C27.8635%2035.1875%2034.4893%2028.5617%2034.4893%2020.3884C34.4893%2012.2151%2027.8635%205.58929%2019.6902%205.58929C11.5169%205.58929%204.89111%2012.2151%204.89111%2020.3884C4.89111%2028.5617%2011.5169%2035.1875%2019.6902%2035.1875Z'%20fill='white'/%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M19.5161%200.714294C30.2857%200.714294%2039.0161%209.44474%2039.0161%2020.2143C39.0161%2030.9838%2030.2857%2039.7143%2019.5161%2039.7143C8.74656%2039.7143%200.0161133%2030.9838%200.0161133%2020.2143C0.0161133%209.44474%208.74656%200.714294%2019.5161%200.714294ZM19.4287%205.34882C11.2187%205.34882%204.5632%2012.0043%204.5632%2020.2143C4.5632%2028.4243%2011.2187%2035.0798%2019.4287%2035.0798C27.6386%2035.0798%2034.2941%2028.4243%2034.2941%2020.2143C34.2941%2012.0043%2027.6386%205.34882%2019.4287%205.34882Z'%20fill='url(%23paint1_linear)'/%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M21.7479%2027.6254C22.3598%2028.6852%2021.9967%2030.0404%2020.9369%2030.6524C19.877%2031.2643%2018.5218%2030.9011%2017.9099%2029.8413L17.2448%2028.6899L16.0937%2029.3546C15.0338%2029.9665%2013.6786%2029.6034%2013.0667%2028.5435C12.4548%2027.4837%2012.8179%2026.1285%2013.8778%2025.5166L15.0288%2024.8517L13.2562%2021.7814L12.105%2022.4461C11.0452%2023.058%209.68995%2022.6949%209.07805%2021.635C8.46614%2020.5752%208.82927%2019.2199%209.88913%2018.608L11.0402%2017.9432L10.3758%2016.7918C9.76387%2015.732%2010.127%2014.3768%2011.1869%2013.7649C12.2467%2013.1529%2013.6019%2013.5161%2014.2138%2014.5759L14.8784%2015.7271L17.9487%2013.9545L17.2843%2012.8032C16.6724%2011.7434%2017.0355%2010.3881%2018.0954%209.77622C19.1552%209.16431%2020.5105%209.52745%2021.1224%2010.5873L21.7869%2011.7385L22.9386%2011.0739C23.9984%2010.462%2025.3536%2010.8252%2025.9655%2011.885C26.5775%2012.9449%2026.2143%2014.3001%2025.1545%2014.912L24.003%2015.5768L25.7756%2018.647L26.9272%2017.9825C27.987%2017.3706%2029.3423%2017.7337%2029.9542%2018.7935C30.5661%2019.8534%2030.203%2021.2086%2029.1431%2021.8205L27.9916%2022.4853L28.6565%2023.6367C29.2684%2024.6966%2028.9052%2026.0518%2027.8454%2026.6637C26.7855%2027.2756%2025.4303%2026.9125%2024.8184%2025.8526L24.1533%2024.7013L21.0831%2026.4739L21.7479%2027.6254ZM18.8671%2022.6356L21.9373%2020.863L20.1647%2017.7928L17.0945%2019.5654L18.8671%2022.6356Z'%20fill='url(%23paint2_linear)'/%3e%3cdefs%3e%3clinearGradient%20id='paint0_linear'%20x1='20.509'%20y1='39.7143'%20x2='20.509'%20y2='0.714294'%20gradientUnits='userSpaceOnUse'%3e%3cstop%20stop-color='%231E3DA0'/%3e%3cstop%20offset='1'%20stop-color='%233750DE'/%3e%3c/linearGradient%3e%3clinearGradient%20id='paint1_linear'%20x1='19.5161'%20y1='0.714294'%20x2='19.5161'%20y2='39.7143'%20gradientUnits='userSpaceOnUse'%3e%3cstop%20stop-color='%231D3BA3'%20stop-opacity='0'/%3e%3cstop%20offset='1'%20stop-color='%23173793'%20stop-opacity='0.652938'/%3e%3c/linearGradient%3e%3clinearGradient%20id='paint2_linear'%20x1='24.3911'%20y1='28.658'%20x2='14.6411'%20y2='11.7705'%20gradientUnits='userSpaceOnUse'%3e%3cstop%20stop-color='%231E3DA0'/%3e%3cstop%20offset='1'%20stop-color='%233750DE'/%3e%3c/linearGradient%3e%3c/defs%3e%3c/svg%3e", CAe = "data:image/svg+xml,%3csvg%20width='30'%20height='30'%20viewBox='0%200%2030%2030'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M15%2030C23.2843%2030%2030%2023.2843%2030%2015C30%206.71573%2023.2843%200%2015%200C6.71573%200%200%206.71573%200%2015C0%2023.2843%206.71573%2030%2015%2030ZM23.125%206.875H6.875V23.125H23.125V6.875Z'%20fill='currentColor'/%3e%3c/svg%3e", AAe = "data:image/svg+xml,%3csvg%20width='100%25'%20height='100%25'%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20436.49%20511.97'%3e%3cdefs%3e%3cstyle%3e.cls-1{fill:url(%23linear-gradient);}.cls-2{fill:%23fff;}%3c/style%3e%3clinearGradient%20id='linear-gradient'%20x1='-18.79'%20y1='359.73'%20x2='194.32'%20y2='359.73'%20gradientTransform='matrix(2.05,%200,%200,%20-2.05,%2038.49,%20992.77)'%20gradientUnits='userSpaceOnUse'%3e%3cstop%20offset='0'%20stop-color='%23f1562b'/%3e%3cstop%20offset='0.3'%20stop-color='%23f1542b'/%3e%3cstop%20offset='0.41'%20stop-color='%23f04d2a'/%3e%3cstop%20offset='0.49'%20stop-color='%23ef4229'/%3e%3cstop%20offset='0.5'%20stop-color='%23ef4029'/%3e%3cstop%20offset='0.56'%20stop-color='%23e83e28'/%3e%3cstop%20offset='0.67'%20stop-color='%23e13c26'/%3e%3cstop%20offset='1'%20stop-color='%23df3c26'/%3e%3c/linearGradient%3e%3c/defs%3e%3cpath%20class='cls-1'%20d='M436.49,165.63,420.7,122.75l11-24.6A8.47,8.47,0,0,0,430,88.78L400.11,58.6a48.16,48.16,0,0,0-50.23-11.66l-8.19,2.89L296.09.43,218.25,0,140.4.61,94.85,50.41l-8.11-2.87A48.33,48.33,0,0,0,36.19,59.3L5.62,90.05a6.73,6.73,0,0,0-1.36,7.47l11.47,25.56L0,165.92,56.47,380.64a89.7,89.7,0,0,0,34.7,50.23l111.68,75.69a24.73,24.73,0,0,0,30.89,0l111.62-75.8A88.86,88.86,0,0,0,380,380.53l46.07-176.14Z'/%3e%3cpath%20class='cls-2'%20d='M231,317.33a65.61,65.61,0,0,0-9.11-3.3h-5.49a66.08,66.08,0,0,0-9.11,3.3l-13.81,5.74-15.6,7.18-25.4,13.24a4.84,4.84,0,0,0-.62,9l22.06,15.49q7,5,13.55,10.76l6.21,5.35,13,11.37,5.89,5.2a10.15,10.15,0,0,0,12.95,0l25.39-22.18,13.6-10.77,22.06-15.79a4.8,4.8,0,0,0-.68-8.93l-25.36-12.8L244.84,323ZM387.4,175.2l.8-2.3a61.26,61.26,0,0,0-.57-9.18,73.51,73.51,0,0,0-8.19-15.44l-14.35-21.06-10.22-13.88-19.23-24a69.65,69.65,0,0,0-5.7-6.67h-.4L321,84.25l-42.27,8.14a33.49,33.49,0,0,1-12.59-1.84l-23.21-7.5-16.61-4.59a70.52,70.52,0,0,0-14.67,0L195,83.1l-23.21,7.54a33.89,33.89,0,0,1-12.59,1.84l-42.22-8-8.54-1.58h-.4a65.79,65.79,0,0,0-5.7,6.67l-19.2,24Q77.81,120.32,73,127.45L58.61,148.51l-6.78,11.31a51,51,0,0,0-1.94,13.35l.8,2.3A34.51,34.51,0,0,0,52,179.81l11.33,13,50.23,53.39a14.31,14.31,0,0,1,2.55,14.34L107.68,280a25.23,25.23,0,0,0-.39,16l1.64,4.52a43.58,43.58,0,0,0,13.39,18.76l7.89,6.43a15,15,0,0,0,14.35,1.72L172.62,314A70.38,70.38,0,0,0,187,304.52l22.46-20.27a9,9,0,0,0,3-6.36,9.08,9.08,0,0,0-2.5-6.56L159.2,237.18a9.83,9.83,0,0,1-3.09-12.45l19.66-36.95a19.21,19.21,0,0,0,1-14.67A22.37,22.37,0,0,0,165.58,163L103.94,139.8c-4.44-1.6-4.2-3.6.51-3.88l36.2-3.59a55.9,55.9,0,0,1,16.9,1.5l31.5,8.8a9.64,9.64,0,0,1,6.74,10.76L183.42,221a34.72,34.72,0,0,0-.61,11.41c.5,1.61,4.73,3.6,9.36,4.73l19.19,4a46.38,46.38,0,0,0,16.86,0l17.26-4c4.64-1,8.82-3.23,9.35-4.85a34.94,34.94,0,0,0-.63-11.4l-12.45-67.59a9.66,9.66,0,0,1,6.74-10.76l31.5-8.83a55.87,55.87,0,0,1,16.9-1.5l36.2,3.37c4.74.44,5,2.2.54,3.88L272,162.79a22.08,22.08,0,0,0-11.16,10.12,19.3,19.3,0,0,0,1,14.67l19.69,36.95A9.84,9.84,0,0,1,278.45,237l-50.66,34.23a9,9,0,0,0,.32,12.78l.15.14,22.49,20.27a71.46,71.46,0,0,0,14.35,9.47l28.06,13.35a14.89,14.89,0,0,0,14.34-1.76l7.9-6.45a43.53,43.53,0,0,0,13.38-18.8l1.65-4.52a25.27,25.27,0,0,0-.39-16l-8.26-19.49a14.4,14.4,0,0,1,2.55-14.35l50.23-53.45,11.3-13a35.8,35.8,0,0,0,1.54-4.24Z'/%3e%3c/svg%3e", TAe = "data:image/svg+xml,%3csvg%20width='100%25'%20height='100%25'%20viewBox='0%200%2040%2040'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M20%2040C31.0457%2040%2040%2031.0457%2040%2020C40%208.9543%2031.0457%200%2020%200C8.9543%200%200%208.9543%200%2020C0%2031.0457%208.9543%2040%2020%2040Z'%20fill='%231652F0'/%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M5.45508%2020.0006C5.45508%2028.0338%2011.9673%2034.546%2020.0006%2034.546C28.0338%2034.546%2034.546%2028.0338%2034.546%2020.0006C34.546%2011.9673%2028.0338%205.45508%2020.0006%205.45508C11.9673%205.45508%205.45508%2011.9673%205.45508%2020.0006ZM17.3137%2015.3145C16.2091%2015.3145%2015.3137%2016.2099%2015.3137%2017.3145V22.6882C15.3137%2023.7928%2016.2091%2024.6882%2017.3137%2024.6882H22.6874C23.792%2024.6882%2024.6874%2023.7928%2024.6874%2022.6882V17.3145C24.6874%2016.2099%2023.792%2015.3145%2022.6874%2015.3145H17.3137Z'%20fill='white'/%3e%3c/svg%3e", kAe = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='52'%20height='52'%20viewBox='0%200%2046%2052'%20class='default-thema'%3e%3cg%3e%3cpath%20d='M23.426%209.819l3.875-2.237v-5.345l-3.875-2.237z'%3e%3c/path%3e%3cpath%20d='M9.161%2033.085v-15.033l12.949-7.472v-10.58l-21.452%2012.386a1.314%201.314%200%200%200-.658%201.14v24.774l.007.073z'%3e%3c/path%3e%3cpath%20d='M35.991%2046.69l-12.957%207.487-12.883-7.443-9.161%205.293%2021.386%2012.35a1.322%201.322%200%200%200%201.316%200l21.453-12.386.015-.007z'%20transform='translate(-.266%20-12.552)'%3e%3c/path%3e%3cpath%20d='M54.893%2015.136l-8.5-4.906v5.337l-9.143%205.279%209.139%205.272v9.622l9.161%205.286v-24.749a1.346%201.346%200%200%200-.657-1.141z'%20transform='translate(27.236%207.48)%20translate(-37.25%20-10.23)'%3e%3c/path%3e%3cpath%20d='M18.228%2023.288l.007%2010.478%208.891-5.133v-10.478z'%3e%3c/path%3e%3c/g%3e%3c/svg%3e", _Ae = "data:image/svg+xml,%3csvg%20width='300'%20height='300'%20viewBox='0%200%20300%20300'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M298.203%2083.7645L170.449%200V46.8332L252.405%20100.089L242.763%20130.598H170.449V169.402H242.763L252.405%20199.911L170.449%20253.167V300L298.203%20216.503L277.313%20150.134L298.203%2083.7645Z'%20fill='url(%23paint0_linear_1661_295)'/%3e%3cpath%20d='M59.3007%20169.402H131.346V130.598H59.0329L49.6589%20100.089L131.346%2046.8332V0L3.59253%2083.7645L24.4831%20150.134L3.59253%20216.503L131.614%20300V253.167L49.6589%20199.911L59.3007%20169.402Z'%20fill='url(%23paint1_linear_1661_295)'/%3e%3cmask%20id='mask0_1661_295'%20style='mask-type:alpha'%20maskUnits='userSpaceOnUse'%20x='3'%20y='0'%20width='296'%20height='300'%3e%3cpath%20d='M298.204%2083.7645L170.45%200V46.8332L252.405%20100.089L242.763%20130.598H170.45V169.402H242.763L252.405%20199.911L170.45%20253.167V300L298.204%20216.503L277.313%20150.134L298.204%2083.7645Z'%20fill='url(%23paint2_linear_1661_295)'/%3e%3cpath%20d='M59.301%20169.402H131.347V130.598H59.0332L49.6592%20100.089L131.347%2046.8332V0L3.59277%2083.7645L24.4834%20150.134L3.59277%20216.503L131.615%20300V253.167L49.6592%20199.911L59.301%20169.402Z'%20fill='url(%23paint3_linear_1661_295)'/%3e%3c/mask%3e%3cg%20mask='url(%23mask0_1661_295)'%3e%3crect%20x='3.75024'%20width='292.5'%20height='300'%20fill='url(%23paint4_linear_1661_295)'/%3e%3c/g%3e%3cdefs%3e%3clinearGradient%20id='paint0_linear_1661_295'%20x1='256.875'%20y1='320.625'%20x2='171.3'%20y2='-32.9459'%20gradientUnits='userSpaceOnUse'%3e%3cstop%20stop-color='%230B46F9'/%3e%3cstop%20offset='1'%20stop-color='%23BBFBE0'/%3e%3c/linearGradient%3e%3clinearGradient%20id='paint1_linear_1661_295'%20x1='256.875'%20y1='320.625'%20x2='171.3'%20y2='-32.9459'%20gradientUnits='userSpaceOnUse'%3e%3cstop%20stop-color='%230B46F9'/%3e%3cstop%20offset='1'%20stop-color='%23BBFBE0'/%3e%3c/linearGradient%3e%3clinearGradient%20id='paint2_linear_1661_295'%20x1='256.875'%20y1='320.625'%20x2='171.3'%20y2='-32.9459'%20gradientUnits='userSpaceOnUse'%3e%3cstop%20stop-color='%230B46F9'/%3e%3cstop%20offset='1'%20stop-color='%23BBFBE0'/%3e%3c/linearGradient%3e%3clinearGradient%20id='paint3_linear_1661_295'%20x1='256.875'%20y1='320.625'%20x2='171.3'%20y2='-32.9459'%20gradientUnits='userSpaceOnUse'%3e%3cstop%20stop-color='%230B46F9'/%3e%3cstop%20offset='1'%20stop-color='%23BBFBE0'/%3e%3c/linearGradient%3e%3clinearGradient%20id='paint4_linear_1661_295'%20x1='22.5002'%20y1='67.5'%20x2='170.625'%20y2='178.125'%20gradientUnits='userSpaceOnUse'%3e%3cstop%20offset='0.119792'%20stop-color='%238952FF'%20stop-opacity='0.87'/%3e%3cstop%20offset='1'%20stop-color='%23DABDFF'%20stop-opacity='0'/%3e%3c/linearGradient%3e%3c/defs%3e%3c/svg%3e", IAe = "data:image/svg+xml,%3csvg%20width='100%25'%20height='100%25'%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20153.42%20152.94'%3e%3cpath%20d='M145.15,75.59v-58a9.29,9.29,0,0,0-9.3-9.28H77.65a2.24,2.24,0,0,1-1.56-.64l-7-7A2.24,2.24,0,0,0,67.48,0H9.31A9.29,9.29,0,0,0,0,9.27H0v58a2.16,2.16,0,0,0,.65,1.55l7,7a2.16,2.16,0,0,1,.65,1.55v58a9.29,9.29,0,0,0,9.3,9.28H75.8a2.24,2.24,0,0,1,1.56.64l7,7a2.24,2.24,0,0,0,1.56.64h58.19a9.29,9.29,0,0,0,9.31-9.27h0v-58a2.16,2.16,0,0,0-.65-1.55l-7-7A2.17,2.17,0,0,1,145.15,75.59Zm-32.3,38.55H40.65A1.68,1.68,0,0,1,39,112.47V40.53a1.68,1.68,0,0,1,1.67-1.67h72.18a1.68,1.68,0,0,1,1.67,1.67v71.94a1.68,1.68,0,0,1-1.67,1.67Z'%20transform='translate(0%200)'%3e%3c/path%3e%3c/svg%3e", PAe = "data:image/svg+xml,%3c?xml%20version='1.0'%20encoding='UTF-8'?%3e%3csvg%20xmlns='http://www.w3.org/2000/svg'%20x='0px'%20y='0px'%20viewBox='0%200%202500%202500'%20style='enable-background:new%200%200%202500%202500;'%3e%3cstyle%20type='text/css'%3e%20.st0{fill-rule:evenodd;clip-rule:evenodd;fill:url(%23SVGID_1_);}%20.st1{fill-rule:evenodd;clip-rule:evenodd;fill:%23FFFFFF;}%20%3c/style%3e%3cg%20%3e%3cradialGradient%20id='SVGID_1_'%20cx='892.72'%20cy='1499.8098'%20r='800'%20gradientTransform='matrix(1.5625%200%200%20-1.5625%20-844.5%203043.2029)'%20gradientUnits='userSpaceOnUse'%3e%3cstop%20offset='0'%20style='stop-color:%23EF7937'%3e%3c/stop%3e%3cstop%20offset='0.502'%20style='stop-color:%23EA7839'%3e%3c/stop%3e%3cstop%20offset='0.7843'%20style='stop-color:%23DF773D'%3e%3c/stop%3e%3cstop%20offset='1'%20style='stop-color:%23D57641'%3e%3c/stop%3e%3c/radialGradient%3e%3cpath%20class='st0'%20d='M509.1,0h1481.9c280,0,509.1,229.1,509.1,509.1v1481.9c0,280-229.1,509.1-509.1,509.1H509.1C229.1,2500,0,2270.9,0,1990.9V509.1C0,229.1,229.1,0,509.1,0L509.1,0z'%3e%3c/path%3e%3cpath%20class='st1'%20d='M1960.3,430.2l-38.4,103.4l-19.6,50.8c-148.7,380.7-264.3,561.4-387.2,561.4c-70.8,0-112.8-21.2-167-70.8l-15.7-14.7c-39.1-37.3-55.5-46.5-93.1-46.5c-19.6,0-54.6,26-98.9,86.5c-46,62.8-96.4,155.6-150.6,277.8l-5,11.4l527.4,0l-65.7,140.9H953.9v578.6H809.2v-1679L1960.3,430.2L1960.3,430.2z%20M1755.1,571.2l-801.2-0.1v559.6c96-172.2,187.2-258.7,285.3-258.7c76.3,0,121.2,22.2,178,73.9l16.2,15.2c36.5,34.8,50.5,42.8,81.6,42.8C1549.4,1003.9,1640.6,854.3,1755.1,571.2z'%3e%3c/path%3e%3c/g%3e%3c/svg%3e", RAe = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%20width='600px'%20height='600px'%20viewBox='0%200%20600%20600'%3e%3cdefs%3e%3cpolygon%20id='path-1'%20points='0%200%20600%200%20600%20600%200%20600'/%3e%3c/defs%3e%3cg%20id='换色'%20stroke='none'%20stroke-width='1'%20fill='none'%20fill-rule='evenodd'%3e%3cg%20id='SVG'%20transform='translate(-1755.000000,%20-5518.000000)'%3e%3cg%20id='编组-7'%20transform='translate(1755.000000,%205518.000000)'%3e%3cg%20id='编组'%3e%3cmask%20id='mask-2'%20fill='white'%3e%3cuse%20xlink:href='%23path-1'/%3e%3c/mask%3e%3cg%20id='Clip-2'/%3e%3cpath%20d='M300,464.998427%20C208.873069,464.998427%20134.996504,391.122566%20134.996504,299.996504%20C134.996504,208.870442%20208.873069,135.000938%20300,135.000938%20L300,-0.000635600624%20C134.310049,-0.000635600624%200,134.314489%200,299.996504%20C0,465.67852%20134.310049,600%20300,600%20C465.689951,600%20600,465.67852%20600,299.996504%20L465.003496,299.996504%20C465.003496,391.122566%20391.126931,464.998427%20300,464.998427'%20id='Fill-1'%20fill='%232354E6'%20mask='url(%23mask-2)'/%3e%3c/g%3e%3cpolygon%20id='Fill-3'%20fill='%2317E6A1'%20points='299.992373%20299.99714%20464.995869%20299.99714%20464.995869%20134.995217%20299.992373%20134.995217'/%3e%3c/g%3e%3c/g%3e%3c/g%3e%3c/svg%3e", OAe = "data:image/svg+xml,%3csvg%20width='100%25'%20height='100%25'%20viewBox='0%200%20189%20188'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M94.5%200.25C42.75%200.25%200.75%2042.25%200.75%2094C0.75%20145.75%2042.75%20187.5%2094.5%20187.5C146.25%20187.5%20188.25%20145.5%20188.25%2093.75C188.25%2042%20146.25%200.25%2094.5%200.25ZM119.25%20114.25C113%20114.25%2097.5%20114.5%2097.5%20114.5L90.5%20141.5H61.5L68.25%20115H23L30.25%2093.25C30.25%2093.25%20109%2093.5%20115.5%2093.25C122%2093%20132%2091.5%20132.25%2078.5C132.5%2060.75%20105.25%2061.75%20103%2077.5C101.5%2087.5%20101.5%2090%20101.5%2090H75.75L80.75%2066.5H39L45.25%2044.5C45.25%2044.5%20106.5%2044.75%20118%2044.75C129.5%2044.75%20160.25%2047.75%20160.25%2076C160.25%20107%20130.5%20114.25%20119.25%20114.25V114.25Z'%20fill='%231A72FE'/%3e%3c/svg%3e", DAe = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='100%25'%20height='100%25'%20viewBox='0%200%2093%2093'%3e%3cdefs%3e%3clinearGradient%20id='a'%20x1='97.185%25'%20x2='-.038%25'%20y1='3.105%25'%20y2='99.699%25'%3e%3cstop%20offset='0%25'%20stop-color='%2311C4D1'/%3e%3cstop%20offset='100%25'%20stop-color='%230062AD'/%3e%3c/linearGradient%3e%3c/defs%3e%3cg%20fill='none'%20fill-rule='nonzero'%3e%3cpath%20fill='url(%23a)'%20d='M92.755%2063.804s0%209.64-1.028%2013.78c-1.028%204.187-2.985%207.06-5.09%209.202-2.154%202.142-4.993%204.09-9.3%205.112-4.356%201.023-13.754.974-13.754.974H29.417s-9.642%200-13.803-1.022c-4.16-1.071-7.097-2.97-9.25-5.113-2.155-2.142-4.112-4.966-5.091-9.3-1.028-4.333-.98-13.682-.98-13.682V29.671s0-9.64%201.029-13.78c1.027-4.187%202.985-7.06%205.09-9.202%202.154-2.142%204.993-4.09%209.3-5.113C20.068.554%2029.466.603%2029.466.603h34.166s9.642%200%2013.803%201.022c4.16%201.071%207.097%202.97%209.25%205.113%202.154%202.142%204.112%204.966%205.091%209.3.98%204.333.98%2013.682.98%2013.682v34.084z'/%3e%3cpath%20fill='%23FFF'%20d='M78.267%2028.795c1.909%2026.244-15.614%2038.71-31.326%2040.073-14.587%201.265-28.292-7.304-29.467-20.597-.979-10.955%206.07-15.678%2011.6-16.117%205.679-.486%2010.427%203.263%2010.867%207.84.392%204.382-2.447%206.427-4.454%206.573-1.566.146-3.524-.78-3.72-2.727-.147-1.704.538-1.899.342-3.7-.293-3.214-3.181-3.555-4.747-3.409-1.91.146-5.385%202.338-4.944%207.694.49%205.404%205.874%209.69%2012.922%209.056%207.636-.682%2012.971-6.378%2013.363-14.412%200-.439.098-.828.293-1.218.098-.146.147-.292.294-.438.196-.292.392-.536.636-.779l.686-.682c3.328-3.019%2015.37-10.225%2026.676-7.985.098%200%20.196.049.245.097.44%200%20.685.341.734.73'/%3e%3c/g%3e%3c/svg%3e", NAe = "data:image/svg+xml,%3csvg%20viewBox='0%200%2036%2012'%20width='100%25'%20height='100%25'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%20class=''%3e%3cpath%20d='M1.888%201.702l-.03.028A5.924%205.924%200%2000.08%205.046c-.052.308-.078.62-.079.93v.036c0%20.3.025.598.072.894.148.923.522%201.82%201.122%202.612.198.261.42.511.668.747l.026.025a6.211%206.211%200%20001.772%201.173c2.342%201.026%205.194.55%207.327-1.16a.496.496%200%2001.017-.013c2.408-1.941%204.618-3.7%206.996-3.7s4.588%201.759%206.996%203.7a7.842%207.842%200%20002.13%201.224c.988.376%202.031.538%203.05.47a6.28%206.28%200%20003.936-1.694l.026-.025c.248-.236.47-.486.669-.747.6-.792.973-1.689%201.12-2.612a5.754%205.754%200%2000-.006-1.86%205.926%205.926%200%2000-1.78-3.316l-.03-.028C32.996.65%2031.61.106%2030.177.014a7.323%207.323%200%2000-3.053.474%207.93%207.93%200%2000-2.127%201.214c-2.417%201.93-4.606%203.7-6.996%203.7-2.39%200-4.579-1.77-6.996-3.7l-.013-.01C9.606.592%207.917%200%206.261%200c-.895%200-1.78.173-2.603.531a6.168%206.168%200%2000-1.77%201.171z'%20fill='url(%23paint0_radial)'%3e%3c/path%3e%3cdefs%3e%3cradialGradient%20id='paint0_radial'%20cx='0'%20cy='0'%20r='1'%20gradientUnits='userSpaceOnUse'%20gradientTransform='matrix(41.2215%200%200%2021.0874%20-.869%203.328)'%3e%3cstop%20stop-color='%231CE5C3'%3e%3c/stop%3e%3cstop%20offset='.103'%20stop-color='%231CE5C3'%3e%3c/stop%3e%3cstop%20offset='.475'%20stop-color='%235440D7'%3e%3c/stop%3e%3cstop%20offset='.631'%20stop-color='%238B2CE4'%3e%3c/stop%3e%3cstop%20offset='.796'%20stop-color='%23D421EB'%3e%3c/stop%3e%3cstop%20offset='1'%20stop-color='%23AC39FD'%3e%3c/stop%3e%3c/radialGradient%3e%3c/defs%3e%3c/svg%3e", MAe = "/assets/mathWallet-BeN17fSf.svg", $Ae = "data:image/svg+xml,%3csvg%20fill='none'%20height='33'%20viewBox='0%200%2035%2033'%20width='35'%20xmlns='http://www.w3.org/2000/svg'%3e%3cg%20stroke-linecap='round'%20stroke-linejoin='round'%20stroke-width='.25'%3e%3cpath%20d='m32.9582%201-13.1341%209.7183%202.4424-5.72731z'%20fill='%23e17726'%20stroke='%23e17726'/%3e%3cg%20fill='%23e27625'%20stroke='%23e27625'%3e%3cpath%20d='m2.66296%201%2013.01714%209.809-2.3254-5.81802z'/%3e%3cpath%20d='m28.2295%2023.5335-3.4947%205.3386%207.4829%202.0603%202.1436-7.2823z'/%3e%3cpath%20d='m1.27281%2023.6501%202.13055%207.2823%207.46994-2.0603-3.48166-5.3386z'/%3e%3cpath%20d='m10.4706%2014.5149-2.0786%203.1358%207.405.3369-.2469-7.969z'/%3e%3cpath%20d='m25.1505%2014.5149-5.1575-4.58704-.1688%208.05974%207.4049-.3369z'/%3e%3cpath%20d='m10.8733%2028.8721%204.4819-2.1639-3.8583-3.0062z'/%3e%3cpath%20d='m20.2659%2026.7082%204.4689%202.1639-.6105-5.1701z'/%3e%3c/g%3e%3cpath%20d='m24.7348%2028.8721-4.469-2.1639.3638%202.9025-.039%201.231z'%20fill='%23d5bfb2'%20stroke='%23d5bfb2'/%3e%3cpath%20d='m10.8732%2028.8721%204.1572%201.9696-.026-1.231.3508-2.9025z'%20fill='%23d5bfb2'%20stroke='%23d5bfb2'/%3e%3cpath%20d='m15.1084%2021.7842-3.7155-1.0884%202.6243-1.2051z'%20fill='%23233447'%20stroke='%23233447'/%3e%3cpath%20d='m20.5126%2021.7842%201.0913-2.2935%202.6372%201.2051z'%20fill='%23233447'%20stroke='%23233447'/%3e%3cpath%20d='m10.8733%2028.8721.6495-5.3386-4.13117.1167z'%20fill='%23cc6228'%20stroke='%23cc6228'/%3e%3cpath%20d='m24.0982%2023.5335.6366%205.3386%203.4946-5.2219z'%20fill='%23cc6228'%20stroke='%23cc6228'/%3e%3cpath%20d='m27.2291%2017.6507-7.405.3369.6885%203.7966%201.0913-2.2935%202.6372%201.2051z'%20fill='%23cc6228'%20stroke='%23cc6228'/%3e%3cpath%20d='m11.3929%2020.6958%202.6242-1.2051%201.0913%202.2935.6885-3.7966-7.40495-.3369z'%20fill='%23cc6228'%20stroke='%23cc6228'/%3e%3cpath%20d='m8.392%2017.6507%203.1049%206.0513-.1039-3.0062z'%20fill='%23e27525'%20stroke='%23e27525'/%3e%3cpath%20d='m24.2412%2020.6958-.1169%203.0062%203.1049-6.0513z'%20fill='%23e27525'%20stroke='%23e27525'/%3e%3cpath%20d='m15.797%2017.9876-.6886%203.7967.8704%204.4833.1949-5.9087z'%20fill='%23e27525'%20stroke='%23e27525'/%3e%3cpath%20d='m19.8242%2017.9876-.3638%202.3584.1819%205.9216.8704-4.4833z'%20fill='%23e27525'%20stroke='%23e27525'/%3e%3cpath%20d='m20.5127%2021.7842-.8704%204.4834.6236.4406%203.8584-3.0062.1169-3.0062z'%20fill='%23f5841f'%20stroke='%23f5841f'/%3e%3cpath%20d='m11.3929%2020.6958.104%203.0062%203.8583%203.0062.6236-.4406-.8704-4.4834z'%20fill='%23f5841f'%20stroke='%23f5841f'/%3e%3cpath%20d='m20.5906%2030.8417.039-1.231-.3378-.2851h-4.9626l-.3248.2851.026%201.231-4.1572-1.9696%201.4551%201.1921%202.9489%202.0344h5.0536l2.962-2.0344%201.442-1.1921z'%20fill='%23c0ac9d'%20stroke='%23c0ac9d'/%3e%3cpath%20d='m20.2659%2026.7082-.6236-.4406h-3.6635l-.6236.4406-.3508%202.9025.3248-.2851h4.9626l.3378.2851z'%20fill='%23161616'%20stroke='%23161616'/%3e%3cpath%20d='m33.5168%2011.3532%201.1043-5.36447-1.6629-4.98873-12.6923%209.3944%204.8846%204.1205%206.8983%202.0085%201.52-1.7752-.6626-.4795%201.0523-.9588-.8054-.622%201.0523-.8034z'%20fill='%23763e1a'%20stroke='%23763e1a'/%3e%3cpath%20d='m1%205.98873%201.11724%205.36447-.71451.5313%201.06527.8034-.80545.622%201.05228.9588-.66255.4795%201.51997%201.7752%206.89835-2.0085%204.8846-4.1205-12.69233-9.3944z'%20fill='%23763e1a'%20stroke='%23763e1a'/%3e%3cpath%20d='m32.0489%2016.5234-6.8983-2.0085%202.0786%203.1358-3.1049%206.0513%204.1052-.0519h6.1318z'%20fill='%23f5841f'%20stroke='%23f5841f'/%3e%3cpath%20d='m10.4705%2014.5149-6.89828%202.0085-2.29944%207.1267h6.11883l4.10519.0519-3.10487-6.0513z'%20fill='%23f5841f'%20stroke='%23f5841f'/%3e%3cpath%20d='m19.8241%2017.9876.4417-7.5932%202.0007-5.4034h-8.9119l2.0006%205.4034.4417%207.5932.1689%202.3842.013%205.8958h3.6635l.013-5.8958z'%20fill='%23f5841f'%20stroke='%23f5841f'/%3e%3c/g%3e%3c/svg%3e", LAe = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%20id='Layer_1'%20x='0px'%20y='0px'%20viewBox='0%200%202500%202500'%20style='enable-background:new%200%200%202500%202500;'%20xml:space='preserve'%3e%3cstyle%20type='text/css'%3e%20.st0{fill-rule:evenodd;clip-rule:evenodd;}%20.st1{fill:%23FFFFFF;}%20%3c/style%3e%3cg%20id='Layer_x0020_1'%3e%3cg%20id='_2187381323856'%3e%3crect%20y='0'%20class='st0'%20width='2500'%20height='2500'%3e%3c/rect%3e%3cg%3e%3cpath%20class='st1'%20d='M1463,1015h-404c-17,0-31,14-31,31v404c0,17,14,31,31,31h404c17,0,31-14,31-31v-404%20C1494,1029,1480,1015,1463,1015z'%3e%3c/path%3e%3cpath%20class='st1'%20d='M996,549H592c-17,0-31,14-31,31v404c0,17,14,31,31,31h404c17,0,31-14,31-31V580C1027,563,1013,549,996,549z'%3e%3c/path%3e%3cpath%20class='st1'%20d='M1930,549h-404c-17,0-31,14-31,31v404c0,17,14,31,31,31h404c17,0,31-14,31-31V580%20C1961,563,1947,549,1930,549z'%3e%3c/path%3e%3cpath%20class='st1'%20d='M996,1482H592c-17,0-31,14-31,31v404c0,17,14,31,31,31h404c17,0,31-14,31-31v-404%20C1027,1496,1013,1482,996,1482z'%3e%3c/path%3e%3cpath%20class='st1'%20d='M1930,1482h-404c-17,0-31,14-31,31v404c0,17,14,31,31,31h404c17,0,31-14,31-31v-404%20C1961,1496,1947,1482,1930,1482z'%3e%3c/path%3e%3c/g%3e%3c/g%3e%3c/g%3e%3c/svg%3e", BAe = "/assets/oneInch-kx6436tv.svg", FAe = "data:image/svg+xml,%3csvg%20width='100%25'%20height='100%25'%20viewBox='0%200%20256%20256'%20xmlns='http://www.w3.org/2000/svg'%20preserveAspectRatio='xMidYMid'%3e%3cdefs%3e%3clinearGradient%20x1='50.0025785%25'%20y1='1.63039062%25'%20x2='50.0025785%25'%20y2='98.5448437%25'%20id='linearGradient-1'%3e%3cstop%20stop-color='%23FF1B2D'%20offset='30%25'%3e%3c/stop%3e%3cstop%20stop-color='%23FA1A2C'%20offset='43.81%25'%3e%3c/stop%3e%3cstop%20stop-color='%23ED1528'%20offset='59.39%25'%3e%3c/stop%3e%3cstop%20stop-color='%23D60E21'%20offset='75.81%25'%3e%3c/stop%3e%3cstop%20stop-color='%23B70519'%20offset='92.72%25'%3e%3c/stop%3e%3cstop%20stop-color='%23A70014'%20offset='100%25'%3e%3c/stop%3e%3c/linearGradient%3e%3clinearGradient%20x1='49.9902998%25'%20y1='0.852967626%25'%20x2='49.9902998%25'%20y2='99.5189748%25'%20id='linearGradient-2'%3e%3cstop%20stop-color='%239C0000'%20offset='0%25'%3e%3c/stop%3e%3cstop%20stop-color='%23FF4B4B'%20offset='70%25'%3e%3c/stop%3e%3c/linearGradient%3e%3c/defs%3e%3cg%3e%3cpath%20d='M85.9,200.1%20C71.7,183.4%2062.6,158.7%2062,131%20L62,125%20C62.6,97.3%2071.8,72.6%2085.9,55.9%20C104.3,32.1%20131.3,21.4%20161.8,21.4%20C180.6,21.4%20198.3,22.7%20213.3,32.7%20C190.8,12.4%20161.1,0.1%20128.5,0%20L128,0%20C57.3,0%200,57.3%200,128%20C0,196.6%2054,252.7%20121.9,255.9%20C123.9,256%20126,256%20128,256%20C160.8,256%20190.7,243.7%20213.3,223.4%20C198.3,233.4%20181.6,233.8%20162.8,233.8%20C132.4,233.9%20104.2,224%2085.9,200.1%20L85.9,200.1%20Z'%20fill='url(%23linearGradient-1)'%3e%3c/path%3e%3cpath%20d='M85.9,55.9%20C97.6,42%20112.8,33.7%20129.4,33.7%20C166.7,33.7%20196.9,75.9%20196.9,128.1%20C196.9,180.3%20166.7,222.5%20129.4,222.5%20C112.8,222.5%2097.7,214.1%2085.9,200.3%20C104.3,224.1%20131.6,239.3%20162,239.3%20C180.7,239.3%20198.3,233.6%20213.3,223.6%20C239.5,200%20256,165.9%20256,128%20C256,90.1%20239.5,56%20213.3,32.6%20C198.3,22.6%20180.8,16.9%20162,16.9%20C131.5,16.9%20104.2,32%2085.9,55.9%20L85.9,55.9%20Z'%20fill='url(%23linearGradient-2)'%3e%3c/path%3e%3c/g%3e%3c/svg%3e", jAe = "data:image/svg+xml,%3csvg%20width='100%25'%20height='100%25'%20viewBox='0%200%20132%20132'%20xmlns='http://www.w3.org/2000/svg'%3e%3cdefs%3e%3clinearGradient%20x1='15.8%25'%20y1='84.9%25'%20x2='106.3%25'%20y2='-17.2%25'%20id='linearGradient-1'%3e%3cstop%20stop-color='%230877FF'%20offset='0%25'%3e%3c/stop%3e%3cstop%20stop-color='%233CCEF9'%20offset='100%25'%3e%3c/stop%3e%3c/linearGradient%3e%3c/defs%3e%3cg%20id='Page-2'%20stroke='none'%20stroke-width='1'%20fill='none'%20fill-rule='evenodd'%3e%3cpath%20d='M65.8599735,0.000607031223%20C64.4416737,0.000607031223%2063.0363726,0.0454744869%2061.6440701,0.135209398%20C59.3754119,0.301605871%2057.6214113,2.19771449%2057.6274798,4.47722124%20L57.6274798,32.8001645%20C57.6294466,34.0359685%2058.1568063,35.2123819%2059.0774227,36.0346405%20C59.9980391,36.8568991%2061.224677,37.2470878%2062.4499879,37.1074402%20C63.5818523,36.9749894%2064.7204182,36.9083004%2065.8599735,36.9077077%20C77.6016631,36.9077077%2088.1871903,43.995619%2092.6805403,54.8663598%20C97.1738904,65.7371006%2094.690175,78.2498645%2086.3875466,86.5699693%20C78.0849183,94.8900741%2065.5984376,97.3790175%2054.7505309,92.8762093%20C43.9026243,88.373401%2036.8296011,77.765592%2036.8296011,65.999187%20L36.8296011,19.2231276%20C36.8304083,16.5637094%2035.3161377,14.1371901%2032.9297089,12.9738059%20C30.54328,11.8104217%2027.7035052,12.1143438%2025.6160782,13.7565347%20C9.44722987,26.2414401%20-0.0174670853,45.544213%202.42011117e-05,65.999187%20C2.42011117e-05,102.411298%2030.0832892,132.297366%2066.4189165,131.997767%20C102.792362,131.843094%20132.153742,102.169136%20131.999394,65.7191272%20C131.845046,29.269118%20102.233419,-0.154065705%2065.8599735,0.000607031223%20Z'%20id='Shape-Copy'%20fill='url(%23linearGradient-1)'%20fill-rule='nonzero'%3e%3c/path%3e%3c/g%3e%3c/svg%3e", UAe = "data:image/svg+xml,%3csvg%20width='100%25'%20height='100%25'%20viewBox='0%200%2024%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M21%2018V19C21%2020.1%2020.1%2021%2019%2021H5C3.89%2021%203%2020.1%203%2019V5C3%203.9%203.89%203%205%203H19C20.1%203%2021%203.9%2021%205V6H12C10.89%206%2010%206.9%2010%208V16C10%2017.1%2010.89%2018%2012%2018H21ZM12%2016H22V8H12V16ZM16%2013.5C15.17%2013.5%2014.5%2012.83%2014.5%2012C14.5%2011.17%2015.17%2010.5%2016%2010.5C16.83%2010.5%2017.5%2011.17%2017.5%2012C17.5%2012.83%2016.83%2013.5%2016%2013.5Z'%20fill='black'/%3e%3c/svg%3e", zAe = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='32'%20height='32'%20fill='none'%20viewBox='0%200%2032%2032'%3e%3cpath%20fill='url(%23a)'%20d='M29.514%2017.732C30.6%2015.298%2025.23%208.496%2020.1%205.662c-3.233-2.196-6.603-1.894-7.285-.93-1.498%202.115%204.959%203.908%209.277%206-.928.404-1.803%201.13-2.317%202.058-1.61-1.763-5.144-3.282-9.29-2.058-2.793.824-5.115%202.767-6.013%205.702A1.762%201.762%200%200%200%202%2018.047c0%20.975.787%201.765%201.759%201.765.18%200%20.743-.12.743-.12l8.995.065c-3.597%205.726-6.44%206.563-6.44%207.555s2.72.723%203.741.354c4.89-1.77%2010.142-7.288%2011.043-8.876%203.784.474%206.965.53%207.673-1.058Z'/%3e%3cpath%20fill='url(%23b)'%20fill-rule='evenodd'%20d='M22.091%2010.732c.2-.08.168-.376.113-.609-.126-.535-2.305-2.694-4.352-3.662-2.789-1.318-4.843-1.25-5.146-.642.568%201.168%203.202%202.265%205.952%203.41%201.174.49%202.369.987%203.433%201.503Z'%20clip-rule='evenodd'/%3e%3cpath%20fill='url(%23c)'%20fill-rule='evenodd'%20d='M18.552%2022.49a16.498%2016.498%200%200%200-1.925-.595c.772-1.386.934-3.439.205-4.737-1.024-1.821-2.309-2.79-5.295-2.79-1.642%200-6.064.554-6.142%204.258-.009.389%200%20.745.028%201.072l8.074.059c-1.089%201.733-2.108%203.018-3%203.995%201.07.275%201.955.507%202.767.719.77.201%201.476.386%202.214.575a33.648%2033.648%200%200%200%203.074-2.556Z'%20clip-rule='evenodd'/%3e%3cpath%20fill='url(%23d)'%20d='M4.364%2019.318c.33%202.813%201.924%203.916%205.18%204.242%203.256.326%205.124.107%207.61.334%202.078.19%203.932%201.252%204.62.885.62-.33.273-1.524-.556-2.29-1.073-.992-2.56-1.681-5.175-1.926.521-1.432.375-3.44-.434-4.532-1.17-1.58-3.33-2.293-6.065-1.981-2.857.326-5.594%201.737-5.18%205.268Z'/%3e%3cdefs%3e%3clinearGradient%20id='a'%20x1='10.16'%20x2='29.29'%20y1='15.576'%20y2='20.983'%20gradientUnits='userSpaceOnUse'%3e%3cstop%20stop-color='%238697FF'/%3e%3cstop%20offset='1'%20stop-color='%23ABB7FF'/%3e%3c/linearGradient%3e%3clinearGradient%20id='b'%20x1='26.06'%20x2='12.217'%20y1='15.211'%20y2='1.382'%20gradientUnits='userSpaceOnUse'%3e%3cstop%20stop-color='%238697FF'/%3e%3cstop%20offset='1'%20stop-color='%235156D8'%20stop-opacity='0'/%3e%3c/linearGradient%3e%3clinearGradient%20id='c'%20x1='18.936'%20x2='5.661'%20y1='22.973'%20y2='15.367'%20gradientUnits='userSpaceOnUse'%3e%3cstop%20stop-color='%23465EED'/%3e%3cstop%20offset='1'%20stop-color='%238697FF'%20stop-opacity='0'/%3e%3c/linearGradient%3e%3clinearGradient%20id='d'%20x1='11.301'%20x2='20.296'%20y1='15.433'%20y2='26.824'%20gradientUnits='userSpaceOnUse'%3e%3cstop%20stop-color='%238898FF'/%3e%3cstop%20offset='.984'%20stop-color='%236277F1'/%3e%3c/linearGradient%3e%3c/defs%3e%3c/svg%3e", HAe = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20id='Layer_1'%20data-name='Layer%201'%20viewBox='0%200%20661.62%20661.47'%3e%3cdefs%3e%3cstyle%3e%20.cls-1%20{%20fill:%20%2312ff80;%20}%20%3c/style%3e%3c/defs%3e%3cpath%20class='cls-1'%20d='M531.98,330.7h-49.42c-14.76,0-26.72,11.96-26.72,26.72v71.73c0,14.76-11.96,26.72-26.72,26.72H232.51c-14.76,0-26.72,11.96-26.72,26.72v49.42c0,14.76,11.96,26.72,26.72,26.72h207.99c14.76,0,26.55-11.96,26.55-26.72v-39.65c0-14.76,11.96-25.23,26.72-25.23h38.2c14.76,0,26.72-11.96,26.72-26.72v-83.3c0-14.76-11.96-26.41-26.72-26.41Z'/%3e%3cpath%20class='cls-1'%20d='M205.78,232.52c0-14.76,11.96-26.72,26.72-26.72h196.49c14.76,0,26.72-11.96,26.72-26.72v-49.42c0-14.76-11.96-26.72-26.72-26.72H221.11c-14.76,0-26.72,11.96-26.72,26.72v38.08c0,14.76-11.96,26.72-26.72,26.72h-38.03c-14.76,0-26.72,11.96-26.72,26.72v83.39c0,14.76,12.01,26.12,26.77,26.12h49.42c14.76,0,26.72-11.96,26.72-26.72l-.05-71.44Z'/%3e%3cpath%20class='cls-1'%20d='M307.55,278.75h47.47c15.47,0,28.02,12.56,28.02,28.02v47.47c0,15.47-12.56,28.02-28.02,28.02h-47.47c-15.47,0-28.02-12.56-28.02-28.02v-47.47c0-15.47,12.56-28.02,28.02-28.02Z'/%3e%3c/svg%3e", VAe = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='32'%20height='32'%20fill='none'%20viewBox='0%200%2032%2032'%3e%3cpath%20fill='%234A21EF'%20d='M14.521%204c-.73%200-1.43.29-1.947.807L4.461%2012.92a1.575%201.575%200%200%200-.001%202.226l5.318%205.316V11.05c0-.703.565-1.272%201.267-1.272h11.177L28%204H14.52ZM9.778%2022.222h11.173c.702%200%201.272-.57%201.272-1.271v-9.413l5.317%205.317c.307.307.46.71.46%201.112%200%20.403-.153.806-.46%201.113l-8.113%208.114a2.755%202.755%200%200%201-1.948.806H4.001l5.777-5.778Z'/%3e%3c/svg%3e", WAe = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%202000%202000'%20width='100%25'%20height='100%25'%3e%3ccircle%20cx='1000'%20cy='1000'%20r='1000'%20fill='%235b6dee'/%3e%3cpath%20d='M831.27%20938.79a571.5%20571.5%200%200%200-104%208.95c28.25-261.28%20246-459.12%20505.24-459.1%20158.73%200%20267.49%2077.72%20267.49%20238.64s-130.54%20238.64-321%20238.64c-140.58-.01-207.13-27.13-347.73-27.13m-10.27%2095.3c-190.45%200-321%2077.72-321%20238.64s108.76%20238.64%20267.49%20238.64c259.27%200%20477-197.82%20505.24-459.1a571.5%20571.5%200%200%201-104%208.95c-140.6-.01-207.15-27.13-347.73-27.13'%20fill='%23fff'/%3e%3c/svg%3e", qAe = "/assets/tallyho-DQ1qPfNZ.svg", GAe = "data:image/svg+xml,%3csvg%20version='1.0'%20xmlns='http://www.w3.org/2000/svg'%20width='256.000000pt'%20height='256.000000pt'%20viewBox='0%200%20256.000000%20256.000000'%20preserveAspectRatio='xMidYMid%20meet'%3e%3cg%20transform='translate(0.000000,256.000000)%20scale(0.100000,-0.100000)'%20fill='%232C7CF5'%20stroke='none'%3e%3cpath%20d='M1120%201915%20c-211%20-57%20-380%20-213%20-458%20-423%20-33%20-90%20-42%20-266%20-18%20-362%2054%20-216%20210%20-388%20424%20-468%2090%20-33%20266%20-42%20362%20-18%20216%2054%20388%20210%20468%20424%2033%2090%2042%20266%2018%20362%20-54%20216%20-210%20388%20-424%20468%20-85%2032%20-283%2041%20-372%2017z'/%3e%3c/g%3e%3c/svg%3e", KAe = "data:image/svg+xml,%3csvg%20width='100%25'%20height='100%25'%20xmlns='http://www.w3.org/2000/svg'%20x='0px'%20y='0px'%20viewBox='0%200%201024%201024'%20style='enable-background:new%200%200%201024%201024;'%20xml:space='preserve'%3e%3cstyle%20type='text/css'%3e%20.st0{fill:%232980FE;}%20.st1{opacity:0.6;fill:%23FFFFFF;}%20.st2{fill:%23FFFFFF;}%20%3c/style%3e%3crect%20x='0.5'%20y='-0.5'%20class='st0'%20width='1024'%20height='1024'/%3e%3cg%3e%3cpath%20class='st1'%20d='M464.1,389.7h-19.1V253.3h-252c-4.8,0-8.7,3.9-8.7,8.7v192.3l0,0l0,0c0,4.8,3.9,8.7,8.7,8.7h96.2v349.7l0,0%20l0,0c0,4.8,3.9,8.7,8.7,8.7h0l0,0h157.4c4.8,0,8.7-3.9,8.7-8.7l0,0l0,0V389.7z'/%3e%3cpath%20class='st2'%20d='M630.8,201.5h-60.5l0,0H404.2l0,0c-4.8,0-8.7,3.9-8.7,8.7V761l0,0l0,0c0,4.8,3.9,8.7,8.7,8.7l0,0h157.4%20c0,0,0,0,0,0c4.8,0,8.7-3.9,8.7-8.7V621.1h60.5c115.9,0,209.8-93.9,209.8-209.8C840.6,295.4,746.7,201.5,630.8,201.5z'/%3e%3c/g%3e%3c/svg%3e", QAe = "data:image/svg+xml,%3csvg%20width='100%25'%20height='100%25'%20viewBox='0%200%2040%2040'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='m1.36250526%206.825c-1.36250526%202.675-1.36250526%206.175-1.36250526%2013.175s0%2010.5%201.36250526%2013.1750526c1.2%202.35%203.11249474%204.2624211%205.46249474%205.4624211%202.675%201.3625263%206.175%201.3625263%2013.175%201.3625263s10.5%200%2013.1750526-1.3625263c2.35-1.2%204.2624211-3.1124211%205.4624211-5.4624211%201.3625263-2.6750526%201.3625263-6.1750526%201.3625263-13.1750526s0-10.5-1.3625263-13.175c-1.2-2.35-3.1124211-4.26249474-5.4624211-5.46249474-2.6750526-1.36250526-6.1750526-1.36250526-13.1750526-1.36250526s-10.5%200-13.175%201.36250526c-2.35%201.2-4.26249474%203.11249474-5.46249474%205.46249474zm28.61875794%203.9624737c.35%200%20.6812631.1437895.9250526.3875789.2436842.25.3812631.5874737.3751557.9311579-.0626294%203.7250527-.2064189%206.5750527-.4751557%208.8312632-.2625263%202.2563158-.6563158%203.9312631-1.25%205.2875789-.4.9062106-.8937895%201.6562106-1.4750526%202.2936842-.7812632.8437895-1.6749474%201.4563158-2.65%202.037579-.4168421.2492631-.8502106.4953684-1.3048421.7535789-.97.5508421-2.0365264%201.1565264-3.2451579%201.9651579-.4374737.2936842-1.0062106.2936842-1.4436843%200-1.2271578-.8181052-2.3077894-1.4312631-3.2866315-1.9865263-.2176842-.1234737-.4303158-.2441052-.6384211-.3634737-1.1436842-.6625263-2.1749474-1.2937894-3.0749474-2.2063158-.6-.6-1.1187368-1.3312631-1.5312631-2.2-.5625158-1.1625263-.94376843-2.5687368-1.22501054-4.3874736-.37501052-2.4312632-.56250526-5.6125264-.63146616-10.0250527-.0060391-.3436842.12521353-.6811579.3689609-.9311579.24374737-.2437894.5812526-.3875789.9312526-.3875789h.5375263c1.6562106.0063158%205.3124211-.1562105%208.4749474-2.61871581.4687369-.36250526%201.1250526-.36250526%201.5937895%200%203.1625263%202.46250531%206.8187368%202.62503161%208.4812631%202.61871581zm-2.9062106%2014.6063158c.4062106-.837579.7437895-1.9937895%201-3.6563158.3062106-1.9874737.4937895-4.6874737.5812632-8.3624211-1.95-.0563158-5.3-.4312631-8.4937895-2.5812631-3.1936842%202.1436842-6.5436842%202.5187368-8.4874737%202.5812631.0687369%203.0374737.2062106%205.4.4249474%207.2562106.25%202.1125263.6063158%203.5437894%201.05%204.55.2937895.6687368.6188421%201.15%201.0063158%201.5749473.5187368.5688421%201.1749474%201.037579%202.0687368%201.5750527.3707369.222421.7794737.4537894%201.2244211.7056842.7927368.4486315%201.7003158.9623158%202.7130526%201.6068421.9941053-.634%201.8886316-1.1424211%202.6721053-1.5877895.2362105-.1342105.4622105-.2627368.6778947-.3872632%201.1-.6312631%201.9125263-1.1562105%202.5187369-1.7687368.4063157-.4187368.7375789-.8749474%201.0437894-1.5062105z'%20fill='%233375bb'%20fill-rule='evenodd'/%3e%3c/svg%3e", YAe = "data:image/svg+xml,%3csvg%20height='512'%20viewBox='0%200%20512%20512'%20width='512'%20xmlns='http://www.w3.org/2000/svg'%3e%3cradialGradient%20id='a'%20cx='0%25'%20cy='50%25'%20r='100%25'%3e%3cstop%20offset='0'%20stop-color='%235d9df6'/%3e%3cstop%20offset='1'%20stop-color='%23006fff'/%3e%3c/radialGradient%3e%3cg%20fill='none'%20fill-rule='evenodd'%3e%3cpath%20d='m256%200c141.384896%200%20256%20114.615104%20256%20256s-114.615104%20256-256%20256-256-114.615104-256-256%20114.615104-256%20256-256z'%20fill='url(%23a)'/%3e%3cpath%20d='m64.6917558%2037.7088298c51.5328072-50.2784397%20135.0839942-50.2784397%20186.6167992%200l6.202057%206.0510906c2.57664%202.5139218%202.57664%206.5897948%200%209.1037177l-21.215998%2020.6995759c-1.288321%201.2569619-3.3771%201.2569619-4.665421%200l-8.534766-8.3270205c-35.950573-35.0754962-94.237969-35.0754962-130.188544%200l-9.1400282%208.9175519c-1.2883217%201.2569609-3.3771016%201.2569609-4.6654208%200l-21.2159973-20.6995759c-2.5766403-2.5139229-2.5766403-6.5897958%200-9.1037177zm230.4934852%2042.8089117%2018.882279%2018.4227262c2.576627%202.5139103%202.576642%206.5897593.000032%209.1036863l-85.141498%2083.070358c-2.576623%202.513941-6.754182%202.513969-9.33084.000066-.00001-.00001-.000023-.000023-.000033-.000034l-60.428256-58.957451c-.64416-.628481-1.68855-.628481-2.33271%200-.000004.000004-.000008.000007-.000012.000011l-60.4269683%2058.957408c-2.5766141%202.513947-6.7541746%202.51399-9.3308408.000092-.0000151-.000014-.0000309-.000029-.0000467-.000046l-85.14386774-83.071463c-2.57663928-2.513921-2.57663928-6.589795%200-9.1037163l18.88231264-18.4226955c2.5766393-2.5139222%206.7541993-2.5139222%209.3308397%200l60.4291347%2058.9582758c.6441608.62848%201.6885495.62848%202.3327103%200%20.0000095-.000009.0000182-.000018.0000277-.000025l60.4261065-58.9582508c2.576581-2.51398%206.754142-2.5140743%209.33084-.0002103.000037.0000354.000072.0000709.000107.0001063l60.429056%2058.9583548c.644159.628479%201.688549.628479%202.332709%200l60.428079-58.9571925c2.57664-2.5139231%206.754199-2.5139231%209.330839%200z'%20fill='%23fff'%20fill-rule='nonzero'%20transform='translate(98%20160)'/%3e%3c/g%3e%3c/svg%3e", JAe = "data:image/svg+xml,%3csvg%20width='100%25'%20height='100%25'%20viewBox='0%200%201025%201024'%20xmlns='http://www.w3.org/2000/svg'%3e%3cdefs%3e%3clinearGradient%20x1='0%25'%20y1='100%25'%20x2='100%25'%20y2='0%25'%20id='linearGradient-1'%3e%3cstop%20stop-color='%231550FF'%20offset='0%25'%3e%3c/stop%3e%3cstop%20stop-color='%230D8DFF'%20offset='100%25'%3e%3c/stop%3e%3c/linearGradient%3e%3c/defs%3e%3cg%20id='io'%20stroke='none'%20stroke-width='1'%20fill='none'%20fill-rule='evenodd'%20transform='translate(0.000000,%200.000000)'%3e%3cg%20id='编组'%3e%3crect%20id='矩形'%20fill='url(%23linearGradient-1)'%20x='0'%20y='0'%20width='1024'%20height='1024'%20rx='192'%3e%3c/rect%3e%3cg%20id='2'%20transform='translate(142.000000,%20354.000000)'%20fill='%23FFFFFF'%20fill-rule='nonzero'%3e%3cpath%20d='M731.739038,157.885431%20L653.658027,240.742988%20C643.041073,252.009426%20625.301078,252.535937%20614.03464,241.918982%20C612.84708,240.799883%20611.75951,239.579221%20610.784322,238.270905%20L529.136156,128.731487%20C521.006704,117.824991%20521.881341,102.656017%20531.210479,92.7561767%20L609.29149,9.89862053%20C619.908444,-1.36781768%20637.648439,-1.89432843%20648.914877,8.72262585%20C650.102437,9.84172546%20651.190007,11.0623873%20652.165195,12.3707028%20L733.813361,121.910121%20C741.942813,132.816618%20741.068176,147.985591%20731.739038,157.885431%20Z'%20id='路径'%3e%3c/path%3e%3cpath%20d='M586.491167,312.367718%20L508.410156,395.225274%20C497.793202,406.491713%20480.053207,407.018223%20468.786769,396.401269%20C467.599209,395.282169%20466.511639,394.061508%20465.536451,392.753192%20L268.220049,128.032931%20C260.090597,117.126435%20260.965235,101.957461%20270.294372,92.0576207%20L348.375384,9.20006454%20C358.992338,-2.06637367%20376.732333,-2.59288442%20387.998771,8.02406986%20C389.18633,9.14316947%20390.2739,10.3638313%20391.249089,11.6721468%20L588.56549,276.392408%20C596.694942,287.298904%20595.820305,302.467878%20586.491167,312.367718%20Z'%20id='路径'%20opacity='0.75'%3e%3c/path%3e%3cpath%20d='M586.345922,312.172858%20L508.264911,395.030414%20C497.647957,406.296852%20479.907962,406.823363%20468.641524,396.206409%20C467.453965,395.087309%20466.366395,393.866647%20465.391206,392.558332%20L369.686767,264.160976%20L486.808283,139.874642%20L588.420246,276.197548%20C596.549698,287.104044%20595.67506,302.273017%20586.345922,312.172858%20Z'%20id='路径'%3e%3c/path%3e%3cpath%20d='M128.683329,11.9400119%20L325.99973,276.660273%20C334.129182,287.566769%20333.254545,302.735743%20323.925407,312.635583%20L245.844396,395.493139%20C235.227442,406.759578%20217.487447,407.286088%20206.221009,396.669134%20C205.033449,395.550035%20203.945879,394.329373%20202.970691,393.021057%20L5.65428933,128.300796%20C-2.47516249,117.3943%20-1.60052498,102.225326%207.72861266,92.3254858%20L85.8096237,9.46792962%20C96.426578,-1.79850858%20114.166573,-2.32501933%20125.433011,8.29193494%20C126.620571,9.41103455%20127.708141,10.6316964%20128.683329,11.9400119%20Z'%20id='路径'%20opacity='0.5'%3e%3c/path%3e%3cpath%20d='M224.568875,140.58034%20L326.180837,276.903246%20C334.310289,287.809742%20333.435651,302.978716%20324.106514,312.878556%20L246.025503,395.736112%20C235.408548,407.002551%20217.668554,407.529061%20206.402115,396.912107%20C205.214556,395.793008%20204.126986,394.572346%20203.151797,393.26403%20L107.447358,264.866675%20L224.568875,140.58034%20Z'%20id='路径'%20opacity='0.5'%3e%3c/path%3e%3c/g%3e%3c/g%3e%3c/g%3e%3c/svg%3e", XAe = "data:image/svg+xml,%3csvg%20width='32'%20height='32'%20viewBox='0%200%2032%2032'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3ccircle%20cx='16'%20cy='16'%20r='16'%20fill='%23335DE5'%20/%3e%3cpath%20d='M17.9926%2017.2268C16.4455%2018.1729%2014.3747%2018.6602%2012.2775%2018.5561C10.5142%2018.471%209.06801%2017.8465%208.19356%2016.82C7.42482%2015.9022%207.12693%2014.6911%207.32873%2013.2979C7.39712%2012.8349%207.53728%2012.3849%207.74433%2011.9638L7.77316%2011.9047C8.49899%2010.5288%209.57617%209.36267%2010.8987%208.52108C12.2212%207.67955%2013.7435%207.19154%2015.3157%207.10518C16.8879%207.01878%2018.4559%207.33698%2019.8653%208.0284C21.2747%208.71986%2022.477%209.76072%2023.3538%2011.0486C24.2306%2012.3364%2024.7518%2013.8268%2024.8659%2015.3732C24.9801%2016.9196%2024.6833%2018.4686%2024.0049%2019.8677C23.3265%2021.2669%2022.2897%2022.4681%2020.9967%2023.3529C19.7036%2024.2378%2018.1989%2024.7759%2016.6305%2024.9143L16.7266%2026C18.4875%2025.8455%2020.1771%2025.2421%2021.6291%2024.2491C23.0811%2023.256%2024.2453%2021.9077%2025.007%2020.3369C25.7687%2018.7661%2026.1016%2017.0269%2025.973%2015.2909C25.8444%2013.5548%2025.2587%2011.8816%2024.2735%2010.4363C23.2884%208.99091%2021.9379%207.82319%2020.3549%207.0481C18.772%206.27303%2017.0113%205.91736%2015.2463%206.01615C13.4812%206.11494%2011.7728%206.66476%2010.2893%207.61146C8.80572%208.55814%207.59825%209.86905%206.78581%2011.4151L6.74737%2011.4931C6.49053%2012.0157%206.31712%2012.5742%206.23327%2013.1489C5.99304%2014.8472%206.3654%2016.3587%207.33833%2017.5225C8.40256%2018.7951%2010.1346%2019.552%2012.2126%2019.6513C14.7423%2019.7767%2017.2575%2019.0978%2019.0424%2017.8489L17.9926%2017.2268Z'%20fill='white'%20/%3e%3cpath%20d='M20.1088%2018.4614C19.1023%2019.3224%2016.7624%2020.8836%2012.8802%2021.0964C8.53444%2021.333%206.7231%2019.9421%206.70628%2019.9279L6.35554%2020.3537L6.70868%2019.935L6%2020.7724C6.07687%2020.8362%207.81374%2022.2176%2011.8929%2022.2176C12.2268%2022.2176%2012.5775%2022.2176%2012.9427%2022.1892C17.6344%2021.9314%2020.2121%2019.9161%2021.1106%2019.0551L20.1088%2018.4614Z'%20fill='white'%20/%3e%3cpath%20d='M21.992%2019.5876C21.3968%2020.358%2020.6642%2021.0152%2019.83%2021.5273C16.8895%2023.3959%2013.1491%2023.6372%2010.5306%2023.5071L10.4753%2024.5975C10.915%2024.6188%2011.3378%2024.6283%2011.7486%2024.6283C19.1333%2024.6283%2022.117%2021.3167%2022.9506%2020.134L21.9896%2019.5782'%20fill='white'%20/%3e%3cpath%20d='M21.7116%2015.4587C22.2012%2015.4587%2022.5981%2015.068%2022.5981%2014.586C22.5981%2014.104%2022.2012%2013.7132%2021.7116%2013.7132C21.2221%2013.7132%2020.8253%2014.104%2020.8253%2014.586C20.8253%2015.068%2021.2221%2015.4587%2021.7116%2015.4587Z'%20fill='white'%20/%3e%3c/svg%3e", ZAe = "data:image/svg+xml,%3csvg%20width='96'%20height='96'%20viewBox='0%200%2096%2096'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cg%20clip-path='url(%23clip0_1995_24609)'%3e%3ccircle%20cx='48'%20cy='48'%20r='48'%20fill='black'/%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M58.9474%2049.9886L75.2467%2065.9784C75.4424%2066.1676%2075.5982%2066.3928%2075.7052%2066.6412C75.8121%2066.8895%2075.8682%2067.156%2075.8701%2067.4256C75.872%2067.6952%2075.8197%2067.9625%2075.7163%2068.2122C75.6129%2068.462%2075.4603%2068.6893%2075.2673%2068.8812L74.0714%2070.0504C73.7353%2070.3959%2073.2912%2070.6215%2072.8097%2070.6914C72.4916%2070.7331%2072.1681%2070.702%2071.8644%2070.6006C71.5607%2070.4991%2071.285%2070.3302%2071.0589%2070.1068L51.1554%2050.5813C50.8093%2050.2424%2050.5347%2049.8399%2050.3474%2049.3968C50.1601%2048.9537%2050.0637%2048.4786%2050.0637%2047.9989C50.0637%2047.5192%2050.1601%2047.0443%2050.3474%2046.6012C50.5347%2046.1581%2050.8093%2045.7555%2051.1554%2045.4166L71.0589%2025.8911C71.2528%2025.7005%2071.4831%2025.5494%2071.7366%2025.4462C71.9901%2025.3431%2072.2619%2025.29%2072.5363%2025.29C72.8108%2025.29%2073.0826%2025.3431%2073.3361%2025.4462C73.5896%2025.5494%2073.8199%2025.7005%2074.0138%2025.8911L75.2467%2027.1207C75.441%2027.311%2075.5951%2027.5369%2075.7002%2027.7856C75.8053%2028.0343%2075.8594%2028.3009%2075.8594%2028.5701C75.8594%2028.8394%2075.8053%2029.106%2075.7002%2029.3547C75.5951%2029.6034%2075.441%2029.8293%2075.2467%2030.0195L58.9474%2046.0133C58.4129%2046.5419%2058.1129%2047.2564%2058.1129%2048.001C58.1129%2048.7456%2058.4129%2049.46%2058.9474%2049.9886ZM37.0489%2046.0303L20.7559%2030.0363C20.5582%2029.8469%2020.4008%2029.6208%2020.2929%2029.3712C20.1849%2029.1216%2020.1285%2028.8534%2020.127%2028.5822C20.1255%2028.3111%2020.1788%2028.0423%2020.284%2027.7915C20.3891%2027.5407%2020.544%2027.313%2020.7395%2027.1214L21.9309%2025.9481C22.2701%2025.6048%2022.7145%2025.3797%2023.1962%2025.3071C23.514%2025.2667%2023.8371%2025.2984%2024.1405%2025.3997C24.4439%2025.5011%2024.7196%2025.6693%2024.9463%2025.8917L44.8421%2045.4175C45.1881%2045.7564%2045.4625%2046.1589%2045.6498%2046.602C45.837%2047.0451%2045.9334%2047.5201%2045.9334%2047.9998C45.9334%2048.4795%2045.837%2048.9545%2045.6498%2049.3976C45.4625%2049.8407%2045.1881%2050.2433%2044.8421%2050.5822L24.9463%2070.108C24.7521%2070.2986%2024.5215%2070.4499%2024.2678%2070.5531C24.014%2070.6563%2023.742%2070.7094%2023.4673%2070.7094C23.1926%2070.7094%2022.9207%2070.6563%2022.6669%2070.5531C22.4131%2070.4499%2022.1826%2070.2986%2021.9884%2070.108L20.7559%2068.8985C20.5617%2068.7079%2020.4076%2068.4816%2020.3024%2068.2326C20.1973%2067.9835%2020.1431%2067.7166%2020.1431%2067.447C20.1431%2067.1774%2020.1973%2066.9105%2020.3024%2066.6615C20.4076%2066.4124%2020.5617%2066.1862%2020.7559%2065.9956L37.0489%2050.0056C37.5833%2049.477%2037.8831%2048.7626%2037.8831%2048.018C37.8831%2047.2734%2037.5833%2046.5589%2037.0489%2046.0303Z'%20fill='white'/%3e%3c/g%3e%3cdefs%3e%3cclipPath%20id='clip0_1995_24609'%3e%3crect%20width='96'%20height='96'%20fill='white'/%3e%3c/clipPath%3e%3c/defs%3e%3c/svg%3e", Tn = {
  mathwallet: MAe,
  walletConnect: YAe,
  alphawallet: wAe,
  frontier: PAe,
  blockwallet: CAe,
  bitGet: EAe,
  gate: RAe,
  binance: xAe,
  placeholder: UAe,
  bitpie: SAe,
  brave: AAe,
  coinbase: TAe,
  dcent: kAe,
  frame: IAe,
  hyperpay: OAe,
  imtoken: DAe,
  liquality: NAe,
  metamask: $Ae,
  okx: LAe,
  oneInch: BAe,
  opera: FAe,
  ownbit: jAe,
  status: WAe,
  tallyho: qAe,
  tokenary: GAe,
  tokenpocket: KAe,
  trust: QAe,
  walletio: JAe,
  xdefi: XAe,
  exodus: _Ae,
  safe: HAe,
  safepal: VAe,
  rabbywallet: zAe,
  cyberconnect: ZAe
};
var Gq = {},
  H3 = {},
  Kq = {},
  ly = {},
  uy = {};
const e9e = "@safe-global/safe-apps-sdk",
  t9e = "8.1.0",
  n9e = "SDK developed to integrate third-party apps with Safe app.",
  r9e = "dist/src/index.js",
  i9e = "dist/src/index.d.ts",
  s9e = ["dist/**/*", "src/**/*", "CHANGELOG.md", "README.md"],
  o9e = !1,
  a9e = ["Safe", "sdk", "apps"],
  c9e = {
    test: "jest",
    "format-dist": `sed -i '' 's/"files":/"_files":/' dist/package.json`,
    build: "yarn rimraf dist && tsc && yarn format-dist"
  },
  l9e = "Safe (https://safe.global)",
  u9e = "MIT",
  d9e = {
    "@safe-global/safe-gateway-typescript-sdk": "^3.5.3",
    viem: "^1.0.0"
  },
  f9e = {
    type: "git",
    url: "git+https://github.com/safe-global/safe-apps-sdk.git"
  },
  h9e = {
    url: "https://github.com/safe-global/safe-apps-sdk/issues"
  },
  p9e = "https://github.com/safe-global/safe-apps-sdk#readme",
  m9e = {
    access: "public"
  },
  g9e = {
    name: e9e,
    version: t9e,
    description: n9e,
    main: r9e,
    typings: i9e,
    _files: s9e,
    sideEffects: o9e,
    keywords: a9e,
    scripts: c9e,
    author: l9e,
    license: u9e,
    dependencies: d9e,
    repository: f9e,
    bugs: h9e,
    homepage: p9e,
    publishConfig: m9e
  };
var y9e = rn && rn.__importDefault || function (e) {
  return e && e.__esModule ? e : {
    default: e
  }
};
Object.defineProperty(uy, "__esModule", {
  value: !0
});
uy.getSDKVersion = void 0;
const v9e = y9e(g9e),
  b9e = () => v9e.default.version.split("-")[0];
uy.getSDKVersion = b9e;
var c6 = {};
Object.defineProperty(c6, "__esModule", {
  value: !0
});
c6.generateRequestId = void 0;
const w9e = e => e.toString(16).padStart(2, "0"),
  x9e = e => {
    const t = new Uint8Array((e || 40) / 2);
    return window.crypto.getRandomValues(t), Array.from(t, w9e).join("")
  },
  E9e = () => typeof window < "u" ? x9e(10) : new Date().getTime().toString(36);
c6.generateRequestId = E9e;
Object.defineProperty(ly, "__esModule", {
  value: !0
});
ly.MessageFormatter = void 0;
const S9e = uy,
  C9e = c6;
class l6 {}
ly.MessageFormatter = l6;
l6.makeRequest = (e, t) => ({
  id: (0, C9e.generateRequestId)(),
  method: e,
  params: t,
  env: {
    sdkVersion: (0, S9e.getSDKVersion)()
  }
});
l6.makeResponse = (e, t, n) => ({
  id: e,
  success: !0,
  version: n,
  data: t
});
l6.makeErrorResponse = (e, t, n) => ({
  id: e,
  success: !1,
  error: t,
  version: n
});
var Rh = {};
(function (e) {
  Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.RestrictedMethods = e.Methods = void 0,
    function (t) {
      t.sendTransactions = "sendTransactions", t.rpcCall = "rpcCall", t.getChainInfo = "getChainInfo", t.getSafeInfo = "getSafeInfo", t.getTxBySafeTxHash = "getTxBySafeTxHash", t.getSafeBalances = "getSafeBalances", t.signMessage = "signMessage", t.signTypedMessage = "signTypedMessage", t.getEnvironmentInfo = "getEnvironmentInfo", t.getOffChainSignature = "getOffChainSignature", t.requestAddressBook = "requestAddressBook", t.wallet_getPermissions = "wallet_getPermissions", t.wallet_requestPermissions = "wallet_requestPermissions"
    }(e.Methods || (e.Methods = {})),
    function (t) {
      t.requestAddressBook = "requestAddressBook"
    }(e.RestrictedMethods || (e.RestrictedMethods = {}))
})(Rh);
(function (e) {
  var t = rn && rn.__createBinding || (Object.create ? function (s, o, a, c) {
      c === void 0 && (c = a);
      var l = Object.getOwnPropertyDescriptor(o, a);
      (!l || ("get" in l ? !o.__esModule : l.writable || l.configurable)) && (l = {
        enumerable: !0,
        get: function () {
          return o[a]
        }
      }), Object.defineProperty(s, c, l)
    } : function (s, o, a, c) {
      c === void 0 && (c = a), s[c] = o[a]
    }),
    n = rn && rn.__exportStar || function (s, o) {
      for (var a in s) a !== "default" && !Object.prototype.hasOwnProperty.call(o, a) && t(o, s, a)
    };
  Object.defineProperty(e, "__esModule", {
    value: !0
  });
  const r = ly;
  class i {
    constructor(o = null, a = !1) {
      this.allowedOrigins = null, this.callbacks = new Map, this.debugMode = !1, this.isServer = typeof window > "u", this.isValidMessage = ({
        origin: c,
        data: l,
        source: u
      }) => {
        const f = !l,
          h = !this.isServer && u === window.parent,
          y = (typeof l.version < "u" && parseInt(l.version.split(".")[0])) >= 1;
        let x = !0;
        return Array.isArray(this.allowedOrigins) && (x = this.allowedOrigins.find(k => k.test(c)) !== void 0), !f && h && y && x
      }, this.logIncomingMessage = c => {
        console.info(`Safe Apps SDK v1: A message was received from origin ${c.origin}. `, c.data)
      }, this.onParentMessage = c => {
        this.isValidMessage(c) && (this.debugMode && this.logIncomingMessage(c), this.handleIncomingMessage(c.data))
      }, this.handleIncomingMessage = c => {
        const {
          id: l
        } = c, u = this.callbacks.get(l);
        u && (u(c), this.callbacks.delete(l))
      }, this.send = (c, l) => {
        const u = r.MessageFormatter.makeRequest(c, l);
        if (this.isServer) throw new Error("Window doesn't exist");
        return window.parent.postMessage(u, "*"), new Promise((f, h) => {
          this.callbacks.set(u.id, g => {
            if (!g.success) {
              h(new Error(g.error));
              return
            }
            f(g)
          })
        })
      }, this.allowedOrigins = o, this.debugMode = a, this.isServer || window.addEventListener("message", this.onParentMessage)
    }
  }
  e.default = i, n(Rh, e)
})(Kq);
var u6 = {},
  d6 = {},
  f6 = {};
Object.defineProperty(f6, "__esModule", {
  value: !0
});
f6.isObjectEIP712TypedData = void 0;
const A9e = e => typeof e == "object" && e != null && "domain" in e && "types" in e && "message" in e;
f6.isObjectEIP712TypedData = A9e;
var Qq = {};
Object.defineProperty(Qq, "__esModule", {
  value: !0
});
var Yq = {},
  Jq = {},
  Zc = {},
  el = {},
  Qk = rn && rn.__awaiter || function (e, t, n, r) {
    function i(s) {
      return s instanceof n ? s : new n(function (o) {
        o(s)
      })
    }
    return new(n || (n = Promise))(function (s, o) {
      function a(u) {
        try {
          l(r.next(u))
        } catch (f) {
          o(f)
        }
      }

      function c(u) {
        try {
          l(r.throw(u))
        } catch (f) {
          o(f)
        }
      }

      function l(u) {
        u.done ? s(u.value) : i(u.value).then(a, c)
      }
      l((r = r.apply(e, t || [])).next())
    })
  };
Object.defineProperty(el, "__esModule", {
  value: !0
});
el.getData = el.fetchData = el.stringifyQuery = el.insertParams = void 0;
const T9e = e => typeof e == "object" && e !== null && "code" in e && "message" in e;

function k9e(e, t, n) {
  return e.replace(new RegExp(`\\{${t}\\}`, "g"), n)
}

function _9e(e, t) {
  return t ? Object.keys(t).reduce((n, r) => k9e(n, r, String(t[r])), e) : e
}
el.insertParams = _9e;

function I9e(e) {
  if (!e) return "";
  const t = new URLSearchParams;
  Object.keys(e).forEach(r => {
    e[r] != null && t.append(r, String(e[r]))
  });
  const n = t.toString();
  return n ? `?${n}` : ""
}
el.stringifyQuery = I9e;

function Xq(e) {
  return Qk(this, void 0, void 0, function* () {
    let t;
    try {
      t = e.status === 204 ? {} : yield e.json()
    } catch {
      if (e.headers && e.headers.get("content-length") !== "0") throw new Error(`Invalid response content: ${e.statusText}`)
    }
    if (!e.ok) {
      const n = T9e(t) ? `${t.code}: ${t.message}` : e.statusText;
      throw new Error(n)
    }
    return t
  })
}

function P9e(e, t, n, r) {
  return Qk(this, void 0, void 0, function* () {
    const i = Object.assign({
        "Content-Type": "application/json"
      }, r),
      s = {
        method: t ?? "POST",
        headers: i
      };
    n != null && (s.body = typeof n == "string" ? n : JSON.stringify(n));
    const o = yield fetch(e, s);
    return Xq(o)
  })
}
el.fetchData = P9e;

function R9e(e, t) {
  return Qk(this, void 0, void 0, function* () {
    const n = {
      method: "GET"
    };
    t && (n.headers = Object.assign(Object.assign({}, t), {
      "Content-Type": "application/json"
    }));
    const r = yield fetch(e, n);
    return Xq(r)
  })
}
el.getData = R9e;
Object.defineProperty(Zc, "__esModule", {
  value: !0
});
Zc.getEndpoint = Zc.deleteEndpoint = Zc.putEndpoint = Zc.postEndpoint = void 0;
const ph = el;

function h6(e, t, n, r) {
  const i = (0, ph.insertParams)(t, n),
    s = (0, ph.stringifyQuery)(r);
  return `${e}${i}${s}`
}

function O9e(e, t, n) {
  const r = h6(e, t, n == null ? void 0 : n.path, n == null ? void 0 : n.query);
  return (0, ph.fetchData)(r, "POST", n == null ? void 0 : n.body, n == null ? void 0 : n.headers)
}
Zc.postEndpoint = O9e;

function D9e(e, t, n) {
  const r = h6(e, t, n == null ? void 0 : n.path, n == null ? void 0 : n.query);
  return (0, ph.fetchData)(r, "PUT", n == null ? void 0 : n.body, n == null ? void 0 : n.headers)
}
Zc.putEndpoint = D9e;

function N9e(e, t, n) {
  const r = h6(e, t, n == null ? void 0 : n.path, n == null ? void 0 : n.query);
  return (0, ph.fetchData)(r, "DELETE", n == null ? void 0 : n.body, n == null ? void 0 : n.headers)
}
Zc.deleteEndpoint = N9e;

function M9e(e, t, n, r) {
  if (r) return (0, ph.getData)(r);
  const i = h6(e, t, n == null ? void 0 : n.path, n == null ? void 0 : n.query);
  return (0, ph.getData)(i, n == null ? void 0 : n.headers)
}
Zc.getEndpoint = M9e;
var p6 = {};
Object.defineProperty(p6, "__esModule", {
  value: !0
});
p6.DEFAULT_BASE_URL = void 0;
p6.DEFAULT_BASE_URL = "https://safe-client.safe.global";
var Zq = {};
(function (e) {
  Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.ImplementationVersionState = void 0,
    function (t) {
      t.UP_TO_DATE = "UP_TO_DATE", t.OUTDATED = "OUTDATED", t.UNKNOWN = "UNKNOWN"
    }(e.ImplementationVersionState || (e.ImplementationVersionState = {}))
})(Zq);
var eG = {};
(function (e) {
  Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.SafeAppSocialPlatforms = e.SafeAppFeatures = e.SafeAppAccessPolicyTypes = void 0,
    function (t) {
      t.NoRestrictions = "NO_RESTRICTIONS", t.DomainAllowlist = "DOMAIN_ALLOWLIST"
    }(e.SafeAppAccessPolicyTypes || (e.SafeAppAccessPolicyTypes = {})),
    function (t) {
      t.BATCHED_TRANSACTIONS = "BATCHED_TRANSACTIONS"
    }(e.SafeAppFeatures || (e.SafeAppFeatures = {})),
    function (t) {
      t.TWITTER = "TWITTER", t.GITHUB = "GITHUB", t.DISCORD = "DISCORD"
    }(e.SafeAppSocialPlatforms || (e.SafeAppSocialPlatforms = {}))
})(eG);
var tG = {};
(function (e) {
  Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.LabelValue = e.DetailedExecutionInfoType = e.TransactionListItemType = e.ConflictType = e.TransactionInfoType = e.SettingsInfoType = e.TransactionTokenType = e.TransferDirection = e.TransactionStatus = e.Operation = void 0,
    function (t) {
      t[t.CALL = 0] = "CALL", t[t.DELEGATE = 1] = "DELEGATE"
    }(e.Operation || (e.Operation = {})),
    function (t) {
      t.AWAITING_CONFIRMATIONS = "AWAITING_CONFIRMATIONS", t.AWAITING_EXECUTION = "AWAITING_EXECUTION", t.CANCELLED = "CANCELLED", t.FAILED = "FAILED", t.SUCCESS = "SUCCESS"
    }(e.TransactionStatus || (e.TransactionStatus = {})),
    function (t) {
      t.INCOMING = "INCOMING", t.OUTGOING = "OUTGOING", t.UNKNOWN = "UNKNOWN"
    }(e.TransferDirection || (e.TransferDirection = {})),
    function (t) {
      t.ERC20 = "ERC20", t.ERC721 = "ERC721", t.NATIVE_COIN = "NATIVE_COIN"
    }(e.TransactionTokenType || (e.TransactionTokenType = {})),
    function (t) {
      t.SET_FALLBACK_HANDLER = "SET_FALLBACK_HANDLER", t.ADD_OWNER = "ADD_OWNER", t.REMOVE_OWNER = "REMOVE_OWNER", t.SWAP_OWNER = "SWAP_OWNER", t.CHANGE_THRESHOLD = "CHANGE_THRESHOLD", t.CHANGE_IMPLEMENTATION = "CHANGE_IMPLEMENTATION", t.ENABLE_MODULE = "ENABLE_MODULE", t.DISABLE_MODULE = "DISABLE_MODULE", t.SET_GUARD = "SET_GUARD", t.DELETE_GUARD = "DELETE_GUARD"
    }(e.SettingsInfoType || (e.SettingsInfoType = {})),
    function (t) {
      t.TRANSFER = "Transfer", t.SETTINGS_CHANGE = "SettingsChange", t.CUSTOM = "Custom", t.CREATION = "Creation"
    }(e.TransactionInfoType || (e.TransactionInfoType = {})),
    function (t) {
      t.NONE = "None", t.HAS_NEXT = "HasNext", t.END = "End"
    }(e.ConflictType || (e.ConflictType = {})),
    function (t) {
      t.TRANSACTION = "TRANSACTION", t.LABEL = "LABEL", t.CONFLICT_HEADER = "CONFLICT_HEADER", t.DATE_LABEL = "DATE_LABEL"
    }(e.TransactionListItemType || (e.TransactionListItemType = {})),
    function (t) {
      t.MULTISIG = "MULTISIG", t.MODULE = "MODULE"
    }(e.DetailedExecutionInfoType || (e.DetailedExecutionInfoType = {})),
    function (t) {
      t.Queued = "Queued", t.Next = "Next"
    }(e.LabelValue || (e.LabelValue = {}))
})(tG);
var nG = {};
(function (e) {
  Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.FEATURES = e.GAS_PRICE_TYPE = e.RPC_AUTHENTICATION = void 0,
    function (t) {
      t.API_KEY_PATH = "API_KEY_PATH", t.NO_AUTHENTICATION = "NO_AUTHENTICATION", t.UNKNOWN = "UNKNOWN"
    }(e.RPC_AUTHENTICATION || (e.RPC_AUTHENTICATION = {})),
    function (t) {
      t.ORACLE = "ORACLE", t.FIXED = "FIXED", t.FIXED_1559 = "FIXED1559", t.UNKNOWN = "UNKNOWN"
    }(e.GAS_PRICE_TYPE || (e.GAS_PRICE_TYPE = {})),
    function (t) {
      t.ERC721 = "ERC721", t.SAFE_APPS = "SAFE_APPS", t.CONTRACT_INTERACTION = "CONTRACT_INTERACTION", t.DOMAIN_LOOKUP = "DOMAIN_LOOKUP", t.SPENDING_LIMIT = "SPENDING_LIMIT", t.EIP1559 = "EIP1559", t.SAFE_TX_GAS_OPTIONAL = "SAFE_TX_GAS_OPTIONAL", t.TX_SIMULATION = "TX_SIMULATION", t.EIP1271 = "EIP1271"
    }(e.FEATURES || (e.FEATURES = {}))
})(nG);
var rG = {};
(function (e) {
  Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.TokenType = void 0,
    function (t) {
      t.ERC20 = "ERC20", t.ERC721 = "ERC721", t.NATIVE_TOKEN = "NATIVE_TOKEN"
    }(e.TokenType || (e.TokenType = {}))
})(rG);
var iG = {};
Object.defineProperty(iG, "__esModule", {
  value: !0
});
var sG = {};
Object.defineProperty(sG, "__esModule", {
  value: !0
});
var oG = {};
(function (e) {
  Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.SafeMessageStatus = e.SafeMessageListItemType = void 0,
    function (t) {
      t.DATE_LABEL = "DATE_LABEL", t.MESSAGE = "MESSAGE"
    }(e.SafeMessageListItemType || (e.SafeMessageListItemType = {})),
    function (t) {
      t.NEEDS_CONFIRMATION = "NEEDS_CONFIRMATION", t.CONFIRMED = "CONFIRMED"
    }(e.SafeMessageStatus || (e.SafeMessageStatus = {}))
})(oG);
var aG = {};
(function (e) {
  Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.DeviceType = void 0,
    function (t) {
      t.ANDROID = "ANDROID", t.IOS = "IOS", t.WEB = "WEB"
    }(e.DeviceType || (e.DeviceType = {}))
})(aG);
var cG = {};
Object.defineProperty(cG, "__esModule", {
  value: !0
});
(function (e) {
  var t = rn && rn.__createBinding || (Object.create ? function (ie, ce, ue, ge) {
      ge === void 0 && (ge = ue);
      var et = Object.getOwnPropertyDescriptor(ce, ue);
      (!et || ("get" in et ? !ce.__esModule : et.writable || et.configurable)) && (et = {
        enumerable: !0,
        get: function () {
          return ce[ue]
        }
      }), Object.defineProperty(ie, ge, et)
    } : function (ie, ce, ue, ge) {
      ge === void 0 && (ge = ue), ie[ge] = ce[ue]
    }),
    n = rn && rn.__exportStar || function (ie, ce) {
      for (var ue in ie) ue !== "default" && !Object.prototype.hasOwnProperty.call(ce, ue) && t(ce, ie, ue)
    };
  Object.defineProperty(e, "__esModule", {
    value: !0
  }), e.unsubscribeAll = e.unsubscribeSingle = e.registerRecoveryModule = e.deleteRegisteredEmail = e.getRegisteredEmail = e.verifyEmail = e.resendEmailVerificationCode = e.changeEmail = e.registerEmail = e.unregisterDevice = e.unregisterSafe = e.registerDevice = e.getDelegates = e.confirmSafeMessage = e.proposeSafeMessage = e.getSafeMessage = e.getSafeMessages = e.getDecodedData = e.getMasterCopies = e.getSafeApps = e.getChainConfig = e.getChainsConfig = e.proposeTransaction = e.getNonces = e.postSafeGasEstimation = e.deleteTransaction = e.getTransactionDetails = e.getTransactionQueue = e.getTransactionHistory = e.getCollectiblesPage = e.getCollectibles = e.getAllOwnedSafes = e.getOwnedSafes = e.getFiatCurrencies = e.getBalances = e.getMultisigTransactions = e.getModuleTransactions = e.getIncomingTransfers = e.getSafeInfo = e.getRelayCount = e.relayTransaction = e.setBaseUrl = void 0;
  const r = Zc,
    i = p6;
  n(Zq, e), n(eG, e), n(tG, e), n(nG, e), n(rG, e), n(iG, e), n(sG, e), n(oG, e), n(aG, e), n(cG, e);
  let s = i.DEFAULT_BASE_URL;
  const o = ie => {
    s = ie
  };
  e.setBaseUrl = o;

  function a(ie, ce) {
    return (0, r.postEndpoint)(s, "/v1/chains/{chainId}/relay", {
      path: {
        chainId: ie
      },
      body: ce
    })
  }
  e.relayTransaction = a;

  function c(ie, ce) {
    return (0, r.getEndpoint)(s, "/v1/chains/{chainId}/relay/{address}", {
      path: {
        chainId: ie,
        address: ce
      }
    })
  }
  e.getRelayCount = c;

  function l(ie, ce) {
    return (0, r.getEndpoint)(s, "/v1/chains/{chainId}/safes/{address}", {
      path: {
        chainId: ie,
        address: ce
      }
    })
  }
  e.getSafeInfo = l;

  function u(ie, ce, ue, ge) {
    return (0, r.getEndpoint)(s, "/v1/chains/{chainId}/safes/{address}/incoming-transfers/", {
      path: {
        chainId: ie,
        address: ce
      },
      query: ue
    }, ge)
  }
  e.getIncomingTransfers = u;

  function f(ie, ce, ue, ge) {
    return (0, r.getEndpoint)(s, "/v1/chains/{chainId}/safes/{address}/module-transactions/", {
      path: {
        chainId: ie,
        address: ce
      },
      query: ue
    }, ge)
  }
  e.getModuleTransactions = f;

  function h(ie, ce, ue, ge) {
    return (0, r.getEndpoint)(s, "/v1/chains/{chainId}/safes/{address}/multisig-transactions/", {
      path: {
        chainId: ie,
        address: ce
      },
      query: ue
    }, ge)
  }
  e.getMultisigTransactions = h;

  function g(ie, ce, ue = "usd", ge = {}) {
    return (0, r.getEndpoint)(s, "/v1/chains/{chainId}/safes/{address}/balances/{currency}", {
      path: {
        chainId: ie,
        address: ce,
        currency: ue
      },
      query: ge
    })
  }
  e.getBalances = g;

  function y() {
    return (0, r.getEndpoint)(s, "/v1/balances/supported-fiat-codes")
  }
  e.getFiatCurrencies = y;

  function x(ie, ce) {
    return (0, r.getEndpoint)(s, "/v1/chains/{chainId}/owners/{address}/safes", {
      path: {
        chainId: ie,
        address: ce
      }
    })
  }
  e.getOwnedSafes = x;

  function k(ie) {
    return (0, r.getEndpoint)(s, "/v1/owners/{address}/safes", {
      path: {
        address: ie
      }
    })
  }
  e.getAllOwnedSafes = k;

  function _(ie, ce, ue = {}) {
    return (0, r.getEndpoint)(s, "/v1/chains/{chainId}/safes/{address}/collectibles", {
      path: {
        chainId: ie,
        address: ce
      },
      query: ue
    })
  }
  e.getCollectibles = _;

  function p(ie, ce, ue = {}, ge) {
    return (0, r.getEndpoint)(s, "/v2/chains/{chainId}/safes/{address}/collectibles", {
      path: {
        chainId: ie,
        address: ce
      },
      query: ue
    }, ge)
  }
  e.getCollectiblesPage = p;

  function v(ie, ce, ue = {}, ge) {
    return (0, r.getEndpoint)(s, "/v1/chains/{chainId}/safes/{safe_address}/transactions/history", {
      path: {
        chainId: ie,
        safe_address: ce
      },
      query: ue
    }, ge)
  }
  e.getTransactionHistory = v;

  function S(ie, ce, ue = {}, ge) {
    return (0, r.getEndpoint)(s, "/v1/chains/{chainId}/safes/{safe_address}/transactions/queued", {
      path: {
        chainId: ie,
        safe_address: ce
      },
      query: ue
    }, ge)
  }
  e.getTransactionQueue = S;

  function I(ie, ce) {
    return (0, r.getEndpoint)(s, "/v1/chains/{chainId}/transactions/{transactionId}", {
      path: {
        chainId: ie,
        transactionId: ce
      }
    })
  }
  e.getTransactionDetails = I;

  function A(ie, ce, ue) {
    return (0, r.deleteEndpoint)(s, "/v1/chains/{chainId}/transactions/{safeTxHash}", {
      path: {
        chainId: ie,
        safeTxHash: ce
      },
      body: {
        signature: ue
      }
    })
  }
  e.deleteTransaction = A;

  function w(ie, ce, ue) {
    return (0, r.postEndpoint)(s, "/v2/chains/{chainId}/safes/{safe_address}/multisig-transactions/estimations", {
      path: {
        chainId: ie,
        safe_address: ce
      },
      body: ue
    })
  }
  e.postSafeGasEstimation = w;

  function E(ie, ce) {
    return (0, r.getEndpoint)(s, "/v1/chains/{chainId}/safes/{safe_address}/nonces", {
      path: {
        chainId: ie,
        safe_address: ce
      }
    })
  }
  e.getNonces = E;

  function D(ie, ce, ue) {
    return (0, r.postEndpoint)(s, "/v1/chains/{chainId}/transactions/{safe_address}/propose", {
      path: {
        chainId: ie,
        safe_address: ce
      },
      body: ue
    })
  }
  e.proposeTransaction = D;

  function $(ie) {
    return (0, r.getEndpoint)(s, "/v1/chains", {
      query: ie
    })
  }
  e.getChainsConfig = $;

  function V(ie) {
    return (0, r.getEndpoint)(s, "/v1/chains/{chainId}", {
      path: {
        chainId: ie
      }
    })
  }
  e.getChainConfig = V;

  function G(ie, ce = {}) {
    return (0, r.getEndpoint)(s, "/v1/chains/{chainId}/safe-apps", {
      path: {
        chainId: ie
      },
      query: ce
    })
  }
  e.getSafeApps = G;

  function L(ie) {
    return (0, r.getEndpoint)(s, "/v1/chains/{chainId}/about/master-copies", {
      path: {
        chainId: ie
      }
    })
  }
  e.getMasterCopies = L;

  function b(ie, ce, ue) {
    return (0, r.postEndpoint)(s, "/v1/chains/{chainId}/data-decoder", {
      path: {
        chainId: ie
      },
      body: {
        data: ce,
        to: ue
      }
    })
  }
  e.getDecodedData = b;

  function T(ie, ce, ue) {
    return (0, r.getEndpoint)(s, "/v1/chains/{chainId}/safes/{safe_address}/messages", {
      path: {
        chainId: ie,
        safe_address: ce
      },
      query: {}
    }, ue)
  }
  e.getSafeMessages = T;

  function R(ie, ce) {
    return (0, r.getEndpoint)(s, "/v1/chains/{chainId}/messages/{message_hash}", {
      path: {
        chainId: ie,
        message_hash: ce
      }
    })
  }
  e.getSafeMessage = R;

  function N(ie, ce, ue) {
    return (0, r.postEndpoint)(s, "/v1/chains/{chainId}/safes/{safe_address}/messages", {
      path: {
        chainId: ie,
        safe_address: ce
      },
      body: ue
    })
  }
  e.proposeSafeMessage = N;

  function O(ie, ce, ue) {
    return (0, r.postEndpoint)(s, "/v1/chains/{chainId}/messages/{message_hash}/signatures", {
      path: {
        chainId: ie,
        message_hash: ce
      },
      body: ue
    })
  }
  e.confirmSafeMessage = O;

  function U(ie, ce = {}) {
    return (0, r.getEndpoint)(s, "/v1/chains/{chainId}/delegates", {
      path: {
        chainId: ie
      },
      query: ce
    })
  }
  e.getDelegates = U;

  function q(ie) {
    return (0, r.postEndpoint)(s, "/v1/register/notifications", {
      body: ie
    })
  }
  e.registerDevice = q;

  function W(ie, ce, ue) {
    return (0, r.deleteEndpoint)(s, "/v1/chains/{chainId}/notifications/devices/{uuid}/safes/{safe_address}", {
      path: {
        chainId: ie,
        safe_address: ce,
        uuid: ue
      }
    })
  }
  e.unregisterSafe = W;

  function M(ie, ce) {
    return (0, r.deleteEndpoint)(s, "/v1/chains/{chainId}/notifications/devices/{uuid}", {
      path: {
        chainId: ie,
        uuid: ce
      }
    })
  }
  e.unregisterDevice = M;

  function Q(ie, ce, ue, ge) {
    return (0, r.postEndpoint)(s, "/v1/chains/{chainId}/safes/{safe_address}/emails", {
      path: {
        chainId: ie,
        safe_address: ce
      },
      body: ue,
      headers: ge
    })
  }
  e.registerEmail = Q;

  function he(ie, ce, ue, ge, et) {
    return (0, r.putEndpoint)(s, "/v1/chains/{chainId}/safes/{safe_address}/emails/{signer}", {
      path: {
        chainId: ie,
        safe_address: ce,
        signer: ue
      },
      body: ge,
      headers: et
    })
  }
  e.changeEmail = he;

  function H(ie, ce, ue) {
    return (0, r.postEndpoint)(s, "/v1/chains/{chainId}/safes/{safe_address}/emails/{signer}/verify-resend", {
      path: {
        chainId: ie,
        safe_address: ce,
        signer: ue
      },
      body: ""
    })
  }
  e.resendEmailVerificationCode = H;

  function ne(ie, ce, ue, ge) {
    return (0, r.putEndpoint)(s, "/v1/chains/{chainId}/safes/{safe_address}/emails/{signer}/verify", {
      path: {
        chainId: ie,
        safe_address: ce,
        signer: ue
      },
      body: ge
    })
  }
  e.verifyEmail = ne;

  function X(ie, ce, ue, ge) {
    return (0, r.getEndpoint)(s, "/v1/chains/{chainId}/safes/{safe_address}/emails/{signer}", {
      path: {
        chainId: ie,
        safe_address: ce,
        signer: ue
      },
      headers: ge
    })
  }
  e.getRegisteredEmail = X;

  function Z(ie, ce, ue, ge) {
    return (0, r.deleteEndpoint)(s, "/v1/chains/{chainId}/safes/{safe_address}/emails/{signer}", {
      path: {
        chainId: ie,
        safe_address: ce,
        signer: ue
      },
      headers: ge
    })
  }
  e.deleteRegisteredEmail = Z;

  function te(ie, ce, ue) {
    return (0, r.postEndpoint)(s, "/v1/chains/{chainId}/safes/{safe_address}/recovery", {
      path: {
        chainId: ie,
        safe_address: ce
      },
      body: ue
    })
  }
  e.registerRecoveryModule = te;

  function F(ie) {
    return (0, r.deleteEndpoint)(s, "/v1/subscriptions", {
      query: ie
    })
  }
  e.unsubscribeSingle = F;

  function J(ie) {
    return (0, r.deleteEndpoint)(s, "/v1/subscriptions/all", {
      query: ie
    })
  }
  e.unsubscribeAll = J
})(Jq);
(function (e) {
  Object.defineProperty(e, "__esModule", {
    value: !0
  }), e.TransferDirection = e.TransactionStatus = e.TokenType = e.Operation = void 0;
  var t = Jq;
  Object.defineProperty(e, "Operation", {
    enumerable: !0,
    get: function () {
      return t.Operation
    }
  }), Object.defineProperty(e, "TokenType", {
    enumerable: !0,
    get: function () {
      return t.TokenType
    }
  }), Object.defineProperty(e, "TransactionStatus", {
    enumerable: !0,
    get: function () {
      return t.TransactionStatus
    }
  }), Object.defineProperty(e, "TransferDirection", {
    enumerable: !0,
    get: function () {
      return t.TransferDirection
    }
  })
})(Yq);
var lG = {};
Object.defineProperty(lG, "__esModule", {
  value: !0
});
(function (e) {
  var t = rn && rn.__createBinding || (Object.create ? function (r, i, s, o) {
      o === void 0 && (o = s);
      var a = Object.getOwnPropertyDescriptor(i, s);
      (!a || ("get" in a ? !i.__esModule : a.writable || a.configurable)) && (a = {
        enumerable: !0,
        get: function () {
          return i[s]
        }
      }), Object.defineProperty(r, o, a)
    } : function (r, i, s, o) {
      o === void 0 && (o = s), r[o] = i[s]
    }),
    n = rn && rn.__exportStar || function (r, i) {
      for (var s in r) s !== "default" && !Object.prototype.hasOwnProperty.call(i, s) && t(i, r, s)
    };
  Object.defineProperty(e, "__esModule", {
    value: !0
  }), n(f6, e), n(Qq, e), n(Yq, e), n(lG, e)
})(d6);
Object.defineProperty(u6, "__esModule", {
  value: !0
});
u6.TXs = void 0;
const kb = Rh,
  $9e = d6;
class L9e {
  constructor(t) {
    this.communicator = t
  }
  async getBySafeTxHash(t) {
    if (!t) throw new Error("Invalid safeTxHash");
    return (await this.communicator.send(kb.Methods.getTxBySafeTxHash, {
      safeTxHash: t
    })).data
  }
  async signMessage(t) {
    const n = {
      message: t
    };
    return (await this.communicator.send(kb.Methods.signMessage, n)).data
  }
  async signTypedMessage(t) {
    if (!(0, $9e.isObjectEIP712TypedData)(t)) throw new Error("Invalid typed data");
    return (await this.communicator.send(kb.Methods.signTypedMessage, {
      typedData: t
    })).data
  }
  async send({
    txs: t,
    params: n
  }) {
    if (!t || !t.length) throw new Error("No transactions were passed");
    const r = {
      txs: t,
      params: n
    };
    return (await this.communicator.send(kb.Methods.sendTransactions, r)).data
  }
}
u6.TXs = L9e;
var m6 = {},
  dy = {};
Object.defineProperty(dy, "__esModule", {
  value: !0
});
dy.RPC_CALLS = void 0;
dy.RPC_CALLS = {
  eth_call: "eth_call",
  eth_gasPrice: "eth_gasPrice",
  eth_getLogs: "eth_getLogs",
  eth_getBalance: "eth_getBalance",
  eth_getCode: "eth_getCode",
  eth_getBlockByHash: "eth_getBlockByHash",
  eth_getBlockByNumber: "eth_getBlockByNumber",
  eth_getStorageAt: "eth_getStorageAt",
  eth_getTransactionByHash: "eth_getTransactionByHash",
  eth_getTransactionReceipt: "eth_getTransactionReceipt",
  eth_getTransactionCount: "eth_getTransactionCount",
  eth_estimateGas: "eth_estimateGas",
  safe_setSettings: "safe_setSettings"
};
Object.defineProperty(m6, "__esModule", {
  value: !0
});
m6.Eth = void 0;
const Ao = dy,
  B9e = Rh,
  $l = {
    defaultBlockParam: (e = "latest") => e,
    returnFullTxObjectParam: (e = !1) => e,
    blockNumberToHex: e => Number.isInteger(e) ? `0x${e.toString(16)}` : e
  };
class F9e {
  constructor(t) {
    this.communicator = t, this.call = this.buildRequest({
      call: Ao.RPC_CALLS.eth_call,
      formatters: [null, $l.defaultBlockParam]
    }), this.getBalance = this.buildRequest({
      call: Ao.RPC_CALLS.eth_getBalance,
      formatters: [null, $l.defaultBlockParam]
    }), this.getCode = this.buildRequest({
      call: Ao.RPC_CALLS.eth_getCode,
      formatters: [null, $l.defaultBlockParam]
    }), this.getStorageAt = this.buildRequest({
      call: Ao.RPC_CALLS.eth_getStorageAt,
      formatters: [null, $l.blockNumberToHex, $l.defaultBlockParam]
    }), this.getPastLogs = this.buildRequest({
      call: Ao.RPC_CALLS.eth_getLogs
    }), this.getBlockByHash = this.buildRequest({
      call: Ao.RPC_CALLS.eth_getBlockByHash,
      formatters: [null, $l.returnFullTxObjectParam]
    }), this.getBlockByNumber = this.buildRequest({
      call: Ao.RPC_CALLS.eth_getBlockByNumber,
      formatters: [$l.blockNumberToHex, $l.returnFullTxObjectParam]
    }), this.getTransactionByHash = this.buildRequest({
      call: Ao.RPC_CALLS.eth_getTransactionByHash
    }), this.getTransactionReceipt = this.buildRequest({
      call: Ao.RPC_CALLS.eth_getTransactionReceipt
    }), this.getTransactionCount = this.buildRequest({
      call: Ao.RPC_CALLS.eth_getTransactionCount,
      formatters: [null, $l.defaultBlockParam]
    }), this.getGasPrice = this.buildRequest({
      call: Ao.RPC_CALLS.eth_gasPrice
    }), this.getEstimateGas = n => this.buildRequest({
      call: Ao.RPC_CALLS.eth_estimateGas
    })([n]), this.setSafeSettings = this.buildRequest({
      call: Ao.RPC_CALLS.safe_setSettings
    })
  }
  buildRequest(t) {
    const {
      call: n,
      formatters: r
    } = t;
    return async i => {
      r && Array.isArray(i) && r.forEach((a, c) => {
        a && (i[c] = a(i[c]))
      });
      const s = {
        call: n,
        params: i || []
      };
      return (await this.communicator.send(B9e.Methods.rpcCall, s)).data
    }
  }
}
m6.Eth = F9e;
var g6 = {};
const j9e = "0.9.8";
let Bs = class SA extends Error {
  constructor(t, n = {}) {
    var o;
    const r = n.cause instanceof SA ? n.cause.details : (o = n.cause) != null && o.message ? n.cause.message : n.details,
      i = n.cause instanceof SA && n.cause.docsPath || n.docsPath,
      s = [t || "An error occurred.", "", ...n.metaMessages ? [...n.metaMessages, ""] : [], ...i ? [`Docs: https://abitype.dev${i}`] : [], ...r ? [`Details: ${r}`] : [], `Version: abitype@${j9e}`].join(`
`);
    super(s), Object.defineProperty(this, "details", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "docsPath", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "metaMessages", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shortMessage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiTypeError"
    }), n.cause && (this.cause = n.cause), this.details = r, this.docsPath = i, this.metaMessages = n.metaMessages, this.shortMessage = t
  }
};

function zd(e, t) {
  const n = e.exec(t);
  return n == null ? void 0 : n.groups
}
const uG = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/,
  dG = /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/,
  fG = /^\(.+?\).*?$/,
  u$ = /^tuple(?<array>(\[(\d*)\])*)$/;

function CA(e) {
  let t = e.type;
  if (u$.test(e.type) && "components" in e) {
    t = "(";
    const n = e.components.length;
    for (let i = 0; i < n; i++) {
      const s = e.components[i];
      t += CA(s), i < n - 1 && (t += ", ")
    }
    const r = zd(u$, e.type);
    return t += `)${(r==null?void 0:r.array)??""}`, CA({
      ...e,
      type: t
    })
  }
  return "indexed" in e && e.indexed && (t = `${t} indexed`), e.name ? `${t} ${e.name}` : t
}

function Lg(e) {
  let t = "";
  const n = e.length;
  for (let r = 0; r < n; r++) {
    const i = e[r];
    t += CA(i), r !== n - 1 && (t += ", ")
  }
  return t
}

function U9e(e) {
  return e.type === "function" ? `function ${e.name}(${Lg(e.inputs)})${e.stateMutability&&e.stateMutability!=="nonpayable"?` ${e.stateMutability}`:""}${e.outputs.length?` returns (${Lg(e.outputs)})`:""}` : e.type === "event" ? `event ${e.name}(${Lg(e.inputs)})` : e.type === "error" ? `error ${e.name}(${Lg(e.inputs)})` : e.type === "constructor" ? `constructor(${Lg(e.inputs)})${e.stateMutability==="payable"?" payable":""}` : e.type === "fallback" ? "fallback()" : "receive() external payable"
}
const hG = /^error (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/;

function z9e(e) {
  return hG.test(e)
}

function H9e(e) {
  return zd(hG, e)
}
const pG = /^event (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/;

function V9e(e) {
  return pG.test(e)
}

function W9e(e) {
  return zd(pG, e)
}
const mG = /^function (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)(?: (?<scope>external|public{1}))?(?: (?<stateMutability>pure|view|nonpayable|payable{1}))?(?: returns\s?\((?<returns>.*?)\))?$/;

function q9e(e) {
  return mG.test(e)
}

function G9e(e) {
  return zd(mG, e)
}
const gG = /^struct (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*) \{(?<properties>.*?)\}$/;

function fy(e) {
  return gG.test(e)
}

function K9e(e) {
  return zd(gG, e)
}
const yG = /^constructor\((?<parameters>.*?)\)(?:\s(?<stateMutability>payable{1}))?$/;

function Q9e(e) {
  return yG.test(e)
}

function Y9e(e) {
  return zd(yG, e)
}
const J9e = /^fallback\(\)$/;

function X9e(e) {
  return J9e.test(e)
}
const Z9e = /^receive\(\) external payable$/;

function eTe(e) {
  return Z9e.test(e)
}
const V3 = new Set(["memory", "indexed", "storage", "calldata"]),
  tTe = new Set(["indexed"]),
  AA = new Set(["calldata", "memory", "storage"]);
class vG extends Bs {
  constructor({
    signature: t
  }) {
    super("Failed to parse ABI item.", {
      details: `parseAbiItem(${JSON.stringify(t,null,2)})`,
      docsPath: "/api/human.html#parseabiitem-1"
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidAbiItemError"
    })
  }
}
class bG extends Bs {
  constructor({
    type: t
  }) {
    super("Unknown type.", {
      metaMessages: [`Type "${t}" is not a valid ABI type. Perhaps you forgot to include a struct signature?`]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "UnknownTypeError"
    })
  }
}
class nTe extends Bs {
  constructor({
    type: t
  }) {
    super("Unknown type.", {
      metaMessages: [`Type "${t}" is not a valid ABI type.`]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "UnknownSolidityTypeError"
    })
  }
}
class wG extends Bs {
  constructor({
    param: t
  }) {
    super("Failed to parse ABI parameter.", {
      details: `parseAbiParameter(${JSON.stringify(t,null,2)})`,
      docsPath: "/api/human.html#parseabiparameter-1"
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidAbiParameterError"
    })
  }
}
class xG extends Bs {
  constructor({
    params: t
  }) {
    super("Failed to parse ABI parameters.", {
      details: `parseAbiParameters(${JSON.stringify(t,null,2)})`,
      docsPath: "/api/human.html#parseabiparameters-1"
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidAbiParametersError"
    })
  }
}
class EG extends Bs {
  constructor({
    param: t
  }) {
    super("Invalid ABI parameter.", {
      details: t
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidParameterError"
    })
  }
}
class SG extends Bs {
  constructor({
    param: t,
    name: n
  }) {
    super("Invalid ABI parameter.", {
      details: t,
      metaMessages: [`"${n}" is a protected Solidity keyword. More info: https://docs.soliditylang.org/en/latest/cheatsheet.html`]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "SolidityProtectedKeywordError"
    })
  }
}
class CG extends Bs {
  constructor({
    param: t,
    type: n,
    modifier: r
  }) {
    super("Invalid ABI parameter.", {
      details: t,
      metaMessages: [`Modifier "${r}" not allowed${n?` in "${n}" type`:""}.`]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidModifierError"
    })
  }
}
class AG extends Bs {
  constructor({
    param: t,
    type: n,
    modifier: r
  }) {
    super("Invalid ABI parameter.", {
      details: t,
      metaMessages: [`Modifier "${r}" not allowed${n?` in "${n}" type`:""}.`, `Data location can only be specified for array, struct, or mapping types, but "${r}" was given.`]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidFunctionModifierError"
    })
  }
}
class TG extends Bs {
  constructor({
    abiParameter: t
  }) {
    super("Invalid ABI parameter.", {
      details: JSON.stringify(t, null, 2),
      metaMessages: ["ABI parameter type is invalid."]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidAbiTypeParameterError"
    })
  }
}
class J0 extends Bs {
  constructor({
    signature: t,
    type: n
  }) {
    super(`Invalid ${n} signature.`, {
      details: t
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidSignatureError"
    })
  }
}
class kG extends Bs {
  constructor({
    signature: t
  }) {
    super("Unknown signature.", {
      details: t
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "UnknownSignatureError"
    })
  }
}
class _G extends Bs {
  constructor({
    signature: t
  }) {
    super("Invalid struct signature.", {
      details: t,
      metaMessages: ["No properties exist."]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidStructSignatureError"
    })
  }
}
class IG extends Bs {
  constructor({
    type: t
  }) {
    super("Circular reference detected.", {
      metaMessages: [`Struct "${t}" is a circular reference.`]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "CircularReferenceError"
    })
  }
}
class PG extends Bs {
  constructor({
    current: t,
    depth: n
  }) {
    super("Unbalanced parentheses.", {
      metaMessages: [`"${t.trim()}" has too many ${n>0?"opening":"closing"} parentheses.`],
      details: `Depth "${n}"`
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidParenthesisError"
    })
  }
}

function rTe(e, t) {
  return t ? `${t}:${e}` : e
}
const KS = new Map([
  ["address", {
    type: "address"
  }],
  ["bool", {
    type: "bool"
  }],
  ["bytes", {
    type: "bytes"
  }],
  ["bytes32", {
    type: "bytes32"
  }],
  ["int", {
    type: "int256"
  }],
  ["int256", {
    type: "int256"
  }],
  ["string", {
    type: "string"
  }],
  ["uint", {
    type: "uint256"
  }],
  ["uint8", {
    type: "uint8"
  }],
  ["uint16", {
    type: "uint16"
  }],
  ["uint24", {
    type: "uint24"
  }],
  ["uint32", {
    type: "uint32"
  }],
  ["uint64", {
    type: "uint64"
  }],
  ["uint96", {
    type: "uint96"
  }],
  ["uint112", {
    type: "uint112"
  }],
  ["uint160", {
    type: "uint160"
  }],
  ["uint192", {
    type: "uint192"
  }],
  ["uint256", {
    type: "uint256"
  }],
  ["address owner", {
    type: "address",
    name: "owner"
  }],
  ["address to", {
    type: "address",
    name: "to"
  }],
  ["bool approved", {
    type: "bool",
    name: "approved"
  }],
  ["bytes _data", {
    type: "bytes",
    name: "_data"
  }],
  ["bytes data", {
    type: "bytes",
    name: "data"
  }],
  ["bytes signature", {
    type: "bytes",
    name: "signature"
  }],
  ["bytes32 hash", {
    type: "bytes32",
    name: "hash"
  }],
  ["bytes32 r", {
    type: "bytes32",
    name: "r"
  }],
  ["bytes32 root", {
    type: "bytes32",
    name: "root"
  }],
  ["bytes32 s", {
    type: "bytes32",
    name: "s"
  }],
  ["string name", {
    type: "string",
    name: "name"
  }],
  ["string symbol", {
    type: "string",
    name: "symbol"
  }],
  ["string tokenURI", {
    type: "string",
    name: "tokenURI"
  }],
  ["uint tokenId", {
    type: "uint256",
    name: "tokenId"
  }],
  ["uint8 v", {
    type: "uint8",
    name: "v"
  }],
  ["uint256 balance", {
    type: "uint256",
    name: "balance"
  }],
  ["uint256 tokenId", {
    type: "uint256",
    name: "tokenId"
  }],
  ["uint256 value", {
    type: "uint256",
    name: "value"
  }],
  ["event:address indexed from", {
    type: "address",
    name: "from",
    indexed: !0
  }],
  ["event:address indexed to", {
    type: "address",
    name: "to",
    indexed: !0
  }],
  ["event:uint indexed tokenId", {
    type: "uint256",
    name: "tokenId",
    indexed: !0
  }],
  ["event:uint256 indexed tokenId", {
    type: "uint256",
    name: "tokenId",
    indexed: !0
  }]
]);

function TA(e, t = {}) {
  if (q9e(e)) {
    const n = G9e(e);
    if (!n) throw new J0({
      signature: e,
      type: "function"
    });
    const r = Mo(n.parameters),
      i = [],
      s = r.length;
    for (let a = 0; a < s; a++) i.push(dc(r[a], {
      modifiers: AA,
      structs: t,
      type: "function"
    }));
    const o = [];
    if (n.returns) {
      const a = Mo(n.returns),
        c = a.length;
      for (let l = 0; l < c; l++) o.push(dc(a[l], {
        modifiers: AA,
        structs: t,
        type: "function"
      }))
    }
    return {
      name: n.name,
      type: "function",
      stateMutability: n.stateMutability ?? "nonpayable",
      inputs: i,
      outputs: o
    }
  }
  if (V9e(e)) {
    const n = W9e(e);
    if (!n) throw new J0({
      signature: e,
      type: "event"
    });
    const r = Mo(n.parameters),
      i = [],
      s = r.length;
    for (let o = 0; o < s; o++) i.push(dc(r[o], {
      modifiers: tTe,
      structs: t,
      type: "event"
    }));
    return {
      name: n.name,
      type: "event",
      inputs: i
    }
  }
  if (z9e(e)) {
    const n = H9e(e);
    if (!n) throw new J0({
      signature: e,
      type: "error"
    });
    const r = Mo(n.parameters),
      i = [],
      s = r.length;
    for (let o = 0; o < s; o++) i.push(dc(r[o], {
      structs: t,
      type: "error"
    }));
    return {
      name: n.name,
      type: "error",
      inputs: i
    }
  }
  if (Q9e(e)) {
    const n = Y9e(e);
    if (!n) throw new J0({
      signature: e,
      type: "constructor"
    });
    const r = Mo(n.parameters),
      i = [],
      s = r.length;
    for (let o = 0; o < s; o++) i.push(dc(r[o], {
      structs: t,
      type: "constructor"
    }));
    return {
      type: "constructor",
      stateMutability: n.stateMutability ?? "nonpayable",
      inputs: i
    }
  }
  if (X9e(e)) return {
    type: "fallback"
  };
  if (eTe(e)) return {
    type: "receive",
    stateMutability: "payable"
  };
  throw new kG({
    signature: e
  })
}
const iTe = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/,
  sTe = /^\((?<type>.+?)\)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/,
  oTe = /^u?int$/;

function dc(e, t) {
  var f, h;
  const n = rTe(e, t == null ? void 0 : t.type);
  if (KS.has(n)) return KS.get(n);
  const r = fG.test(e),
    i = zd(r ? sTe : iTe, e);
  if (!i) throw new EG({
    param: e
  });
  if (i.name && cTe(i.name)) throw new SG({
    param: e,
    name: i.name
  });
  const s = i.name ? {
      name: i.name
    } : {},
    o = i.modifier === "indexed" ? {
      indexed: !0
    } : {},
    a = (t == null ? void 0 : t.structs) ?? {};
  let c, l = {};
  if (r) {
    c = "tuple";
    const g = Mo(i.type),
      y = [],
      x = g.length;
    for (let k = 0; k < x; k++) y.push(dc(g[k], {
      structs: a
    }));
    l = {
      components: y
    }
  } else if (i.type in a) c = "tuple", l = {
    components: a[i.type]
  };
  else if (oTe.test(i.type)) c = `${i.type}256`;
  else if (c = i.type, (t == null ? void 0 : t.type) !== "struct" && !RG(c)) throw new nTe({
    type: c
  });
  if (i.modifier) {
    if (!((h = (f = t == null ? void 0 : t.modifiers) == null ? void 0 : f.has) != null && h.call(f, i.modifier))) throw new CG({
      param: e,
      type: t == null ? void 0 : t.type,
      modifier: i.modifier
    });
    if (AA.has(i.modifier) && !lTe(c, !!i.array)) throw new AG({
      param: e,
      type: t == null ? void 0 : t.type,
      modifier: i.modifier
    })
  }
  const u = {
    type: `${c}${i.array??""}`,
    ...s,
    ...o,
    ...l
  };
  return KS.set(n, u), u
}

function Mo(e, t = [], n = "", r = 0) {
  if (e === "") {
    if (n === "") return t;
    if (r !== 0) throw new PG({
      current: n,
      depth: r
    });
    return t.push(n.trim()), t
  }
  const i = e.length;
  for (let s = 0; s < i; s++) {
    const o = e[s],
      a = e.slice(s + 1);
    switch (o) {
      case ",":
        return r === 0 ? Mo(a, [...t, n.trim()]) : Mo(a, t, `${n}${o}`, r);
      case "(":
        return Mo(a, t, `${n}${o}`, r + 1);
      case ")":
        return Mo(a, t, `${n}${o}`, r - 1);
      default:
        return Mo(a, t, `${n}${o}`, r)
    }
  }
  return []
}

function RG(e) {
  return e === "address" || e === "bool" || e === "function" || e === "string" || uG.test(e) || dG.test(e)
}
const aTe = /^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/;

function cTe(e) {
  return e === "address" || e === "bool" || e === "function" || e === "string" || e === "tuple" || uG.test(e) || dG.test(e) || aTe.test(e)
}

function lTe(e, t) {
  return t || e === "bytes" || e === "string" || e === "tuple"
}

function y6(e) {
  const t = {},
    n = e.length;
  for (let o = 0; o < n; o++) {
    const a = e[o];
    if (!fy(a)) continue;
    const c = K9e(a);
    if (!c) throw new J0({
      signature: a,
      type: "struct"
    });
    const l = c.properties.split(";"),
      u = [],
      f = l.length;
    for (let h = 0; h < f; h++) {
      const y = l[h].trim();
      if (!y) continue;
      const x = dc(y, {
        type: "struct"
      });
      u.push(x)
    }
    if (!u.length) throw new _G({
      signature: a
    });
    t[c.name] = u
  }
  const r = {},
    i = Object.entries(t),
    s = i.length;
  for (let o = 0; o < s; o++) {
    const [a, c] = i[o];
    r[a] = OG(c, t)
  }
  return r
}
const uTe = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?$/;

function OG(e, t, n = new Set) {
  const r = [],
    i = e.length;
  for (let s = 0; s < i; s++) {
    const o = e[s];
    if (fG.test(o.type)) r.push(o);
    else {
      const c = zd(uTe, o.type);
      if (!(c != null && c.type)) throw new TG({
        abiParameter: o
      });
      const {
        array: l,
        type: u
      } = c;
      if (u in t) {
        if (n.has(u)) throw new IG({
          type: u
        });
        r.push({
          ...o,
          type: `tuple${l??""}`,
          components: OG(t[u] ?? [], t, new Set([...n, u]))
        })
      } else if (RG(u)) r.push(o);
      else throw new bG({
        type: u
      })
    }
  }
  return r
}

function dTe(e) {
  const t = y6(e),
    n = [],
    r = e.length;
  for (let i = 0; i < r; i++) {
    const s = e[i];
    fy(s) || n.push(TA(s, t))
  }
  return n
}

function fTe(e) {
  let t;
  if (typeof e == "string") t = TA(e);
  else {
    const n = y6(e),
      r = e.length;
    for (let i = 0; i < r; i++) {
      const s = e[i];
      if (!fy(s)) {
        t = TA(s, n);
        break
      }
    }
  }
  if (!t) throw new vG({
    signature: e
  });
  return t
}

function hTe(e) {
  let t;
  if (typeof e == "string") t = dc(e, {
    modifiers: V3
  });
  else {
    const n = y6(e),
      r = e.length;
    for (let i = 0; i < r; i++) {
      const s = e[i];
      if (!fy(s)) {
        t = dc(s, {
          modifiers: V3,
          structs: n
        });
        break
      }
    }
  }
  if (!t) throw new wG({
    param: e
  });
  return t
}

function pTe(e) {
  const t = [];
  if (typeof e == "string") {
    const n = Mo(e),
      r = n.length;
    for (let i = 0; i < r; i++) t.push(dc(n[i], {
      modifiers: V3
    }))
  } else {
    const n = y6(e),
      r = e.length;
    for (let i = 0; i < r; i++) {
      const s = e[i];
      if (fy(s)) continue;
      const o = Mo(s),
        a = o.length;
      for (let c = 0; c < a; c++) t.push(dc(o[c], {
        modifiers: V3,
        structs: n
      }))
    }
  }
  if (t.length === 0) throw new xG({
    params: e
  });
  return t
}

function Tt(e, t, n) {
  return r => {
    var i;
    return ((i = e[t.name || n]) == null ? void 0 : i.call(e, r)) ?? t(e, r)
  }
}

function Ac(e, {
  includeName: t = !1
} = {}) {
  if (e.type !== "function" && e.type !== "event" && e.type !== "error") throw new HG(e.type);
  return `${e.name}(${v6(e.inputs,{includeName:t})})`
}

function v6(e, {
  includeName: t = !1
} = {}) {
  return e ? e.map(n => mTe(n, {
    includeName: t
  })).join(t ? ", " : ",") : ""
}

function mTe(e, {
  includeName: t
}) {
  return e.type.startsWith("tuple") ? `(${v6(e.components,{includeName:t})})${e.type.slice(5)}` : e.type + (t && e.name ? ` ${e.name}` : "")
}

function hn(e, {
  strict: t = !0
} = {}) {
  return !e || typeof e != "string" ? !1 : t ? /^0x[0-9a-fA-F]*$/.test(e) : e.startsWith("0x")
}

function Qr(e) {
  return hn(e, {
    strict: !1
  }) ? Math.ceil((e.length - 2) / 2) : e.length
}
const gTe = "1.21.3",
  yTe = e => e,
  Dm = e => e,
  vTe = () => `viem@${gTe}`;
class $e extends Error {
  constructor(t, n = {}) {
    var s;
    super(), Object.defineProperty(this, "details", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "docsPath", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "metaMessages", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shortMessage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ViemError"
    }), Object.defineProperty(this, "version", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: vTe()
    });
    const r = n.cause instanceof $e ? n.cause.details : (s = n.cause) != null && s.message ? n.cause.message : n.details,
      i = n.cause instanceof $e && n.cause.docsPath || n.docsPath;
    this.message = [t || "An error occurred.", "", ...n.metaMessages ? [...n.metaMessages, ""] : [], ...i ? [`Docs: https://viem.sh${i}.html${n.docsSlug?`#${n.docsSlug}`:""}`] : [], ...r ? [`Details: ${r}`] : [], `Version: ${this.version}`].join(`
`), n.cause && (this.cause = n.cause), this.details = r, this.docsPath = i, this.metaMessages = n.metaMessages, this.shortMessage = t
  }
  walk(t) {
    return DG(this, t)
  }
}

function DG(e, t) {
  return t != null && t(e) ? e : e && typeof e == "object" && "cause" in e ? DG(e.cause, t) : t ? null : e
}
class Yk extends $e {
  constructor({
    docsPath: t
  }) {
    super(["A constructor was not found on the ABI.", "Make sure you are using the correct ABI and that the constructor exists on it."].join(`
`), {
      docsPath: t
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiConstructorNotFoundError"
    })
  }
}
class m2 extends $e {
  constructor({
    docsPath: t
  }) {
    super(["Constructor arguments were provided (`args`), but a constructor parameters (`inputs`) were not found on the ABI.", "Make sure you are using the correct ABI, and that the `inputs` attribute on the constructor exists."].join(`
`), {
      docsPath: t
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiConstructorParamsNotFoundError"
    })
  }
}
class bTe extends $e {
  constructor({
    data: t,
    size: n
  }) {
    super([`Data size of ${n} bytes is invalid.`, "Size must be in increments of 32 bytes (size % 32 === 0)."].join(`
`), {
      metaMessages: [`Data: ${t} (${n} bytes)`]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiDecodingDataSizeInvalidError"
    })
  }
}
class b6 extends $e {
  constructor({
    data: t,
    params: n,
    size: r
  }) {
    super([`Data size of ${r} bytes is too small for given parameters.`].join(`
`), {
      metaMessages: [`Params: (${v6(n,{includeName:!0})})`, `Data:   ${t} (${r} bytes)`]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiDecodingDataSizeTooSmallError"
    }), Object.defineProperty(this, "data", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "params", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "size", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.data = t, this.params = n, this.size = r
  }
}
class hy extends $e {
  constructor() {
    super('Cannot decode zero data ("0x") with ABI parameters.'), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiDecodingZeroDataError"
    })
  }
}
class NG extends $e {
  constructor({
    expectedLength: t,
    givenLength: n,
    type: r
  }) {
    super([`ABI encoding array length mismatch for type ${r}.`, `Expected length: ${t}`, `Given length: ${n}`].join(`
`)), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiEncodingArrayLengthMismatchError"
    })
  }
}
class MG extends $e {
  constructor({
    expectedSize: t,
    value: n
  }) {
    super(`Size of bytes "${n}" (bytes${Qr(n)}) does not match expected size (bytes${t}).`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiEncodingBytesSizeMismatchError"
    })
  }
}
class Jk extends $e {
  constructor({
    expectedLength: t,
    givenLength: n
  }) {
    super(["ABI encoding params/values length mismatch.", `Expected length (params): ${t}`, `Given length (values): ${n}`].join(`
`)), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiEncodingLengthMismatchError"
    })
  }
}
class $G extends $e {
  constructor(t, {
    docsPath: n
  }) {
    super([`Arguments (\`args\`) were provided to "${t}", but "${t}" on the ABI does not contain any parameters (\`inputs\`).`, "Cannot encode error result without knowing what the parameter types are.", "Make sure you are using the correct ABI and that the inputs exist on it."].join(`
`), {
      docsPath: n
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiErrorInputsNotFoundError"
    })
  }
}
class kA extends $e {
  constructor(t, {
    docsPath: n
  } = {}) {
    super([`Error ${t?`"${t}" `:""}not found on ABI.`, "Make sure you are using the correct ABI and that the error exists on it."].join(`
`), {
      docsPath: n
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiErrorNotFoundError"
    })
  }
}
class Xk extends $e {
  constructor(t, {
    docsPath: n
  }) {
    super([`Encoded error signature "${t}" not found on ABI.`, "Make sure you are using the correct ABI and that the error exists on it.", `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${t}.`].join(`
`), {
      docsPath: n
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiErrorSignatureNotFoundError"
    }), Object.defineProperty(this, "signature", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.signature = t
  }
}
class LG extends $e {
  constructor({
    docsPath: t
  }) {
    super("Cannot extract event signature from empty topics.", {
      docsPath: t
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiEventSignatureEmptyTopicsError"
    })
  }
}
class BG extends $e {
  constructor(t, {
    docsPath: n
  }) {
    super([`Encoded event signature "${t}" not found on ABI.`, "Make sure you are using the correct ABI and that the event exists on it.", `You can look up the signature here: https://openchain.xyz/signatures?query=${t}.`].join(`
`), {
      docsPath: n
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiEventSignatureNotFoundError"
    })
  }
}
class _A extends $e {
  constructor(t, {
    docsPath: n
  } = {}) {
    super([`Event ${t?`"${t}" `:""}not found on ABI.`, "Make sure you are using the correct ABI and that the event exists on it."].join(`
`), {
      docsPath: n
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiEventNotFoundError"
    })
  }
}
class mh extends $e {
  constructor(t, {
    docsPath: n
  } = {}) {
    super([`Function ${t?`"${t}" `:""}not found on ABI.`, "Make sure you are using the correct ABI and that the function exists on it."].join(`
`), {
      docsPath: n
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiFunctionNotFoundError"
    })
  }
}
class Zk extends $e {
  constructor(t, {
    docsPath: n
  }) {
    super([`Function "${t}" does not contain any \`outputs\` on ABI.`, "Cannot decode function result without knowing what the parameter types are.", "Make sure you are using the correct ABI and that the function exists on it."].join(`
`), {
      docsPath: n
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiFunctionOutputsNotFoundError"
    })
  }
}
class FG extends $e {
  constructor(t, {
    docsPath: n
  }) {
    super([`Encoded function signature "${t}" not found on ABI.`, "Make sure you are using the correct ABI and that the function exists on it.", `You can look up the signature here: https://openchain.xyz/signatures?query=${t}.`].join(`
`), {
      docsPath: n
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiFunctionSignatureNotFoundError"
    })
  }
}
class wTe extends $e {
  constructor(t, n) {
    super("Found ambiguous types in overloaded ABI items.", {
      metaMessages: [`\`${t.type}\` in \`${Ac(t.abiItem)}\`, and`, `\`${n.type}\` in \`${Ac(n.abiItem)}\``, "", "These types encode differently and cannot be distinguished at runtime.", "Remove one of the ambiguous items in the ABI."]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiItemAmbiguityError"
    })
  }
}
class e7 extends $e {
  constructor({
    expectedSize: t,
    givenSize: n
  }) {
    super(`Expected bytes${t}, got bytes${n}.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "BytesSizeMismatchError"
    })
  }
}
class Td extends $e {
  constructor({
    abiItem: t,
    data: n,
    params: r,
    size: i
  }) {
    super([`Data size of ${i} bytes is too small for non-indexed event parameters.`].join(`
`), {
      metaMessages: [`Params: (${v6(r,{includeName:!0})})`, `Data:   ${n} (${i} bytes)`]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "DecodeLogDataMismatch"
    }), Object.defineProperty(this, "abiItem", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "data", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "params", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "size", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.abiItem = t, this.data = n, this.params = r, this.size = i
  }
}
class Oh extends $e {
  constructor({
    abiItem: t,
    param: n
  }) {
    super([`Expected a topic for indexed event parameter${n.name?` "${n.name}"`:""} on event "${Ac(t,{includeName:!0})}".`].join(`
`)), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "DecodeLogTopicsMismatch"
    }), Object.defineProperty(this, "abiItem", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.abiItem = t
  }
}
class jG extends $e {
  constructor(t, {
    docsPath: n
  }) {
    super([`Type "${t}" is not a valid encoding type.`, "Please provide a valid ABI type."].join(`
`), {
      docsPath: n
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidAbiEncodingType"
    })
  }
}
class UG extends $e {
  constructor(t, {
    docsPath: n
  }) {
    super([`Type "${t}" is not a valid decoding type.`, "Please provide a valid ABI type."].join(`
`), {
      docsPath: n
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidAbiDecodingType"
    })
  }
}
class zG extends $e {
  constructor(t) {
    super([`Value "${t}" is not a valid array.`].join(`
`)), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidArrayError"
    })
  }
}
class HG extends $e {
  constructor(t) {
    super([`"${t}" is not a valid definition type.`, 'Valid types: "function", "event", "error"'].join(`
`)), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidDefinitionTypeError"
    })
  }
}
class VG extends $e {
  constructor(t) {
    super(`Type "${t}" is not supported for packed encoding.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "UnsupportedPackedAbiType"
    })
  }
}
class WG extends $e {
  constructor(t) {
    super(`Filter type "${t}" is not supported.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "FilterTypeNotSupportedError"
    })
  }
}
class t7 extends $e {
  constructor({
    offset: t,
    position: n,
    size: r
  }) {
    super(`Slice ${n==="start"?"starting":"ending"} at offset "${t}" is out-of-bounds (size: ${r}).`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "SliceOffsetOutOfBoundsError"
    })
  }
}
class n7 extends $e {
  constructor({
    size: t,
    targetSize: n,
    type: r
  }) {
    super(`${r.charAt(0).toUpperCase()}${r.slice(1).toLowerCase()} size (${t}) exceeds padding size (${n}).`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "SizeExceedsPaddingSizeError"
    })
  }
}

function bc(e, {
  dir: t,
  size: n = 32
} = {}) {
  return typeof e == "string" ? wc(e, {
    dir: t,
    size: n
  }) : qG(e, {
    dir: t,
    size: n
  })
}

function wc(e, {
  dir: t,
  size: n = 32
} = {}) {
  if (n === null) return e;
  const r = e.replace("0x", "");
  if (r.length > n * 2) throw new n7({
    size: Math.ceil(r.length / 2),
    targetSize: n,
    type: "hex"
  });
  return `0x${r[t==="right"?"padEnd":"padStart"](n*2,"0")}`
}

function qG(e, {
  dir: t,
  size: n = 32
} = {}) {
  if (n === null) return e;
  if (e.length > n) throw new n7({
    size: e.length,
    targetSize: n,
    type: "bytes"
  });
  const r = new Uint8Array(n);
  for (let i = 0; i < n; i++) {
    const s = t === "right";
    r[s ? i : n - i - 1] = e[s ? i : e.length - i - 1]
  }
  return r
}
class xTe extends $e {
  constructor({
    consumed: t,
    length: n
  }) {
    super(`Consumed bytes (${t}) is shorter than data length (${n-1}).`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "DataLengthTooLongError"
    })
  }
}
class ETe extends $e {
  constructor({
    length: t,
    dataLength: n
  }) {
    super(`Data length (${n-1}) is shorter than consumed bytes length (${t-1}).`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "DataLengthTooShortError"
    })
  }
}
class GG extends $e {
  constructor({
    max: t,
    min: n,
    signed: r,
    size: i,
    value: s
  }) {
    super(`Number "${s}" is not in safe ${i?`${i*8}-bit ${r?"signed":"unsigned"} `:""}integer range ${t?`(${n} to ${t})`:`(above ${n})`}`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "IntegerOutOfRangeError"
    })
  }
}
class KG extends $e {
  constructor(t) {
    super(`Bytes value "${t}" is not a valid boolean. The bytes array must contain a single byte of either a 0 or 1 value.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidBytesBooleanError"
    })
  }
}
class QG extends $e {
  constructor(t) {
    super(`Hex value "${t}" is not a valid boolean. The hex value must be "0x0" (false) or "0x1" (true).`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidHexBooleanError"
    })
  }
}
class YG extends $e {
  constructor(t) {
    super(`Hex value "${t}" is an odd length (${t.length}). It must be an even length.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidHexValueError"
    })
  }
}
class STe extends $e {
  constructor({
    nextOffset: t,
    offset: n
  }) {
    super(`Next offset (${t}) is greater than previous offset + consumed bytes (${n})`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "OffsetOutOfBoundsError"
    })
  }
}
class JG extends $e {
  constructor({
    givenSize: t,
    maxSize: n
  }) {
    super(`Size cannot exceed ${n} bytes. Given size: ${t} bytes.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "SizeOverflowError"
    })
  }
}

function lo(e, {
  dir: t = "left"
} = {}) {
  let n = typeof e == "string" ? e.replace("0x", "") : e,
    r = 0;
  for (let i = 0; i < n.length - 1 && n[t === "left" ? i : n.length - i - 1].toString() === "0"; i++) r++;
  return n = t === "left" ? n.slice(r) : n.slice(0, n.length - r), typeof e == "string" ? (n.length === 1 && t === "right" && (n = `${n}0`), `0x${n.length%2===1?`0${n}`:n}`) : n
}

function za(e, {
  size: t
}) {
  if (Qr(e) > t) throw new JG({
    givenSize: Qr(e),
    maxSize: t
  })
}

function CTe(e, t) {
  const n = typeof t == "string" ? {
      to: t
    } : t,
    r = n.to;
  return r === "number" ? Xn(e, n) : r === "bigint" ? Jn(e, n) : r === "string" ? w6(e, n) : r === "boolean" ? r7(e, n) : wu(e, n)
}

function Jn(e, t = {}) {
  const {
    signed: n
  } = t;
  t.size && za(e, {
    size: t.size
  });
  const r = BigInt(e);
  if (!n) return r;
  const i = (e.length - 2) / 2,
    s = (1n << BigInt(i) * 8n - 1n) - 1n;
  return r <= s ? r : r - BigInt(`0x${"f".padStart(i*2,"f")}`) - 1n
}

function r7(e, t = {}) {
  let n = e;
  if (t.size && (za(n, {
      size: t.size
    }), n = lo(n)), lo(n) === "0x00") return !1;
  if (lo(n) === "0x01") return !0;
  throw new QG(n)
}

function Xn(e, t = {}) {
  return Number(Jn(e, t))
}

function w6(e, t = {}) {
  let n = wu(e);
  return t.size && (za(n, {
    size: t.size
  }), n = lo(n, {
    dir: "right"
  })), new TextDecoder().decode(n)
}
const ATe = Array.from({
  length: 256
}, (e, t) => t.toString(16).padStart(2, "0"));

function yn(e, t = {}) {
  return typeof e == "number" || typeof e == "bigint" ? Ct(e, t) : typeof e == "string" ? py(e, t) : typeof e == "boolean" ? x6(e, t) : mo(e, t)
}

function x6(e, t = {}) {
  const n = `0x${Number(e)}`;
  return typeof t.size == "number" ? (za(n, {
    size: t.size
  }), bc(n, {
    size: t.size
  })) : n
}

function mo(e, t = {}) {
  let n = "";
  for (let i = 0; i < e.length; i++) n += ATe[e[i]];
  const r = `0x${n}`;
  return typeof t.size == "number" ? (za(r, {
    size: t.size
  }), bc(r, {
    dir: "right",
    size: t.size
  })) : r
}

function Ct(e, t = {}) {
  const {
    signed: n,
    size: r
  } = t, i = BigInt(e);
  let s;
  r ? n ? s = (1n << BigInt(r) * 8n - 1n) - 1n : s = 2n ** (BigInt(r) * 8n) - 1n : typeof e == "number" && (s = BigInt(Number.MAX_SAFE_INTEGER));
  const o = typeof s == "bigint" && n ? -s - 1n : 0;
  if (s && i > s || i < o) {
    const c = typeof e == "bigint" ? "n" : "";
    throw new GG({
      max: s ? `${s}${c}` : void 0,
      min: `${o}${c}`,
      signed: n,
      size: r,
      value: `${e}${c}`
    })
  }
  const a = `0x${(n&&i<0?(1n<<BigInt(r*8))+BigInt(i):i).toString(16)}`;
  return r ? bc(a, {
    size: r
  }) : a
}
const TTe = new TextEncoder;

function py(e, t = {}) {
  const n = TTe.encode(e);
  return mo(n, t)
}
const kTe = new TextEncoder;

function Bi(e, t = {}) {
  return typeof e == "number" || typeof e == "bigint" ? ZG(e, t) : typeof e == "boolean" ? XG(e, t) : hn(e) ? wu(e, t) : ul(e, t)
}

function XG(e, t = {}) {
  const n = new Uint8Array(1);
  return n[0] = Number(e), typeof t.size == "number" ? (za(n, {
    size: t.size
  }), bc(n, {
    size: t.size
  })) : n
}
const Ll = {
  zero: 48,
  nine: 57,
  A: 65,
  F: 70,
  a: 97,
  f: 102
};

function d$(e) {
  if (e >= Ll.zero && e <= Ll.nine) return e - Ll.zero;
  if (e >= Ll.A && e <= Ll.F) return e - (Ll.A - 10);
  if (e >= Ll.a && e <= Ll.f) return e - (Ll.a - 10)
}

function wu(e, t = {}) {
  let n = e;
  t.size && (za(n, {
    size: t.size
  }), n = bc(n, {
    dir: "right",
    size: t.size
  }));
  let r = n.slice(2);
  r.length % 2 && (r = `0${r}`);
  const i = r.length / 2,
    s = new Uint8Array(i);
  for (let o = 0, a = 0; o < i; o++) {
    const c = d$(r.charCodeAt(a++)),
      l = d$(r.charCodeAt(a++));
    if (c === void 0 || l === void 0) throw new $e(`Invalid byte sequence ("${r[a-2]}${r[a-1]}" in "${r}").`);
    s[o] = c * 16 + l
  }
  return s
}

function ZG(e, t) {
  const n = Ct(e, t);
  return wu(n)
}

function ul(e, t = {}) {
  const n = kTe.encode(e);
  return typeof t.size == "number" ? (za(n, {
    size: t.size
  }), bc(n, {
    dir: "right",
    size: t.size
  })) : n
}

function _Te(e) {
  let t = !0,
    n = "",
    r = 0,
    i = "",
    s = !1;
  for (let o = 0; o < e.length; o++) {
    const a = e[o];
    if (["(", ")", ","].includes(a) && (t = !0), a === "(" && r++, a === ")" && r--, !!t) {
      if (r === 0) {
        if (a === " " && ["event", "function", ""].includes(i)) i = "";
        else if (i += a, a === ")") {
          s = !0;
          break
        }
        continue
      }
      if (a === " ") {
        e[o - 1] !== "," && n !== "," && n !== ",(" && (n = "", t = !1);
        continue
      }
      i += a, n += a
    }
  }
  if (!s) throw new $e("Unable to normalize signature.");
  return i
}
const i7 = e => {
    const t = typeof e == "string" ? e : U9e(e);
    return _Te(t)
  },
  eK = e => i7(e);

function W3(e) {
  if (!Number.isSafeInteger(e) || e < 0) throw new Error(`Wrong positive integer: ${e}`)
}

function s7(e, ...t) {
  if (!(e instanceof Uint8Array)) throw new Error("Expected Uint8Array");
  if (t.length > 0 && !t.includes(e.length)) throw new Error(`Expected Uint8Array of length ${t}, not of length=${e.length}`)
}

function ITe(e) {
  if (typeof e != "function" || typeof e.create != "function") throw new Error("Hash should be wrapped by utils.wrapConstructor");
  W3(e.outputLen), W3(e.blockLen)
}

function jp(e, t = !0) {
  if (e.destroyed) throw new Error("Hash instance has been destroyed");
  if (t && e.finished) throw new Error("Hash#digest() has already been called")
}

function tK(e, t) {
  s7(e);
  const n = t.outputLen;
  if (e.length < n) throw new Error(`digestInto() expects output buffer of length at least ${n}`)
}
const _b = BigInt(2 ** 32 - 1),
  f$ = BigInt(32);

function PTe(e, t = !1) {
  return t ? {
    h: Number(e & _b),
    l: Number(e >> f$ & _b)
  } : {
    h: Number(e >> f$ & _b) | 0,
    l: Number(e & _b) | 0
  }
}

function RTe(e, t = !1) {
  let n = new Uint32Array(e.length),
    r = new Uint32Array(e.length);
  for (let i = 0; i < e.length; i++) {
    const {
      h: s,
      l: o
    } = PTe(e[i], t);
    [n[i], r[i]] = [s, o]
  }
  return [n, r]
}
const OTe = (e, t, n) => e << n | t >>> 32 - n,
  DTe = (e, t, n) => t << n | e >>> 32 - n,
  NTe = (e, t, n) => t << n - 32 | e >>> 64 - n,
  MTe = (e, t, n) => e << n - 32 | t >>> 64 - n,
  QS = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0; /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const nK = e => e instanceof Uint8Array,
  $Te = e => new Uint32Array(e.buffer, e.byteOffset, Math.floor(e.byteLength / 4)),
  YS = e => new DataView(e.buffer, e.byteOffset, e.byteLength),
  Lc = (e, t) => e << 32 - t | e >>> t,
  LTe = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!LTe) throw new Error("Non little-endian hardware is not supported");

function BTe(e) {
  if (typeof e != "string") throw new Error(`utf8ToBytes expected string, got ${typeof e}`);
  return new Uint8Array(new TextEncoder().encode(e))
}

function E6(e) {
  if (typeof e == "string" && (e = BTe(e)), !nK(e)) throw new Error(`expected Uint8Array, got ${typeof e}`);
  return e
}

function FTe(...e) {
  const t = new Uint8Array(e.reduce((r, i) => r + i.length, 0));
  let n = 0;
  return e.forEach(r => {
    if (!nK(r)) throw new Error("Uint8Array expected");
    t.set(r, n), n += r.length
  }), t
}
class o7 {
  clone() {
    return this._cloneInto()
  }
}

function a7(e) {
  const t = r => e().update(E6(r)).digest(),
    n = e();
  return t.outputLen = n.outputLen, t.blockLen = n.blockLen, t.create = () => e(), t
}

function rK(e = 32) {
  if (QS && typeof QS.getRandomValues == "function") return QS.getRandomValues(new Uint8Array(e));
  throw new Error("crypto.getRandomValues must be defined")
}
const [iK, sK, oK] = [
  [],
  [],
  []
], jTe = BigInt(0), Bg = BigInt(1), UTe = BigInt(2), zTe = BigInt(7), HTe = BigInt(256), VTe = BigInt(113);
for (let e = 0, t = Bg, n = 1, r = 0; e < 24; e++) {
  [n, r] = [r, (2 * n + 3 * r) % 5], iK.push(2 * (5 * r + n)), sK.push((e + 1) * (e + 2) / 2 % 64);
  let i = jTe;
  for (let s = 0; s < 7; s++) t = (t << Bg ^ (t >> zTe) * VTe) % HTe, t & UTe && (i ^= Bg << (Bg << BigInt(s)) - Bg);
  oK.push(i)
}
const [WTe, qTe] = RTe(oK, !0), h$ = (e, t, n) => n > 32 ? NTe(e, t, n) : OTe(e, t, n), p$ = (e, t, n) => n > 32 ? MTe(e, t, n) : DTe(e, t, n);

function GTe(e, t = 24) {
  const n = new Uint32Array(10);
  for (let r = 24 - t; r < 24; r++) {
    for (let o = 0; o < 10; o++) n[o] = e[o] ^ e[o + 10] ^ e[o + 20] ^ e[o + 30] ^ e[o + 40];
    for (let o = 0; o < 10; o += 2) {
      const a = (o + 8) % 10,
        c = (o + 2) % 10,
        l = n[c],
        u = n[c + 1],
        f = h$(l, u, 1) ^ n[a],
        h = p$(l, u, 1) ^ n[a + 1];
      for (let g = 0; g < 50; g += 10) e[o + g] ^= f, e[o + g + 1] ^= h
    }
    let i = e[2],
      s = e[3];
    for (let o = 0; o < 24; o++) {
      const a = sK[o],
        c = h$(i, s, a),
        l = p$(i, s, a),
        u = iK[o];
      i = e[u], s = e[u + 1], e[u] = c, e[u + 1] = l
    }
    for (let o = 0; o < 50; o += 10) {
      for (let a = 0; a < 10; a++) n[a] = e[o + a];
      for (let a = 0; a < 10; a++) e[o + a] ^= ~n[(a + 2) % 10] & n[(a + 4) % 10]
    }
    e[0] ^= WTe[r], e[1] ^= qTe[r]
  }
  n.fill(0)
}
class c7 extends o7 {
  constructor(t, n, r, i = !1, s = 24) {
    if (super(), this.blockLen = t, this.suffix = n, this.outputLen = r, this.enableXOF = i, this.rounds = s, this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, W3(r), 0 >= this.blockLen || this.blockLen >= 200) throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200), this.state32 = $Te(this.state)
  }
  keccak() {
    GTe(this.state32, this.rounds), this.posOut = 0, this.pos = 0
  }
  update(t) {
    jp(this);
    const {
      blockLen: n,
      state: r
    } = this;
    t = E6(t);
    const i = t.length;
    for (let s = 0; s < i;) {
      const o = Math.min(n - this.pos, i - s);
      for (let a = 0; a < o; a++) r[this.pos++] ^= t[s++];
      this.pos === n && this.keccak()
    }
    return this
  }
  finish() {
    if (this.finished) return;
    this.finished = !0;
    const {
      state: t,
      suffix: n,
      pos: r,
      blockLen: i
    } = this;
    t[r] ^= n, n & 128 && r === i - 1 && this.keccak(), t[i - 1] ^= 128, this.keccak()
  }
  writeInto(t) {
    jp(this, !1), s7(t), this.finish();
    const n = this.state,
      {
        blockLen: r
      } = this;
    for (let i = 0, s = t.length; i < s;) {
      this.posOut >= r && this.keccak();
      const o = Math.min(r - this.posOut, s - i);
      t.set(n.subarray(this.posOut, this.posOut + o), i), this.posOut += o, i += o
    }
    return t
  }
  xofInto(t) {
    if (!this.enableXOF) throw new Error("XOF is not possible for this instance");
    return this.writeInto(t)
  }
  xof(t) {
    return W3(t), this.xofInto(new Uint8Array(t))
  }
  digestInto(t) {
    if (tK(t, this), this.finished) throw new Error("digest() was already called");
    return this.writeInto(t), this.destroy(), t
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen))
  }
  destroy() {
    this.destroyed = !0, this.state.fill(0)
  }
  _cloneInto(t) {
    const {
      blockLen: n,
      suffix: r,
      outputLen: i,
      rounds: s,
      enableXOF: o
    } = this;
    return t || (t = new c7(n, r, i, o, s)), t.state32.set(this.state32), t.pos = this.pos, t.posOut = this.posOut, t.finished = this.finished, t.rounds = s, t.suffix = r, t.outputLen = i, t.enableXOF = o, t.destroyed = this.destroyed, t
  }
}
const KTe = (e, t, n) => a7(() => new c7(t, e, n)),
  QTe = KTe(1, 136, 256 / 8);

function ii(e, t) {
  const n = t || "hex",
    r = QTe(hn(e, {
      strict: !1
    }) ? Bi(e) : e);
  return n === "bytes" ? r : yn(r)
}
const YTe = e => ii(Bi(e)),
  S6 = e => YTe(eK(e));
class go extends $e {
  constructor({
    address: t
  }) {
    super(`Address "${t}" is invalid.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidAddressError"
    })
  }
}
const JTe = /^0x[a-fA-F0-9]{40}$/;

function Hi(e) {
  return JTe.test(e)
}

function Da(e) {
  return typeof e[0] == "string" ? xu(e) : aK(e)
}

function aK(e) {
  let t = 0;
  for (const i of e) t += i.length;
  const n = new Uint8Array(t);
  let r = 0;
  for (const i of e) n.set(i, r), r += i.length;
  return n
}

function xu(e) {
  return `0x${e.reduce((t,n)=>t+n.replace("0x",""),"")}`
}

function Sr(e, t, n, {
  strict: r
} = {}) {
  return hn(e, {
    strict: !1
  }) ? l7(e, t, n, {
    strict: r
  }) : uK(e, t, n, {
    strict: r
  })
}

function cK(e, t) {
  if (typeof t == "number" && t > 0 && t > Qr(e) - 1) throw new t7({
    offset: t,
    position: "start",
    size: Qr(e)
  })
}

function lK(e, t, n) {
  if (typeof t == "number" && typeof n == "number" && Qr(e) !== n - t) throw new t7({
    offset: n,
    position: "end",
    size: Qr(e)
  })
}

function uK(e, t, n, {
  strict: r
} = {}) {
  cK(e, t);
  const i = e.slice(t, n);
  return r && lK(i, t, n), i
}

function l7(e, t, n, {
  strict: r
} = {}) {
  cK(e, t);
  const i = `0x${e.replace("0x","").slice((t??0)*2,(n??e.length)*2)}`;
  return r && lK(i, t, n), i
}

function Eu(e, t) {
  if (e.length !== t.length) throw new Jk({
    expectedLength: e.length,
    givenLength: t.length
  });
  const n = XTe({
      params: e,
      values: t
    }),
    r = d7(n);
  return r.length === 0 ? "0x" : r
}

function XTe({
  params: e,
  values: t
}) {
  const n = [];
  for (let r = 0; r < e.length; r++) n.push(u7({
    param: e[r],
    value: t[r]
  }));
  return n
}

function u7({
  param: e,
  value: t
}) {
  const n = C6(e.type);
  if (n) {
    const [r, i] = n;
    return eke(t, {
      length: r,
      param: {
        ...e,
        type: i
      }
    })
  }
  if (e.type === "tuple") return ske(t, {
    param: e
  });
  if (e.type === "address") return ZTe(t);
  if (e.type === "bool") return nke(t);
  if (e.type.startsWith("uint") || e.type.startsWith("int")) {
    const r = e.type.startsWith("int");
    return rke(t, {
      signed: r
    })
  }
  if (e.type.startsWith("bytes")) return tke(t, {
    param: e
  });
  if (e.type === "string") return ike(t);
  throw new jG(e.type, {
    docsPath: "/docs/contract/encodeAbiParameters"
  })
}

function d7(e) {
  let t = 0;
  for (let s = 0; s < e.length; s++) {
    const {
      dynamic: o,
      encoded: a
    } = e[s];
    o ? t += 32 : t += Qr(a)
  }
  const n = [],
    r = [];
  let i = 0;
  for (let s = 0; s < e.length; s++) {
    const {
      dynamic: o,
      encoded: a
    } = e[s];
    o ? (n.push(Ct(t + i, {
      size: 32
    })), r.push(a), i += Qr(a)) : n.push(a)
  }
  return Da([...n, ...r])
}

function ZTe(e) {
  if (!Hi(e)) throw new go({
    address: e
  });
  return {
    dynamic: !1,
    encoded: wc(e.toLowerCase())
  }
}

function eke(e, {
  length: t,
  param: n
}) {
  const r = t === null;
  if (!Array.isArray(e)) throw new zG(e);
  if (!r && e.length !== t) throw new NG({
    expectedLength: t,
    givenLength: e.length,
    type: `${n.type}[${t}]`
  });
  let i = !1;
  const s = [];
  for (let o = 0; o < e.length; o++) {
    const a = u7({
      param: n,
      value: e[o]
    });
    a.dynamic && (i = !0), s.push(a)
  }
  if (r || i) {
    const o = d7(s);
    if (r) {
      const a = Ct(s.length, {
        size: 32
      });
      return {
        dynamic: !0,
        encoded: s.length > 0 ? Da([a, o]) : a
      }
    }
    if (i) return {
      dynamic: !0,
      encoded: o
    }
  }
  return {
    dynamic: !1,
    encoded: Da(s.map(({
      encoded: o
    }) => o))
  }
}

function tke(e, {
  param: t
}) {
  const [, n] = t.type.split("bytes"), r = Qr(e);
  if (!n) {
    let i = e;
    return r % 32 !== 0 && (i = wc(i, {
      dir: "right",
      size: Math.ceil((e.length - 2) / 2 / 32) * 32
    })), {
      dynamic: !0,
      encoded: Da([wc(Ct(r, {
        size: 32
      })), i])
    }
  }
  if (r !== parseInt(n)) throw new MG({
    expectedSize: parseInt(n),
    value: e
  });
  return {
    dynamic: !1,
    encoded: wc(e, {
      dir: "right"
    })
  }
}

function nke(e) {
  return {
    dynamic: !1,
    encoded: wc(x6(e))
  }
}

function rke(e, {
  signed: t
}) {
  return {
    dynamic: !1,
    encoded: Ct(e, {
      size: 32,
      signed: t
    })
  }
}

function ike(e) {
  const t = py(e),
    n = Math.ceil(Qr(t) / 32),
    r = [];
  for (let i = 0; i < n; i++) r.push(wc(Sr(t, i * 32, (i + 1) * 32), {
    dir: "right"
  }));
  return {
    dynamic: !0,
    encoded: Da([wc(Ct(Qr(t), {
      size: 32
    })), ...r])
  }
}

function ske(e, {
  param: t
}) {
  let n = !1;
  const r = [];
  for (let i = 0; i < t.components.length; i++) {
    const s = t.components[i],
      o = Array.isArray(e) ? i : s.name,
      a = u7({
        param: s,
        value: e[o]
      });
    r.push(a), a.dynamic && (n = !0)
  }
  return {
    dynamic: n,
    encoded: n ? d7(r) : Da(r.map(({
      encoded: i
    }) => i))
  }
}

function C6(e) {
  const t = e.match(/^(.*)\[(\d+)?\]$/);
  return t ? [t[2] ? Number(t[2]) : null, t[1]] : void 0
}
const oke = e => ii(Bi(e)),
  Nm = e => Sr(oke(i7(e)), 0, 4);

function Hd({
  abi: e,
  args: t = [],
  name: n
}) {
  const r = hn(n, {
      strict: !1
    }),
    i = e.filter(o => r ? o.type === "function" ? Nm(o) === n : o.type === "event" ? S6(o) === n : !1 : "name" in o && o.name === n);
  if (i.length === 0) return;
  if (i.length === 1) return i[0];
  let s;
  for (const o of i) {
    if (!("inputs" in o)) continue;
    if (!t || t.length === 0) {
      if (!o.inputs || o.inputs.length === 0) return o;
      continue
    }
    if (!o.inputs || o.inputs.length === 0 || o.inputs.length !== t.length) continue;
    if (t.every((c, l) => {
        const u = "inputs" in o && o.inputs[l];
        return u ? IA(c, u) : !1
      })) {
      if (s && "inputs" in s && s.inputs) {
        const c = dK(o.inputs, s.inputs, t);
        if (c) throw new wTe({
          abiItem: o,
          type: c[0]
        }, {
          abiItem: s,
          type: c[1]
        })
      }
      s = o
    }
  }
  return s || i[0]
}

function IA(e, t) {
  const n = typeof e,
    r = t.type;
  switch (r) {
    case "address":
      return Hi(e);
    case "bool":
      return n === "boolean";
    case "function":
      return n === "string";
    case "string":
      return n === "string";
    default:
      return r === "tuple" && "components" in t ? Object.values(t.components).every((i, s) => IA(Object.values(e)[s], i)) : /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(r) ? n === "number" || n === "bigint" : /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(r) ? n === "string" || e instanceof Uint8Array : /[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(r) ? Array.isArray(e) && e.every(i => IA(i, {
        ...t,
        type: r.replace(/(\[[0-9]{0,}\])$/, "")
      })) : !1
  }
}

function dK(e, t, n) {
  for (const r in e) {
    const i = e[r],
      s = t[r];
    if (i.type === "tuple" && s.type === "tuple" && "components" in i && "components" in s) return dK(i.components, s.components, n[r]);
    const o = [i.type, s.type];
    if (o.includes("address") && o.includes("bytes20") ? !0 : o.includes("address") && o.includes("string") || o.includes("address") && o.includes("bytes") ? Hi(n[r]) : !1) return o
  }
}

function Mm({
  abi: e,
  eventName: t,
  args: n
}) {
  var a;
  let r = e[0];
  if (t && (r = Hd({
      abi: e,
      args: n,
      name: t
    }), !r)) throw new _A(t, {
    docsPath: "/docs/contract/encodeEventTopics"
  });
  if (r.type !== "event") throw new _A(void 0, {
    docsPath: "/docs/contract/encodeEventTopics"
  });
  const i = Ac(r),
    s = S6(i);
  let o = [];
  if (n && "inputs" in r) {
    const c = (a = r.inputs) == null ? void 0 : a.filter(u => "indexed" in u && u.indexed),
      l = Array.isArray(n) ? n : Object.values(n).length > 0 ? (c == null ? void 0 : c.map(u => n[u.name])) ?? [] : [];
    l.length > 0 && (o = (c == null ? void 0 : c.map((u, f) => Array.isArray(l[f]) ? l[f].map((h, g) => m$({
      param: u,
      value: l[f][g]
    })) : l[f] ? m$({
      param: u,
      value: l[f]
    }) : null)) ?? [])
  }
  return [s, ...o]
}

function m$({
  param: e,
  value: t
}) {
  if (e.type === "string" || e.type === "bytes") return ii(Bi(t));
  if (e.type === "tuple" || e.type.match(/^(.*)\[(\d+)?\]$/)) throw new WG(e.type);
  return Eu([e], [t])
}

function A6(e, {
  method: t
}) {
  var r, i;
  const n = {};
  return e.transport.type === "fallback" && ((i = (r = e.transport).onResponse) == null || i.call(r, ({
    method: s,
    response: o,
    status: a,
    transport: c
  }) => {
    a === "success" && t === s && (n[o] = c.request)
  })), s => n[s] || e.request
}
async function f7(e, {
  address: t,
  abi: n,
  args: r,
  eventName: i,
  fromBlock: s,
  strict: o,
  toBlock: a
}) {
  const c = A6(e, {
      method: "eth_newFilter"
    }),
    l = i ? Mm({
      abi: n,
      args: r,
      eventName: i
    }) : void 0,
    u = await e.request({
      method: "eth_newFilter",
      params: [{
        address: t,
        fromBlock: typeof s == "bigint" ? Ct(s) : s,
        toBlock: typeof a == "bigint" ? Ct(a) : a,
        topics: l
      }]
    });
  return {
    abi: n,
    args: r,
    eventName: i,
    id: u,
    request: c(u),
    strict: o,
    type: "event"
  }
}

function Ha(e) {
  return typeof e == "string" ? {
    address: e,
    type: "json-rpc"
  } : e
}

function Su({
  abi: e,
  args: t,
  functionName: n
}) {
  let r = e[0];
  if (n && (r = Hd({
      abi: e,
      args: t,
      name: n
    }), !r)) throw new mh(n, {
    docsPath: "/docs/contract/encodeFunctionData"
  });
  if (r.type !== "function") throw new mh(void 0, {
    docsPath: "/docs/contract/encodeFunctionData"
  });
  const i = Ac(r),
    s = Nm(i),
    o = "inputs" in r && r.inputs ? Eu(r.inputs, t ?? []) : void 0;
  return xu([s, o ?? "0x"])
}
const fK = {
    1: "An `assert` condition failed.",
    17: "Arithmic operation resulted in underflow or overflow.",
    18: "Division or modulo by zero (e.g. `5 / 0` or `23 % 0`).",
    33: "Attempted to convert to an invalid type.",
    34: "Attempted to access a storage byte array that is incorrectly encoded.",
    49: "Performed `.pop()` on an empty array",
    50: "Array index is out of bounds.",
    65: "Allocated too much memory or created an array which is too large.",
    81: "Attempted to call a zero-initialized variable of internal function type."
  },
  ake = {
    inputs: [{
      name: "message",
      type: "string"
    }],
    name: "Error",
    type: "error"
  },
  cke = {
    inputs: [{
      name: "reason",
      type: "uint256"
    }],
    name: "Panic",
    type: "error"
  };

function my(e, t) {
  const n = t ? `${t}${e.toLowerCase()}` : e.substring(2).toLowerCase(),
    r = ii(ul(n), "bytes"),
    i = (t ? n.substring(`${t}0x`.length) : n).split("");
  for (let s = 0; s < 40; s += 2) r[s >> 1] >> 4 >= 8 && i[s] && (i[s] = i[s].toUpperCase()), (r[s >> 1] & 15) >= 8 && i[s + 1] && (i[s + 1] = i[s + 1].toUpperCase());
  return `0x${i.join("")}`
}

function kd(e, t) {
  if (!Hi(e)) throw new go({
    address: e
  });
  return my(e, t)
}

function Dh(e, t) {
  if (t === "0x" && e.length > 0) throw new hy;
  if (Qr(t) && Qr(t) < 32) throw new b6({
    data: t,
    params: e,
    size: Qr(t)
  });
  return lke({
    data: t,
    params: e
  })
}

function lke({
  data: e,
  params: t
}) {
  const n = [];
  let r = 0;
  for (let i = 0; i < t.length; i++) {
    if (r >= Qr(e)) throw new b6({
      data: e,
      params: t,
      size: Qr(e)
    });
    const s = t[i],
      {
        consumed: o,
        value: a
      } = gp({
        data: e,
        param: s,
        position: r
      });
    n.push(a), r += o
  }
  return n
}

function gp({
  data: e,
  param: t,
  position: n
}) {
  const r = C6(t.type);
  if (r) {
    const [s, o] = r;
    return dke(e, {
      length: s,
      param: {
        ...t,
        type: o
      },
      position: n
    })
  }
  if (t.type === "tuple") return gke(e, {
    param: t,
    position: n
  });
  if (t.type === "string") return mke(e, {
    position: n
  });
  if (t.type.startsWith("bytes")) return hke(e, {
    param: t,
    position: n
  });
  const i = Sr(e, n, n + 32, {
    strict: !0
  });
  if (t.type.startsWith("uint") || t.type.startsWith("int")) return pke(i, {
    param: t
  });
  if (t.type === "address") return uke(i);
  if (t.type === "bool") return fke(i);
  throw new UG(t.type, {
    docsPath: "/docs/contract/decodeAbiParameters"
  })
}

function uke(e) {
  return {
    consumed: 32,
    value: my(Sr(e, -20))
  }
}

function dke(e, {
  param: t,
  length: n,
  position: r
}) {
  if (!n) {
    const o = Xn(Sr(e, r, r + 32, {
        strict: !0
      })),
      a = Xn(Sr(e, o, o + 32, {
        strict: !0
      }));
    let c = 0;
    const l = [];
    for (let u = 0; u < a; ++u) {
      const f = gp({
        data: Sr(e, o + 32),
        param: t,
        position: c
      });
      c += f.consumed, l.push(f.value)
    }
    return {
      value: l,
      consumed: 32
    }
  }
  if (q3(t)) {
    const o = C6(t.type),
      a = !(o != null && o[0]);
    let c = 0;
    const l = [];
    for (let u = 0; u < n; ++u) {
      const f = Xn(Sr(e, r, r + 32, {
          strict: !0
        })),
        h = gp({
          data: Sr(e, f),
          param: t,
          position: a ? c : u * 32
        });
      c += h.consumed, l.push(h.value)
    }
    return {
      value: l,
      consumed: 32
    }
  }
  let i = 0;
  const s = [];
  for (let o = 0; o < n; ++o) {
    const a = gp({
      data: e,
      param: t,
      position: r + i
    });
    i += a.consumed, s.push(a.value)
  }
  return {
    value: s,
    consumed: i
  }
}

function fke(e) {
  return {
    consumed: 32,
    value: r7(e)
  }
}

function hke(e, {
  param: t,
  position: n
}) {
  const [r, i] = t.type.split("bytes");
  if (!i) {
    const o = Xn(Sr(e, n, n + 32, {
        strict: !0
      })),
      a = Xn(Sr(e, o, o + 32, {
        strict: !0
      }));
    return a === 0 ? {
      consumed: 32,
      value: "0x"
    } : {
      consumed: 32,
      value: Sr(e, o + 32, o + 32 + a, {
        strict: !0
      })
    }
  }
  return {
    consumed: 32,
    value: Sr(e, n, n + parseInt(i), {
      strict: !0
    })
  }
}

function pke(e, {
  param: t
}) {
  const n = t.type.startsWith("int");
  return {
    consumed: 32,
    value: parseInt(t.type.split("int")[1] || "256") > 48 ? Jn(e, {
      signed: n
    }) : Xn(e, {
      signed: n
    })
  }
}

function mke(e, {
  position: t
}) {
  const n = Xn(Sr(e, t, t + 32, {
      strict: !0
    })),
    r = Xn(Sr(e, n, n + 32, {
      strict: !0
    }));
  return r === 0 ? {
    consumed: 32,
    value: ""
  } : {
    consumed: 32,
    value: w6(lo(Sr(e, n + 32, n + 32 + r, {
      strict: !0
    })))
  }
}

function gke(e, {
  param: t,
  position: n
}) {
  const r = t.components.length === 0 || t.components.some(({
      name: o
    }) => !o),
    i = r ? [] : {};
  let s = 0;
  if (q3(t)) {
    const o = Xn(Sr(e, n, n + 32, {
      strict: !0
    }));
    for (let a = 0; a < t.components.length; ++a) {
      const c = t.components[a],
        l = gp({
          data: Sr(e, o),
          param: c,
          position: s
        });
      s += l.consumed, i[r ? a : c == null ? void 0 : c.name] = l.value
    }
    return {
      consumed: 32,
      value: i
    }
  }
  for (let o = 0; o < t.components.length; ++o) {
    const a = t.components[o],
      c = gp({
        data: e,
        param: a,
        position: n + s
      });
    s += c.consumed, i[r ? o : a == null ? void 0 : a.name] = c.value
  }
  return {
    consumed: s,
    value: i
  }
}

function q3(e) {
  var r;
  const {
    type: t
  } = e;
  if (t === "string" || t === "bytes" || t.endsWith("[]")) return !0;
  if (t === "tuple") return (r = e.components) == null ? void 0 : r.some(q3);
  const n = C6(e.type);
  return !!(n && q3({
    ...e,
    type: n[1]
  }))
}

function h7({
  abi: e,
  data: t
}) {
  const n = Sr(t, 0, 4);
  if (n === "0x") throw new hy;
  const i = [...e || [], ake, cke].find(s => s.type === "error" && n === Nm(Ac(s)));
  if (!i) throw new Xk(n, {
    docsPath: "/docs/contract/decodeErrorResult"
  });
  return {
    abiItem: i,
    args: "inputs" in i && i.inputs && i.inputs.length > 0 ? Dh(i.inputs, Sr(t, 4)) : void 0,
    errorName: i.name
  }
}
const Ti = (e, t, n) => JSON.stringify(e, (r, i) => {
  const s = typeof i == "bigint" ? i.toString() : i;
  return typeof t == "function" ? t(r, s) : s
}, n);

function hK({
  abiItem: e,
  args: t,
  includeFunctionName: n = !0,
  includeName: r = !1
}) {
  if ("name" in e && "inputs" in e && e.inputs) return `${n?e.name:""}(${e.inputs.map((i,s)=>`${r&&i.name?`${i.name}: `:""}${typeof t[s]=="object"?Ti(t[s]):t[s]}`).join(", ")})`
}
const p7 = {
    gwei: 9,
    wei: 18
  },
  m7 = {
    ether: -9,
    wei: 9
  },
  yke = {
    ether: -18,
    gwei: -9
  };

function g7(e, t) {
  let n = e.toString();
  const r = n.startsWith("-");
  r && (n = n.slice(1)), n = n.padStart(t, "0");
  let [i, s] = [n.slice(0, n.length - t), n.slice(n.length - t)];
  return s = s.replace(/(0+)$/, ""), `${r?"-":""}${i||"0"}${s?`.${s}`:""}`
}

function T6(e, t = "wei") {
  return g7(e, p7[t])
}

function Is(e, t = "wei") {
  return g7(e, m7[t])
}

function gy(e) {
  const t = Object.entries(e).map(([r, i]) => i === void 0 || i === !1 ? null : [r, i]).filter(Boolean),
    n = t.reduce((r, [i]) => Math.max(r, i.length), 0);
  return t.map(([r, i]) => `  ${`${r}:`.padEnd(n+1)}  ${i}`).join(`
`)
}
class pK extends $e {
  constructor() {
    super(["Cannot specify both a `gasPrice` and a `maxFeePerGas`/`maxPriorityFeePerGas`.", "Use `maxFeePerGas`/`maxPriorityFeePerGas` for EIP-1559 compatible networks, and `gasPrice` for others."].join(`
`)), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "FeeConflictError"
    })
  }
}
class y7 extends $e {
  constructor({
    v: t
  }) {
    super(`Invalid \`v\` value "${t}". Expected 27 or 28.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidLegacyVError"
    })
  }
}
class mK extends $e {
  constructor({
    transaction: t
  }) {
    super("Cannot infer a transaction type from provided transaction.", {
      metaMessages: ["Provided Transaction:", "{", gy(t), "}", "", "To infer the type, either provide:", "- a `type` to the Transaction, or", "- an EIP-1559 Transaction with `maxFeePerGas`, or", "- an EIP-2930 Transaction with `gasPrice` & `accessList`, or", "- a Legacy Transaction with `gasPrice`"]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidSerializableTransactionError"
    })
  }
}
class gK extends $e {
  constructor({
    serializedType: t
  }) {
    super(`Serialized transaction type "${t}" is invalid.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidSerializedTransactionType"
    }), Object.defineProperty(this, "serializedType", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.serializedType = t
  }
}
class k6 extends $e {
  constructor({
    attributes: t,
    serializedTransaction: n,
    type: r
  }) {
    const i = Object.entries(t).map(([s, o]) => typeof o > "u" ? s : void 0).filter(Boolean);
    super(`Invalid serialized transaction of type "${r}" was provided.`, {
      metaMessages: [`Serialized Transaction: "${n}"`, i.length > 0 ? `Missing Attributes: ${i.join(", ")}` : ""].filter(Boolean)
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidSerializedTransactionError"
    }), Object.defineProperty(this, "serializedTransaction", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "type", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.serializedTransaction = n, this.type = r
  }
}
class yK extends $e {
  constructor({
    storageKey: t
  }) {
    super(`Size for storage key "${t}" is invalid. Expected 32 bytes. Got ${Math.floor((t.length-2)/2)} bytes.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidStorageKeySizeError"
    })
  }
}
class vK extends $e {
  constructor(t, {
    account: n,
    docsPath: r,
    chain: i,
    data: s,
    gas: o,
    gasPrice: a,
    maxFeePerGas: c,
    maxPriorityFeePerGas: l,
    nonce: u,
    to: f,
    value: h
  }) {
    var y;
    const g = gy({
      chain: i && `${i==null?void 0:i.name} (id: ${i==null?void 0:i.id})`,
      from: n == null ? void 0 : n.address,
      to: f,
      value: typeof h < "u" && `${T6(h)} ${((y=i==null?void 0:i.nativeCurrency)==null?void 0:y.symbol)||"ETH"}`,
      data: s,
      gas: o,
      gasPrice: typeof a < "u" && `${Is(a)} gwei`,
      maxFeePerGas: typeof c < "u" && `${Is(c)} gwei`,
      maxPriorityFeePerGas: typeof l < "u" && `${Is(l)} gwei`,
      nonce: u
    });
    super(t.shortMessage, {
      cause: t,
      docsPath: r,
      metaMessages: [...t.metaMessages ? [...t.metaMessages, " "] : [], "Request Arguments:", g].filter(Boolean)
    }), Object.defineProperty(this, "cause", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "TransactionExecutionError"
    }), this.cause = t
  }
}
class v7 extends $e {
  constructor({
    blockHash: t,
    blockNumber: n,
    blockTag: r,
    hash: i,
    index: s
  }) {
    let o = "Transaction";
    r && s !== void 0 && (o = `Transaction at block time "${r}" at index "${s}"`), t && s !== void 0 && (o = `Transaction at block hash "${t}" at index "${s}"`), n && s !== void 0 && (o = `Transaction at block number "${n}" at index "${s}"`), i && (o = `Transaction with hash "${i}"`), super(`${o} could not be found.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "TransactionNotFoundError"
    })
  }
}
class b7 extends $e {
  constructor({
    hash: t
  }) {
    super(`Transaction receipt with hash "${t}" could not be found. The Transaction may not be processed on a block yet.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "TransactionReceiptNotFoundError"
    })
  }
}
class bK extends $e {
  constructor({
    hash: t
  }) {
    super(`Timed out while waiting for transaction with hash "${t}" to be confirmed.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "WaitForTransactionReceiptTimeoutError"
    })
  }
}
class w7 extends $e {
  constructor(t, {
    account: n,
    docsPath: r,
    chain: i,
    data: s,
    gas: o,
    gasPrice: a,
    maxFeePerGas: c,
    maxPriorityFeePerGas: l,
    nonce: u,
    to: f,
    value: h
  }) {
    var x;
    const g = n ? Ha(n) : void 0,
      y = gy({
        from: g == null ? void 0 : g.address,
        to: f,
        value: typeof h < "u" && `${T6(h)} ${((x=i==null?void 0:i.nativeCurrency)==null?void 0:x.symbol)||"ETH"}`,
        data: s,
        gas: o,
        gasPrice: typeof a < "u" && `${Is(a)} gwei`,
        maxFeePerGas: typeof c < "u" && `${Is(c)} gwei`,
        maxPriorityFeePerGas: typeof l < "u" && `${Is(l)} gwei`,
        nonce: u
      });
    super(t.shortMessage, {
      cause: t,
      docsPath: r,
      metaMessages: [...t.metaMessages ? [...t.metaMessages, " "] : [], "Raw Call Arguments:", y].filter(Boolean)
    }), Object.defineProperty(this, "cause", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "CallExecutionError"
    }), this.cause = t
  }
}
class wK extends $e {
  constructor(t, {
    abi: n,
    args: r,
    contractAddress: i,
    docsPath: s,
    functionName: o,
    sender: a
  }) {
    const c = Hd({
        abi: n,
        args: r,
        name: o
      }),
      l = c ? hK({
        abiItem: c,
        args: r,
        includeFunctionName: !1,
        includeName: !1
      }) : void 0,
      u = c ? Ac(c, {
        includeName: !0
      }) : void 0,
      f = gy({
        address: i && yTe(i),
        function: u,
        args: l && l !== "()" && `${[...Array((o==null?void 0:o.length)??0).keys()].map(()=>" ").join("")}${l}`,
        sender: a
      });
    super(t.shortMessage || `An unknown error occurred while executing the contract function "${o}".`, {
      cause: t,
      docsPath: s,
      metaMessages: [...t.metaMessages ? [...t.metaMessages, " "] : [], "Contract Call:", f].filter(Boolean)
    }), Object.defineProperty(this, "abi", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "args", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "cause", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "contractAddress", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "formattedArgs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "functionName", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "sender", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ContractFunctionExecutionError"
    }), this.abi = n, this.args = r, this.cause = t, this.contractAddress = i, this.functionName = o, this.sender = a
  }
}
class G3 extends $e {
  constructor({
    abi: t,
    data: n,
    functionName: r,
    message: i
  }) {
    let s, o, a, c;
    if (n && n !== "0x") try {
      o = h7({
        abi: t,
        data: n
      });
      const {
        abiItem: u,
        errorName: f,
        args: h
      } = o;
      if (f === "Error") c = h[0];
      else if (f === "Panic") {
        const [g] = h;
        c = fK[g]
      } else {
        const g = u ? Ac(u, {
            includeName: !0
          }) : void 0,
          y = u && h ? hK({
            abiItem: u,
            args: h,
            includeFunctionName: !1,
            includeName: !1
          }) : void 0;
        a = [g ? `Error: ${g}` : "", y && y !== "()" ? `       ${[...Array((f==null?void 0:f.length)??0).keys()].map(()=>" ").join("")}${y}` : ""]
      }
    } catch (u) {
      s = u
    } else i && (c = i);
    let l;
    s instanceof Xk && (l = s.signature, a = [`Unable to decode signature "${l}" as it was not found on the provided ABI.`, "Make sure you are using the correct ABI and that the error exists on it.", `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${l}.`]), super(c && c !== "execution reverted" || l ? [`The contract function "${r}" reverted with the following ${l?"signature":"reason"}:`, c || l].join(`
`) : `The contract function "${r}" reverted.`, {
      cause: s,
      metaMessages: a
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ContractFunctionRevertedError"
    }), Object.defineProperty(this, "data", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "reason", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "signature", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.data = o, this.reason = c, this.signature = l
  }
}
class xK extends $e {
  constructor({
    functionName: t
  }) {
    super(`The contract function "${t}" returned no data ("0x").`, {
      metaMessages: ["This could be due to any of the following:", `  - The contract does not have the function "${t}",`, "  - The parameters passed to the contract function may be invalid, or", "  - The address is not a contract."]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ContractFunctionZeroDataError"
    })
  }
}
class _6 extends $e {
  constructor({
    data: t,
    message: n
  }) {
    super(n || ""), Object.defineProperty(this, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 3
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "RawContractError"
    }), Object.defineProperty(this, "data", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.data = t
  }
}
class vd extends $e {
  constructor({
    body: t,
    details: n,
    headers: r,
    status: i,
    url: s
  }) {
    super("HTTP request failed.", {
      details: n,
      metaMessages: [i && `Status: ${i}`, `URL: ${Dm(s)}`, t && `Request body: ${Ti(t)}`].filter(Boolean)
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "HttpRequestError"
    }), Object.defineProperty(this, "body", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "headers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "status", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "url", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.body = t, this.headers = r, this.status = i, this.url = s
  }
}
class EK extends $e {
  constructor({
    body: t,
    details: n,
    url: r
  }) {
    super("WebSocket request failed.", {
      details: n,
      metaMessages: [`URL: ${Dm(r)}`, `Request body: ${Ti(t)}`]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "WebSocketRequestError"
    })
  }
}
class I6 extends $e {
  constructor({
    body: t,
    error: n,
    url: r
  }) {
    super("RPC Request failed.", {
      cause: n,
      details: n.message,
      metaMessages: [`URL: ${Dm(r)}`, `Request body: ${Ti(t)}`]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "RpcRequestError"
    }), Object.defineProperty(this, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.code = n.code
  }
}
class K3 extends $e {
  constructor({
    body: t,
    url: n
  }) {
    super("The request took too long to respond.", {
      details: "The request timed out.",
      metaMessages: [`URL: ${Dm(n)}`, `Request body: ${Ti(t)}`]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "TimeoutError"
    })
  }
}
const vke = -1;
class Fs extends $e {
  constructor(t, {
    code: n,
    docsPath: r,
    metaMessages: i,
    shortMessage: s
  }) {
    super(s, {
      cause: t,
      docsPath: r,
      metaMessages: i || (t == null ? void 0 : t.metaMessages)
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "RpcError"
    }), Object.defineProperty(this, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.name = t.name, this.code = t instanceof I6 ? t.code : n ?? vke
  }
}
class Nh extends Fs {
  constructor(t, n) {
    super(t, n), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ProviderRpcError"
    }), Object.defineProperty(this, "data", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.data = n.data
  }
}
class Up extends Fs {
  constructor(t) {
    super(t, {
      code: Up.code,
      shortMessage: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ParseRpcError"
    })
  }
}
Object.defineProperty(Up, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32700
});
class zp extends Fs {
  constructor(t) {
    super(t, {
      code: zp.code,
      shortMessage: "JSON is not a valid request object."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidRequestRpcError"
    })
  }
}
Object.defineProperty(zp, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32600
});
class Hp extends Fs {
  constructor(t) {
    super(t, {
      code: Hp.code,
      shortMessage: "The method does not exist / is not available."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "MethodNotFoundRpcError"
    })
  }
}
Object.defineProperty(Hp, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32601
});
class Vp extends Fs {
  constructor(t) {
    super(t, {
      code: Vp.code,
      shortMessage: ["Invalid parameters were provided to the RPC method.", "Double check you have provided the correct parameters."].join(`
`)
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidParamsRpcError"
    })
  }
}
Object.defineProperty(Vp, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32602
});
class gh extends Fs {
  constructor(t) {
    super(t, {
      code: gh.code,
      shortMessage: "An internal error was received."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InternalRpcError"
    })
  }
}
Object.defineProperty(gh, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32603
});
class _d extends Fs {
  constructor(t) {
    super(t, {
      code: _d.code,
      shortMessage: ["Missing or invalid parameters.", "Double check you have provided the correct parameters."].join(`
`)
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidInputRpcError"
    })
  }
}
Object.defineProperty(_d, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32e3
});
class Wp extends Fs {
  constructor(t) {
    super(t, {
      code: Wp.code,
      shortMessage: "Requested resource not found."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ResourceNotFoundRpcError"
    })
  }
}
Object.defineProperty(Wp, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32001
});
class qp extends Fs {
  constructor(t) {
    super(t, {
      code: qp.code,
      shortMessage: "Requested resource not available."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ResourceUnavailableRpcError"
    })
  }
}
Object.defineProperty(qp, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32002
});
class Gp extends Fs {
  constructor(t) {
    super(t, {
      code: Gp.code,
      shortMessage: "Transaction creation failed."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "TransactionRejectedRpcError"
    })
  }
}
Object.defineProperty(Gp, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32003
});
class Kp extends Fs {
  constructor(t) {
    super(t, {
      code: Kp.code,
      shortMessage: "Method is not implemented."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "MethodNotSupportedRpcError"
    })
  }
}
Object.defineProperty(Kp, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32004
});
class Qp extends Fs {
  constructor(t) {
    super(t, {
      code: Qp.code,
      shortMessage: "Request exceeds defined limit."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "LimitExceededRpcError"
    })
  }
}
Object.defineProperty(Qp, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32005
});
class Yp extends Fs {
  constructor(t) {
    super(t, {
      code: Yp.code,
      shortMessage: "Version of JSON-RPC protocol is not supported."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "JsonRpcVersionUnsupportedError"
    })
  }
}
Object.defineProperty(Yp, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32006
});
class Gf extends Nh {
  constructor(t) {
    super(t, {
      code: Gf.code,
      shortMessage: "User rejected the request."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "UserRejectedRequestError"
    })
  }
}
Object.defineProperty(Gf, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4001
});
class Jp extends Nh {
  constructor(t) {
    super(t, {
      code: Jp.code,
      shortMessage: "The requested method and/or account has not been authorized by the user."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "UnauthorizedProviderError"
    })
  }
}
Object.defineProperty(Jp, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4100
});
class Xp extends Nh {
  constructor(t) {
    super(t, {
      code: Xp.code,
      shortMessage: "The Provider does not support the requested method."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "UnsupportedProviderMethodError"
    })
  }
}
Object.defineProperty(Xp, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4200
});
class yh extends Nh {
  constructor(t) {
    super(t, {
      code: yh.code,
      shortMessage: "The Provider is disconnected from all chains."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ProviderDisconnectedError"
    })
  }
}
Object.defineProperty(yh, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4900
});
class Zp extends Nh {
  constructor(t) {
    super(t, {
      code: Zp.code,
      shortMessage: "The Provider is not connected to the requested chain."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ChainDisconnectedError"
    })
  }
}
Object.defineProperty(Zp, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4901
});
class em extends Nh {
  constructor(t) {
    super(t, {
      code: em.code,
      shortMessage: "An error occurred when attempting to switch chain."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "SwitchChainError"
    })
  }
}
Object.defineProperty(em, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4902
});
class SK extends Fs {
  constructor(t) {
    super(t, {
      shortMessage: "An unknown RPC error occurred."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "UnknownRpcError"
    })
  }
}
const bke = 3;

function tm(e, {
  abi: t,
  address: n,
  args: r,
  docsPath: i,
  functionName: s,
  sender: o
}) {
  const {
    code: a,
    data: c,
    message: l,
    shortMessage: u
  } = e instanceof _6 ? e : e instanceof $e ? e.walk(h => "data" in h) || e.walk() : {}, f = e instanceof hy ? new xK({
    functionName: s
  }) : [bke, gh.code].includes(a) && (c || l || u) ? new G3({
    abi: t,
    data: typeof c == "object" ? c.data : c,
    functionName: s,
    message: u ?? l
  }) : e;
  return new wK(f, {
    abi: t,
    args: r,
    contractAddress: n,
    docsPath: i,
    functionName: s,
    sender: o
  })
}
class $m extends $e {
  constructor({
    docsPath: t
  } = {}) {
    super(["Could not find an Account to execute with this Action.", "Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the WalletClient."].join(`
`), {
      docsPath: t,
      docsSlug: "account"
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AccountNotFoundError"
    })
  }
}
class CK extends $e {
  constructor(t, {
    account: n,
    docsPath: r,
    chain: i,
    data: s,
    gas: o,
    gasPrice: a,
    maxFeePerGas: c,
    maxPriorityFeePerGas: l,
    nonce: u,
    to: f,
    value: h
  }) {
    var y;
    const g = gy({
      from: n == null ? void 0 : n.address,
      to: f,
      value: typeof h < "u" && `${T6(h)} ${((y=i==null?void 0:i.nativeCurrency)==null?void 0:y.symbol)||"ETH"}`,
      data: s,
      gas: o,
      gasPrice: typeof a < "u" && `${Is(a)} gwei`,
      maxFeePerGas: typeof c < "u" && `${Is(c)} gwei`,
      maxPriorityFeePerGas: typeof l < "u" && `${Is(l)} gwei`,
      nonce: u
    });
    super(t.shortMessage, {
      cause: t,
      docsPath: r,
      metaMessages: [...t.metaMessages ? [...t.metaMessages, " "] : [], "Estimate Gas Arguments:", g].filter(Boolean)
    }), Object.defineProperty(this, "cause", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "EstimateGasExecutionError"
    }), this.cause = t
  }
}
class $f extends $e {
  constructor({
    cause: t,
    message: n
  } = {}) {
    var i;
    const r = (i = n == null ? void 0 : n.replace("execution reverted: ", "")) == null ? void 0 : i.replace("execution reverted", "");
    super(`Execution reverted ${r?`with reason: ${r}`:"for an unknown reason"}.`, {
      cause: t
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ExecutionRevertedError"
    })
  }
}
Object.defineProperty($f, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 3
});
Object.defineProperty($f, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /execution reverted/
});
class Id extends $e {
  constructor({
    cause: t,
    maxFeePerGas: n
  } = {}) {
    super(`The fee cap (\`maxFeePerGas\`${n?` = ${Is(n)} gwei`:""}) cannot be higher than the maximum allowed value (2^256-1).`, {
      cause: t
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "FeeCapTooHigh"
    })
  }
}
Object.defineProperty(Id, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /max fee per gas higher than 2\^256-1|fee cap higher than 2\^256-1/
});
class Q3 extends $e {
  constructor({
    cause: t,
    maxFeePerGas: n
  } = {}) {
    super(`The fee cap (\`maxFeePerGas\`${n?` = ${Is(n)}`:""} gwei) cannot be lower than the block base fee.`, {
      cause: t
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "FeeCapTooLow"
    })
  }
}
Object.defineProperty(Q3, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /max fee per gas less than block base fee|fee cap less than block base fee|transaction is outdated/
});
class Y3 extends $e {
  constructor({
    cause: t,
    nonce: n
  } = {}) {
    super(`Nonce provided for the transaction ${n?`(${n}) `:""}is higher than the next one expected.`, {
      cause: t
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "NonceTooHighError"
    })
  }
}
Object.defineProperty(Y3, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /nonce too high/
});
class J3 extends $e {
  constructor({
    cause: t,
    nonce: n
  } = {}) {
    super([`Nonce provided for the transaction ${n?`(${n}) `:""}is lower than the current nonce of the account.`, "Try increasing the nonce or find the latest nonce with `getTransactionCount`."].join(`
`), {
      cause: t
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "NonceTooLowError"
    })
  }
}
Object.defineProperty(J3, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /nonce too low|transaction already imported|already known/
});
class X3 extends $e {
  constructor({
    cause: t,
    nonce: n
  } = {}) {
    super(`Nonce provided for the transaction ${n?`(${n}) `:""}exceeds the maximum allowed nonce.`, {
      cause: t
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "NonceMaxValueError"
    })
  }
}
Object.defineProperty(X3, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /nonce has max value/
});
class Z3 extends $e {
  constructor({
    cause: t
  } = {}) {
    super(["The total cost (gas * gas fee + value) of executing this transaction exceeds the balance of the account."].join(`
`), {
      cause: t,
      metaMessages: ["This error could arise when the account does not have enough funds to:", " - pay for the total gas fee,", " - pay for the value to send.", " ", "The cost of the transaction is calculated as `gas * gas fee + value`, where:", " - `gas` is the amount of gas needed for transaction to execute,", " - `gas fee` is the gas fee,", " - `value` is the amount of ether to send to the recipient."]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InsufficientFundsError"
    })
  }
}
Object.defineProperty(Z3, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /insufficient funds/
});
class ex extends $e {
  constructor({
    cause: t,
    gas: n
  } = {}) {
    super(`The amount of gas ${n?`(${n}) `:""}provided for the transaction exceeds the limit allowed for the block.`, {
      cause: t
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "IntrinsicGasTooHighError"
    })
  }
}
Object.defineProperty(ex, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /intrinsic gas too high|gas limit reached/
});
class tx extends $e {
  constructor({
    cause: t,
    gas: n
  } = {}) {
    super(`The amount of gas ${n?`(${n}) `:""}provided for the transaction is too low.`, {
      cause: t
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "IntrinsicGasTooLowError"
    })
  }
}
Object.defineProperty(tx, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /intrinsic gas too low/
});
class nx extends $e {
  constructor({
    cause: t
  }) {
    super("The transaction type is not supported for this chain.", {
      cause: t
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "TransactionTypeNotSupportedError"
    })
  }
}
Object.defineProperty(nx, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /transaction type not valid/
});
class nm extends $e {
  constructor({
    cause: t,
    maxPriorityFeePerGas: n,
    maxFeePerGas: r
  } = {}) {
    super([`The provided tip (\`maxPriorityFeePerGas\`${n?` = ${Is(n)} gwei`:""}) cannot be higher than the fee cap (\`maxFeePerGas\`${r?` = ${Is(r)} gwei`:""}).`].join(`
`), {
      cause: t
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "TipAboveFeeCapError"
    })
  }
}
Object.defineProperty(nm, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /max priority fee per gas higher than max fee per gas|tip higher than fee cap/
});
class yy extends $e {
  constructor({
    cause: t
  }) {
    super(`An error occurred while executing: ${t==null?void 0:t.shortMessage}`, {
      cause: t
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "UnknownNodeError"
    })
  }
}

function x7(e, t) {
  const n = (e.details || "").toLowerCase(),
    r = e.walk(i => i.code === $f.code);
  return r instanceof $e ? new $f({
    cause: e,
    message: r.details
  }) : $f.nodeMessage.test(n) ? new $f({
    cause: e,
    message: e.details
  }) : Id.nodeMessage.test(n) ? new Id({
    cause: e,
    maxFeePerGas: t == null ? void 0 : t.maxFeePerGas
  }) : Q3.nodeMessage.test(n) ? new Q3({
    cause: e,
    maxFeePerGas: t == null ? void 0 : t.maxFeePerGas
  }) : Y3.nodeMessage.test(n) ? new Y3({
    cause: e,
    nonce: t == null ? void 0 : t.nonce
  }) : J3.nodeMessage.test(n) ? new J3({
    cause: e,
    nonce: t == null ? void 0 : t.nonce
  }) : X3.nodeMessage.test(n) ? new X3({
    cause: e,
    nonce: t == null ? void 0 : t.nonce
  }) : Z3.nodeMessage.test(n) ? new Z3({
    cause: e
  }) : ex.nodeMessage.test(n) ? new ex({
    cause: e,
    gas: t == null ? void 0 : t.gas
  }) : tx.nodeMessage.test(n) ? new tx({
    cause: e,
    gas: t == null ? void 0 : t.gas
  }) : nx.nodeMessage.test(n) ? new nx({
    cause: e
  }) : nm.nodeMessage.test(n) ? new nm({
    cause: e,
    maxFeePerGas: t == null ? void 0 : t.maxFeePerGas,
    maxPriorityFeePerGas: t == null ? void 0 : t.maxPriorityFeePerGas
  }) : new yy({
    cause: e
  })
}

function wke(e, {
  docsPath: t,
  ...n
}) {
  const r = (() => {
    const i = x7(e, n);
    return i instanceof yy ? e : i
  })();
  return new CK(r, {
    docsPath: t,
    ...n
  })
}

function P6(e, {
  format: t
}) {
  if (!t) return {};
  const n = {};

  function r(s) {
    const o = Object.keys(s);
    for (const a of o) a in e && (n[a] = e[a]), s[a] && typeof s[a] == "object" && !Array.isArray(s[a]) && r(s[a])
  }
  const i = t(e || {});
  return r(i), n
}

function R6(e, t) {
  return ({
    exclude: n,
    format: r
  }) => ({
    exclude: n,
    format: i => {
      const s = t(i);
      if (n)
        for (const o of n) delete s[o];
      return {
        ...s,
        ...r(i)
      }
    },
    type: e
  })
}
const AK = {
  legacy: "0x0",
  eip2930: "0x1",
  eip1559: "0x2"
};

function Mh(e) {
  return {
    ...e,
    gas: typeof e.gas < "u" ? Ct(e.gas) : void 0,
    gasPrice: typeof e.gasPrice < "u" ? Ct(e.gasPrice) : void 0,
    maxFeePerGas: typeof e.maxFeePerGas < "u" ? Ct(e.maxFeePerGas) : void 0,
    maxPriorityFeePerGas: typeof e.maxPriorityFeePerGas < "u" ? Ct(e.maxPriorityFeePerGas) : void 0,
    nonce: typeof e.nonce < "u" ? Ct(e.nonce) : void 0,
    type: typeof e.type < "u" ? AK[e.type] : void 0,
    value: typeof e.value < "u" ? Ct(e.value) : void 0
  }
}
const xke = R6("transactionRequest", Mh);

function Lm(e) {
  const {
    account: t,
    gasPrice: n,
    maxFeePerGas: r,
    maxPriorityFeePerGas: i,
    to: s
  } = e, o = t ? Ha(t) : void 0;
  if (o && !Hi(o.address)) throw new go({
    address: o.address
  });
  if (s && !Hi(s)) throw new go({
    address: s
  });
  if (typeof n < "u" && (typeof r < "u" || typeof i < "u")) throw new pK;
  if (r && r > 2n ** 256n - 1n) throw new Id({
    maxFeePerGas: r
  });
  if (i && r && i > r) throw new nm({
    maxFeePerGas: r,
    maxPriorityFeePerGas: i
  })
}
class TK extends $e {
  constructor() {
    super("`baseFeeMultiplier` must be greater than 1."), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "BaseFeeScalarError"
    })
  }
}
class O6 extends $e {
  constructor() {
    super("Chain does not support EIP-1559 fees."), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "Eip1559FeesNotSupportedError"
    })
  }
}
class kK extends $e {
  constructor({
    maxPriorityFeePerGas: t
  }) {
    super(`\`maxFeePerGas\` cannot be less than the \`maxPriorityFeePerGas\` (${Is(t)} gwei).`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "MaxFeePerGasTooLowError"
    })
  }
}
class E7 extends $e {
  constructor({
    blockHash: t,
    blockNumber: n
  }) {
    let r = "Block";
    t && (r = `Block at hash "${t}"`), n && (r = `Block at number "${n}"`), super(`${r} could not be found.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "BlockNotFoundError"
    })
  }
}
const S7 = {
  "0x0": "legacy",
  "0x1": "eip2930",
  "0x2": "eip1559"
};

function vy(e) {
  const t = {
    ...e,
    blockHash: e.blockHash ? e.blockHash : null,
    blockNumber: e.blockNumber ? BigInt(e.blockNumber) : null,
    chainId: e.chainId ? Xn(e.chainId) : void 0,
    gas: e.gas ? BigInt(e.gas) : void 0,
    gasPrice: e.gasPrice ? BigInt(e.gasPrice) : void 0,
    maxFeePerGas: e.maxFeePerGas ? BigInt(e.maxFeePerGas) : void 0,
    maxPriorityFeePerGas: e.maxPriorityFeePerGas ? BigInt(e.maxPriorityFeePerGas) : void 0,
    nonce: e.nonce ? Xn(e.nonce) : void 0,
    to: e.to ? e.to : null,
    transactionIndex: e.transactionIndex ? Number(e.transactionIndex) : null,
    type: e.type ? S7[e.type] : void 0,
    typeHex: e.type ? e.type : void 0,
    value: e.value ? BigInt(e.value) : void 0,
    v: e.v ? BigInt(e.v) : void 0
  };
  return t.yParity = (() => {
    if (e.yParity) return Number(e.yParity);
    if (typeof t.v == "bigint") {
      if (t.v === 0n || t.v === 27n) return 0;
      if (t.v === 1n || t.v === 28n) return 1;
      if (t.v >= 35n) return t.v % 2n === 0n ? 1 : 0
    }
  })(), t.type === "legacy" && (delete t.accessList, delete t.maxFeePerGas, delete t.maxPriorityFeePerGas, delete t.yParity), t.type === "eip2930" && (delete t.maxFeePerGas, delete t.maxPriorityFeePerGas), t
}
const _K = R6("transaction", vy);

function D6(e) {
  var n;
  const t = (n = e.transactions) == null ? void 0 : n.map(r => typeof r == "string" ? r : vy(r));
  return {
    ...e,
    baseFeePerGas: e.baseFeePerGas ? BigInt(e.baseFeePerGas) : null,
    difficulty: e.difficulty ? BigInt(e.difficulty) : void 0,
    gasLimit: e.gasLimit ? BigInt(e.gasLimit) : void 0,
    gasUsed: e.gasUsed ? BigInt(e.gasUsed) : void 0,
    hash: e.hash ? e.hash : null,
    logsBloom: e.logsBloom ? e.logsBloom : null,
    nonce: e.nonce ? e.nonce : null,
    number: e.number ? BigInt(e.number) : null,
    size: e.size ? BigInt(e.size) : void 0,
    timestamp: e.timestamp ? BigInt(e.timestamp) : void 0,
    transactions: t,
    totalDifficulty: e.totalDifficulty ? BigInt(e.totalDifficulty) : null
  }
}
const IK = R6("block", D6);
async function Pd(e, {
  blockHash: t,
  blockNumber: n,
  blockTag: r,
  includeTransactions: i
} = {}) {
  var u, f, h;
  const s = r ?? "latest",
    o = i ?? !1,
    a = n !== void 0 ? Ct(n) : void 0;
  let c = null;
  if (t ? c = await e.request({
      method: "eth_getBlockByHash",
      params: [t, o]
    }) : c = await e.request({
      method: "eth_getBlockByNumber",
      params: [a || s, o]
    }), !c) throw new E7({
    blockHash: t,
    blockNumber: n
  });
  return (((h = (f = (u = e.chain) == null ? void 0 : u.formatters) == null ? void 0 : f.block) == null ? void 0 : h.format) || D6)(c)
}
async function C7(e) {
  const t = await e.request({
    method: "eth_gasPrice"
  });
  return BigInt(t)
}
async function Eke(e, t) {
  return PK(e, t)
}
async function PK(e, t) {
  var s, o, a;
  const {
    block: n,
    chain: r = e.chain,
    request: i
  } = t || {};
  if (typeof ((s = r == null ? void 0 : r.fees) == null ? void 0 : s.defaultPriorityFee) == "function") {
    const c = n || await Tt(e, Pd, "getBlock")({});
    return r.fees.defaultPriorityFee({
      block: c,
      client: e,
      request: i
    })
  }
  if (typeof ((o = r == null ? void 0 : r.fees) == null ? void 0 : o.defaultPriorityFee) < "u") return (a = r == null ? void 0 : r.fees) == null ? void 0 : a.defaultPriorityFee;
  try {
    const c = await e.request({
      method: "eth_maxPriorityFeePerGas"
    });
    return Jn(c)
  } catch {
    const [c, l] = await Promise.all([n ? Promise.resolve(n) : Tt(e, Pd, "getBlock")({}), Tt(e, C7, "getGasPrice")({})]);
    if (typeof c.baseFeePerGas != "bigint") throw new O6;
    const u = l - c.baseFeePerGas;
    return u < 0n ? 0n : u
  }
}
async function Ske(e, t) {
  return PA(e, t)
}
async function PA(e, t) {
  var h, g;
  const {
    block: n,
    chain: r = e.chain,
    request: i,
    type: s = "eip1559"
  } = t || {}, o = await (async () => {
    var y, x;
    return typeof ((y = r == null ? void 0 : r.fees) == null ? void 0 : y.baseFeeMultiplier) == "function" ? r.fees.baseFeeMultiplier({
      block: n,
      client: e,
      request: i
    }) : ((x = r == null ? void 0 : r.fees) == null ? void 0 : x.baseFeeMultiplier) ?? 1.2
  })();
  if (o < 1) throw new TK;
  const c = 10 ** (((h = o.toString().split(".")[1]) == null ? void 0 : h.length) ?? 0),
    l = y => y * BigInt(Math.ceil(o * c)) / BigInt(c),
    u = n || await Tt(e, Pd, "getBlock")({});
  if (typeof ((g = r == null ? void 0 : r.fees) == null ? void 0 : g.estimateFeesPerGas) == "function") return r.fees.estimateFeesPerGas({
    block: n,
    client: e,
    multiply: l,
    request: i,
    type: s
  });
  if (s === "eip1559") {
    if (typeof u.baseFeePerGas != "bigint") throw new O6;
    const y = i != null && i.maxPriorityFeePerGas ? i.maxPriorityFeePerGas : await PK(e, {
        block: u,
        chain: r,
        request: i
      }),
      x = l(u.baseFeePerGas);
    return {
      maxFeePerGas: (i == null ? void 0 : i.maxFeePerGas) ?? x + y,
      maxPriorityFeePerGas: y
    }
  }
  return {
    gasPrice: (i == null ? void 0 : i.gasPrice) ?? l(await Tt(e, C7, "getGasPrice")({}))
  }
}
async function RK(e, {
  address: t,
  blockTag: n = "latest",
  blockNumber: r
}) {
  const i = await e.request({
    method: "eth_getTransactionCount",
    params: [t, r ? Ct(r) : n]
  });
  return Xn(i)
}

function A7(e) {
  if (e.type) return e.type;
  if (typeof e.maxFeePerGas < "u" || typeof e.maxPriorityFeePerGas < "u") return "eip1559";
  if (typeof e.gasPrice < "u") return typeof e.accessList < "u" ? "eip2930" : "legacy";
  throw new mK({
    transaction: e
  })
}
async function N6(e, t) {
  const {
    account: n = e.account,
    chain: r,
    gas: i,
    nonce: s,
    type: o
  } = t;
  if (!n) throw new $m;
  const a = Ha(n),
    c = await Tt(e, Pd, "getBlock")({
      blockTag: "latest"
    }),
    l = {
      ...t,
      from: a.address
    };
  if (typeof s > "u" && (l.nonce = await Tt(e, RK, "getTransactionCount")({
      address: a.address,
      blockTag: "pending"
    })), typeof o > "u") try {
    l.type = A7(l)
  } catch {
    l.type = typeof c.baseFeePerGas == "bigint" ? "eip1559" : "legacy"
  }
  if (l.type === "eip1559") {
    const {
      maxFeePerGas: u,
      maxPriorityFeePerGas: f
    } = await PA(e, {
      block: c,
      chain: r,
      request: l
    });
    if (typeof t.maxPriorityFeePerGas > "u" && t.maxFeePerGas && t.maxFeePerGas < f) throw new kK({
      maxPriorityFeePerGas: f
    });
    l.maxPriorityFeePerGas = f, l.maxFeePerGas = u
  } else {
    if (typeof t.maxFeePerGas < "u" || typeof t.maxPriorityFeePerGas < "u") throw new O6;
    const {
      gasPrice: u
    } = await PA(e, {
      block: c,
      chain: r,
      request: l,
      type: "legacy"
    });
    l.gasPrice = u
  }
  return typeof i > "u" && (l.gas = await Tt(e, T7, "estimateGas")({
    ...l,
    account: {
      address: a.address,
      type: "json-rpc"
    }
  })), Lm(l), l
}
async function T7(e, t) {
  var i, s, o;
  const n = t.account ?? e.account;
  if (!n) throw new $m({
    docsPath: "/docs/actions/public/estimateGas"
  });
  const r = Ha(n);
  try {
    const {
      accessList: a,
      blockNumber: c,
      blockTag: l,
      data: u,
      gas: f,
      gasPrice: h,
      maxFeePerGas: g,
      maxPriorityFeePerGas: y,
      nonce: x,
      to: k,
      value: _,
      ...p
    } = r.type === "local" ? await N6(e, t) : t, S = (c ? Ct(c) : void 0) || l;
    Lm(t);
    const I = (o = (s = (i = e.chain) == null ? void 0 : i.formatters) == null ? void 0 : s.transactionRequest) == null ? void 0 : o.format,
      w = (I || Mh)({
        ...P6(p, {
          format: I
        }),
        from: r.address,
        accessList: a,
        data: u,
        gas: f,
        gasPrice: h,
        maxFeePerGas: g,
        maxPriorityFeePerGas: y,
        nonce: x,
        to: k,
        value: _
      }),
      E = await e.request({
        method: "eth_estimateGas",
        params: S ? [w, S] : [w]
      });
    return BigInt(E)
  } catch (a) {
    throw wke(a, {
      ...t,
      account: r,
      chain: e.chain
    })
  }
}
async function OK(e, {
  abi: t,
  address: n,
  args: r,
  functionName: i,
  ...s
}) {
  const o = Su({
    abi: t,
    args: r,
    functionName: i
  });
  try {
    return await Tt(e, T7, "estimateGas")({
      data: o,
      to: n,
      ...s
    })
  } catch (a) {
    const c = s.account ? Ha(s.account) : void 0;
    throw tm(a, {
      abi: t,
      address: n,
      args: r,
      docsPath: "/docs/contract/estimateContractGas",
      functionName: i,
      sender: c == null ? void 0 : c.address
    })
  }
}
const g$ = "/docs/contract/decodeEventLog";

function Bm({
  abi: e,
  data: t,
  strict: n,
  topics: r
}) {
  const i = n ?? !0,
    [s, ...o] = r;
  if (!s) throw new LG({
    docsPath: g$
  });
  const a = e.find(y => y.type === "event" && s === S6(Ac(y)));
  if (!(a && "name" in a) || a.type !== "event") throw new BG(s, {
    docsPath: g$
  });
  const {
    name: c,
    inputs: l
  } = a, u = l == null ? void 0 : l.some(y => !("name" in y && y.name));
  let f = u ? [] : {};
  const h = l.filter(y => "indexed" in y && y.indexed);
  for (let y = 0; y < h.length; y++) {
    const x = h[y],
      k = o[y];
    if (!k) throw new Oh({
      abiItem: a,
      param: x
    });
    f[x.name || y] = Cke({
      param: x,
      value: k
    })
  }
  const g = l.filter(y => !("indexed" in y && y.indexed));
  if (g.length > 0) {
    if (t && t !== "0x") try {
      const y = Dh(g, t);
      if (y)
        if (u) f = [...f, ...y];
        else
          for (let x = 0; x < g.length; x++) f[g[x].name] = y[x]
    } catch (y) {
      if (i) throw y instanceof b6 ? new Td({
        abiItem: a,
        data: y.data,
        params: y.params,
        size: y.size
      }) : y
    } else if (i) throw new Td({
      abiItem: a,
      data: "0x",
      params: g,
      size: 0
    })
  }
  return {
    eventName: c,
    args: Object.values(f).length > 0 ? f : void 0
  }
}

function Cke({
  param: e,
  value: t
}) {
  return e.type === "string" || e.type === "bytes" || e.type === "tuple" || e.type.match(/^(.*)\[(\d+)?\]$/) ? t : (Dh([e], t) || [])[0]
}

function Na(e, {
  args: t,
  eventName: n
} = {}) {
  return {
    ...e,
    blockHash: e.blockHash ? e.blockHash : null,
    blockNumber: e.blockNumber ? BigInt(e.blockNumber) : null,
    logIndex: e.logIndex ? Number(e.logIndex) : null,
    transactionHash: e.transactionHash ? e.transactionHash : null,
    transactionIndex: e.transactionIndex ? Number(e.transactionIndex) : null,
    ...n ? {
      args: t,
      eventName: n
    } : {}
  }
}
async function k7(e, {
  address: t,
  blockHash: n,
  fromBlock: r,
  toBlock: i,
  event: s,
  events: o,
  args: a,
  strict: c
} = {}) {
  const l = c ?? !1,
    u = o ?? (s ? [s] : void 0);
  let f = [];
  u && (f = [u.flatMap(g => Mm({
    abi: [g],
    eventName: g.name,
    args: a
  }))], s && (f = f[0]));
  let h;
  return n ? h = await e.request({
    method: "eth_getLogs",
    params: [{
      address: t,
      topics: f,
      blockHash: n
    }]
  }) : h = await e.request({
    method: "eth_getLogs",
    params: [{
      address: t,
      topics: f,
      fromBlock: typeof r == "bigint" ? Ct(r) : r,
      toBlock: typeof i == "bigint" ? Ct(i) : i
    }]
  }), h.map(g => {
    var y;
    try {
      const {
        eventName: x,
        args: k
      } = u ? Bm({
        abi: u,
        data: g.data,
        topics: g.topics,
        strict: l
      }) : {
        eventName: void 0,
        args: void 0
      };
      return Na(g, {
        args: k,
        eventName: x
      })
    } catch (x) {
      let k, _;
      if (x instanceof Td || x instanceof Oh) {
        if (l) return;
        k = x.abiItem.name, _ = (y = x.abiItem.inputs) == null ? void 0 : y.some(p => !("name" in p && p.name))
      }
      return Na(g, {
        args: _ ? [] : {},
        eventName: k
      })
    }
  }).filter(Boolean)
}
async function _7(e, {
  abi: t,
  address: n,
  args: r,
  blockHash: i,
  eventName: s,
  fromBlock: o,
  toBlock: a,
  strict: c
}) {
  const l = s ? Hd({
      abi: t,
      name: s
    }) : void 0,
    u = l ? void 0 : t.filter(f => f.type === "event");
  return Tt(e, k7, "getLogs")({
    address: n,
    args: r,
    blockHash: i,
    event: l,
    events: u,
    fromBlock: o,
    toBlock: a,
    strict: c
  })
}
const JS = "/docs/contract/decodeFunctionResult";

function $h({
  abi: e,
  args: t,
  functionName: n,
  data: r
}) {
  let i = e[0];
  if (n && (i = Hd({
      abi: e,
      args: t,
      name: n
    }), !i)) throw new mh(n, {
    docsPath: JS
  });
  if (i.type !== "function") throw new mh(void 0, {
    docsPath: JS
  });
  if (!i.outputs) throw new Zk(i.name, {
    docsPath: JS
  });
  const s = Dh(i.outputs, r);
  if (s && s.length > 1) return s;
  if (s && s.length === 1) return s[0]
}
const Ake = "modulepreload",
  Tke = function (e) {
    return "/" + e
  },
  y$ = {},
  I7 = function (t, n, r) {
    let i = Promise.resolve();
    if (n && n.length > 0) {
      const s = document.getElementsByTagName("link"),
        o = document.querySelector("meta[property=csp-nonce]"),
        a = (o == null ? void 0 : o.nonce) || (o == null ? void 0 : o.getAttribute("nonce"));
      i = Promise.all(n.map(c => {
        if (c = Tke(c), c in y$) return;
        y$[c] = !0;
        const l = c.endsWith(".css"),
          u = l ? '[rel="stylesheet"]' : "";
        if (!!r)
          for (let g = s.length - 1; g >= 0; g--) {
            const y = s[g];
            if (y.href === c && (!l || y.rel === "stylesheet")) return
          } else if (document.querySelector(`link[href="${c}"]${u}`)) return;
        const h = document.createElement("link");
        if (h.rel = l ? "stylesheet" : Ake, l || (h.as = "script", h.crossOrigin = ""), h.href = c, a && h.setAttribute("nonce", a), document.head.appendChild(h), l) return new Promise((g, y) => {
          h.addEventListener("load", g), h.addEventListener("error", () => y(new Error(`Unable to preload CSS for ${c}`)))
        })
      }))
    }
    return i.then(() => t()).catch(s => {
      const o = new Event("vite:preloadError", {
        cancelable: !0
      });
      if (o.payload = s, window.dispatchEvent(o), !o.defaultPrevented) throw s
    })
  },
  rx = [{
    inputs: [{
      components: [{
        name: "target",
        type: "address"
      }, {
        name: "allowFailure",
        type: "bool"
      }, {
        name: "callData",
        type: "bytes"
      }],
      name: "calls",
      type: "tuple[]"
    }],
    name: "aggregate3",
    outputs: [{
      components: [{
        name: "success",
        type: "bool"
      }, {
        name: "returnData",
        type: "bytes"
      }],
      name: "returnData",
      type: "tuple[]"
    }],
    stateMutability: "view",
    type: "function"
  }],
  DK = [{
    inputs: [],
    name: "ResolverNotFound",
    type: "error"
  }, {
    inputs: [],
    name: "ResolverWildcardNotSupported",
    type: "error"
  }],
  NK = [...DK, {
    name: "resolve",
    type: "function",
    stateMutability: "view",
    inputs: [{
      name: "name",
      type: "bytes"
    }, {
      name: "data",
      type: "bytes"
    }],
    outputs: [{
      name: "",
      type: "bytes"
    }, {
      name: "address",
      type: "address"
    }]
  }],
  kke = [...DK, {
    name: "reverse",
    type: "function",
    stateMutability: "view",
    inputs: [{
      type: "bytes",
      name: "reverseName"
    }],
    outputs: [{
      type: "string",
      name: "resolvedName"
    }, {
      type: "address",
      name: "resolvedAddress"
    }, {
      type: "address",
      name: "reverseResolver"
    }, {
      type: "address",
      name: "resolver"
    }]
  }],
  v$ = [{
    name: "text",
    type: "function",
    stateMutability: "view",
    inputs: [{
      name: "name",
      type: "bytes32"
    }, {
      name: "key",
      type: "string"
    }],
    outputs: [{
      name: "",
      type: "string"
    }]
  }],
  b$ = [{
    name: "addr",
    type: "function",
    stateMutability: "view",
    inputs: [{
      name: "name",
      type: "bytes32"
    }],
    outputs: [{
      name: "",
      type: "address"
    }]
  }, {
    name: "addr",
    type: "function",
    stateMutability: "view",
    inputs: [{
      name: "name",
      type: "bytes32"
    }, {
      name: "coinType",
      type: "uint256"
    }],
    outputs: [{
      name: "",
      type: "bytes"
    }]
  }],
  _ke = [{
    inputs: [{
      internalType: "address",
      name: "_signer",
      type: "address"
    }, {
      internalType: "bytes32",
      name: "_hash",
      type: "bytes32"
    }, {
      internalType: "bytes",
      name: "_signature",
      type: "bytes"
    }],
    stateMutability: "nonpayable",
    type: "constructor"
  }],
  Ike = "0x82ad56cb";
class ix extends $e {
  constructor({
    blockNumber: t,
    chain: n,
    contract: r
  }) {
    super(`Chain "${n.name}" does not support contract "${r.name}".`, {
      metaMessages: ["This could be due to any of the following:", ...t && r.blockCreated && r.blockCreated > t ? [`- The contract "${r.name}" was not deployed until block ${r.blockCreated} (current block ${t}).`] : [`- The chain does not have the contract "${r.name}" configured.`]]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ChainDoesNotSupportContract"
    })
  }
}
class MK extends $e {
  constructor({
    chain: t,
    currentChainId: n
  }) {
    super(`The current chain of the wallet (id: ${n}) does not match the target chain for the transaction (id: ${t.id} – ${t.name}).`, {
      metaMessages: [`Current Chain ID:  ${n}`, `Expected Chain ID: ${t.id} – ${t.name}`]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ChainMismatchError"
    })
  }
}
class $K extends $e {
  constructor() {
    super(["No chain was provided to the request.", "Please provide a chain with the `chain` argument on the Action, or by supplying a `chain` to WalletClient."].join(`
`)), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ChainNotFoundError"
    })
  }
}
class P7 extends $e {
  constructor() {
    super("No chain was provided to the Client."), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ClientChainNotConfiguredError"
    })
  }
}
class M6 extends $e {
  constructor({
    chainId: t
  }) {
    super(`Chain ID "${t}" is invalid.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidChainIdError"
    })
  }
}

function Lh({
  blockNumber: e,
  chain: t,
  contract: n
}) {
  var i;
  const r = (i = t == null ? void 0 : t.contracts) == null ? void 0 : i[n];
  if (!r) throw new ix({
    chain: t,
    contract: {
      name: n
    }
  });
  if (e && r.blockCreated && r.blockCreated > e) throw new ix({
    blockNumber: e,
    chain: t,
    contract: {
      name: n,
      blockCreated: r.blockCreated
    }
  });
  return r.address
}

function Pke(e, {
  docsPath: t,
  ...n
}) {
  const r = (() => {
    const i = x7(e, n);
    return i instanceof yy ? e : i
  })();
  return new w7(r, {
    docsPath: t,
    ...n
  })
}
const XS = new Map;

function R7({
  fn: e,
  id: t,
  shouldSplitBatch: n,
  wait: r = 0,
  sort: i
}) {
  const s = async () => {
    const u = c();
    o();
    const f = u.map(({
      args: h
    }) => h);
    f.length !== 0 && e(f).then(h => {
      var g;
      i && Array.isArray(h) && h.sort(i);
      for (let y = 0; y < u.length; y++) {
        const {
          pendingPromise: x
        } = u[y];
        (g = x.resolve) == null || g.call(x, [h[y], h])
      }
    }).catch(h => {
      var g;
      for (let y = 0; y < u.length; y++) {
        const {
          pendingPromise: x
        } = u[y];
        (g = x.reject) == null || g.call(x, h)
      }
    })
  }, o = () => XS.delete(t), a = () => c().map(({
    args: u
  }) => u), c = () => XS.get(t) || [], l = u => XS.set(t, [...c(), u]);
  return {
    flush: o,
    async schedule(u) {
      const f = {},
        h = new Promise((x, k) => {
          f.resolve = x, f.reject = k
        });
      return (n == null ? void 0 : n([...a(), u])) && s(), c().length > 0 ? (l({
        args: u,
        pendingPromise: f
      }), h) : (l({
        args: u,
        pendingPromise: f
      }), setTimeout(s, r), h)
    }
  }
}
async function by(e, t) {
  var _, p, v, S;
  const {
    account: n = e.account,
    batch: r = !!((_ = e.batch) != null && _.multicall),
    blockNumber: i,
    blockTag: s = "latest",
    accessList: o,
    data: a,
    gas: c,
    gasPrice: l,
    maxFeePerGas: u,
    maxPriorityFeePerGas: f,
    nonce: h,
    to: g,
    value: y,
    ...x
  } = t, k = n ? Ha(n) : void 0;
  try {
    Lm(t);
    const A = (i ? Ct(i) : void 0) || s,
      w = (S = (v = (p = e.chain) == null ? void 0 : p.formatters) == null ? void 0 : v.transactionRequest) == null ? void 0 : S.format,
      D = (w || Mh)({
        ...P6(x, {
          format: w
        }),
        from: k == null ? void 0 : k.address,
        accessList: o,
        data: a,
        gas: c,
        gasPrice: l,
        maxFeePerGas: u,
        maxPriorityFeePerGas: f,
        nonce: h,
        to: g,
        value: y
      });
    if (r && Rke({
        request: D
      })) try {
      return await Oke(e, {
        ...D,
        blockNumber: i,
        blockTag: s
      })
    } catch (V) {
      if (!(V instanceof P7) && !(V instanceof ix)) throw V
    }
    const $ = await e.request({
      method: "eth_call",
      params: A ? [D, A] : [D]
    });
    return $ === "0x" ? {
      data: void 0
    } : {
      data: $
    }
  } catch (I) {
    const A = Dke(I),
      {
        offchainLookup: w,
        offchainLookupSignature: E
      } = await I7(() => Promise.resolve().then(() => A7e), void 0);
    if ((A == null ? void 0 : A.slice(0, 10)) === E && g) return {
      data: await w(e, {
        data: A,
        to: g
      })
    };
    throw Pke(I, {
      ...t,
      account: k,
      chain: e.chain
    })
  }
}

function Rke({
  request: e
}) {
  const {
    data: t,
    to: n,
    ...r
  } = e;
  return !(!t || t.startsWith(Ike) || !n || Object.values(r).filter(i => typeof i < "u").length > 0)
}
async function Oke(e, t) {
  var x;
  const {
    batchSize: n = 1024,
    wait: r = 0
  } = typeof ((x = e.batch) == null ? void 0 : x.multicall) == "object" ? e.batch.multicall: {}, {
    blockNumber: i,
    blockTag: s = "latest",
    data: o,
    multicallAddress: a,
    to: c
  } = t;
  let l = a;
  if (!l) {
    if (!e.chain) throw new P7;
    l = Lh({
      blockNumber: i,
      chain: e.chain,
      contract: "multicall3"
    })
  }
  const f = (i ? Ct(i) : void 0) || s,
    {
      schedule: h
    } = R7({
      id: `${e.uid}.${f}`,
      wait: r,
      shouldSplitBatch(k) {
        return k.reduce((p, {
          data: v
        }) => p + (v.length - 2), 0) > n * 2
      },
      fn: async k => {
        const _ = k.map(S => ({
            allowFailure: !0,
            callData: S.data,
            target: S.to
          })),
          p = Su({
            abi: rx,
            args: [_],
            functionName: "aggregate3"
          }),
          v = await e.request({
            method: "eth_call",
            params: [{
              data: p,
              to: l
            }, f]
          });
        return $h({
          abi: rx,
          args: [_],
          functionName: "aggregate3",
          data: v || "0x"
        })
      }
    }),
    [{
      returnData: g,
      success: y
    }] = await h({
      data: o,
      to: c
    });
  if (!y) throw new _6({
    data: g
  });
  return g === "0x" ? {
    data: void 0
  } : {
    data: g
  }
}

function Dke(e) {
  if (!(e instanceof $e)) return;
  const t = e.walk();
  return typeof t.data == "object" ? t.data.data : t.data
}
async function hu(e, {
  abi: t,
  address: n,
  args: r,
  functionName: i,
  ...s
}) {
  const o = Su({
    abi: t,
    args: r,
    functionName: i
  });
  try {
    const {
      data: a
    } = await Tt(e, by, "call")({
      data: o,
      to: n,
      ...s
    });
    return $h({
      abi: t,
      args: r,
      functionName: i,
      data: a || "0x"
    })
  } catch (a) {
    throw tm(a, {
      abi: t,
      address: n,
      args: r,
      docsPath: "/docs/contract/readContract",
      functionName: i
    })
  }
}
async function LK(e, {
  abi: t,
  address: n,
  args: r,
  dataSuffix: i,
  functionName: s,
  ...o
}) {
  const a = o.account ? Ha(o.account) : void 0,
    c = Su({
      abi: t,
      args: r,
      functionName: s
    });
  try {
    const {
      data: l
    } = await Tt(e, by, "call")({
      batch: !1,
      data: `${c}${i?i.replace("0x",""):""}`,
      to: n,
      ...o
    });
    return {
      result: $h({
        abi: t,
        args: r,
        functionName: s,
        data: l || "0x"
      }),
      request: {
        abi: t,
        address: n,
        args: r,
        dataSuffix: i,
        functionName: s,
        ...o
      }
    }
  } catch (l) {
    throw tm(l, {
      abi: t,
      address: n,
      args: r,
      docsPath: "/docs/contract/simulateContract",
      functionName: s,
      sender: a == null ? void 0 : a.address
    })
  }
}
const ZS = new Map,
  w$ = new Map;
let Nke = 0;

function Fm(e, t, n) {
  const r = ++Nke,
    i = () => ZS.get(e) || [],
    s = () => {
      const u = i();
      ZS.set(e, u.filter(f => f.id !== r))
    },
    o = () => {
      const u = w$.get(e);
      i().length === 1 && u && u(), s()
    },
    a = i();
  if (ZS.set(e, [...a, {
      id: r,
      fns: t
    }]), a && a.length > 0) return o;
  const c = {};
  for (const u in t) c[u] = (...f) => {
    var g, y;
    const h = i();
    if (h.length !== 0)
      for (const x of h)(y = (g = x.fns)[u]) == null || y.call(g, ...f)
  };
  const l = n(c);
  return typeof l == "function" && w$.set(e, l), o
}
async function sx(e) {
  return new Promise(t => setTimeout(t, e))
}

function wy(e, {
  emitOnBegin: t,
  initialWaitTime: n,
  interval: r
}) {
  let i = !0;
  const s = () => i = !1;
  return (async () => {
    let a;
    t && (a = await e({
      unpoll: s
    }));
    const c = await (n == null ? void 0 : n(a)) ?? r;
    await sx(c);
    const l = async () => {
      i && (await e({
        unpoll: s
      }), await sx(r), l())
    };
    l()
  })(), s
}
const Mke = new Map,
  $ke = new Map;

function Lke(e) {
  const t = (i, s) => ({
      clear: () => s.delete(i),
      get: () => s.get(i),
      set: o => s.set(i, o)
    }),
    n = t(e, Mke),
    r = t(e, $ke);
  return {
    clear: () => {
      n.clear(), r.clear()
    },
    promise: n,
    response: r
  }
}
async function Bke(e, {
  cacheKey: t,
  cacheTime: n = 1 / 0
}) {
  const r = Lke(t),
    i = r.response.get();
  if (i && n > 0 && new Date().getTime() - i.created.getTime() < n) return i.data;
  let s = r.promise.get();
  s || (s = e(), r.promise.set(s));
  try {
    const o = await s;
    return r.response.set({
      created: new Date,
      data: o
    }), o
  } finally {
    r.promise.clear()
  }
}
const Fke = e => `blockNumber.${e}`;
async function xy(e, {
  cacheTime: t = e.cacheTime,
  maxAge: n
} = {}) {
  const r = await Bke(() => e.request({
    method: "eth_blockNumber"
  }), {
    cacheKey: Fke(e.uid),
    cacheTime: n ?? t
  });
  return BigInt(r)
}
async function $6(e, {
  filter: t
}) {
  const n = "strict" in t && t.strict;
  return (await t.request({
    method: "eth_getFilterChanges",
    params: [t.id]
  })).map(i => {
    var s;
    if (typeof i == "string") return i;
    try {
      const {
        eventName: o,
        args: a
      } = "abi" in t && t.abi ? Bm({
        abi: t.abi,
        data: i.data,
        topics: i.topics,
        strict: n
      }) : {
        eventName: void 0,
        args: void 0
      };
      return Na(i, {
        args: a,
        eventName: o
      })
    } catch (o) {
      let a, c;
      if (o instanceof Td || o instanceof Oh) {
        if ("strict" in t && t.strict) return;
        a = o.abiItem.name, c = (s = o.abiItem.inputs) == null ? void 0 : s.some(l => !("name" in l && l.name))
      }
      return Na(i, {
        args: c ? [] : {},
        eventName: a
      })
    }
  }).filter(Boolean)
}
async function L6(e, {
  filter: t
}) {
  return t.request({
    method: "eth_uninstallFilter",
    params: [t.id]
  })
}

function BK(e, {
  abi: t,
  address: n,
  args: r,
  batch: i = !0,
  eventName: s,
  onError: o,
  onLogs: a,
  poll: c,
  pollingInterval: l = e.pollingInterval,
  strict: u
}) {
  return (typeof c < "u" ? c : e.transport.type !== "webSocket") ? (() => {
    const y = Ti(["watchContractEvent", n, r, i, e.uid, s, l]),
      x = u ?? !1;
    return Fm(y, {
      onLogs: a,
      onError: o
    }, k => {
      let _, p, v = !1;
      const S = wy(async () => {
        var I;
        if (!v) {
          try {
            p = await Tt(e, f7, "createContractEventFilter")({
              abi: t,
              address: n,
              args: r,
              eventName: s,
              strict: x
            })
          } catch {}
          v = !0;
          return
        }
        try {
          let A;
          if (p) A = await Tt(e, $6, "getFilterChanges")({
            filter: p
          });
          else {
            const w = await Tt(e, xy, "getBlockNumber")({});
            _ && _ !== w ? A = await Tt(e, _7, "getContractEvents")({
              abi: t,
              address: n,
              args: r,
              eventName: s,
              fromBlock: _ + 1n,
              toBlock: w,
              strict: x
            }) : A = [], _ = w
          }
          if (A.length === 0) return;
          if (i) k.onLogs(A);
          else
            for (const w of A) k.onLogs([w])
        } catch (A) {
          p && A instanceof _d && (v = !1), (I = k.onError) == null || I.call(k, A)
        }
      }, {
        emitOnBegin: !0,
        interval: l
      });
      return async () => {
        p && await Tt(e, L6, "uninstallFilter")({
          filter: p
        }), S()
      }
    })
  })() : (() => {
    let y = !0,
      x = () => y = !1;
    return (async () => {
      try {
        const k = s ? Mm({
            abi: t,
            eventName: s,
            args: r
          }) : [],
          {
            unsubscribe: _
          } = await e.transport.subscribe({
            params: ["logs", {
              address: n,
              topics: k
            }],
            onData(p) {
              var S;
              if (!y) return;
              const v = p.result;
              try {
                const {
                  eventName: I,
                  args: A
                } = Bm({
                  abi: t,
                  data: v.data,
                  topics: v.topics,
                  strict: u
                }), w = Na(v, {
                  args: A,
                  eventName: I
                });
                a([w])
              } catch (I) {
                let A, w;
                if (I instanceof Td || I instanceof Oh) {
                  if (u) return;
                  A = I.abiItem.name, w = (S = I.abiItem.inputs) == null ? void 0 : S.some(D => !("name" in D && D.name))
                }
                const E = Na(v, {
                  args: w ? [] : {},
                  eventName: A
                });
                a([E])
              }
            },
            onError(p) {
              o == null || o(p)
            }
          });
        x = _, y || x()
      } catch (k) {
        o == null || o(k)
      }
    })(), x
  })()
}

function O7({
  chain: e,
  currentChainId: t
}) {
  if (!e) throw new $K;
  if (t !== e.id) throw new MK({
    chain: e,
    currentChainId: t
  })
}

function jke(e, {
  docsPath: t,
  ...n
}) {
  const r = (() => {
    const i = x7(e, n);
    return i instanceof yy ? e : i
  })();
  return new vK(r, {
    docsPath: t,
    ...n
  })
}
async function g2(e) {
  const t = await e.request({
    method: "eth_chainId"
  });
  return Xn(t)
}
async function D7(e, {
  serializedTransaction: t
}) {
  return e.request({
    method: "eth_sendRawTransaction",
    params: [t]
  })
}
async function N7(e, t) {
  var x, k, _, p;
  const {
    account: n = e.account,
    chain: r = e.chain,
    accessList: i,
    data: s,
    gas: o,
    gasPrice: a,
    maxFeePerGas: c,
    maxPriorityFeePerGas: l,
    nonce: u,
    to: f,
    value: h,
    ...g
  } = t;
  if (!n) throw new $m({
    docsPath: "/docs/actions/wallet/sendTransaction"
  });
  const y = Ha(n);
  try {
    Lm(t);
    let v;
    if (r !== null && (v = await Tt(e, g2, "getChainId")({}), O7({
        currentChainId: v,
        chain: r
      })), y.type === "local") {
      const w = await Tt(e, N6, "prepareTransactionRequest")({
        account: y,
        accessList: i,
        chain: r,
        data: s,
        gas: o,
        gasPrice: a,
        maxFeePerGas: c,
        maxPriorityFeePerGas: l,
        nonce: u,
        to: f,
        value: h,
        ...g
      });
      v || (v = await Tt(e, g2, "getChainId")({}));
      const E = (x = r == null ? void 0 : r.serializers) == null ? void 0 : x.transaction,
        D = await y.signTransaction({
          ...w,
          chainId: v
        }, {
          serializer: E
        });
      return await Tt(e, D7, "sendRawTransaction")({
        serializedTransaction: D
      })
    }
    const S = (p = (_ = (k = e.chain) == null ? void 0 : k.formatters) == null ? void 0 : _.transactionRequest) == null ? void 0 : p.format,
      A = (S || Mh)({
        ...P6(g, {
          format: S
        }),
        accessList: i,
        data: s,
        from: y.address,
        gas: o,
        gasPrice: a,
        maxFeePerGas: c,
        maxPriorityFeePerGas: l,
        nonce: u,
        to: f,
        value: h
      });
    return await e.request({
      method: "eth_sendTransaction",
      params: [A]
    })
  } catch (v) {
    throw jke(v, {
      ...t,
      account: y,
      chain: t.chain || void 0
    })
  }
}
async function FK(e, {
  abi: t,
  address: n,
  args: r,
  dataSuffix: i,
  functionName: s,
  ...o
}) {
  const a = Su({
    abi: t,
    args: r,
    functionName: s
  });
  return await Tt(e, N7, "sendTransaction")({
    data: `${a}${i?i.replace("0x",""):""}`,
    to: n,
    ...o
  })
}

function Uke({
  abi: e,
  address: t,
  publicClient: n,
  walletClient: r
}) {
  const i = n != null,
    s = r != null,
    o = {};
  let a = !1,
    c = !1,
    l = !1;
  for (const u of e)
    if (u.type === "function" ? u.stateMutability === "view" || u.stateMutability === "pure" ? a = !0 : c = !0 : u.type === "event" && (l = !0), a && c && l) break;
  return i && (a && (o.read = new Proxy({}, {
    get(u, f) {
      return (...h) => {
        const {
          args: g,
          options: y
        } = Ib(h);
        return Tt(n, hu, "readContract")({
          abi: e,
          address: t,
          functionName: f,
          args: g,
          ...y
        })
      }
    }
  })), c && (o.simulate = new Proxy({}, {
    get(u, f) {
      return (...h) => {
        const {
          args: g,
          options: y
        } = Ib(h);
        return Tt(n, LK, "simulateContract")({
          abi: e,
          address: t,
          functionName: f,
          args: g,
          ...y
        })
      }
    }
  })), l && (o.createEventFilter = new Proxy({}, {
    get(u, f) {
      return (...h) => {
        const g = e.find(k => k.type === "event" && k.name === f),
          {
            args: y,
            options: x
          } = e8(h, g);
        return Tt(n, f7, "createContractEventFilter")({
          abi: e,
          address: t,
          eventName: f,
          args: y,
          ...x
        })
      }
    }
  }), o.getEvents = new Proxy({}, {
    get(u, f) {
      return (...h) => {
        const g = e.find(k => k.type === "event" && k.name === f),
          {
            args: y,
            options: x
          } = e8(h, g);
        return Tt(n, _7, "getContractEvents")({
          abi: e,
          address: t,
          eventName: f,
          args: y,
          ...x
        })
      }
    }
  }), o.watchEvent = new Proxy({}, {
    get(u, f) {
      return (...h) => {
        const g = e.find(k => k.type === "event" && k.name === f),
          {
            args: y,
            options: x
          } = e8(h, g);
        return Tt(n, BK, "watchContractEvent")({
          abi: e,
          address: t,
          eventName: f,
          args: y,
          ...x
        })
      }
    }
  }))), s && c && (o.write = new Proxy({}, {
    get(u, f) {
      return (...h) => {
        const {
          args: g,
          options: y
        } = Ib(h);
        return Tt(r, FK, "writeContract")({
          abi: e,
          address: t,
          functionName: f,
          args: g,
          ...y
        })
      }
    }
  })), (i || s) && c && (o.estimateGas = new Proxy({}, {
    get(u, f) {
      return (...h) => {
        const {
          args: g,
          options: y
        } = Ib(h);
        return Tt(n ?? r, OK, "estimateContractGas")({
          abi: e,
          address: t,
          functionName: f,
          args: g,
          ...y,
          account: y.account ?? r.account
        })
      }
    }
  })), o.address = t, o.abi = e, o
}

function Ib(e) {
  const t = e.length && Array.isArray(e[0]),
    n = t ? e[0] : [],
    r = (t ? e[1] : e[0]) ?? {};
  return {
    args: n,
    options: r
  }
}

function e8(e, t) {
  let n = !1;
  Array.isArray(e[0]) ? n = !0 : e.length === 1 ? n = t.inputs.some(s => s.indexed) : e.length === 2 && (n = !0);
  const r = n ? e[0] : void 0,
    i = (n ? e[1] : e[0]) ?? {};
  return {
    args: r,
    options: i
  }
}
async function zke(e, {
  chain: t
}) {
  const {
    id: n,
    name: r,
    nativeCurrency: i,
    rpcUrls: s,
    blockExplorers: o
  } = t;
  await e.request({
    method: "wallet_addEthereumChain",
    params: [{
      chainId: Ct(n),
      chainName: r,
      nativeCurrency: i,
      rpcUrls: s.default.http,
      blockExplorerUrls: o ? Object.values(o).map(({
        url: a
      }) => a) : void 0
    }]
  })
}

function Hke(e) {
  const t = ii(`0x${e.substring(4)}`).substring(26);
  return my(`0x${t}`)
}
const RA = 256;
let Pb = RA,
  Rb;

function Vke(e = 11) {
  if (!Rb || Pb + e > RA * 2) {
    Rb = "", Pb = 0;
    for (let t = 0; t < RA; t++) Rb += (256 + Math.random() * 256 | 0).toString(16).substring(1)
  }
  return Rb.substring(Pb, Pb++ + e)
}

function B6(e) {
  const {
    batch: t,
    cacheTime: n = e.pollingInterval ?? 4e3,
    key: r = "base",
    name: i = "Base Client",
    pollingInterval: s = 4e3,
    type: o = "base"
  } = e, a = e.chain, c = e.account ? Ha(e.account) : void 0, {
    config: l,
    request: u,
    value: f
  } = e.transport({
    chain: a,
    pollingInterval: s
  }), h = {
    ...l,
    ...f
  }, g = {
    account: c,
    batch: t,
    cacheTime: n,
    chain: a,
    key: r,
    name: i,
    pollingInterval: s,
    request: u,
    transport: h,
    type: o,
    uid: Vke()
  };

  function y(x) {
    return k => {
      const _ = k(x);
      for (const v in g) delete _[v];
      const p = {
        ...x,
        ..._
      };
      return Object.assign(p, {
        extend: y(p)
      })
    }
  }
  return Object.assign(g, {
    extend: y(g)
  })
}

function OA(e, {
  delay: t = 100,
  retryCount: n = 2,
  shouldRetry: r = () => !0
} = {}) {
  return new Promise((i, s) => {
    const o = async ({
      count: a = 0
    } = {}) => {
      const c = async ({
        error: l
      }) => {
        const u = typeof t == "function" ? t({
          count: a,
          error: l
        }) : t;
        u && await sx(u), o({
          count: a + 1
        })
      };
      try {
        const l = await e();
        i(l)
      } catch (l) {
        if (a < n && await r({
            count: a,
            error: l
          })) return c({
          error: l
        });
        s(l)
      }
    };
    o()
  })
}
const jK = e => "code" in e ? e.code !== -1 && e.code !== -32004 && e.code !== -32005 && e.code !== -32042 && e.code !== -32603 : e instanceof vd && e.status ? e.status !== 403 && e.status !== 408 && e.status !== 413 && e.status !== 429 && e.status !== 500 && e.status !== 502 && e.status !== 503 && e.status !== 504 : !1;

function Wke(e, {
  retryDelay: t = 150,
  retryCount: n = 3
} = {}) {
  return async r => OA(async () => {
    try {
      return await e(r)
    } catch (i) {
      const s = i;
      switch (s.code) {
        case Up.code:
          throw new Up(s);
        case zp.code:
          throw new zp(s);
        case Hp.code:
          throw new Hp(s);
        case Vp.code:
          throw new Vp(s);
        case gh.code:
          throw new gh(s);
        case _d.code:
          throw new _d(s);
        case Wp.code:
          throw new Wp(s);
        case qp.code:
          throw new qp(s);
        case Gp.code:
          throw new Gp(s);
        case Kp.code:
          throw new Kp(s);
        case Qp.code:
          throw new Qp(s);
        case Yp.code:
          throw new Yp(s);
        case Gf.code:
          throw new Gf(s);
        case Jp.code:
          throw new Jp(s);
        case Xp.code:
          throw new Xp(s);
        case yh.code:
          throw new yh(s);
        case Zp.code:
          throw new Zp(s);
        case em.code:
          throw new em(s);
        case 5e3:
          throw new Gf(s);
        default:
          throw i instanceof $e ? i : new SK(s)
      }
    }
  }, {
    delay: ({
      count: i,
      error: s
    }) => {
      var o;
      if (s && s instanceof vd) {
        const a = (o = s == null ? void 0 : s.headers) == null ? void 0 : o.get("Retry-After");
        if (a != null && a.match(/\d/)) return parseInt(a) * 1e3
      }
      return ~~(1 << i) * t
    },
    retryCount: n,
    shouldRetry: ({
      error: i
    }) => !jK(i)
  })
}

function Ey({
  key: e,
  name: t,
  request: n,
  retryCount: r = 3,
  retryDelay: i = 150,
  timeout: s,
  type: o
}, a) {
  return {
    config: {
      key: e,
      name: t,
      request: n,
      retryCount: r,
      retryDelay: i,
      timeout: s,
      type: o
    },
    request: Wke(n, {
      retryCount: r,
      retryDelay: i
    }),
    value: a
  }
}

function qke(e, t = {}) {
  const {
    key: n = "custom",
    name: r = "Custom Provider",
    retryDelay: i
  } = t;
  return ({
    retryCount: s
  }) => Ey({
    key: n,
    name: r,
    request: e.request.bind(e),
    retryCount: t.retryCount ?? s,
    retryDelay: i,
    type: "custom"
  })
}

function Gke(e, t = {}) {
  const {
    key: n = "fallback",
    name: r = "Fallback",
    rank: i = !1,
    retryCount: s,
    retryDelay: o
  } = t;
  return ({
    chain: a,
    pollingInterval: c = 4e3,
    timeout: l
  }) => {
    let u = e,
      f = () => {};
    const h = Ey({
      key: n,
      name: r,
      async request({
        method: g,
        params: y
      }) {
        const x = async (k = 0) => {
          const _ = u[k]({
            chain: a,
            retryCount: 0,
            timeout: l
          });
          try {
            const p = await _.request({
              method: g,
              params: y
            });
            return f({
              method: g,
              params: y,
              response: p,
              transport: _,
              status: "success"
            }), p
          } catch (p) {
            if (f({
                error: p,
                method: g,
                params: y,
                transport: _,
                status: "error"
              }), jK(p) || k === u.length - 1) throw p;
            return x(k + 1)
          }
        };
        return x()
      },
      retryCount: s,
      retryDelay: o,
      type: "fallback"
    }, {
      onResponse: g => f = g,
      transports: u.map(g => g({
        chain: a,
        retryCount: 0
      }))
    });
    if (i) {
      const g = typeof i == "object" ? i : {};
      Kke({
        chain: a,
        interval: g.interval ?? c,
        onTransports: y => u = y,
        sampleCount: g.sampleCount,
        timeout: g.timeout,
        transports: u,
        weights: g.weights
      })
    }
    return h
  }
}

function Kke({
  chain: e,
  interval: t = 4e3,
  onTransports: n,
  sampleCount: r = 10,
  timeout: i = 1e3,
  transports: s,
  weights: o = {}
}) {
  const {
    stability: a = .7,
    latency: c = .3
  } = o, l = [], u = async () => {
    const f = await Promise.all(s.map(async y => {
      const x = y({
          chain: e,
          retryCount: 0,
          timeout: i
        }),
        k = Date.now();
      let _, p;
      try {
        await x.request({
          method: "net_listening"
        }), p = 1
      } catch {
        p = 0
      } finally {
        _ = Date.now()
      }
      return {
        latency: _ - k,
        success: p
      }
    }));
    l.push(f), l.length > r && l.shift();
    const h = Math.max(...l.map(y => Math.max(...y.map(({
        latency: x
      }) => x)))),
      g = s.map((y, x) => {
        const k = l.map(I => I[x].latency),
          p = 1 - k.reduce((I, A) => I + A, 0) / k.length / h,
          v = l.map(I => I[x].success),
          S = v.reduce((I, A) => I + A, 0) / v.length;
        return S === 0 ? [0, x] : [c * p + a * S, x]
      }).sort((y, x) => x[0] - y[0]);
    n(g.map(([, y]) => s[y])), await sx(t), u()
  };
  u()
}
class M7 extends $e {
  constructor() {
    super("No URL was provided to the Transport. Please provide a valid RPC URL to the Transport.", {
      docsPath: "/docs/clients/intro"
    })
  }
}

function Qke() {
  if (typeof WebSocket < "u") return WebSocket;
  if (typeof global.WebSocket < "u") return global.WebSocket;
  if (typeof window.WebSocket < "u") return window.WebSocket;
  if (typeof self.WebSocket < "u") return self.WebSocket;
  throw new Error("`WebSocket` is not supported in this environment")
}
const x$ = Qke();

function UK(e, {
  errorInstance: t = new Error("timed out"),
  timeout: n,
  signal: r
}) {
  return new Promise((i, s) => {
    (async () => {
      let o;
      try {
        const a = new AbortController;
        n > 0 && (o = setTimeout(() => {
          r ? a.abort() : s(t)
        }, n)), i(await e({
          signal: a == null ? void 0 : a.signal
        }))
      } catch (a) {
        a.name === "AbortError" && s(t), s(a)
      } finally {
        clearTimeout(o)
      }
    })()
  })
}
let DA = 0;
async function Yke(e, {
  body: t,
  fetchOptions: n = {},
  timeout: r = 1e4
}) {
  var a;
  const {
    headers: i,
    method: s,
    signal: o
  } = n;
  try {
    const c = await UK(async ({
      signal: u
    }) => await fetch(e, {
      ...n,
      body: Array.isArray(t) ? Ti(t.map(h => ({
        jsonrpc: "2.0",
        id: h.id ?? DA++,
        ...h
      }))) : Ti({
        jsonrpc: "2.0",
        id: t.id ?? DA++,
        ...t
      }),
      headers: {
        ...i,
        "Content-Type": "application/json"
      },
      method: s || "POST",
      signal: o || (r > 0 ? u : void 0)
    }), {
      errorInstance: new K3({
        body: t,
        url: e
      }),
      timeout: r,
      signal: !0
    });
    let l;
    if ((a = c.headers.get("Content-Type")) != null && a.startsWith("application/json") ? l = await c.json() : l = await c.text(), !c.ok) throw new vd({
      body: t,
      details: Ti(l.error) || c.statusText,
      headers: c.headers,
      status: c.status,
      url: e
    });
    return l
  } catch (c) {
    throw c instanceof vd || c instanceof K3 ? c : new vd({
      body: t,
      details: c.message,
      url: e
    })
  }
}
const t8 = new Map;
async function n8(e) {
  let t = t8.get(e);
  if (t) return t;
  const {
    schedule: n
  } = R7({
    id: e,
    fn: async () => {
      const s = new x$(e),
        o = new Map,
        a = new Map,
        c = ({
          data: u
        }) => {
          const f = JSON.parse(u),
            h = f.method === "eth_subscription",
            g = h ? f.params.subscription : f.id,
            y = h ? a : o,
            x = y.get(g);
          x && x({
            data: u
          }), h || y.delete(g)
        },
        l = () => {
          t8.delete(e), s.removeEventListener("close", l), s.removeEventListener("message", c)
        };
      return s.addEventListener("close", l), s.addEventListener("message", c), s.readyState === x$.CONNECTING && await new Promise((u, f) => {
        s && (s.onopen = u, s.onerror = f)
      }), t = Object.assign(s, {
        requests: o,
        subscriptions: a
      }), t8.set(e, t), [t]
    }
  }), [r, [i]] = await n();
  return i
}

function Jke(e, {
  body: t,
  onResponse: n
}) {
  if (e.readyState === e.CLOSED || e.readyState === e.CLOSING) throw new EK({
    body: t,
    url: e.url,
    details: "Socket is closed."
  });
  const r = DA++,
    i = ({
      data: s
    }) => {
      var a;
      const o = JSON.parse(s);
      typeof o.id == "number" && r !== o.id || (n == null || n(o), t.method === "eth_subscribe" && typeof o.result == "string" && e.subscriptions.set(o.result, i), t.method === "eth_unsubscribe" && e.subscriptions.delete((a = t.params) == null ? void 0 : a[0]))
    };
  return e.requests.set(r, i), e.send(JSON.stringify({
    jsonrpc: "2.0",
    ...t,
    id: r
  })), e
}
async function Xke(e, {
  body: t,
  timeout: n = 1e4
}) {
  return UK(() => new Promise(r => yp.webSocket(e, {
    body: t,
    onResponse: r
  })), {
    errorInstance: new K3({
      body: t,
      url: e.url
    }),
    timeout: n
  })
}
const yp = {
  http: Yke,
  webSocket: Jke,
  webSocketAsync: Xke
};

function zK(e, t = {}) {
  const {
    batch: n,
    fetchOptions: r,
    key: i = "http",
    name: s = "HTTP JSON-RPC",
    retryDelay: o
  } = t;
  return ({
    chain: a,
    retryCount: c,
    timeout: l
  }) => {
    const {
      batchSize: u = 1e3,
      wait: f = 0
    } = typeof n == "object" ? n : {}, h = t.retryCount ?? c, g = l ?? t.timeout ?? 1e4, y = e || (a == null ? void 0 : a.rpcUrls.default.http[0]);
    if (!y) throw new M7;
    return Ey({
      key: i,
      name: s,
      async request({
        method: x,
        params: k
      }) {
        const _ = {
            method: x,
            params: k
          },
          {
            schedule: p
          } = R7({
            id: `${e}`,
            wait: f,
            shouldSplitBatch(A) {
              return A.length > u
            },
            fn: A => yp.http(y, {
              body: A,
              fetchOptions: r,
              timeout: g
            }),
            sort: (A, w) => A.id - w.id
          }),
          v = async A => n ? p(A) : [await yp.http(y, {
            body: A,
            fetchOptions: r,
            timeout: g
          })], [{
            error: S,
            result: I
          }] = await v(_);
        if (S) throw new I6({
          body: _,
          error: S,
          url: y
        });
        return I
      },
      retryCount: h,
      retryDelay: o,
      timeout: g,
      type: "http"
    }, {
      fetchOptions: r,
      url: e
    })
  }
}

function $7(e, t) {
  var r, i, s;
  if (!(e instanceof $e)) return !1;
  const n = e.walk(o => o instanceof G3);
  return n instanceof G3 ? !!(((r = n.data) == null ? void 0 : r.errorName) === "ResolverNotFound" || ((i = n.data) == null ? void 0 : i.errorName) === "ResolverWildcardNotSupported" || (s = n.reason) != null && s.includes("Wildcard on non-extended resolvers is not supported") || t === "reverse" && n.reason === fK[50]) : !1
}

function HK(e) {
  if (e.length !== 66 || e.indexOf("[") !== 0 || e.indexOf("]") !== 65) return null;
  const t = `0x${e.slice(1,65)}`;
  return hn(t) ? t : null
}

function T1(e) {
  let t = new Uint8Array(32).fill(0);
  if (!e) return mo(t);
  const n = e.split(".");
  for (let r = n.length - 1; r >= 0; r -= 1) {
    const i = HK(n[r]),
      s = i ? Bi(i) : ii(ul(n[r]), "bytes");
    t = ii(Da([t, s]), "bytes")
  }
  return mo(t)
}

function Zke(e) {
  return `[${e.slice(2)}]`
}

function VK(e) {
  const t = new Uint8Array(32).fill(0);
  return e ? HK(e) || ii(ul(e)) : mo(t)
}

function F6(e) {
  const t = e.replace(/^\.|\.$/gm, "");
  if (t.length === 0) return new Uint8Array(1);
  const n = new Uint8Array(ul(t).byteLength + 2);
  let r = 0;
  const i = t.split(".");
  for (let s = 0; s < i.length; s++) {
    let o = ul(i[s]);
    o.byteLength > 255 && (o = ul(Zke(VK(i[s])))), n[r] = o.length, n.set(o, r + 1), r += o.length + 1
  }
  return n.byteLength !== r + 1 ? n.slice(0, r + 1) : n
}
async function e7e(e, {
  blockNumber: t,
  blockTag: n,
  coinType: r,
  name: i,
  universalResolverAddress: s
}) {
  let o = s;
  if (!o) {
    if (!e.chain) throw new Error("client chain not configured. universalResolverAddress is required.");
    o = Lh({
      blockNumber: t,
      chain: e.chain,
      contract: "ensUniversalResolver"
    })
  }
  try {
    const a = Su({
        abi: b$,
        functionName: "addr",
        ...r != null ? {
          args: [T1(i), BigInt(r)]
        } : {
          args: [T1(i)]
        }
      }),
      c = await Tt(e, hu, "readContract")({
        address: o,
        abi: NK,
        functionName: "resolve",
        args: [yn(F6(i)), a],
        blockNumber: t,
        blockTag: n
      });
    if (c[0] === "0x") return null;
    const l = $h({
      abi: b$,
      args: r != null ? [T1(i), BigInt(r)] : void 0,
      functionName: "addr",
      data: c[0]
    });
    return l === "0x" || lo(l) === "0x00" ? null : l
  } catch (a) {
    if ($7(a, "resolve")) return null;
    throw a
  }
}
class t7e extends $e {
  constructor({
    data: t
  }) {
    super("Unable to extract image from metadata. The metadata may be malformed or invalid.", {
      metaMessages: ["- Metadata must be a JSON object with at least an `image`, `image_url` or `image_data` property.", "", `Provided data: ${JSON.stringify(t)}`]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "EnsAvatarInvalidMetadataError"
    })
  }
}
class I0 extends $e {
  constructor({
    reason: t
  }) {
    super(`ENS NFT avatar URI is invalid. ${t}`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "EnsAvatarInvalidNftUriError"
    })
  }
}
class j6 extends $e {
  constructor({
    uri: t
  }) {
    super(`Unable to resolve ENS avatar URI "${t}". The URI may be malformed, invalid, or does not respond with a valid image.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "EnsAvatarUriResolutionError"
    })
  }
}
class WK extends $e {
  constructor({
    namespace: t
  }) {
    super(`ENS NFT avatar namespace "${t}" is not supported. Must be "erc721" or "erc1155".`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "EnsAvatarUnsupportedNamespaceError"
    })
  }
}
const n7e = /(?<protocol>https?:\/\/[^\/]*|ipfs:\/|ipns:\/|ar:\/)?(?<root>\/)?(?<subpath>ipfs\/|ipns\/)?(?<target>[\w\-.]+)(?<subtarget>\/.*)?/,
  r7e = /^(Qm[1-9A-HJ-NP-Za-km-z]{44,}|b[A-Za-z2-7]{58,}|B[A-Z2-7]{58,}|z[1-9A-HJ-NP-Za-km-z]{48,}|F[0-9A-F]{50,})(\/(?<target>[\w\-.]+))?(?<subtarget>\/.*)?$/,
  i7e = /^data:([a-zA-Z\-/+]*);base64,([^"].*)/,
  s7e = /^data:([a-zA-Z\-/+]*)?(;[a-zA-Z0-9].*?)?(,)/;
async function o7e(e) {
  try {
    const t = await fetch(e, {
      method: "HEAD"
    });
    if (t.status === 200) {
      const n = t.headers.get("content-type");
      return n == null ? void 0 : n.startsWith("image/")
    }
    return !1
  } catch (t) {
    return typeof t == "object" && typeof t.response < "u" || !globalThis.hasOwnProperty("Image") ? !1 : new Promise(n => {
      const r = new Image;
      r.onload = () => {
        n(!0)
      }, r.onerror = () => {
        n(!1)
      }, r.src = e
    })
  }
}

function E$(e, t) {
  return e ? e.endsWith("/") ? e.slice(0, -1) : e : t
}

function qK({
  uri: e,
  gatewayUrls: t
}) {
  const n = i7e.test(e);
  if (n) return {
    uri: e,
    isOnChain: !0,
    isEncoded: n
  };
  const r = E$(t == null ? void 0 : t.ipfs, "https://ipfs.io"),
    i = E$(t == null ? void 0 : t.arweave, "https://arweave.net"),
    s = e.match(n7e),
    {
      protocol: o,
      subpath: a,
      target: c,
      subtarget: l = ""
    } = (s == null ? void 0 : s.groups) || {},
    u = o === "ipns:/" || a === "ipns/",
    f = o === "ipfs:/" || a === "ipfs/" || r7e.test(e);
  if (e.startsWith("http") && !u && !f) {
    let g = e;
    return t != null && t.arweave && (g = e.replace(/https:\/\/arweave.net/g, t == null ? void 0 : t.arweave)), {
      uri: g,
      isOnChain: !1,
      isEncoded: !1
    }
  }
  if ((u || f) && c) return {
    uri: `${r}/${u?"ipns":"ipfs"}/${c}${l}`,
    isOnChain: !1,
    isEncoded: !1
  };
  if (o === "ar:/" && c) return {
    uri: `${i}/${c}${l||""}`,
    isOnChain: !1,
    isEncoded: !1
  };
  let h = e.replace(s7e, "");
  if (h.startsWith("<svg") && (h = `data:image/svg+xml;base64,${btoa(h)}`), h.startsWith("data:") || h.startsWith("{")) return {
    uri: h,
    isOnChain: !0,
    isEncoded: !1
  };
  throw new j6({
    uri: e
  })
}

function GK(e) {
  if (typeof e != "object" || !("image" in e) && !("image_url" in e) && !("image_data" in e)) throw new t7e({
    data: e
  });
  return e.image || e.image_url || e.image_data
}
async function a7e({
  gatewayUrls: e,
  uri: t
}) {
  try {
    const n = await fetch(t).then(i => i.json());
    return await L7({
      gatewayUrls: e,
      uri: GK(n)
    })
  } catch {
    throw new j6({
      uri: t
    })
  }
}
async function L7({
  gatewayUrls: e,
  uri: t
}) {
  const {
    uri: n,
    isOnChain: r
  } = qK({
    uri: t,
    gatewayUrls: e
  });
  if (r || await o7e(n)) return n;
  throw new j6({
    uri: t
  })
}

function c7e(e) {
  let t = e;
  t.startsWith("did:nft:") && (t = t.replace("did:nft:", "").replace(/_/g, "/"));
  const [n, r, i] = t.split("/"), [s, o] = n.split(":"), [a, c] = r.split(":");
  if (!s || s.toLowerCase() !== "eip155") throw new I0({
    reason: "Only EIP-155 supported"
  });
  if (!o) throw new I0({
    reason: "Chain ID not found"
  });
  if (!c) throw new I0({
    reason: "Contract address not found"
  });
  if (!i) throw new I0({
    reason: "Token ID not found"
  });
  if (!a) throw new I0({
    reason: "ERC namespace not found"
  });
  return {
    chainID: parseInt(o),
    namespace: a.toLowerCase(),
    contractAddress: c,
    tokenID: i
  }
}
async function l7e(e, {
  nft: t
}) {
  if (t.namespace === "erc721") return hu(e, {
    address: t.contractAddress,
    abi: [{
      name: "tokenURI",
      type: "function",
      stateMutability: "view",
      inputs: [{
        name: "tokenId",
        type: "uint256"
      }],
      outputs: [{
        name: "",
        type: "string"
      }]
    }],
    functionName: "tokenURI",
    args: [BigInt(t.tokenID)]
  });
  if (t.namespace === "erc1155") return hu(e, {
    address: t.contractAddress,
    abi: [{
      name: "uri",
      type: "function",
      stateMutability: "view",
      inputs: [{
        name: "_id",
        type: "uint256"
      }],
      outputs: [{
        name: "",
        type: "string"
      }]
    }],
    functionName: "uri",
    args: [BigInt(t.tokenID)]
  });
  throw new WK({
    namespace: t.namespace
  })
}
async function u7e(e, {
  gatewayUrls: t,
  record: n
}) {
  return /eip155:/i.test(n) ? d7e(e, {
    gatewayUrls: t,
    record: n
  }) : L7({
    uri: n,
    gatewayUrls: t
  })
}
async function d7e(e, {
  gatewayUrls: t,
  record: n
}) {
  const r = c7e(n),
    i = await l7e(e, {
      nft: r
    }),
    {
      uri: s,
      isOnChain: o,
      isEncoded: a
    } = qK({
      uri: i,
      gatewayUrls: t
    });
  if (o && (s.includes("data:application/json;base64,") || s.startsWith("{"))) {
    const l = a ? atob(s.replace("data:application/json;base64,", "")) : s,
      u = JSON.parse(l);
    return L7({
      uri: GK(u),
      gatewayUrls: t
    })
  }
  let c = r.tokenID;
  return r.namespace === "erc1155" && (c = c.replace("0x", "").padStart(64, "0")), a7e({
    gatewayUrls: t,
    uri: s.replace(/(?:0x)?{id}/, c)
  })
}
async function KK(e, {
  blockNumber: t,
  blockTag: n,
  name: r,
  key: i,
  universalResolverAddress: s
}) {
  let o = s;
  if (!o) {
    if (!e.chain) throw new Error("client chain not configured. universalResolverAddress is required.");
    o = Lh({
      blockNumber: t,
      chain: e.chain,
      contract: "ensUniversalResolver"
    })
  }
  try {
    const a = await Tt(e, hu, "readContract")({
      address: o,
      abi: NK,
      functionName: "resolve",
      args: [yn(F6(r)), Su({
        abi: v$,
        functionName: "text",
        args: [T1(r), i]
      })],
      blockNumber: t,
      blockTag: n
    });
    if (a[0] === "0x") return null;
    const c = $h({
      abi: v$,
      functionName: "text",
      data: a[0]
    });
    return c === "" ? null : c
  } catch (a) {
    if ($7(a, "resolve")) return null;
    throw a
  }
}
async function f7e(e, {
  blockNumber: t,
  blockTag: n,
  gatewayUrls: r,
  name: i,
  universalResolverAddress: s
}) {
  const o = await Tt(e, KK, "getEnsText")({
    blockNumber: t,
    blockTag: n,
    key: "avatar",
    name: i,
    universalResolverAddress: s
  });
  if (!o) return null;
  try {
    return await u7e(e, {
      record: o,
      gatewayUrls: r
    })
  } catch {
    return null
  }
}
async function h7e(e, {
  address: t,
  blockNumber: n,
  blockTag: r,
  universalResolverAddress: i
}) {
  let s = i;
  if (!s) {
    if (!e.chain) throw new Error("client chain not configured. universalResolverAddress is required.");
    s = Lh({
      blockNumber: n,
      chain: e.chain,
      contract: "ensUniversalResolver"
    })
  }
  const o = `${t.toLowerCase().substring(2)}.addr.reverse`;
  try {
    const [a, c] = await Tt(e, hu, "readContract")({
      address: s,
      abi: kke,
      functionName: "reverse",
      args: [yn(F6(o))],
      blockNumber: n,
      blockTag: r
    });
    return t.toLowerCase() !== c.toLowerCase() ? null : a
  } catch (a) {
    if ($7(a, "reverse")) return null;
    throw a
  }
}
async function p7e(e, {
  blockNumber: t,
  blockTag: n,
  name: r,
  universalResolverAddress: i
}) {
  let s = i;
  if (!s) {
    if (!e.chain) throw new Error("client chain not configured. universalResolverAddress is required.");
    s = Lh({
      blockNumber: t,
      chain: e.chain,
      contract: "ensUniversalResolver"
    })
  }
  const [o] = await Tt(e, hu, "readContract")({
    address: s,
    abi: [{
      inputs: [{
        type: "bytes"
      }],
      name: "findResolver",
      outputs: [{
        type: "address"
      }, {
        type: "bytes32"
      }],
      stateMutability: "view",
      type: "function"
    }],
    functionName: "findResolver",
    args: [yn(F6(r))],
    blockNumber: t,
    blockTag: n
  });
  return o
}
async function m7e(e) {
  const t = A6(e, {
      method: "eth_newBlockFilter"
    }),
    n = await e.request({
      method: "eth_newBlockFilter"
    });
  return {
    id: n,
    request: t(n),
    type: "block"
  }
}
async function QK(e, {
  address: t,
  args: n,
  event: r,
  events: i,
  fromBlock: s,
  strict: o,
  toBlock: a
} = {}) {
  const c = i ?? (r ? [r] : void 0),
    l = A6(e, {
      method: "eth_newFilter"
    });
  let u = [];
  c && (u = [c.flatMap(h => Mm({
    abi: [h],
    eventName: h.name,
    args: n
  }))], r && (u = u[0]));
  const f = await e.request({
    method: "eth_newFilter",
    params: [{
      address: t,
      fromBlock: typeof s == "bigint" ? Ct(s) : s,
      toBlock: typeof a == "bigint" ? Ct(a) : a,
      ...u.length ? {
        topics: u
      } : {}
    }]
  });
  return {
    abi: c,
    args: n,
    eventName: r ? r.name : void 0,
    fromBlock: s,
    id: f,
    request: l(f),
    strict: o,
    toBlock: a,
    type: "event"
  }
}
async function YK(e) {
  const t = A6(e, {
      method: "eth_newPendingTransactionFilter"
    }),
    n = await e.request({
      method: "eth_newPendingTransactionFilter"
    });
  return {
    id: n,
    request: t(n),
    type: "transaction"
  }
}
async function g7e(e, {
  address: t,
  blockNumber: n,
  blockTag: r = "latest"
}) {
  const i = n ? Ct(n) : void 0,
    s = await e.request({
      method: "eth_getBalance",
      params: [t, i || r]
    });
  return BigInt(s)
}
async function y7e(e, {
  blockHash: t,
  blockNumber: n,
  blockTag: r = "latest"
} = {}) {
  const i = n !== void 0 ? Ct(n) : void 0;
  let s;
  return t ? s = await e.request({
    method: "eth_getBlockTransactionCountByHash",
    params: [t]
  }) : s = await e.request({
    method: "eth_getBlockTransactionCountByNumber",
    params: [i || r]
  }), Xn(s)
}
async function v7e(e, {
  address: t,
  blockNumber: n,
  blockTag: r = "latest"
}) {
  const i = n !== void 0 ? Ct(n) : void 0,
    s = await e.request({
      method: "eth_getCode",
      params: [t, i || r]
    });
  if (s !== "0x") return s
}

function b7e(e) {
  var t;
  return {
    baseFeePerGas: e.baseFeePerGas.map(n => BigInt(n)),
    gasUsedRatio: e.gasUsedRatio,
    oldestBlock: BigInt(e.oldestBlock),
    reward: (t = e.reward) == null ? void 0 : t.map(n => n.map(r => BigInt(r)))
  }
}
async function w7e(e, {
  blockCount: t,
  blockNumber: n,
  blockTag: r = "latest",
  rewardPercentiles: i
}) {
  const s = n ? Ct(n) : void 0,
    o = await e.request({
      method: "eth_feeHistory",
      params: [Ct(t), s || r, i]
    });
  return b7e(o)
}
async function x7e(e, {
  filter: t
}) {
  const n = t.strict ?? !1;
  return (await t.request({
    method: "eth_getFilterLogs",
    params: [t.id]
  })).map(i => {
    var s;
    try {
      const {
        eventName: o,
        args: a
      } = "abi" in t && t.abi ? Bm({
        abi: t.abi,
        data: i.data,
        topics: i.topics,
        strict: n
      }) : {
        eventName: void 0,
        args: void 0
      };
      return Na(i, {
        args: a,
        eventName: o
      })
    } catch (o) {
      let a, c;
      if (o instanceof Td || o instanceof Oh) {
        if ("strict" in t && t.strict) return;
        a = o.abiItem.name, c = (s = o.abiItem.inputs) == null ? void 0 : s.some(l => !("name" in l && l.name))
      }
      return Na(i, {
        args: c ? [] : {},
        eventName: a
      })
    }
  }).filter(Boolean)
}
class E7e extends $e {
  constructor({
    callbackSelector: t,
    cause: n,
    data: r,
    extraData: i,
    sender: s,
    urls: o
  }) {
    var a;
    super(n.shortMessage || "An error occurred while fetching for an offchain result.", {
      cause: n,
      metaMessages: [...n.metaMessages || [], (a = n.metaMessages) != null && a.length ? "" : [], "Offchain Gateway Call:", o && ["  Gateway URL(s):", ...o.map(c => `    ${Dm(c)}`)], `  Sender: ${s}`, `  Data: ${r}`, `  Callback selector: ${t}`, `  Extra data: ${i}`].flat()
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "OffchainLookupError"
    })
  }
}
class S7e extends $e {
  constructor({
    result: t,
    url: n
  }) {
    super("Offchain gateway response is malformed. Response data must be a hex value.", {
      metaMessages: [`Gateway URL: ${Dm(n)}`, `Response: ${Ti(t)}`]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "OffchainLookupResponseMalformedError"
    })
  }
}
class C7e extends $e {
  constructor({
    sender: t,
    to: n
  }) {
    super("Reverted sender address does not match target contract address (`to`).", {
      metaMessages: [`Contract address: ${n}`, `OffchainLookup sender address: ${t}`]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "OffchainLookupSenderMismatchError"
    })
  }
}

function U6(e, t) {
  if (!Hi(e)) throw new go({
    address: e
  });
  if (!Hi(t)) throw new go({
    address: t
  });
  return e.toLowerCase() === t.toLowerCase()
}
const JK = "0x556f1830",
  B7 = {
    name: "OffchainLookup",
    type: "error",
    inputs: [{
      name: "sender",
      type: "address"
    }, {
      name: "urls",
      type: "string[]"
    }, {
      name: "callData",
      type: "bytes"
    }, {
      name: "callbackFunction",
      type: "bytes4"
    }, {
      name: "extraData",
      type: "bytes"
    }]
  };
async function XK(e, {
  blockNumber: t,
  blockTag: n,
  data: r,
  to: i
}) {
  const {
    args: s
  } = h7({
    data: r,
    abi: [B7]
  }), [o, a, c, l, u] = s;
  try {
    if (!U6(i, o)) throw new C7e({
      sender: o,
      to: i
    });
    const f = await F7({
        data: c,
        sender: o,
        urls: a
      }),
      {
        data: h
      } = await by(e, {
        blockNumber: t,
        blockTag: n,
        data: Da([l, Eu([{
          type: "bytes"
        }, {
          type: "bytes"
        }], [f, u])]),
        to: i
      });
    return h
  } catch (f) {
    throw new E7e({
      callbackSelector: l,
      cause: f,
      data: r,
      extraData: u,
      sender: o,
      urls: a
    })
  }
}
async function F7({
  data: e,
  sender: t,
  urls: n
}) {
  var i;
  let r = new Error("An unknown error occurred.");
  for (let s = 0; s < n.length; s++) {
    const o = n[s],
      a = o.includes("{data}") ? "GET" : "POST",
      c = a === "POST" ? {
        data: e,
        sender: t
      } : void 0;
    try {
      const l = await fetch(o.replace("{sender}", t).replace("{data}", e), {
        body: JSON.stringify(c),
        method: a
      });
      let u;
      if ((i = l.headers.get("Content-Type")) != null && i.startsWith("application/json") ? u = (await l.json()).data : u = await l.text(), !l.ok) {
        r = new vd({
          body: c,
          details: u != null && u.error ? Ti(u.error) : l.statusText,
          headers: l.headers,
          status: l.status,
          url: o
        });
        continue
      }
      if (!hn(u)) {
        r = new S7e({
          result: u,
          url: o
        });
        continue
      }
      return u
    } catch (l) {
      r = new vd({
        body: c,
        details: l.message,
        url: o
      })
    }
  }
  throw r
}
const A7e = Object.freeze(Object.defineProperty({
  __proto__: null,
  ccipFetch: F7,
  offchainLookup: XK,
  offchainLookupAbiItem: B7,
  offchainLookupSignature: JK
}, Symbol.toStringTag, {
  value: "Module"
}));

function fs(e, t = {}) {
  const {
    fees: n = e.fees,
    formatters: r = e.formatters,
    serializers: i = e.serializers
  } = t;
  return {
    ...e,
    fees: n,
    formatters: r,
    serializers: i
  }
}

function T7e({
  chains: e,
  id: t
}) {
  return e.find(n => n.id === t)
}
const k7e = /^(.*)\[([0-9]*)\]$/,
  ZK = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/,
  eQ = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;

function j7({
  domain: e,
  message: t,
  primaryType: n,
  types: r
}) {
  const i = typeof e > "u" ? {} : e,
    s = {
      EIP712Domain: z6({
        domain: i
      }),
      ...r
    };
  z7({
    domain: i,
    message: t,
    primaryType: n,
    types: s
  });
  const o = ["0x1901"];
  return i && o.push(U7({
    domain: i,
    types: s
  })), n !== "EIP712Domain" && o.push(tQ({
    data: t,
    primaryType: n,
    types: s
  })), ii(Da(o))
}

function U7({
  domain: e,
  types: t
}) {
  return tQ({
    data: e,
    primaryType: "EIP712Domain",
    types: t
  })
}

function tQ({
  data: e,
  primaryType: t,
  types: n
}) {
  const r = nQ({
    data: e,
    primaryType: t,
    types: n
  });
  return ii(r)
}

function nQ({
  data: e,
  primaryType: t,
  types: n
}) {
  const r = [{
      type: "bytes32"
    }],
    i = [_7e({
      primaryType: t,
      types: n
    })];
  for (const s of n[t]) {
    const [o, a] = iQ({
      types: n,
      name: s.name,
      type: s.type,
      value: e[s.name]
    });
    r.push(o), i.push(a)
  }
  return Eu(r, i)
}

function _7e({
  primaryType: e,
  types: t
}) {
  const n = yn(I7e({
    primaryType: e,
    types: t
  }));
  return ii(n)
}

function I7e({
  primaryType: e,
  types: t
}) {
  let n = "";
  const r = rQ({
    primaryType: e,
    types: t
  });
  r.delete(e);
  const i = [e, ...Array.from(r).sort()];
  for (const s of i) n += `${s}(${t[s].map(({name:o,type:a})=>`
  $ {
    a
  }
  $ {
    o
  }
  `).join(",")})`;
  return n
}

function rQ({
  primaryType: e,
  types: t
}, n = new Set) {
  const r = e.match(/^\w*/u),
    i = r == null ? void 0 : r[0];
  if (n.has(i) || t[i] === void 0) return n;
  n.add(i);
  for (const s of t[i]) rQ({
    primaryType: s.type,
    types: t
  }, n);
  return n
}

function iQ({
  types: e,
  name: t,
  type: n,
  value: r
}) {
  if (e[n] !== void 0) return [{
    type: "bytes32"
  }, ii(nQ({
    data: r,
    primaryType: n,
    types: e
  }))];
  if (n === "bytes") return r = `0x${(r.length%2?"0":"")+r.slice(2)}`, [{
    type: "bytes32"
  }, ii(r)];
  if (n === "string") return [{
    type: "bytes32"
  }, ii(yn(r))];
  if (n.lastIndexOf("]") === n.length - 1) {
    const i = n.slice(0, n.lastIndexOf("[")),
      s = r.map(o => iQ({
        name: t,
        type: i,
        types: e,
        value: o
      }));
    return [{
      type: "bytes32"
    }, ii(Eu(s.map(([o]) => o), s.map(([, o]) => o)))]
  }
  return [{
    type: n
  }, r]
}

function z7({
  domain: e,
  message: t,
  primaryType: n,
  types: r
}) {
  const i = r,
    s = (o, a) => {
      for (const c of o) {
        const {
          name: l,
          type: u
        } = c, f = u, h = a[l], g = f.match(eQ);
        if (g && (typeof h == "number" || typeof h == "bigint")) {
          const [k, _, p] = g;
          Ct(h, {
            signed: _ === "int",
            size: parseInt(p) / 8
          })
        }
        if (f === "address" && typeof h == "string" && !Hi(h)) throw new go({
          address: h
        });
        const y = f.match(ZK);
        if (y) {
          const [k, _] = y;
          if (_ && Qr(h) !== parseInt(_)) throw new e7({
            expectedSize: parseInt(_),
            givenSize: Qr(h)
          })
        }
        const x = i[f];
        x && s(x, h)
      }
    };
  if (i.EIP712Domain && e && s(i.EIP712Domain, e), n !== "EIP712Domain") {
    const o = i[n];
    s(o, t)
  }
}

function z6({
  domain: e
}) {
  return [typeof (e == null ? void 0 : e.name) == "string" && {
    name: "name",
    type: "string"
  }, (e == null ? void 0 : e.version) && {
    name: "version",
    type: "string"
  }, typeof (e == null ? void 0 : e.chainId) == "number" && {
    name: "chainId",
    type: "uint256"
  }, (e == null ? void 0 : e.verifyingContract) && {
    name: "verifyingContract",
    type: "address"
  }, (e == null ? void 0 : e.salt) && {
    name: "salt",
    type: "bytes32"
  }].filter(Boolean)
}

function P7e({
  domain: e
}) {
  return U7({
    domain: e,
    types: {
      EIP712Domain: z6({
        domain: e
      })
    }
  })
}

function R7e({
  abi: e,
  data: t
}) {
  const n = Sr(t, 0, 4),
    r = e.find(i => i.type === "function" && n === Nm(Ac(i)));
  if (!r) throw new FG(n, {
    docsPath: "/docs/contract/decodeFunctionData"
  });
  return {
    functionName: r.name,
    args: "inputs" in r && r.inputs && r.inputs.length > 0 ? Dh(r.inputs, Sr(t, 4)) : void 0
  }
}
const r8 = "/docs/contract/encodeDeployData";

function H7({
  abi: e,
  args: t,
  bytecode: n
}) {
  if (!t || t.length === 0) return n;
  const r = e.find(s => "type" in s && s.type === "constructor");
  if (!r) throw new Yk({
    docsPath: r8
  });
  if (!("inputs" in r)) throw new m2({
    docsPath: r8
  });
  if (!r.inputs || r.inputs.length === 0) throw new m2({
    docsPath: r8
  });
  const i = Eu(r.inputs, t);
  return xu([n, i])
}
const i8 = "/docs/contract/encodeErrorResult";

function O7e({
  abi: e,
  errorName: t,
  args: n
}) {
  let r = e[0];
  if (t && (r = Hd({
      abi: e,
      args: n,
      name: t
    }), !r)) throw new kA(t, {
    docsPath: i8
  });
  if (r.type !== "error") throw new kA(void 0, {
    docsPath: i8
  });
  const i = Ac(r),
    s = Nm(i);
  let o = "0x";
  if (n && n.length > 0) {
    if (!r.inputs) throw new $G(r.name, {
      docsPath: i8
    });
    o = Eu(r.inputs, n)
  }
  return xu([s, o])
}
const D7e = "/docs/contract/encodeFunctionResult";

function N7e({
  abi: e,
  functionName: t,
  result: n
}) {
  let r = e[0];
  if (t && (r = Hd({
      abi: e,
      name: t
    }), !r)) throw new mh(t, {
    docsPath: "/docs/contract/encodeFunctionResult"
  });
  if (r.type !== "function") throw new mh(void 0, {
    docsPath: "/docs/contract/encodeFunctionResult"
  });
  if (!r.outputs) throw new Zk(r.name, {
    docsPath: D7e
  });
  let i = Array.isArray(n) ? n : [n];
  return r.outputs.length === 0 && !i[0] && (i = []), Eu(r.outputs, i)
}

function M7e(e, t) {
  if (e.length !== t.length) throw new Jk({
    expectedLength: e.length,
    givenLength: t.length
  });
  const n = [];
  for (let r = 0; r < e.length; r++) {
    const i = e[r],
      s = t[r];
    n.push(sQ(i, s))
  }
  return xu(n)
}

function sQ(e, t, n = !1) {
  if (e === "address") {
    const o = t;
    if (!Hi(o)) throw new go({
      address: o
    });
    return bc(o.toLowerCase(), {
      size: n ? 32 : null
    })
  }
  if (e === "string") return py(t);
  if (e === "bytes") return t;
  if (e === "bool") return bc(x6(t), {
    size: n ? 32 : 1
  });
  const r = e.match(eQ);
  if (r) {
    const [o, a, c = "256"] = r, l = parseInt(c) / 8;
    return Ct(t, {
      size: n ? 32 : l,
      signed: a === "int"
    })
  }
  const i = e.match(ZK);
  if (i) {
    const [o, a] = i;
    if (parseInt(a) !== (t.length - 2) / 2) throw new e7({
      expectedSize: parseInt(a),
      givenSize: (t.length - 2) / 2
    });
    return bc(t, {
      dir: "right",
      size: n ? 32 : null
    })
  }
  const s = e.match(k7e);
  if (s && Array.isArray(t)) {
    const [o, a] = s, c = [];
    for (let l = 0; l < t.length; l++) c.push(sQ(a, t[l], !0));
    return c.length === 0 ? "0x" : xu(c)
  }
  throw new VG(e)
}

function NA(e) {
  return !e || typeof e != "object" || !("BYTES_PER_ELEMENT" in e) ? !1 : e.BYTES_PER_ELEMENT === 1 && e.constructor.name === "Uint8Array"
}
class S$ extends $e {
  constructor({
    offset: t
  }) {
    super(`Offset \`${t}\` cannot be negative.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "NegativeOffsetError"
    })
  }
}
class $7e extends $e {
  constructor({
    length: t,
    position: n
  }) {
    super(`Position \`${n}\` is out of bounds (\`0 < position < ${t}\`).`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "PositionOutOfBoundsError"
    })
  }
}
const L7e = {
  bytes: new Uint8Array,
  dataView: new DataView(new ArrayBuffer(0)),
  position: 0,
  assertPosition(e) {
    if (e < 0 || e > this.bytes.length - 1) throw new $7e({
      length: this.bytes.length,
      position: e
    })
  },
  decrementPosition(e) {
    if (e < 0) throw new S$({
      offset: e
    });
    const t = this.position - e;
    this.assertPosition(t), this.position = t
  },
  incrementPosition(e) {
    if (e < 0) throw new S$({
      offset: e
    });
    const t = this.position + e;
    this.assertPosition(t), this.position = t
  },
  inspectByte(e) {
    const t = e ?? this.position;
    return this.assertPosition(t), this.bytes[t]
  },
  inspectBytes(e, t) {
    const n = t ?? this.position;
    return this.assertPosition(n + e - 1), this.bytes.subarray(n, n + e)
  },
  inspectUint8(e) {
    const t = e ?? this.position;
    return this.assertPosition(t), this.bytes[t]
  },
  inspectUint16(e) {
    const t = e ?? this.position;
    return this.assertPosition(t + 1), this.dataView.getUint16(t)
  },
  inspectUint24(e) {
    const t = e ?? this.position;
    return this.assertPosition(t + 2), (this.dataView.getUint16(t) << 8) + this.dataView.getUint8(t + 2)
  },
  inspectUint32(e) {
    const t = e ?? this.position;
    return this.assertPosition(t + 3), this.dataView.getUint32(t)
  },
  pushByte(e) {
    this.assertPosition(this.position), this.bytes[this.position] = e, this.position++
  },
  pushBytes(e) {
    this.assertPosition(this.position + e.length - 1), this.bytes.set(e, this.position), this.position += e.length
  },
  pushUint8(e) {
    this.assertPosition(this.position), this.bytes[this.position] = e, this.position++
  },
  pushUint16(e) {
    this.assertPosition(this.position + 1), this.dataView.setUint16(this.position, e), this.position += 2
  },
  pushUint24(e) {
    this.assertPosition(this.position + 2), this.dataView.setUint16(this.position, e >> 8), this.dataView.setUint8(this.position + 2, e & 255), this.position += 3
  },
  pushUint32(e) {
    this.assertPosition(this.position + 3), this.dataView.setUint32(this.position, e), this.position += 4
  },
  readByte() {
    const e = this.inspectByte();
    return this.position++, e
  },
  readBytes(e) {
    const t = this.inspectBytes(e);
    return this.position += e, t
  },
  readUint8() {
    const e = this.inspectUint8();
    return this.position += 1, e
  },
  readUint16() {
    const e = this.inspectUint16();
    return this.position += 2, e
  },
  readUint24() {
    const e = this.inspectUint24();
    return this.position += 3, e
  },
  readUint32() {
    const e = this.inspectUint32();
    return this.position += 4, e
  },
  setPosition(e) {
    this.assertPosition(e), this.position = e
  }
};

function oQ(e) {
  const t = Object.create(L7e);
  return t.bytes = e, t.dataView = new DataView(e.buffer, e.byteOffset, e.byteLength), t
}

function Bh(e, t = "hex") {
  const n = aQ(e),
    r = oQ(new Uint8Array(n.length));
  return n.encode(r), t === "hex" ? mo(r.bytes) : r.bytes
}

function B7e(e, t = "bytes") {
  return Bh(e, t)
}

function F7e(e, t = "hex") {
  return Bh(e, t)
}

function aQ(e) {
  return Array.isArray(e) ? j7e(e.map(t => aQ(t))) : U7e(e)
}

function j7e(e) {
  const t = e.reduce((i, s) => i + s.length, 0),
    n = cQ(t);
  return {
    length: t <= 55 ? 1 + t : 1 + n + t,
    encode(i) {
      t <= 55 ? i.pushByte(192 + t) : (i.pushByte(247 + n), n === 1 ? i.pushUint8(t) : n === 2 ? i.pushUint16(t) : n === 3 ? i.pushUint24(t) : i.pushUint32(t));
      for (const {
          encode: s
        } of e) s(i)
    }
  }
}

function U7e(e) {
  const t = typeof e == "string" ? wu(e) : e,
    n = cQ(t.length);
  return {
    length: t.length === 1 && t[0] < 128 ? 1 : t.length <= 55 ? 1 + t.length : 1 + n + t.length,
    encode(i) {
      t.length === 1 && t[0] < 128 ? i.pushBytes(t) : t.length <= 55 ? (i.pushByte(128 + t.length), i.pushBytes(t)) : (i.pushByte(183 + n), n === 1 ? i.pushUint8(t.length) : n === 2 ? i.pushUint16(t.length) : n === 3 ? i.pushUint24(t.length) : i.pushUint32(t.length), i.pushBytes(t))
    }
  }
}

function cQ(e) {
  if (e < 2 ** 8) return 1;
  if (e < 2 ** 16) return 2;
  if (e < 2 ** 24) return 3;
  if (e < 2 ** 32) return 4;
  throw new $e("Length is too large.")
}

function z7e(e) {
  return e.opcode === "CREATE2" ? uQ(e) : lQ(e)
}

function lQ(e) {
  const t = Bi(kd(e.from));
  let n = Bi(e.nonce);
  return n[0] === 0 && (n = new Uint8Array([])), kd(`0x${ii(Bh([t,n],"bytes")).slice(26)}`)
}

function uQ(e) {
  const t = Bi(kd(e.from)),
    n = bc(NA(e.salt) ? e.salt : Bi(e.salt), {
      size: 32
    }),
    r = "bytecodeHash" in e ? NA(e.bytecodeHash) ? e.bytecodeHash : Bi(e.bytecodeHash) : ii(e.bytecode, "bytes");
  return kd(Sr(ii(Da([Bi("0xff"), t, n, r])), 12))
}
const H7e = {
  "0x0": "reverted",
  "0x1": "success"
};

function V7(e) {
  return {
    ...e,
    blockNumber: e.blockNumber ? BigInt(e.blockNumber) : null,
    contractAddress: e.contractAddress ? e.contractAddress : null,
    cumulativeGasUsed: e.cumulativeGasUsed ? BigInt(e.cumulativeGasUsed) : null,
    effectiveGasPrice: e.effectiveGasPrice ? BigInt(e.effectiveGasPrice) : null,
    gasUsed: e.gasUsed ? BigInt(e.gasUsed) : null,
    logs: e.logs ? e.logs.map(t => Na(t)) : null,
    to: e.to ? e.to : null,
    transactionIndex: e.transactionIndex ? Xn(e.transactionIndex) : null,
    status: e.status ? H7e[e.status] : null,
    type: e.type ? S7[e.type] || e.type : null
  }
}
const dQ = R6("transactionReceipt", V7);

function V7e(e, t) {
  const n = typeof t == "string" ? {
      to: t
    } : t,
    r = n.to;
  return r === "number" ? hQ(e, n) : r === "bigint" ? MA(e, n) : r === "boolean" ? fQ(e, n) : r === "string" ? pQ(e, n) : mo(e, n)
}

function MA(e, t = {}) {
  typeof t.size < "u" && za(e, {
    size: t.size
  });
  const n = mo(e, t);
  return Jn(n)
}

function fQ(e, t = {}) {
  let n = e;
  if (typeof t.size < "u" && (za(n, {
      size: t.size
    }), n = lo(n)), n.length > 1 || n[0] > 1) throw new KG(n);
  return !!n[0]
}

function hQ(e, t = {}) {
  typeof t.size < "u" && za(e, {
    size: t.size
  });
  const n = mo(e, t);
  return Xn(n)
}

function pQ(e, t = {}) {
  let n = e;
  return typeof t.size < "u" && (za(n, {
    size: t.size
  }), n = lo(n, {
    dir: "right"
  })), new TextDecoder().decode(n)
}

function W7(e, t = "hex") {
  const n = (() => {
      if (typeof e == "string") {
        if (e.length > 3 && e.length % 2 !== 0) throw new YG(e);
        return wu(e)
      }
      return e
    })(),
    r = oQ(n);
  return mQ(r, t)
}

function mQ(e, t = "hex") {
  if (e.bytes.length === 0) return t === "hex" ? mo(e.bytes) : e.bytes;
  const n = e.readByte();
  if (n < 128 && e.decrementPosition(1), n < 192) {
    const i = C$(e, n, 128),
      s = e.readBytes(i);
    return t === "hex" ? mo(s) : s
  }
  const r = C$(e, n, 192);
  return W7e(e, r, t)
}

function C$(e, t, n) {
  if (n === 128 && t < 128) return 1;
  if (t <= n + 55) return t - n;
  if (t === n + 55 + 1) return e.readUint8();
  if (t === n + 55 + 2) return e.readUint16();
  if (t === n + 55 + 3) return e.readUint24();
  if (t === n + 55 + 4) return e.readUint32();
  throw new $e("Invalid RLP prefix")
}

function W7e(e, t, n) {
  const r = e.position,
    i = [];
  for (; e.position - r < t;) i.push(mQ(e, n));
  return i
}

function gQ(e) {
  return hn(e) && Qr(e) === 32
}

function q7e(e, t, n, r) {
  if (typeof e.setBigUint64 == "function") return e.setBigUint64(t, n, r);
  const i = BigInt(32),
    s = BigInt(4294967295),
    o = Number(n >> i & s),
    a = Number(n & s),
    c = r ? 4 : 0,
    l = r ? 0 : 4;
  e.setUint32(t + c, o, r), e.setUint32(t + l, a, r)
}
class yQ extends o7 {
  constructor(t, n, r, i) {
    super(), this.blockLen = t, this.outputLen = n, this.padOffset = r, this.isLE = i, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(t), this.view = YS(this.buffer)
  }
  update(t) {
    jp(this);
    const {
      view: n,
      buffer: r,
      blockLen: i
    } = this;
    t = E6(t);
    const s = t.length;
    for (let o = 0; o < s;) {
      const a = Math.min(i - this.pos, s - o);
      if (a === i) {
        const c = YS(t);
        for (; i <= s - o; o += i) this.process(c, o);
        continue
      }
      r.set(t.subarray(o, o + a), this.pos), this.pos += a, o += a, this.pos === i && (this.process(n, 0), this.pos = 0)
    }
    return this.length += t.length, this.roundClean(), this
  }
  digestInto(t) {
    jp(this), tK(t, this), this.finished = !0;
    const {
      buffer: n,
      view: r,
      blockLen: i,
      isLE: s
    } = this;
    let {
      pos: o
    } = this;
    n[o++] = 128, this.buffer.subarray(o).fill(0), this.padOffset > i - o && (this.process(r, 0), o = 0);
    for (let f = o; f < i; f++) n[f] = 0;
    q7e(r, i - 8, BigInt(this.length * 8), s), this.process(r, 0);
    const a = YS(t),
      c = this.outputLen;
    if (c % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
    const l = c / 4,
      u = this.get();
    if (l > u.length) throw new Error("_sha2: outputLen bigger than state");
    for (let f = 0; f < l; f++) a.setUint32(4 * f, u[f], s)
  }
  digest() {
    const {
      buffer: t,
      outputLen: n
    } = this;
    this.digestInto(t);
    const r = t.slice(0, n);
    return this.destroy(), r
  }
  _cloneInto(t) {
    t || (t = new this.constructor), t.set(...this.get());
    const {
      blockLen: n,
      buffer: r,
      length: i,
      finished: s,
      destroyed: o,
      pos: a
    } = this;
    return t.length = i, t.pos = a, t.finished = s, t.destroyed = o, i % n && t.buffer.set(r), t
  }
}
const G7e = (e, t, n) => e & t ^ ~e & n,
  K7e = (e, t, n) => e & t ^ e & n ^ t & n,
  Q7e = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]),
  Gu = new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]),
  Ku = new Uint32Array(64);
class Y7e extends yQ {
  constructor() {
    super(64, 32, 8, !1), this.A = Gu[0] | 0, this.B = Gu[1] | 0, this.C = Gu[2] | 0, this.D = Gu[3] | 0, this.E = Gu[4] | 0, this.F = Gu[5] | 0, this.G = Gu[6] | 0, this.H = Gu[7] | 0
  }
  get() {
    const {
      A: t,
      B: n,
      C: r,
      D: i,
      E: s,
      F: o,
      G: a,
      H: c
    } = this;
    return [t, n, r, i, s, o, a, c]
  }
  set(t, n, r, i, s, o, a, c) {
    this.A = t | 0, this.B = n | 0, this.C = r | 0, this.D = i | 0, this.E = s | 0, this.F = o | 0, this.G = a | 0, this.H = c | 0
  }
  process(t, n) {
    for (let f = 0; f < 16; f++, n += 4) Ku[f] = t.getUint32(n, !1);
    for (let f = 16; f < 64; f++) {
      const h = Ku[f - 15],
        g = Ku[f - 2],
        y = Lc(h, 7) ^ Lc(h, 18) ^ h >>> 3,
        x = Lc(g, 17) ^ Lc(g, 19) ^ g >>> 10;
      Ku[f] = x + Ku[f - 7] + y + Ku[f - 16] | 0
    }
    let {
      A: r,
      B: i,
      C: s,
      D: o,
      E: a,
      F: c,
      G: l,
      H: u
    } = this;
    for (let f = 0; f < 64; f++) {
      const h = Lc(a, 6) ^ Lc(a, 11) ^ Lc(a, 25),
        g = u + h + G7e(a, c, l) + Q7e[f] + Ku[f] | 0,
        x = (Lc(r, 2) ^ Lc(r, 13) ^ Lc(r, 22)) + K7e(r, i, s) | 0;
      u = l, l = c, c = a, a = o + g | 0, o = s, s = i, i = r, r = g + x | 0
    }
    r = r + this.A | 0, i = i + this.B | 0, s = s + this.C | 0, o = o + this.D | 0, a = a + this.E | 0, c = c + this.F | 0, l = l + this.G | 0, u = u + this.H | 0, this.set(r, i, s, o, a, c, l, u)
  }
  roundClean() {
    Ku.fill(0)
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0)
  }
}
const y2 = a7(() => new Y7e);

function J7e(e, t) {
  const n = t || "hex",
    r = y2(hn(e, {
      strict: !1
    }) ? Bi(e) : e);
  return n === "bytes" ? r : yn(r)
}
const X7e = new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]),
  vQ = Uint8Array.from({
    length: 16
  }, (e, t) => t),
  Z7e = vQ.map(e => (9 * e + 5) % 16);
let q7 = [vQ],
  G7 = [Z7e];
for (let e = 0; e < 4; e++)
  for (let t of [q7, G7]) t.push(t[e].map(n => X7e[n]));
const bQ = [
    [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
    [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
    [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
    [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
    [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
  ].map(e => new Uint8Array(e)),
  e_e = q7.map((e, t) => e.map(n => bQ[t][n])),
  t_e = G7.map((e, t) => e.map(n => bQ[t][n])),
  n_e = new Uint32Array([0, 1518500249, 1859775393, 2400959708, 2840853838]),
  r_e = new Uint32Array([1352829926, 1548603684, 1836072691, 2053994217, 0]),
  Ob = (e, t) => e << t | e >>> 32 - t;

function A$(e, t, n, r) {
  return e === 0 ? t ^ n ^ r : e === 1 ? t & n | ~t & r : e === 2 ? (t | ~n) ^ r : e === 3 ? t & r | n & ~r : t ^ (n | ~r)
}
const Db = new Uint32Array(16);
class i_e extends yQ {
  constructor() {
    super(64, 20, 8, !0), this.h0 = 1732584193, this.h1 = -271733879, this.h2 = -1732584194, this.h3 = 271733878, this.h4 = -1009589776
  }
  get() {
    const {
      h0: t,
      h1: n,
      h2: r,
      h3: i,
      h4: s
    } = this;
    return [t, n, r, i, s]
  }
  set(t, n, r, i, s) {
    this.h0 = t | 0, this.h1 = n | 0, this.h2 = r | 0, this.h3 = i | 0, this.h4 = s | 0
  }
  process(t, n) {
    for (let g = 0; g < 16; g++, n += 4) Db[g] = t.getUint32(n, !0);
    let r = this.h0 | 0,
      i = r,
      s = this.h1 | 0,
      o = s,
      a = this.h2 | 0,
      c = a,
      l = this.h3 | 0,
      u = l,
      f = this.h4 | 0,
      h = f;
    for (let g = 0; g < 5; g++) {
      const y = 4 - g,
        x = n_e[g],
        k = r_e[g],
        _ = q7[g],
        p = G7[g],
        v = e_e[g],
        S = t_e[g];
      for (let I = 0; I < 16; I++) {
        const A = Ob(r + A$(g, s, a, l) + Db[_[I]] + x, v[I]) + f | 0;
        r = f, f = l, l = Ob(a, 10) | 0, a = s, s = A
      }
      for (let I = 0; I < 16; I++) {
        const A = Ob(i + A$(y, o, c, u) + Db[p[I]] + k, S[I]) + h | 0;
        i = h, h = u, u = Ob(c, 10) | 0, c = o, o = A
      }
    }
    this.set(this.h1 + a + u | 0, this.h2 + l + h | 0, this.h3 + f + i | 0, this.h4 + r + o | 0, this.h0 + s + c | 0)
  }
  roundClean() {
    Db.fill(0)
  }
  destroy() {
    this.destroyed = !0, this.buffer.fill(0), this.set(0, 0, 0, 0, 0)
  }
}
const s_e = a7(() => new i_e);

function o_e(e, t) {
  const n = t || "hex",
    r = s_e(hn(e, {
      strict: !1
    }) ? Bi(e) : e);
  return n === "bytes" ? r : yn(r)
}
async function wQ({
  hash: e,
  signature: t
}) {
  const n = hn(t) ? t : yn(t),
    r = hn(e) ? e : yn(e);
  let i = Xn(`0x${n.slice(130)}`);
  (i === 0 || i === 1) && (i += 27);
  const {
    secp256k1: s
  } = await I7(() => Promise.resolve().then(() => sOe), void 0);
  return `0x${s.Signature.fromCompact(n.substring(2,130)).addRecoveryBit(i-27).recoverPublicKey(r.substring(2)).toHex(!1)}`
}
async function K7({
  hash: e,
  signature: t
}) {
  return Hke(await wQ({
    hash: e,
    signature: t
  }))
}
const xQ = `Ethereum Signed Message:
`;

function Q7(e, t) {
  const n = typeof e == "string" ? ul(e) : e.raw instanceof Uint8Array ? e.raw : Bi(e.raw),
    r = ul(`${xQ}${n.length}`);
  return ii(Da([r, n]), t)
}
async function EQ({
  message: e,
  signature: t
}) {
  return K7({
    hash: Q7(e),
    signature: t
  })
}
async function SQ({
  domain: e,
  message: t,
  primaryType: n,
  signature: r,
  types: i
}) {
  return K7({
    hash: j7({
      domain: e,
      message: t,
      primaryType: n,
      types: i
    }),
    signature: r
  })
}
async function a_e({
  address: e,
  message: t,
  signature: n
}) {
  return U6(kd(e), await EQ({
    message: t,
    signature: n
  }))
}
async function c_e({
  address: e,
  domain: t,
  message: n,
  primaryType: r,
  signature: i,
  types: s
}) {
  return U6(kd(e), await SQ({
    domain: t,
    message: n,
    primaryType: r,
    signature: i,
    types: s
  }))
}

function CQ(e) {
  const t = l7(e, 0, 1);
  if (t === "0x02") return "eip1559";
  if (t === "0x01") return "eip2930";
  if (t !== "0x" && Xn(t) >= 192) return "legacy";
  throw new gK({
    serializedType: t
  })
}

function Y7(e) {
  const {
    chainId: t,
    maxPriorityFeePerGas: n,
    gasPrice: r,
    maxFeePerGas: i,
    to: s
  } = e;
  if (t <= 0) throw new M6({
    chainId: t
  });
  if (s && !Hi(s)) throw new go({
    address: s
  });
  if (r) throw new $e("`gasPrice` is not a valid EIP-1559 Transaction attribute.");
  if (i && i > 2n ** 256n - 1n) throw new Id({
    maxFeePerGas: i
  });
  if (n && i && n > i) throw new nm({
    maxFeePerGas: i,
    maxPriorityFeePerGas: n
  })
}

function J7(e) {
  const {
    chainId: t,
    maxPriorityFeePerGas: n,
    gasPrice: r,
    maxFeePerGas: i,
    to: s
  } = e;
  if (t <= 0) throw new M6({
    chainId: t
  });
  if (s && !Hi(s)) throw new go({
    address: s
  });
  if (n || i) throw new $e("`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid EIP-2930 Transaction attribute.");
  if (r && r > 2n ** 256n - 1n) throw new Id({
    maxFeePerGas: r
  })
}

function X7(e) {
  const {
    chainId: t,
    maxPriorityFeePerGas: n,
    gasPrice: r,
    maxFeePerGas: i,
    to: s,
    accessList: o
  } = e;
  if (s && !Hi(s)) throw new go({
    address: s
  });
  if (typeof t < "u" && t <= 0) throw new M6({
    chainId: t
  });
  if (n || i) throw new $e("`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid Legacy Transaction attribute.");
  if (r && r > 2n ** 256n - 1n) throw new Id({
    maxFeePerGas: r
  });
  if (o) throw new $e("`accessList` is not a valid Legacy Transaction attribute.")
}

function l_e(e) {
  const t = CQ(e);
  return t === "eip1559" ? u_e(e) : t === "eip2930" ? d_e(e) : f_e(e)
}

function u_e(e) {
  const t = AQ(e),
    [n, r, i, s, o, a, c, l, u, f, h, g] = t;
  if (!(t.length === 9 || t.length === 12)) throw new k6({
    attributes: {
      chainId: n,
      nonce: r,
      maxPriorityFeePerGas: i,
      maxFeePerGas: s,
      gas: o,
      to: a,
      value: c,
      data: l,
      accessList: u,
      ...t.length > 9 ? {
        v: f,
        r: h,
        s: g
      } : {}
    },
    serializedTransaction: e,
    type: "eip1559"
  });
  const y = {
    chainId: Xn(n),
    type: "eip1559"
  };
  return hn(a) && a !== "0x" && (y.to = a), hn(o) && o !== "0x" && (y.gas = Jn(o)), hn(l) && l !== "0x" && (y.data = l), hn(r) && r !== "0x" && (y.nonce = Xn(r)), hn(c) && c !== "0x" && (y.value = Jn(c)), hn(s) && s !== "0x" && (y.maxFeePerGas = Jn(s)), hn(i) && i !== "0x" && (y.maxPriorityFeePerGas = Jn(i)), u.length !== 0 && u !== "0x" && (y.accessList = TQ(u)), Y7(y), {
    ...t.length === 12 ? kQ(t) : void 0,
    ...y
  }
}

function d_e(e) {
  const t = AQ(e),
    [n, r, i, s, o, a, c, l, u, f, h] = t;
  if (!(t.length === 8 || t.length === 11)) throw new k6({
    attributes: {
      chainId: n,
      nonce: r,
      gasPrice: i,
      gas: s,
      to: o,
      value: a,
      data: c,
      accessList: l,
      ...t.length > 8 ? {
        v: u,
        r: f,
        s: h
      } : {}
    },
    serializedTransaction: e,
    type: "eip2930"
  });
  const g = {
    chainId: Xn(n),
    type: "eip2930"
  };
  return hn(o) && o !== "0x" && (g.to = o), hn(s) && s !== "0x" && (g.gas = Jn(s)), hn(c) && c !== "0x" && (g.data = c), hn(r) && r !== "0x" && (g.nonce = Xn(r)), hn(a) && a !== "0x" && (g.value = Jn(a)), hn(i) && i !== "0x" && (g.gasPrice = Jn(i)), l.length !== 0 && l !== "0x" && (g.accessList = TQ(l)), J7(g), {
    ...t.length === 11 ? kQ(t) : void 0,
    ...g
  }
}

function f_e(e) {
  const t = W7(e, "hex"),
    [n, r, i, s, o, a, c, l, u] = t;
  if (!(t.length === 6 || t.length === 9)) throw new k6({
    attributes: {
      nonce: n,
      gasPrice: r,
      gas: i,
      to: s,
      value: o,
      data: a,
      ...t.length > 6 ? {
        v: c,
        r: l,
        s: u
      } : {}
    },
    serializedTransaction: e,
    type: "legacy"
  });
  const f = {
    type: "legacy"
  };
  if (hn(s) && s !== "0x" && (f.to = s), hn(i) && i !== "0x" && (f.gas = Jn(i)), hn(a) && a !== "0x" && (f.data = a), hn(n) && n !== "0x" && (f.nonce = Xn(n)), hn(o) && o !== "0x" && (f.value = Jn(o)), hn(r) && r !== "0x" && (f.gasPrice = Jn(r)), X7(f), t.length === 6) return f;
  const h = hn(c) && c !== "0x" ? Jn(c) : 0n;
  if (u === "0x" && l === "0x") return h > 0 && (f.chainId = Number(h)), f;
  const g = h,
    y = Number((g - 35n) / 2n);
  if (y > 0) f.chainId = y;
  else if (g !== 27n && g !== 28n) throw new y7({
    v: g
  });
  return f.v = g, f.s = u, f.r = l, f
}

function AQ(e) {
  return W7(`0x${e.slice(4)}`, "hex")
}

function TQ(e) {
  const t = [];
  for (let n = 0; n < e.length; n++) {
    const [r, i] = e[n];
    if (!Hi(r)) throw new go({
      address: r
    });
    t.push({
      address: r,
      storageKeys: i.map(s => gQ(s) ? s : lo(s))
    })
  }
  return t
}

function kQ(e) {
  const t = e.slice(-3),
    n = t[0] === "0x" || Jn(t[0]) === 0n ? 27n : 28n;
  return {
    r: wc(t[1], {
      size: 32
    }),
    s: wc(t[2], {
      size: 32
    }),
    v: n,
    yParity: n === 27n ? 0 : 1
  }
}

function Z7(e) {
  if (!e || e.length === 0) return [];
  const t = [];
  for (let n = 0; n < e.length; n++) {
    const {
      address: r,
      storageKeys: i
    } = e[n];
    for (let s = 0; s < i.length; s++)
      if (i[s].length - 2 !== 64) throw new yK({
        storageKey: i[s]
      });
    if (!Hi(r)) throw new go({
      address: r
    });
    t.push([r, i])
  }
  return t
}

function h_e(e, t) {
  const n = A7(e);
  return n === "eip1559" ? p_e(e, t) : n === "eip2930" ? m_e(e, t) : g_e(e, t)
}

function p_e(e, t) {
  const {
    chainId: n,
    gas: r,
    nonce: i,
    to: s,
    value: o,
    maxFeePerGas: a,
    maxPriorityFeePerGas: c,
    accessList: l,
    data: u
  } = e;
  Y7(e);
  const f = Z7(l),
    h = [yn(n), i ? yn(i) : "0x", c ? yn(c) : "0x", a ? yn(a) : "0x", r ? yn(r) : "0x", s ?? "0x", o ? yn(o) : "0x", u ?? "0x", f];
  if (t) {
    const g = t.v === 0n ? "0x" : t.v === 1n ? yn(1) : t.v === 27n ? "0x" : yn(1);
    h.push(g, lo(t.r), lo(t.s))
  }
  return xu(["0x02", Bh(h)])
}

function m_e(e, t) {
  const {
    chainId: n,
    gas: r,
    data: i,
    nonce: s,
    to: o,
    value: a,
    accessList: c,
    gasPrice: l
  } = e;
  J7(e);
  const u = Z7(c),
    f = [yn(n), s ? yn(s) : "0x", l ? yn(l) : "0x", r ? yn(r) : "0x", o ?? "0x", a ? yn(a) : "0x", i ?? "0x", u];
  if (t) {
    const h = t.v === 0n ? "0x" : t.v === 1n ? yn(1) : t.v === 27n ? "0x" : yn(1);
    f.push(h, lo(t.r), lo(t.s))
  }
  return xu(["0x01", Bh(f)])
}

function g_e(e, t) {
  const {
    chainId: n = 0,
    gas: r,
    data: i,
    nonce: s,
    to: o,
    value: a,
    gasPrice: c
  } = e;
  X7(e);
  let l = [s ? yn(s) : "0x", c ? yn(c) : "0x", r ? yn(r) : "0x", o ?? "0x", a ? yn(a) : "0x", i ?? "0x"];
  if (t) {
    const u = (() => {
      if (n > 0) return BigInt(n * 2) + BigInt(35n + t.v - 27n);
      if (t.v >= 35n) return (t.v - 35n) / 2n > 0 ? t.v : 27n + (t.v === 35n ? 0n : 1n);
      const f = 27n + (t.v === 27n ? 0n : 1n);
      if (t.v !== f) throw new y7({
        v: t.v
      });
      return f
    })();
    l = [...l, yn(u), t.r, t.s]
  } else n > 0 && (l = [...l, yn(n), "0x", "0x"]);
  return Bh(l)
}

function e_(e, t) {
  let [n, r = "0"] = e.split(".");
  const i = n.startsWith("-");
  if (i && (n = n.slice(1)), r = r.replace(/(0+)$/, ""), t === 0) Math.round(+`.${r}`) === 1 && (n = `${BigInt(n)+1n}`), r = "";
  else if (r.length > t) {
    const [s, o, a] = [r.slice(0, t - 1), r.slice(t - 1, t), r.slice(t)], c = Math.round(+`${o}.${a}`);
    c > 9 ? r = `${BigInt(s)+BigInt(1)}0`.padStart(s.length + 1, "0") : r = `${s}${c}`, r.length > t && (r = r.slice(1), n = `${BigInt(n)+1n}`), r = r.slice(0, t)
  } else r = r.padEnd(t, "0");
  return BigInt(`${i?"-":""}${n}${r}`)
}

function y_e(e, t = "wei") {
  return e_(e, p7[t])
}

function v_e(e, t = "wei") {
  return e_(e, m7[t])
}

function b_e(e) {
  return e.map(t => ({
    ...t,
    value: BigInt(t.value)
  }))
}

function w_e(e) {
  return {
    ...e,
    balance: e.balance ? BigInt(e.balance) : void 0,
    nonce: e.nonce ? Xn(e.nonce) : void 0,
    storageProof: e.storageProof ? b_e(e.storageProof) : void 0
  }
}
async function x_e(e, {
  address: t,
  blockNumber: n,
  blockTag: r,
  storageKeys: i
}) {
  const s = r ?? "latest",
    o = n !== void 0 ? Ct(n) : void 0,
    a = await e.request({
      method: "eth_getProof",
      params: [t, i, o || s]
    });
  return w_e(a)
}
async function E_e(e, {
  address: t,
  blockNumber: n,
  blockTag: r = "latest",
  slot: i
}) {
  const s = n !== void 0 ? Ct(n) : void 0;
  return await e.request({
    method: "eth_getStorageAt",
    params: [t, i, s || r]
  })
}
async function t_(e, {
  blockHash: t,
  blockNumber: n,
  blockTag: r,
  hash: i,
  index: s
}) {
  var u, f, h;
  const o = r || "latest",
    a = n !== void 0 ? Ct(n) : void 0;
  let c = null;
  if (i ? c = await e.request({
      method: "eth_getTransactionByHash",
      params: [i]
    }) : t ? c = await e.request({
      method: "eth_getTransactionByBlockHashAndIndex",
      params: [t, Ct(s)]
    }) : (a || o) && (c = await e.request({
      method: "eth_getTransactionByBlockNumberAndIndex",
      params: [a || o, Ct(s)]
    })), !c) throw new v7({
    blockHash: t,
    blockNumber: n,
    blockTag: o,
    hash: i,
    index: s
  });
  return (((h = (f = (u = e.chain) == null ? void 0 : u.formatters) == null ? void 0 : f.transaction) == null ? void 0 : h.format) || vy)(c)
}
async function S_e(e, {
  hash: t,
  transactionReceipt: n
}) {
  const [r, i] = await Promise.all([Tt(e, xy, "getBlockNumber")({}), t ? Tt(e, t_, "getBlockNumber")({
    hash: t
  }) : void 0]), s = (n == null ? void 0 : n.blockNumber) || (i == null ? void 0 : i.blockNumber);
  return s ? r - s + 1n : 0n
}
async function $A(e, {
  hash: t
}) {
  var i, s, o;
  const n = await e.request({
    method: "eth_getTransactionReceipt",
    params: [t]
  });
  if (!n) throw new b7({
    hash: t
  });
  return (((o = (s = (i = e.chain) == null ? void 0 : i.formatters) == null ? void 0 : s.transactionReceipt) == null ? void 0 : o.format) || V7)(n)
}
async function C_e(e, t) {
  var x;
  const {
    allowFailure: n = !0,
    batchSize: r,
    blockNumber: i,
    blockTag: s,
    contracts: o,
    multicallAddress: a
  } = t, c = r ?? (typeof ((x = e.batch) == null ? void 0 : x.multicall) == "object" && e.batch.multicall.batchSize || 1024);
  let l = a;
  if (!l) {
    if (!e.chain) throw new Error("client chain not configured. multicallAddress is required.");
    l = Lh({
      blockNumber: i,
      chain: e.chain,
      contract: "multicall3"
    })
  }
  const u = [
    []
  ];
  let f = 0,
    h = 0;
  for (let k = 0; k < o.length; k++) {
    const {
      abi: _,
      address: p,
      args: v,
      functionName: S
    } = o[k];
    try {
      const I = Su({
        abi: _,
        args: v,
        functionName: S
      });
      h += (I.length - 2) / 2, c > 0 && h > c && u[f].length > 0 && (f++, h = (I.length - 2) / 2, u[f] = []), u[f] = [...u[f], {
        allowFailure: !0,
        callData: I,
        target: p
      }]
    } catch (I) {
      const A = tm(I, {
        abi: _,
        address: p,
        args: v,
        docsPath: "/docs/contract/multicall",
        functionName: S
      });
      if (!n) throw A;
      u[f] = [...u[f], {
        allowFailure: !0,
        callData: "0x",
        target: p
      }]
    }
  }
  const g = await Promise.allSettled(u.map(k => Tt(e, hu, "readContract")({
      abi: rx,
      address: l,
      args: [k],
      blockNumber: i,
      blockTag: s,
      functionName: "aggregate3"
    }))),
    y = [];
  for (let k = 0; k < g.length; k++) {
    const _ = g[k];
    if (_.status === "rejected") {
      if (!n) throw _.reason;
      for (let v = 0; v < u[k].length; v++) y.push({
        status: "failure",
        error: _.reason,
        result: void 0
      });
      continue
    }
    const p = _.value;
    for (let v = 0; v < p.length; v++) {
      const {
        returnData: S,
        success: I
      } = p[v], {
        callData: A
      } = u[k][v], {
        abi: w,
        address: E,
        functionName: D,
        args: $
      } = o[y.length];
      try {
        if (A === "0x") throw new hy;
        if (!I) throw new _6({
          data: S
        });
        const V = $h({
          abi: w,
          args: $,
          data: S,
          functionName: D
        });
        y.push(n ? {
          result: V,
          status: "success"
        } : V)
      } catch (V) {
        const G = tm(V, {
          abi: w,
          address: E,
          args: $,
          docsPath: "/docs/contract/multicall",
          functionName: D
        });
        if (!n) throw G;
        y.push({
          error: G,
          result: void 0,
          status: "failure"
        })
      }
    }
  }
  if (y.length !== o.length) throw new $e("multicall results mismatch");
  return y
}
const A_e = "0x60806040523480156200001157600080fd5b50604051620007003803806200070083398101604081905262000034916200056f565b6000620000438484846200004f565b9050806000526001601ff35b600080846001600160a01b0316803b806020016040519081016040528181526000908060200190933c90507f6492649264926492649264926492649264926492649264926492649264926492620000a68462000451565b036200021f57600060608085806020019051810190620000c79190620005ce565b8651929550909350915060000362000192576000836001600160a01b031683604051620000f5919062000643565b6000604051808303816000865af19150503d806000811462000134576040519150601f19603f3d011682016040523d82523d6000602084013e62000139565b606091505b5050905080620001905760405162461bcd60e51b815260206004820152601e60248201527f5369676e617475726556616c696461746f723a206465706c6f796d656e74000060448201526064015b60405180910390fd5b505b604051630b135d3f60e11b808252906001600160a01b038a1690631626ba7e90620001c4908b90869060040162000661565b602060405180830381865afa158015620001e2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200020891906200069d565b6001600160e01b031916149450505050506200044a565b805115620002b157604051630b135d3f60e11b808252906001600160a01b03871690631626ba7e9062000259908890889060040162000661565b602060405180830381865afa15801562000277573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200029d91906200069d565b6001600160e01b031916149150506200044a565b8251604114620003195760405162461bcd60e51b815260206004820152603a6024820152600080516020620006e083398151915260448201527f3a20696e76616c6964207369676e6174757265206c656e677468000000000000606482015260840162000187565b620003236200046b565b506020830151604080850151855186939260009185919081106200034b576200034b620006c9565b016020015160f81c9050601b81148015906200036b57508060ff16601c14155b15620003cf5760405162461bcd60e51b815260206004820152603b6024820152600080516020620006e083398151915260448201527f3a20696e76616c6964207369676e617475726520762076616c75650000000000606482015260840162000187565b6040805160008152602081018083528a905260ff83169181019190915260608101849052608081018390526001600160a01b038a169060019060a0016020604051602081039080840390855afa1580156200042e573d6000803e3d6000fd5b505050602060405103516001600160a01b031614955050505050505b9392505050565b60006020825110156200046357600080fd5b508051015190565b60405180606001604052806003906020820280368337509192915050565b6001600160a01b03811681146200049f57600080fd5b50565b634e487b7160e01b600052604160045260246000fd5b60005b83811015620004d5578181015183820152602001620004bb565b50506000910152565b600082601f830112620004f057600080fd5b81516001600160401b03808211156200050d576200050d620004a2565b604051601f8301601f19908116603f01168101908282118183101715620005385762000538620004a2565b816040528381528660208588010111156200055257600080fd5b62000565846020830160208901620004b8565b9695505050505050565b6000806000606084860312156200058557600080fd5b8351620005928162000489565b6020850151604086015191945092506001600160401b03811115620005b657600080fd5b620005c486828701620004de565b9150509250925092565b600080600060608486031215620005e457600080fd5b8351620005f18162000489565b60208501519093506001600160401b03808211156200060f57600080fd5b6200061d87838801620004de565b935060408601519150808211156200063457600080fd5b50620005c486828701620004de565b6000825162000657818460208701620004b8565b9190910192915050565b828152604060208201526000825180604084015262000688816060850160208701620004b8565b601f01601f1916919091016060019392505050565b600060208284031215620006b057600080fd5b81516001600160e01b0319811681146200044a57600080fd5b634e487b7160e01b600052603260045260246000fdfe5369676e617475726556616c696461746f72237265636f7665725369676e6572"; /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _Q = BigInt(0),
  H6 = BigInt(1),
  T_e = BigInt(2),
  V6 = e => e instanceof Uint8Array,
  k_e = Array.from({
    length: 256
  }, (e, t) => t.toString(16).padStart(2, "0"));

function rm(e) {
  if (!V6(e)) throw new Error("Uint8Array expected");
  let t = "";
  for (let n = 0; n < e.length; n++) t += k_e[e[n]];
  return t
}

function IQ(e) {
  const t = e.toString(16);
  return t.length & 1 ? `0${t}` : t
}

function n_(e) {
  if (typeof e != "string") throw new Error("hex string expected, got " + typeof e);
  return BigInt(e === "" ? "0" : `0x${e}`)
}

function im(e) {
  if (typeof e != "string") throw new Error("hex string expected, got " + typeof e);
  const t = e.length;
  if (t % 2) throw new Error("padded hex string expected, got unpadded hex of length " + t);
  const n = new Uint8Array(t / 2);
  for (let r = 0; r < n.length; r++) {
    const i = r * 2,
      s = e.slice(i, i + 2),
      o = Number.parseInt(s, 16);
    if (Number.isNaN(o) || o < 0) throw new Error("Invalid byte sequence");
    n[r] = o
  }
  return n
}

function Ps(e) {
  return n_(rm(e))
}

function r_(e) {
  if (!V6(e)) throw new Error("Uint8Array expected");
  return n_(rm(Uint8Array.from(e).reverse()))
}

function Rd(e, t) {
  return im(e.toString(16).padStart(t * 2, "0"))
}

function i_(e, t) {
  return Rd(e, t).reverse()
}

function __e(e) {
  return im(IQ(e))
}

function ns(e, t, n) {
  let r;
  if (typeof t == "string") try {
      r = im(t)
    } catch (s) {
      throw new Error(`${e} must be valid hex string, got "${t}". Cause: ${s}`)
    } else if (V6(t)) r = Uint8Array.from(t);
    else throw new Error(`${e} must be hex string or Uint8Array`);
  const i = r.length;
  if (typeof n == "number" && i !== n) throw new Error(`${e} expected ${n} bytes, got ${i}`);
  return r
}

function Do(...e) {
  const t = new Uint8Array(e.reduce((r, i) => r + i.length, 0));
  let n = 0;
  return e.forEach(r => {
    if (!V6(r)) throw new Error("Uint8Array expected");
    t.set(r, n), n += r.length
  }), t
}

function PQ(e, t) {
  if (e.length !== t.length) return !1;
  for (let n = 0; n < e.length; n++)
    if (e[n] !== t[n]) return !1;
  return !0
}

function W6(e) {
  if (typeof e != "string") throw new Error(`utf8ToBytes expected string, got ${typeof e}`);
  return new Uint8Array(new TextEncoder().encode(e))
}

function I_e(e) {
  let t;
  for (t = 0; e > _Q; e >>= H6, t += 1);
  return t
}

function P_e(e, t) {
  return e >> BigInt(t) & H6
}
const R_e = (e, t, n) => e | (n ? H6 : _Q) << BigInt(t),
  s_ = e => (T_e << BigInt(e - 1)) - H6,
  s8 = e => new Uint8Array(e),
  T$ = e => Uint8Array.from(e);

function RQ(e, t, n) {
  if (typeof e != "number" || e < 2) throw new Error("hashLen must be a number");
  if (typeof t != "number" || t < 2) throw new Error("qByteLen must be a number");
  if (typeof n != "function") throw new Error("hmacFn must be a function");
  let r = s8(e),
    i = s8(e),
    s = 0;
  const o = () => {
      r.fill(1), i.fill(0), s = 0
    },
    a = (...f) => n(i, r, ...f),
    c = (f = s8()) => {
      i = a(T$([0]), f), r = a(), f.length !== 0 && (i = a(T$([1]), f), r = a())
    },
    l = () => {
      if (s++ >= 1e3) throw new Error("drbg: tried 1000 values");
      let f = 0;
      const h = [];
      for (; f < t;) {
        r = a();
        const g = r.slice();
        h.push(g), f += r.length
      }
      return Do(...h)
    };
  return (f, h) => {
    o(), c(f);
    let g;
    for (; !(g = h(l()));) c();
    return o(), g
  }
}
const O_e = {
  bigint: e => typeof e == "bigint",
  function: e => typeof e == "function",
  boolean: e => typeof e == "boolean",
  string: e => typeof e == "string",
  stringOrUint8Array: e => typeof e == "string" || e instanceof Uint8Array,
  isSafeInteger: e => Number.isSafeInteger(e),
  array: e => Array.isArray(e),
  field: (e, t) => t.Fp.isValid(e),
  hash: e => typeof e == "function" && Number.isSafeInteger(e.outputLen)
};

function jm(e, t, n = {}) {
  const r = (i, s, o) => {
    const a = O_e[s];
    if (typeof a != "function") throw new Error(`Invalid validator "${s}", expected function`);
    const c = e[i];
    if (!(o && c === void 0) && !a(c, e)) throw new Error(`Invalid param ${String(i)}=${c} (${typeof c}), expected ${s}`)
  };
  for (const [i, s] of Object.entries(t)) r(i, s, !1);
  for (const [i, s] of Object.entries(n)) r(i, s, !0);
  return e
}
const D_e = Object.freeze(Object.defineProperty({
  __proto__: null,
  bitGet: P_e,
  bitLen: I_e,
  bitMask: s_,
  bitSet: R_e,
  bytesToHex: rm,
  bytesToNumberBE: Ps,
  bytesToNumberLE: r_,
  concatBytes: Do,
  createHmacDrbg: RQ,
  ensureBytes: ns,
  equalBytes: PQ,
  hexToBytes: im,
  hexToNumber: n_,
  numberToBytesBE: Rd,
  numberToBytesLE: i_,
  numberToHexUnpadded: IQ,
  numberToVarBytesBE: __e,
  utf8ToBytes: W6,
  validateObject: jm
}, Symbol.toStringTag, {
  value: "Module"
}));

function N_e(e, t) {
  const n = hn(e) ? Bi(e) : e,
    r = hn(t) ? Bi(t) : t;
  return PQ(n, r)
}
async function OQ(e, {
  address: t,
  hash: n,
  signature: r,
  ...i
}) {
  const s = hn(r) ? r : yn(r);
  try {
    const {
      data: o
    } = await Tt(e, by, "call")({
      data: H7({
        abi: _ke,
        args: [t, n, s],
        bytecode: A_e
      }),
      ...i
    });
    return N_e(o ?? "0x0", "0x1")
  } catch (o) {
    if (o instanceof w7) return !1;
    throw o
  }
}
async function M_e(e, {
  address: t,
  message: n,
  signature: r,
  ...i
}) {
  const s = Q7(n);
  return OQ(e, {
    address: t,
    hash: s,
    signature: r,
    ...i
  })
}
async function $_e(e, {
  address: t,
  signature: n,
  message: r,
  primaryType: i,
  types: s,
  domain: o,
  ...a
}) {
  const c = j7({
    message: r,
    primaryType: i,
    types: s,
    domain: o
  });
  return OQ(e, {
    address: t,
    hash: c,
    signature: n,
    ...a
  })
}

function DQ(e, {
  emitOnBegin: t = !1,
  emitMissed: n = !1,
  onBlockNumber: r,
  onError: i,
  poll: s,
  pollingInterval: o = e.pollingInterval
}) {
  const a = typeof s < "u" ? s : e.transport.type !== "webSocket";
  let c;
  return a ? (() => {
    const f = Ti(["watchBlockNumber", e.uid, t, n, o]);
    return Fm(f, {
      onBlockNumber: r,
      onError: i
    }, h => wy(async () => {
      var g;
      try {
        const y = await Tt(e, xy, "getBlockNumber")({
          cacheTime: 0
        });
        if (c) {
          if (y === c) return;
          if (y - c > 1 && n)
            for (let x = c + 1n; x < y; x++) h.onBlockNumber(x, c), c = x
        }(!c || y > c) && (h.onBlockNumber(y, c), c = y)
      } catch (y) {
        (g = h.onError) == null || g.call(h, y)
      }
    }, {
      emitOnBegin: t,
      interval: o
    }))
  })() : (() => {
    let f = !0,
      h = () => f = !1;
    return (async () => {
      try {
        const {
          unsubscribe: g
        } = await e.transport.subscribe({
          params: ["newHeads"],
          onData(y) {
            var k;
            if (!f) return;
            const x = Jn((k = y.result) == null ? void 0 : k.number);
            r(x, c), c = x
          },
          onError(y) {
            i == null || i(y)
          }
        });
        h = g, f || h()
      } catch (g) {
        i == null || i(g)
      }
    })(), h
  })()
}
async function L_e(e, {
  confirmations: t = 1,
  hash: n,
  onReplaced: r,
  pollingInterval: i = e.pollingInterval,
  timeout: s
}) {
  const o = Ti(["waitForTransactionReceipt", e.uid, n]);
  let a, c, l, u = !1;
  return new Promise((f, h) => {
    s && setTimeout(() => h(new bK({
      hash: n
    })), s);
    const g = Fm(o, {
      onReplaced: r,
      resolve: f,
      reject: h
    }, y => {
      const x = Tt(e, DQ, "watchBlockNumber")({
        emitMissed: !0,
        emitOnBegin: !0,
        poll: !0,
        pollingInterval: i,
        async onBlockNumber(k) {
          if (u) return;
          let _ = k;
          const p = v => {
            x(), v(), g()
          };
          try {
            if (l) {
              if (t > 1 && (!l.blockNumber || _ - l.blockNumber + 1n < t)) return;
              p(() => y.resolve(l));
              return
            }
            if (a || (u = !0, await OA(async () => {
                a = await Tt(e, t_, "getTransaction")({
                  hash: n
                }), a.blockNumber && (_ = a.blockNumber)
              }, {
                delay: ({
                  count: v
                }) => ~~(1 << v) * 200,
                retryCount: 6
              }), u = !1), l = await Tt(e, $A, "getTransactionReceipt")({
                hash: n
              }), t > 1 && (!l.blockNumber || _ - l.blockNumber + 1n < t)) return;
            p(() => y.resolve(l))
          } catch (v) {
            if (a && (v instanceof v7 || v instanceof b7)) try {
              c = a, u = !0;
              const S = await OA(() => Tt(e, Pd, "getBlock")({
                blockNumber: _,
                includeTransactions: !0
              }), {
                delay: ({
                  count: w
                }) => ~~(1 << w) * 200,
                retryCount: 6,
                shouldRetry: ({
                  error: w
                }) => w instanceof E7
              });
              u = !1;
              const I = S.transactions.find(({
                from: w,
                nonce: E
              }) => w === c.from && E === c.nonce);
              if (!I || (l = await Tt(e, $A, "getTransactionReceipt")({
                  hash: I.hash
                }), t > 1 && (!l.blockNumber || _ - l.blockNumber + 1n < t))) return;
              let A = "replaced";
              I.to === c.to && I.value === c.value ? A = "repriced" : I.from === I.to && I.value === 0n && (A = "cancelled"), p(() => {
                var w;
                (w = y.onReplaced) == null || w.call(y, {
                  reason: A,
                  replacedTransaction: c,
                  transaction: I,
                  transactionReceipt: l
                }), y.resolve(l)
              })
            } catch (S) {
              p(() => y.reject(S))
            } else p(() => y.reject(v))
          }
        }
      })
    })
  })
}

function B_e(e, {
  blockTag: t = "latest",
  emitMissed: n = !1,
  emitOnBegin: r = !1,
  onBlock: i,
  onError: s,
  includeTransactions: o,
  poll: a,
  pollingInterval: c = e.pollingInterval
}) {
  const l = typeof a < "u" ? a : e.transport.type !== "webSocket",
    u = o ?? !1;
  let f;
  return l ? (() => {
    const y = Ti(["watchBlocks", e.uid, n, r, u, c]);
    return Fm(y, {
      onBlock: i,
      onError: s
    }, x => wy(async () => {
      var k;
      try {
        const _ = await Tt(e, Pd, "getBlock")({
          blockTag: t,
          includeTransactions: u
        });
        if (_.number && (f != null && f.number)) {
          if (_.number === f.number) return;
          if (_.number - f.number > 1 && n)
            for (let p = (f == null ? void 0 : f.number) + 1n; p < _.number; p++) {
              const v = await Tt(e, Pd, "getBlock")({
                blockNumber: p,
                includeTransactions: u
              });
              x.onBlock(v, f), f = v
            }
        }(!(f != null && f.number) || t === "pending" && !(_ != null && _.number) || _.number && _.number > f.number) && (x.onBlock(_, f), f = _)
      } catch (_) {
        (k = x.onError) == null || k.call(x, _)
      }
    }, {
      emitOnBegin: r,
      interval: c
    }))
  })() : (() => {
    let y = !0,
      x = () => y = !1;
    return (async () => {
      try {
        const {
          unsubscribe: k
        } = await e.transport.subscribe({
          params: ["newHeads"],
          onData(_) {
            var S, I, A;
            if (!y) return;
            const v = (((A = (I = (S = e.chain) == null ? void 0 : S.formatters) == null ? void 0 : I.block) == null ? void 0 : A.format) || D6)(_.result);
            i(v, f), f = v
          },
          onError(_) {
            s == null || s(_)
          }
        });
        x = k, y || x()
      } catch (k) {
        s == null || s(k)
      }
    })(), x
  })()
}

function F_e(e, {
  address: t,
  args: n,
  batch: r = !0,
  event: i,
  events: s,
  onError: o,
  onLogs: a,
  poll: c,
  pollingInterval: l = e.pollingInterval,
  strict: u
}) {
  const f = typeof c < "u" ? c : e.transport.type !== "webSocket",
    h = u ?? !1;
  return f ? (() => {
    const x = Ti(["watchEvent", t, n, r, e.uid, i, l]);
    return Fm(x, {
      onLogs: a,
      onError: o
    }, k => {
      let _, p, v = !1;
      const S = wy(async () => {
        var I;
        if (!v) {
          try {
            p = await Tt(e, QK, "createEventFilter")({
              address: t,
              args: n,
              event: i,
              events: s,
              strict: h
            })
          } catch {}
          v = !0;
          return
        }
        try {
          let A;
          if (p) A = await Tt(e, $6, "getFilterChanges")({
            filter: p
          });
          else {
            const w = await Tt(e, xy, "getBlockNumber")({});
            _ && _ !== w ? A = await Tt(e, k7, "getLogs")({
              address: t,
              args: n,
              event: i,
              events: s,
              fromBlock: _ + 1n,
              toBlock: w
            }) : A = [], _ = w
          }
          if (A.length === 0) return;
          if (r) k.onLogs(A);
          else
            for (const w of A) k.onLogs([w])
        } catch (A) {
          p && A instanceof _d && (v = !1), (I = k.onError) == null || I.call(k, A)
        }
      }, {
        emitOnBegin: !0,
        interval: l
      });
      return async () => {
        p && await Tt(e, L6, "uninstallFilter")({
          filter: p
        }), S()
      }
    })
  })() : (() => {
    let x = !0,
      k = () => x = !1;
    return (async () => {
      try {
        const _ = s ?? (i ? [i] : void 0);
        let p = [];
        _ && (p = [_.flatMap(S => Mm({
          abi: [S],
          eventName: S.name,
          args: n
        }))], i && (p = p[0]));
        const {
          unsubscribe: v
        } = await e.transport.subscribe({
          params: ["logs", {
            address: t,
            topics: p
          }],
          onData(S) {
            var A;
            if (!x) return;
            const I = S.result;
            try {
              const {
                eventName: w,
                args: E
              } = Bm({
                abi: _,
                data: I.data,
                topics: I.topics,
                strict: h
              }), D = Na(I, {
                args: E,
                eventName: w
              });
              a([D])
            } catch (w) {
              let E, D;
              if (w instanceof Td || w instanceof Oh) {
                if (u) return;
                E = w.abiItem.name, D = (A = w.abiItem.inputs) == null ? void 0 : A.some(V => !("name" in V && V.name))
              }
              const $ = Na(I, {
                args: D ? [] : {},
                eventName: E
              });
              a([$])
            }
          },
          onError(S) {
            o == null || o(S)
          }
        });
        k = v, x || k()
      } catch (_) {
        o == null || o(_)
      }
    })(), k
  })()
}

function j_e(e, {
  batch: t = !0,
  onError: n,
  onTransactions: r,
  poll: i,
  pollingInterval: s = e.pollingInterval
}) {
  return (typeof i < "u" ? i : e.transport.type !== "webSocket") ? (() => {
    const l = Ti(["watchPendingTransactions", e.uid, t, s]);
    return Fm(l, {
      onTransactions: r,
      onError: n
    }, u => {
      let f;
      const h = wy(async () => {
        var g;
        try {
          if (!f) try {
            f = await Tt(e, YK, "createPendingTransactionFilter")({});
            return
          } catch (x) {
            throw h(), x
          }
          const y = await Tt(e, $6, "getFilterChanges")({
            filter: f
          });
          if (y.length === 0) return;
          if (t) u.onTransactions(y);
          else
            for (const x of y) u.onTransactions([x])
        } catch (y) {
          (g = u.onError) == null || g.call(u, y)
        }
      }, {
        emitOnBegin: !0,
        interval: s
      });
      return async () => {
        f && await Tt(e, L6, "uninstallFilter")({
          filter: f
        }), h()
      }
    })
  })() : (() => {
    let l = !0,
      u = () => l = !1;
    return (async () => {
      try {
        const {
          unsubscribe: f
        } = await e.transport.subscribe({
          params: ["newPendingTransactions"],
          onData(h) {
            if (!l) return;
            const g = h.result;
            r([g])
          },
          onError(h) {
            n == null || n(h)
          }
        });
        u = f, l || u()
      } catch (f) {
        n == null || n(f)
      }
    })(), u
  })()
}

function NQ(e) {
  return {
    call: t => by(e, t),
    createBlockFilter: () => m7e(e),
    createContractEventFilter: t => f7(e, t),
    createEventFilter: t => QK(e, t),
    createPendingTransactionFilter: () => YK(e),
    estimateContractGas: t => OK(e, t),
    estimateGas: t => T7(e, t),
    getBalance: t => g7e(e, t),
    getBlock: t => Pd(e, t),
    getBlockNumber: t => xy(e, t),
    getBlockTransactionCount: t => y7e(e, t),
    getBytecode: t => v7e(e, t),
    getChainId: () => g2(e),
    getContractEvents: t => _7(e, t),
    getEnsAddress: t => e7e(e, t),
    getEnsAvatar: t => f7e(e, t),
    getEnsName: t => h7e(e, t),
    getEnsResolver: t => p7e(e, t),
    getEnsText: t => KK(e, t),
    getFeeHistory: t => w7e(e, t),
    estimateFeesPerGas: t => Ske(e, t),
    getFilterChanges: t => $6(e, t),
    getFilterLogs: t => x7e(e, t),
    getGasPrice: () => C7(e),
    getLogs: t => k7(e, t),
    getProof: t => x_e(e, t),
    estimateMaxPriorityFeePerGas: t => Eke(e, t),
    getStorageAt: t => E_e(e, t),
    getTransaction: t => t_(e, t),
    getTransactionConfirmations: t => S_e(e, t),
    getTransactionCount: t => RK(e, t),
    getTransactionReceipt: t => $A(e, t),
    multicall: t => C_e(e, t),
    prepareTransactionRequest: t => N6(e, t),
    readContract: t => hu(e, t),
    sendRawTransaction: t => D7(e, t),
    simulateContract: t => LK(e, t),
    verifyMessage: t => M_e(e, t),
    verifyTypedData: t => $_e(e, t),
    uninstallFilter: t => L6(e, t),
    waitForTransactionReceipt: t => L_e(e, t),
    watchBlocks: t => B_e(e, t),
    watchBlockNumber: t => DQ(e, t),
    watchContractEvent: t => BK(e, t),
    watchEvent: t => F_e(e, t),
    watchPendingTransactions: t => j_e(e, t)
  }
}

function MQ(e) {
  const {
    key: t = "public",
    name: n = "Public Client"
  } = e;
  return B6({
    ...e,
    key: t,
    name: n,
    type: "publicClient"
  }).extend(NQ)
}
async function U_e(e, {
  hash: t
}) {
  await e.request({
    method: `${e.mode}_dropTransaction`,
    params: [t]
  })
}
async function z_e(e) {
  return e.request({
    method: `${e.mode}_dumpState`
  })
}
async function H_e(e) {
  return e.mode === "ganache" ? await e.request({
    method: "eth_mining"
  }) : await e.request({
    method: `${e.mode}_getAutomine`
  })
}
async function V_e(e) {
  return await e.request({
    method: "txpool_content"
  })
}
async function W_e(e) {
  const {
    pending: t,
    queued: n
  } = await e.request({
    method: "txpool_status"
  });
  return {
    pending: Xn(t),
    queued: Xn(n)
  }
}
async function q_e(e, {
  address: t
}) {
  await e.request({
    method: `${e.mode}_impersonateAccount`,
    params: [t]
  })
}
async function G_e(e, {
  seconds: t
}) {
  return await e.request({
    method: "evm_increaseTime",
    params: [Ct(t)]
  })
}
async function K_e(e) {
  return await e.request({
    method: "txpool_inspect"
  })
}
async function Q_e(e, {
  state: t
}) {
  await e.request({
    method: `${e.mode}_loadState`,
    params: [t]
  })
}
async function Y_e(e, {
  blocks: t,
  interval: n
}) {
  e.mode === "ganache" ? await e.request({
    method: "evm_mine",
    params: [{
      blocks: Ct(t)
    }]
  }) : await e.request({
    method: `${e.mode}_mine`,
    params: [Ct(t), Ct(n || 0)]
  })
}
async function J_e(e) {
  await e.request({
    method: `${e.mode}_removeBlockTimestampInterval`
  })
}
async function X_e(e, {
  blockNumber: t,
  jsonRpcUrl: n
} = {}) {
  await e.request({
    method: `${e.mode}_reset`,
    params: [{
      forking: {
        blockNumber: Number(t),
        jsonRpcUrl: n
      }
    }]
  })
}
async function Z_e(e, {
  id: t
}) {
  await e.request({
    method: "evm_revert",
    params: [t]
  })
}
async function eIe(e, t) {
  var _, p, v;
  const {
    accessList: n,
    data: r,
    from: i,
    gas: s,
    gasPrice: o,
    maxFeePerGas: a,
    maxPriorityFeePerGas: c,
    nonce: l,
    to: u,
    value: f,
    ...h
  } = t, g = (v = (p = (_ = e.chain) == null ? void 0 : _.formatters) == null ? void 0 : p.transactionRequest) == null ? void 0 : v.format, x = (g || Mh)({
    ...P6(h, {
      format: g
    }),
    accessList: n,
    data: r,
    from: i,
    gas: s,
    gasPrice: o,
    maxFeePerGas: a,
    maxPriorityFeePerGas: c,
    nonce: l,
    to: u,
    value: f
  });
  return await e.request({
    method: "eth_sendUnsignedTransaction",
    params: [x]
  })
}
async function tIe(e, t) {
  e.mode === "ganache" ? t ? await e.request({
    method: "miner_start"
  }) : await e.request({
    method: "miner_stop"
  }) : await e.request({
    method: "evm_setAutomine",
    params: [t]
  })
}
async function nIe(e, {
  address: t,
  value: n
}) {
  e.mode === "ganache" ? await e.request({
    method: "evm_setAccountBalance",
    params: [t, Ct(n)]
  }) : await e.request({
    method: `${e.mode}_setBalance`,
    params: [t, Ct(n)]
  })
}
async function rIe(e, {
  gasLimit: t
}) {
  await e.request({
    method: "evm_setBlockGasLimit",
    params: [Ct(t)]
  })
}
async function iIe(e, {
  interval: t
}) {
  const n = e.mode === "hardhat" ? t * 1e3 : t;
  await e.request({
    method: `${e.mode}_setBlockTimestampInterval`,
    params: [n]
  })
}
async function sIe(e, {
  address: t,
  bytecode: n
}) {
  await e.request({
    method: `${e.mode}_setCode`,
    params: [t, n]
  })
}
async function oIe(e, {
  address: t
}) {
  await e.request({
    method: `${e.mode}_setCoinbase`,
    params: [t]
  })
}
async function aIe(e, {
  interval: t
}) {
  const n = e.mode === "hardhat" ? t * 1e3 : t;
  await e.request({
    method: "evm_setIntervalMining",
    params: [n]
  })
}
async function cIe(e, t) {
  await e.request({
    method: `${e.mode}_setLoggingEnabled`,
    params: [t]
  })
}
async function lIe(e, {
  gasPrice: t
}) {
  await e.request({
    method: `${e.mode}_setMinGasPrice`,
    params: [Ct(t)]
  })
}
async function uIe(e, {
  baseFeePerGas: t
}) {
  await e.request({
    method: `${e.mode}_setNextBlockBaseFeePerGas`,
    params: [Ct(t)]
  })
}
async function dIe(e, {
  timestamp: t
}) {
  await e.request({
    method: "evm_setNextBlockTimestamp",
    params: [Ct(t)]
  })
}
async function fIe(e, {
  address: t,
  nonce: n
}) {
  await e.request({
    method: `${e.mode}_setNonce`,
    params: [t, Ct(n)]
  })
}
async function hIe(e, t) {
  await e.request({
    method: `${e.mode}_setRpcUrl`,
    params: [t]
  })
}
async function pIe(e, {
  address: t,
  index: n,
  value: r
}) {
  await e.request({
    method: `${e.mode}_setStorageAt`,
    params: [t, typeof n == "number" ? Ct(n) : n, r]
  })
}
async function mIe(e) {
  return await e.request({
    method: "evm_snapshot"
  })
}
async function gIe(e, {
  address: t
}) {
  await e.request({
    method: `${e.mode}_stopImpersonatingAccount`,
    params: [t]
  })
}

function $Q({
  mode: e
}) {
  return t => {
    const n = t.extend(() => ({
      mode: e
    }));
    return {
      dropTransaction: r => U_e(n, r),
      dumpState: () => z_e(n),
      getAutomine: () => H_e(n),
      getTxpoolContent: () => V_e(n),
      getTxpoolStatus: () => W_e(n),
      impersonateAccount: r => q_e(n, r),
      increaseTime: r => G_e(n, r),
      inspectTxpool: () => K_e(n),
      loadState: r => Q_e(n, r),
      mine: r => Y_e(n, r),
      removeBlockTimestampInterval: () => J_e(n),
      reset: r => X_e(n, r),
      revert: r => Z_e(n, r),
      sendUnsignedTransaction: r => eIe(n, r),
      setAutomine: r => tIe(n, r),
      setBalance: r => nIe(n, r),
      setBlockGasLimit: r => rIe(n, r),
      setBlockTimestampInterval: r => iIe(n, r),
      setCode: r => sIe(n, r),
      setCoinbase: r => oIe(n, r),
      setIntervalMining: r => aIe(n, r),
      setLoggingEnabled: r => cIe(n, r),
      setMinGasPrice: r => lIe(n, r),
      setNextBlockBaseFeePerGas: r => uIe(n, r),
      setNextBlockTimestamp: r => dIe(n, r),
      setNonce: r => fIe(n, r),
      setRpcUrl: r => hIe(n, r),
      setStorageAt: r => pIe(n, r),
      snapshot: () => mIe(n),
      stopImpersonatingAccount: r => gIe(n, r)
    }
  }
}

function yIe(e) {
  const {
    key: t = "test",
    name: n = "Test Client",
    mode: r
  } = e;
  return B6({
    ...e,
    key: t,
    name: n,
    type: "testClient"
  }).extend(s => ({
    mode: r,
    ...$Q({
      mode: r
    })(s)
  }))
}

function vIe(e, {
  abi: t,
  args: n,
  bytecode: r,
  ...i
}) {
  const s = H7({
    abi: t,
    args: n,
    bytecode: r
  });
  return N7(e, {
    ...i,
    data: s
  })
}
async function bIe(e) {
  var n;
  return ((n = e.account) == null ? void 0 : n.type) === "local" ? [e.account.address] : (await e.request({
    method: "eth_accounts"
  })).map(r => my(r))
}
async function wIe(e) {
  return await e.request({
    method: "wallet_getPermissions"
  })
}
async function xIe(e) {
  return (await e.request({
    method: "eth_requestAccounts"
  })).map(n => kd(n))
}
async function EIe(e, t) {
  return e.request({
    method: "wallet_requestPermissions",
    params: [t]
  })
}
async function SIe(e, {
  account: t = e.account,
  message: n
}) {
  if (!t) throw new $m({
    docsPath: "/docs/actions/wallet/signMessage"
  });
  const r = Ha(t);
  if (r.type === "local") return r.signMessage({
    message: n
  });
  const i = typeof n == "string" ? py(n) : n.raw instanceof Uint8Array ? yn(n.raw) : n.raw;
  return e.request({
    method: "personal_sign",
    params: [i, r.address]
  })
}
async function CIe(e, t) {
  var l, u, f, h;
  const {
    account: n = e.account,
    chain: r = e.chain,
    ...i
  } = t;
  if (!n) throw new $m({
    docsPath: "/docs/actions/wallet/signTransaction"
  });
  const s = Ha(n);
  Lm({
    account: s,
    ...t
  });
  const o = await Tt(e, g2, "getChainId")({});
  r !== null && O7({
    currentChainId: o,
    chain: r
  });
  const a = (r == null ? void 0 : r.formatters) || ((l = e.chain) == null ? void 0 : l.formatters),
    c = ((u = a == null ? void 0 : a.transactionRequest) == null ? void 0 : u.format) || Mh;
  return s.type === "local" ? s.signTransaction({
    ...i,
    chainId: o
  }, {
    serializer: (h = (f = e.chain) == null ? void 0 : f.serializers) == null ? void 0 : h.transaction
  }) : await e.request({
    method: "eth_signTransaction",
    params: [{
      ...c(i),
      chainId: Ct(o),
      from: s.address
    }]
  })
}
async function AIe(e, {
  account: t = e.account,
  domain: n,
  message: r,
  primaryType: i,
  types: s
}) {
  if (!t) throw new $m({
    docsPath: "/docs/actions/wallet/signTypedData"
  });
  const o = Ha(t),
    a = {
      EIP712Domain: z6({
        domain: n
      }),
      ...s
    };
  if (z7({
      domain: n,
      message: r,
      primaryType: i,
      types: a
    }), o.type === "local") return o.signTypedData({
    domain: n,
    primaryType: i,
    types: a,
    message: r
  });
  const c = Ti({
    domain: n ?? {},
    primaryType: i,
    types: a,
    message: r
  }, (l, u) => hn(u) ? u.toLowerCase() : u);
  return e.request({
    method: "eth_signTypedData_v4",
    params: [o.address, c]
  })
}
async function TIe(e, {
  id: t
}) {
  await e.request({
    method: "wallet_switchEthereumChain",
    params: [{
      chainId: Ct(t)
    }]
  })
}
async function kIe(e, t) {
  return await e.request({
    method: "wallet_watchAsset",
    params: t
  })
}

function LQ(e) {
  return {
    addChain: t => zke(e, t),
    deployContract: t => vIe(e, t),
    getAddresses: () => bIe(e),
    getChainId: () => g2(e),
    getPermissions: () => wIe(e),
    prepareTransactionRequest: t => N6(e, t),
    requestAddresses: () => xIe(e),
    requestPermissions: t => EIe(e, t),
    sendRawTransaction: t => D7(e, t),
    sendTransaction: t => N7(e, t),
    signMessage: t => SIe(e, t),
    signTransaction: t => CIe(e, t),
    signTypedData: t => AIe(e, t),
    switchChain: t => TIe(e, t),
    watchAsset: t => kIe(e, t),
    writeContract: t => FK(e, t)
  }
}

function _Ie(e) {
  const {
    key: t = "wallet",
    name: n = "Wallet Client",
    transport: r
  } = e;
  return B6({
    ...e,
    key: t,
    name: n,
    transport: s => r({
      ...s,
      retryCount: 0
    }),
    type: "walletClient"
  }).extend(LQ)
}

function IIe(e, t = {}) {
  const {
    key: n = "webSocket",
    name: r = "WebSocket JSON-RPC",
    retryDelay: i
  } = t;
  return ({
    chain: s,
    retryCount: o,
    timeout: a
  }) => {
    var f;
    const c = t.retryCount ?? o,
      l = a ?? t.timeout ?? 1e4,
      u = e || ((f = s == null ? void 0 : s.rpcUrls.default.webSocket) == null ? void 0 : f[0]);
    if (!u) throw new M7;
    return Ey({
      key: n,
      name: r,
      async request({
        method: h,
        params: g
      }) {
        const y = {
            method: h,
            params: g
          },
          x = await n8(u),
          {
            error: k,
            result: _
          } = await yp.webSocketAsync(x, {
            body: y,
            timeout: l
          });
        if (k) throw new I6({
          body: y,
          error: k,
          url: u
        });
        return _
      },
      retryCount: c,
      retryDelay: i,
      timeout: l,
      type: "webSocket"
    }, {
      getSocket() {
        return n8(u)
      },
      async subscribe({
        params: h,
        onData: g,
        onError: y
      }) {
        const x = await n8(u),
          {
            result: k
          } = await new Promise((_, p) => yp.webSocket(x, {
            body: {
              method: "eth_subscribe",
              params: h
            },
            onResponse(v) {
              if (v.error) {
                p(v.error), y == null || y(v.error);
                return
              }
              if (typeof v.id == "number") {
                _(v);
                return
              }
              v.method === "eth_subscription" && g(v.params)
            }
          }));
        return {
          subscriptionId: k,
          async unsubscribe() {
            return new Promise(_ => yp.webSocket(x, {
              body: {
                method: "eth_unsubscribe",
                params: [k]
              },
              onResponse: _
            }))
          }
        }
      }
    })
  }
}
const PIe = "0x0000000000000000000000000000000000000000",
  RIe = 2n ** (8n - 1n) - 1n,
  OIe = 2n ** (16n - 1n) - 1n,
  DIe = 2n ** (24n - 1n) - 1n,
  NIe = 2n ** (32n - 1n) - 1n,
  MIe = 2n ** (40n - 1n) - 1n,
  $Ie = 2n ** (48n - 1n) - 1n,
  LIe = 2n ** (56n - 1n) - 1n,
  BIe = 2n ** (64n - 1n) - 1n,
  FIe = 2n ** (72n - 1n) - 1n,
  jIe = 2n ** (80n - 1n) - 1n,
  UIe = 2n ** (88n - 1n) - 1n,
  zIe = 2n ** (96n - 1n) - 1n,
  HIe = 2n ** (104n - 1n) - 1n,
  VIe = 2n ** (112n - 1n) - 1n,
  WIe = 2n ** (120n - 1n) - 1n,
  qIe = 2n ** (128n - 1n) - 1n,
  GIe = 2n ** (136n - 1n) - 1n,
  KIe = 2n ** (144n - 1n) - 1n,
  QIe = 2n ** (152n - 1n) - 1n,
  YIe = 2n ** (160n - 1n) - 1n,
  JIe = 2n ** (168n - 1n) - 1n,
  XIe = 2n ** (176n - 1n) - 1n,
  ZIe = 2n ** (184n - 1n) - 1n,
  ePe = 2n ** (192n - 1n) - 1n,
  tPe = 2n ** (200n - 1n) - 1n,
  nPe = 2n ** (208n - 1n) - 1n,
  rPe = 2n ** (216n - 1n) - 1n,
  iPe = 2n ** (224n - 1n) - 1n,
  sPe = 2n ** (232n - 1n) - 1n,
  oPe = 2n ** (240n - 1n) - 1n,
  aPe = 2n ** (248n - 1n) - 1n,
  cPe = 2n ** (256n - 1n) - 1n,
  lPe = -(2n ** (8n - 1n)),
  uPe = -(2n ** (16n - 1n)),
  dPe = -(2n ** (24n - 1n)),
  fPe = -(2n ** (32n - 1n)),
  hPe = -(2n ** (40n - 1n)),
  pPe = -(2n ** (48n - 1n)),
  mPe = -(2n ** (56n - 1n)),
  gPe = -(2n ** (64n - 1n)),
  yPe = -(2n ** (72n - 1n)),
  vPe = -(2n ** (80n - 1n)),
  bPe = -(2n ** (88n - 1n)),
  wPe = -(2n ** (96n - 1n)),
  xPe = -(2n ** (104n - 1n)),
  EPe = -(2n ** (112n - 1n)),
  SPe = -(2n ** (120n - 1n)),
  CPe = -(2n ** (128n - 1n)),
  APe = -(2n ** (136n - 1n)),
  TPe = -(2n ** (144n - 1n)),
  kPe = -(2n ** (152n - 1n)),
  _Pe = -(2n ** (160n - 1n)),
  IPe = -(2n ** (168n - 1n)),
  PPe = -(2n ** (176n - 1n)),
  RPe = -(2n ** (184n - 1n)),
  OPe = -(2n ** (192n - 1n)),
  DPe = -(2n ** (200n - 1n)),
  NPe = -(2n ** (208n - 1n)),
  MPe = -(2n ** (216n - 1n)),
  $Pe = -(2n ** (224n - 1n)),
  LPe = -(2n ** (232n - 1n)),
  BPe = -(2n ** (240n - 1n)),
  FPe = -(2n ** (248n - 1n)),
  jPe = -(2n ** (256n - 1n)),
  UPe = 2n ** 8n - 1n,
  zPe = 2n ** 16n - 1n,
  HPe = 2n ** 24n - 1n,
  VPe = 2n ** 32n - 1n,
  WPe = 2n ** 40n - 1n,
  qPe = 2n ** 48n - 1n,
  GPe = 2n ** 56n - 1n,
  KPe = 2n ** 64n - 1n,
  QPe = 2n ** 72n - 1n,
  YPe = 2n ** 80n - 1n,
  JPe = 2n ** 88n - 1n,
  XPe = 2n ** 96n - 1n,
  ZPe = 2n ** 104n - 1n,
  eRe = 2n ** 112n - 1n,
  tRe = 2n ** 120n - 1n,
  nRe = 2n ** 128n - 1n,
  rRe = 2n ** 136n - 1n,
  iRe = 2n ** 144n - 1n,
  sRe = 2n ** 152n - 1n,
  oRe = 2n ** 160n - 1n,
  aRe = 2n ** 168n - 1n,
  cRe = 2n ** 176n - 1n,
  lRe = 2n ** 184n - 1n,
  uRe = 2n ** 192n - 1n,
  dRe = 2n ** 200n - 1n,
  fRe = 2n ** 208n - 1n,
  hRe = 2n ** 216n - 1n,
  pRe = 2n ** 224n - 1n,
  mRe = 2n ** 232n - 1n,
  gRe = 2n ** 240n - 1n,
  yRe = 2n ** 248n - 1n,
  vRe = 2n ** 256n - 1n,
  bRe = "0x0000000000000000000000000000000000000000000000000000000000000000",
  o8 = "/docs/contract/decodeDeployData";

function wRe({
  abi: e,
  bytecode: t,
  data: n
}) {
  if (n === t) return {
    bytecode: t
  };
  const r = e.find(s => "type" in s && s.type === "constructor");
  if (!r) throw new Yk({
    docsPath: o8
  });
  if (!("inputs" in r)) throw new m2({
    docsPath: o8
  });
  if (!r.inputs || r.inputs.length === 0) throw new m2({
    docsPath: o8
  });
  return {
    args: Dh(r.inputs, `0x${n.replace(t,"")}`),
    bytecode: t
  }
}

function xRe({
  r: e,
  yParityAndS: t
}) {
  const n = wu(t),
    r = n[0] & 128 ? 28n : 27n,
    i = n;
  return r === 28n && (i[0] &= 127), {
    r: e,
    s: mo(i),
    v: r
  }
} /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Si = BigInt(0),
  Kr = BigInt(1),
  Tf = BigInt(2),
  ERe = BigInt(3),
  LA = BigInt(4),
  k$ = BigInt(5),
  _$ = BigInt(8);
BigInt(9);
BigInt(16);

function xi(e, t) {
  const n = e % t;
  return n >= Si ? n : t + n
}

function SRe(e, t, n) {
  if (n <= Si || t < Si) throw new Error("Expected power/modulo > 0");
  if (n === Kr) return Si;
  let r = Kr;
  for (; t > Si;) t & Kr && (r = r * e % n), e = e * e % n, t >>= Kr;
  return r
}

function aa(e, t, n) {
  let r = e;
  for (; t-- > Si;) r *= r, r %= n;
  return r
}

function BA(e, t) {
  if (e === Si || t <= Si) throw new Error(`invert: expected positive integers, got n=${e} mod=${t}`);
  let n = xi(e, t),
    r = t,
    i = Si,
    s = Kr;
  for (; n !== Si;) {
    const a = r / n,
      c = r % n,
      l = i - s * a;
    r = n, n = c, i = s, s = l
  }
  if (r !== Kr) throw new Error("invert: does not exist");
  return xi(i, t)
}

function CRe(e) {
  const t = (e - Kr) / Tf;
  let n, r, i;
  for (n = e - Kr, r = 0; n % Tf === Si; n /= Tf, r++);
  for (i = Tf; i < e && SRe(i, t, e) !== e - Kr; i++);
  if (r === 1) {
    const o = (e + Kr) / LA;
    return function (c, l) {
      const u = c.pow(l, o);
      if (!c.eql(c.sqr(u), l)) throw new Error("Cannot find square root");
      return u
    }
  }
  const s = (n + Kr) / Tf;
  return function (a, c) {
    if (a.pow(c, t) === a.neg(a.ONE)) throw new Error("Cannot find square root");
    let l = r,
      u = a.pow(a.mul(a.ONE, i), n),
      f = a.pow(c, s),
      h = a.pow(c, n);
    for (; !a.eql(h, a.ONE);) {
      if (a.eql(h, a.ZERO)) return a.ZERO;
      let g = 1;
      for (let x = a.sqr(h); g < l && !a.eql(x, a.ONE); g++) x = a.sqr(x);
      const y = a.pow(u, Kr << BigInt(l - g - 1));
      u = a.sqr(y), f = a.mul(f, y), h = a.mul(h, u), l = g
    }
    return f
  }
}

function ARe(e) {
  if (e % LA === ERe) {
    const t = (e + Kr) / LA;
    return function (r, i) {
      const s = r.pow(i, t);
      if (!r.eql(r.sqr(s), i)) throw new Error("Cannot find square root");
      return s
    }
  }
  if (e % _$ === k$) {
    const t = (e - k$) / _$;
    return function (r, i) {
      const s = r.mul(i, Tf),
        o = r.pow(s, t),
        a = r.mul(i, o),
        c = r.mul(r.mul(a, Tf), o),
        l = r.mul(a, r.sub(c, r.ONE));
      if (!r.eql(r.sqr(l), i)) throw new Error("Cannot find square root");
      return l
    }
  }
  return CRe(e)
}
const TRe = ["create", "isValid", "is0", "neg", "inv", "sqrt", "sqr", "eql", "add", "sub", "mul", "pow", "div", "addN", "subN", "mulN", "sqrN"];

function BQ(e) {
  const t = {
      ORDER: "bigint",
      MASK: "bigint",
      BYTES: "isSafeInteger",
      BITS: "isSafeInteger"
    },
    n = TRe.reduce((r, i) => (r[i] = "function", r), t);
  return jm(e, n)
}

function kRe(e, t, n) {
  if (n < Si) throw new Error("Expected power > 0");
  if (n === Si) return e.ONE;
  if (n === Kr) return t;
  let r = e.ONE,
    i = t;
  for (; n > Si;) n & Kr && (r = e.mul(r, i)), i = e.sqr(i), n >>= Kr;
  return r
}

function _Re(e, t) {
  const n = new Array(t.length),
    r = t.reduce((s, o, a) => e.is0(o) ? s : (n[a] = s, e.mul(s, o)), e.ONE),
    i = e.inv(r);
  return t.reduceRight((s, o, a) => e.is0(o) ? s : (n[a] = e.mul(s, n[a]), e.mul(s, o)), i), n
}

function FQ(e, t) {
  const n = t !== void 0 ? t : e.toString(2).length,
    r = Math.ceil(n / 8);
  return {
    nBitLength: n,
    nByteLength: r
  }
}

function IRe(e, t, n = !1, r = {}) {
  if (e <= Si) throw new Error(`Expected Field ORDER > 0, got ${e}`);
  const {
    nBitLength: i,
    nByteLength: s
  } = FQ(e, t);
  if (s > 2048) throw new Error("Field lengths over 2048 bytes are not supported");
  const o = ARe(e),
    a = Object.freeze({
      ORDER: e,
      BITS: i,
      BYTES: s,
      MASK: s_(i),
      ZERO: Si,
      ONE: Kr,
      create: c => xi(c, e),
      isValid: c => {
        if (typeof c != "bigint") throw new Error(`Invalid field element: expected bigint, got ${typeof c}`);
        return Si <= c && c < e
      },
      is0: c => c === Si,
      isOdd: c => (c & Kr) === Kr,
      neg: c => xi(-c, e),
      eql: (c, l) => c === l,
      sqr: c => xi(c * c, e),
      add: (c, l) => xi(c + l, e),
      sub: (c, l) => xi(c - l, e),
      mul: (c, l) => xi(c * l, e),
      pow: (c, l) => kRe(a, c, l),
      div: (c, l) => xi(c * BA(l, e), e),
      sqrN: c => c * c,
      addN: (c, l) => c + l,
      subN: (c, l) => c - l,
      mulN: (c, l) => c * l,
      inv: c => BA(c, e),
      sqrt: r.sqrt || (c => o(a, c)),
      invertBatch: c => _Re(a, c),
      cmov: (c, l, u) => u ? l : c,
      toBytes: c => n ? i_(c, s) : Rd(c, s),
      fromBytes: c => {
        if (c.length !== s) throw new Error(`Fp.fromBytes: expected ${s}, got ${c.length}`);
        return n ? r_(c) : Ps(c)
      }
    });
  return Object.freeze(a)
}

function jQ(e) {
  if (typeof e != "bigint") throw new Error("field order must be bigint");
  const t = e.toString(2).length;
  return Math.ceil(t / 8)
}

function UQ(e) {
  const t = jQ(e);
  return t + Math.ceil(t / 2)
}

function PRe(e, t, n = !1) {
  const r = e.length,
    i = jQ(t),
    s = UQ(t);
  if (r < 16 || r < s || r > 1024) throw new Error(`expected ${s}-1024 bytes of input, got ${r}`);
  const o = n ? Ps(e) : r_(e),
    a = xi(o, t - Kr) + Kr;
  return n ? i_(a, i) : Rd(a, i)
} /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const RRe = BigInt(0),
  a8 = BigInt(1);

function ORe(e, t) {
  const n = (i, s) => {
      const o = s.negate();
      return i ? o : s
    },
    r = i => {
      const s = Math.ceil(t / i) + 1,
        o = 2 ** (i - 1);
      return {
        windows: s,
        windowSize: o
      }
    };
  return {
    constTimeNegate: n,
    unsafeLadder(i, s) {
      let o = e.ZERO,
        a = i;
      for (; s > RRe;) s & a8 && (o = o.add(a)), a = a.double(), s >>= a8;
      return o
    },
    precomputeWindow(i, s) {
      const {
        windows: o,
        windowSize: a
      } = r(s), c = [];
      let l = i,
        u = l;
      for (let f = 0; f < o; f++) {
        u = l, c.push(u);
        for (let h = 1; h < a; h++) u = u.add(l), c.push(u);
        l = u.double()
      }
      return c
    },
    wNAF(i, s, o) {
      const {
        windows: a,
        windowSize: c
      } = r(i);
      let l = e.ZERO,
        u = e.BASE;
      const f = BigInt(2 ** i - 1),
        h = 2 ** i,
        g = BigInt(i);
      for (let y = 0; y < a; y++) {
        const x = y * c;
        let k = Number(o & f);
        o >>= g, k > c && (k -= h, o += a8);
        const _ = x,
          p = x + Math.abs(k) - 1,
          v = y % 2 !== 0,
          S = k < 0;
        k === 0 ? u = u.add(n(v, s[_])) : l = l.add(n(S, s[p]))
      }
      return {
        p: l,
        f: u
      }
    },
    wNAFCached(i, s, o, a) {
      const c = i._WINDOW_SIZE || 1;
      let l = s.get(i);
      return l || (l = this.precomputeWindow(i, c), c !== 1 && s.set(i, a(l))), this.wNAF(c, l, o)
    }
  }
}

function zQ(e) {
  return BQ(e.Fp), jm(e, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  }), Object.freeze({
    ...FQ(e.n, e.nBitLength),
    ...e,
    p: e.Fp.ORDER
  })
} /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function DRe(e) {
  const t = zQ(e);
  jm(t, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const {
    endo: n,
    Fp: r,
    a: i
  } = t;
  if (n) {
    if (!r.eql(i, r.ZERO)) throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    if (typeof n != "object" || typeof n.beta != "bigint" || typeof n.splitScalar != "function") throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")
  }
  return Object.freeze({
    ...t
  })
}
const {
  bytesToNumberBE: NRe,
  hexToBytes: MRe
} = D_e, Lf = {
  Err: class extends Error {
    constructor(t = "") {
      super(t)
    }
  },
  _parseInt(e) {
    const {
      Err: t
    } = Lf;
    if (e.length < 2 || e[0] !== 2) throw new t("Invalid signature integer tag");
    const n = e[1],
      r = e.subarray(2, n + 2);
    if (!n || r.length !== n) throw new t("Invalid signature integer: wrong length");
    if (r[0] & 128) throw new t("Invalid signature integer: negative");
    if (r[0] === 0 && !(r[1] & 128)) throw new t("Invalid signature integer: unnecessary leading zero");
    return {
      d: NRe(r),
      l: e.subarray(n + 2)
    }
  },
  toSig(e) {
    const {
      Err: t
    } = Lf, n = typeof e == "string" ? MRe(e) : e;
    if (!(n instanceof Uint8Array)) throw new Error("ui8a expected");
    let r = n.length;
    if (r < 2 || n[0] != 48) throw new t("Invalid signature tag");
    if (n[1] !== r - 2) throw new t("Invalid signature: incorrect length");
    const {
      d: i,
      l: s
    } = Lf._parseInt(n.subarray(2)), {
      d: o,
      l: a
    } = Lf._parseInt(s);
    if (a.length) throw new t("Invalid signature: left bytes after parsing");
    return {
      r: i,
      s: o
    }
  },
  hexFromSig(e) {
    const t = l => Number.parseInt(l[0], 16) & 8 ? "00" + l : l,
      n = l => {
        const u = l.toString(16);
        return u.length & 1 ? `0${u}` : u
      },
      r = t(n(e.s)),
      i = t(n(e.r)),
      s = r.length / 2,
      o = i.length / 2,
      a = n(s),
      c = n(o);
    return `30${n(o+s+4)}02${c}${i}02${a}${r}`
  }
}, fc = BigInt(0), Br = BigInt(1), Qu = BigInt(2), ox = BigInt(3), I$ = BigInt(4);

function $Re(e) {
  const t = DRe(e),
    {
      Fp: n
    } = t,
    r = t.toBytes || ((y, x, k) => {
      const _ = x.toAffine();
      return Do(Uint8Array.from([4]), n.toBytes(_.x), n.toBytes(_.y))
    }),
    i = t.fromBytes || (y => {
      const x = y.subarray(1),
        k = n.fromBytes(x.subarray(0, n.BYTES)),
        _ = n.fromBytes(x.subarray(n.BYTES, 2 * n.BYTES));
      return {
        x: k,
        y: _
      }
    });

  function s(y) {
    const {
      a: x,
      b: k
    } = t, _ = n.sqr(y), p = n.mul(_, y);
    return n.add(n.add(p, n.mul(y, x)), k)
  }
  if (!n.eql(n.sqr(t.Gy), s(t.Gx))) throw new Error("bad generator point: equation left != right");

  function o(y) {
    return typeof y == "bigint" && fc < y && y < t.n
  }

  function a(y) {
    if (!o(y)) throw new Error("Expected valid bigint: 0 < bigint < curve.n")
  }

  function c(y) {
    const {
      allowedPrivateKeyLengths: x,
      nByteLength: k,
      wrapPrivateKey: _,
      n: p
    } = t;
    if (x && typeof y != "bigint") {
      if (y instanceof Uint8Array && (y = rm(y)), typeof y != "string" || !x.includes(y.length)) throw new Error("Invalid key");
      y = y.padStart(k * 2, "0")
    }
    let v;
    try {
      v = typeof y == "bigint" ? y : Ps(ns("private key", y, k))
    } catch {
      throw new Error(`private key must be ${k} bytes, hex or bigint, not ${typeof y}`)
    }
    return _ && (v = xi(v, p)), a(v), v
  }
  const l = new Map;

  function u(y) {
    if (!(y instanceof f)) throw new Error("ProjectivePoint expected")
  }
  class f {
    constructor(x, k, _) {
      if (this.px = x, this.py = k, this.pz = _, x == null || !n.isValid(x)) throw new Error("x required");
      if (k == null || !n.isValid(k)) throw new Error("y required");
      if (_ == null || !n.isValid(_)) throw new Error("z required")
    }
    static fromAffine(x) {
      const {
        x: k,
        y: _
      } = x || {};
      if (!x || !n.isValid(k) || !n.isValid(_)) throw new Error("invalid affine point");
      if (x instanceof f) throw new Error("projective point not allowed");
      const p = v => n.eql(v, n.ZERO);
      return p(k) && p(_) ? f.ZERO : new f(k, _, n.ONE)
    }
    get x() {
      return this.toAffine().x
    }
    get y() {
      return this.toAffine().y
    }
    static normalizeZ(x) {
      const k = n.invertBatch(x.map(_ => _.pz));
      return x.map((_, p) => _.toAffine(k[p])).map(f.fromAffine)
    }
    static fromHex(x) {
      const k = f.fromAffine(i(ns("pointHex", x)));
      return k.assertValidity(), k
    }
    static fromPrivateKey(x) {
      return f.BASE.multiply(c(x))
    }
    _setWindowSize(x) {
      this._WINDOW_SIZE = x, l.delete(this)
    }
    assertValidity() {
      if (this.is0()) {
        if (t.allowInfinityPoint && !n.is0(this.py)) return;
        throw new Error("bad point: ZERO")
      }
      const {
        x,
        y: k
      } = this.toAffine();
      if (!n.isValid(x) || !n.isValid(k)) throw new Error("bad point: x or y not FE");
      const _ = n.sqr(k),
        p = s(x);
      if (!n.eql(_, p)) throw new Error("bad point: equation left != right");
      if (!this.isTorsionFree()) throw new Error("bad point: not in prime-order subgroup")
    }
    hasEvenY() {
      const {
        y: x
      } = this.toAffine();
      if (n.isOdd) return !n.isOdd(x);
      throw new Error("Field doesn't support isOdd")
    }
    equals(x) {
      u(x);
      const {
        px: k,
        py: _,
        pz: p
      } = this, {
        px: v,
        py: S,
        pz: I
      } = x, A = n.eql(n.mul(k, I), n.mul(v, p)), w = n.eql(n.mul(_, I), n.mul(S, p));
      return A && w
    }
    negate() {
      return new f(this.px, n.neg(this.py), this.pz)
    }
    double() {
      const {
        a: x,
        b: k
      } = t, _ = n.mul(k, ox), {
        px: p,
        py: v,
        pz: S
      } = this;
      let I = n.ZERO,
        A = n.ZERO,
        w = n.ZERO,
        E = n.mul(p, p),
        D = n.mul(v, v),
        $ = n.mul(S, S),
        V = n.mul(p, v);
      return V = n.add(V, V), w = n.mul(p, S), w = n.add(w, w), I = n.mul(x, w), A = n.mul(_, $), A = n.add(I, A), I = n.sub(D, A), A = n.add(D, A), A = n.mul(I, A), I = n.mul(V, I), w = n.mul(_, w), $ = n.mul(x, $), V = n.sub(E, $), V = n.mul(x, V), V = n.add(V, w), w = n.add(E, E), E = n.add(w, E), E = n.add(E, $), E = n.mul(E, V), A = n.add(A, E), $ = n.mul(v, S), $ = n.add($, $), E = n.mul($, V), I = n.sub(I, E), w = n.mul($, D), w = n.add(w, w), w = n.add(w, w), new f(I, A, w)
    }
    add(x) {
      u(x);
      const {
        px: k,
        py: _,
        pz: p
      } = this, {
        px: v,
        py: S,
        pz: I
      } = x;
      let A = n.ZERO,
        w = n.ZERO,
        E = n.ZERO;
      const D = t.a,
        $ = n.mul(t.b, ox);
      let V = n.mul(k, v),
        G = n.mul(_, S),
        L = n.mul(p, I),
        b = n.add(k, _),
        T = n.add(v, S);
      b = n.mul(b, T), T = n.add(V, G), b = n.sub(b, T), T = n.add(k, p);
      let R = n.add(v, I);
      return T = n.mul(T, R), R = n.add(V, L), T = n.sub(T, R), R = n.add(_, p), A = n.add(S, I), R = n.mul(R, A), A = n.add(G, L), R = n.sub(R, A), E = n.mul(D, T), A = n.mul($, L), E = n.add(A, E), A = n.sub(G, E), E = n.add(G, E), w = n.mul(A, E), G = n.add(V, V), G = n.add(G, V), L = n.mul(D, L), T = n.mul($, T), G = n.add(G, L), L = n.sub(V, L), L = n.mul(D, L), T = n.add(T, L), V = n.mul(G, T), w = n.add(w, V), V = n.mul(R, T), A = n.mul(b, A), A = n.sub(A, V), V = n.mul(b, G), E = n.mul(R, E), E = n.add(E, V), new f(A, w, E)
    }
    subtract(x) {
      return this.add(x.negate())
    }
    is0() {
      return this.equals(f.ZERO)
    }
    wNAF(x) {
      return g.wNAFCached(this, l, x, k => {
        const _ = n.invertBatch(k.map(p => p.pz));
        return k.map((p, v) => p.toAffine(_[v])).map(f.fromAffine)
      })
    }
    multiplyUnsafe(x) {
      const k = f.ZERO;
      if (x === fc) return k;
      if (a(x), x === Br) return this;
      const {
        endo: _
      } = t;
      if (!_) return g.unsafeLadder(this, x);
      let {
        k1neg: p,
        k1: v,
        k2neg: S,
        k2: I
      } = _.splitScalar(x), A = k, w = k, E = this;
      for (; v > fc || I > fc;) v & Br && (A = A.add(E)), I & Br && (w = w.add(E)), E = E.double(), v >>= Br, I >>= Br;
      return p && (A = A.negate()), S && (w = w.negate()), w = new f(n.mul(w.px, _.beta), w.py, w.pz), A.add(w)
    }
    multiply(x) {
      a(x);
      let k = x,
        _, p;
      const {
        endo: v
      } = t;
      if (v) {
        const {
          k1neg: S,
          k1: I,
          k2neg: A,
          k2: w
        } = v.splitScalar(k);
        let {
          p: E,
          f: D
        } = this.wNAF(I), {
          p: $,
          f: V
        } = this.wNAF(w);
        E = g.constTimeNegate(S, E), $ = g.constTimeNegate(A, $), $ = new f(n.mul($.px, v.beta), $.py, $.pz), _ = E.add($), p = D.add(V)
      } else {
        const {
          p: S,
          f: I
        } = this.wNAF(k);
        _ = S, p = I
      }
      return f.normalizeZ([_, p])[0]
    }
    multiplyAndAddUnsafe(x, k, _) {
      const p = f.BASE,
        v = (I, A) => A === fc || A === Br || !I.equals(p) ? I.multiplyUnsafe(A) : I.multiply(A),
        S = v(this, k).add(v(x, _));
      return S.is0() ? void 0 : S
    }
    toAffine(x) {
      const {
        px: k,
        py: _,
        pz: p
      } = this, v = this.is0();
      x == null && (x = v ? n.ONE : n.inv(p));
      const S = n.mul(k, x),
        I = n.mul(_, x),
        A = n.mul(p, x);
      if (v) return {
        x: n.ZERO,
        y: n.ZERO
      };
      if (!n.eql(A, n.ONE)) throw new Error("invZ was invalid");
      return {
        x: S,
        y: I
      }
    }
    isTorsionFree() {
      const {
        h: x,
        isTorsionFree: k
      } = t;
      if (x === Br) return !0;
      if (k) return k(f, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve")
    }
    clearCofactor() {
      const {
        h: x,
        clearCofactor: k
      } = t;
      return x === Br ? this : k ? k(f, this) : this.multiplyUnsafe(t.h)
    }
    toRawBytes(x = !0) {
      return this.assertValidity(), r(f, this, x)
    }
    toHex(x = !0) {
      return rm(this.toRawBytes(x))
    }
  }
  f.BASE = new f(t.Gx, t.Gy, n.ONE), f.ZERO = new f(n.ZERO, n.ONE, n.ZERO);
  const h = t.nBitLength,
    g = ORe(f, t.endo ? Math.ceil(h / 2) : h);
  return {
    CURVE: t,
    ProjectivePoint: f,
    normPrivateKeyToScalar: c,
    weierstrassEquation: s,
    isWithinCurveOrder: o
  }
}

function LRe(e) {
  const t = zQ(e);
  return jm(t, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  }), Object.freeze({
    lowS: !0,
    ...t
  })
}

function BRe(e) {
  const t = LRe(e),
    {
      Fp: n,
      n: r
    } = t,
    i = n.BYTES + 1,
    s = 2 * n.BYTES + 1;

  function o(T) {
    return fc < T && T < n.ORDER
  }

  function a(T) {
    return xi(T, r)
  }

  function c(T) {
    return BA(T, r)
  }
  const {
    ProjectivePoint: l,
    normPrivateKeyToScalar: u,
    weierstrassEquation: f,
    isWithinCurveOrder: h
  } = $Re({
    ...t,
    toBytes(T, R, N) {
      const O = R.toAffine(),
        U = n.toBytes(O.x),
        q = Do;
      return N ? q(Uint8Array.from([R.hasEvenY() ? 2 : 3]), U) : q(Uint8Array.from([4]), U, n.toBytes(O.y))
    },
    fromBytes(T) {
      const R = T.length,
        N = T[0],
        O = T.subarray(1);
      if (R === i && (N === 2 || N === 3)) {
        const U = Ps(O);
        if (!o(U)) throw new Error("Point is not on curve");
        const q = f(U);
        let W = n.sqrt(q);
        const M = (W & Br) === Br;
        return (N & 1) === 1 !== M && (W = n.neg(W)), {
          x: U,
          y: W
        }
      } else if (R === s && N === 4) {
        const U = n.fromBytes(O.subarray(0, n.BYTES)),
          q = n.fromBytes(O.subarray(n.BYTES, 2 * n.BYTES));
        return {
          x: U,
          y: q
        }
      } else throw new Error(`Point of length ${R} was invalid. Expected ${i} compressed bytes or ${s} uncompressed bytes`)
    }
  }), g = T => rm(Rd(T, t.nByteLength));

  function y(T) {
    const R = r >> Br;
    return T > R
  }

  function x(T) {
    return y(T) ? a(-T) : T
  }
  const k = (T, R, N) => Ps(T.slice(R, N));
  class _ {
    constructor(R, N, O) {
      this.r = R, this.s = N, this.recovery = O, this.assertValidity()
    }
    static fromCompact(R) {
      const N = t.nByteLength;
      return R = ns("compactSignature", R, N * 2), new _(k(R, 0, N), k(R, N, 2 * N))
    }
    static fromDER(R) {
      const {
        r: N,
        s: O
      } = Lf.toSig(ns("DER", R));
      return new _(N, O)
    }
    assertValidity() {
      if (!h(this.r)) throw new Error("r must be 0 < r < CURVE.n");
      if (!h(this.s)) throw new Error("s must be 0 < s < CURVE.n")
    }
    addRecoveryBit(R) {
      return new _(this.r, this.s, R)
    }
    recoverPublicKey(R) {
      const {
        r: N,
        s: O,
        recovery: U
      } = this, q = w(ns("msgHash", R));
      if (U == null || ![0, 1, 2, 3].includes(U)) throw new Error("recovery id invalid");
      const W = U === 2 || U === 3 ? N + t.n : N;
      if (W >= n.ORDER) throw new Error("recovery id 2 or 3 invalid");
      const M = U & 1 ? "03" : "02",
        Q = l.fromHex(M + g(W)),
        he = c(W),
        H = a(-q * he),
        ne = a(O * he),
        X = l.BASE.multiplyAndAddUnsafe(Q, H, ne);
      if (!X) throw new Error("point at infinify");
      return X.assertValidity(), X
    }
    hasHighS() {
      return y(this.s)
    }
    normalizeS() {
      return this.hasHighS() ? new _(this.r, a(-this.s), this.recovery) : this
    }
    toDERRawBytes() {
      return im(this.toDERHex())
    }
    toDERHex() {
      return Lf.hexFromSig({
        r: this.r,
        s: this.s
      })
    }
    toCompactRawBytes() {
      return im(this.toCompactHex())
    }
    toCompactHex() {
      return g(this.r) + g(this.s)
    }
  }
  const p = {
    isValidPrivateKey(T) {
      try {
        return u(T), !0
      } catch {
        return !1
      }
    },
    normPrivateKeyToScalar: u,
    randomPrivateKey: () => {
      const T = UQ(t.n);
      return PRe(t.randomBytes(T), t.n)
    },
    precompute(T = 8, R = l.BASE) {
      return R._setWindowSize(T), R.multiply(BigInt(3)), R
    }
  };

  function v(T, R = !0) {
    return l.fromPrivateKey(T).toRawBytes(R)
  }

  function S(T) {
    const R = T instanceof Uint8Array,
      N = typeof T == "string",
      O = (R || N) && T.length;
    return R ? O === i || O === s : N ? O === 2 * i || O === 2 * s : T instanceof l
  }

  function I(T, R, N = !0) {
    if (S(T)) throw new Error("first arg must be private key");
    if (!S(R)) throw new Error("second arg must be public key");
    return l.fromHex(R).multiply(u(T)).toRawBytes(N)
  }
  const A = t.bits2int || function (T) {
      const R = Ps(T),
        N = T.length * 8 - t.nBitLength;
      return N > 0 ? R >> BigInt(N) : R
    },
    w = t.bits2int_modN || function (T) {
      return a(A(T))
    },
    E = s_(t.nBitLength);

  function D(T) {
    if (typeof T != "bigint") throw new Error("bigint expected");
    if (!(fc <= T && T < E)) throw new Error(`bigint expected < 2^${t.nBitLength}`);
    return Rd(T, t.nByteLength)
  }

  function $(T, R, N = V) {
    if (["recovered", "canonical"].some(te => te in N)) throw new Error("sign() legacy options not supported");
    const {
      hash: O,
      randomBytes: U
    } = t;
    let {
      lowS: q,
      prehash: W,
      extraEntropy: M
    } = N;
    q == null && (q = !0), T = ns("msgHash", T), W && (T = ns("prehashed msgHash", O(T)));
    const Q = w(T),
      he = u(R),
      H = [D(he), D(Q)];
    if (M != null) {
      const te = M === !0 ? U(n.BYTES) : M;
      H.push(ns("extraEntropy", te))
    }
    const ne = Do(...H),
      X = Q;

    function Z(te) {
      const F = A(te);
      if (!h(F)) return;
      const J = c(F),
        ie = l.BASE.multiply(F).toAffine(),
        ce = a(ie.x);
      if (ce === fc) return;
      const ue = a(J * a(X + ce * he));
      if (ue === fc) return;
      let ge = (ie.x === ce ? 0 : 2) | Number(ie.y & Br),
        et = ue;
      return q && y(ue) && (et = x(ue), ge ^= 1), new _(ce, et, ge)
    }
    return {
      seed: ne,
      k2sig: Z
    }
  }
  const V = {
      lowS: t.lowS,
      prehash: !1
    },
    G = {
      lowS: t.lowS,
      prehash: !1
    };

  function L(T, R, N = V) {
    const {
      seed: O,
      k2sig: U
    } = $(T, R, N), q = t;
    return RQ(q.hash.outputLen, q.nByteLength, q.hmac)(O, U)
  }
  l.BASE._setWindowSize(8);

  function b(T, R, N, O = G) {
    var ie;
    const U = T;
    if (R = ns("msgHash", R), N = ns("publicKey", N), "strict" in O) throw new Error("options.strict was renamed to lowS");
    const {
      lowS: q,
      prehash: W
    } = O;
    let M, Q;
    try {
      if (typeof U == "string" || U instanceof Uint8Array) try {
        M = _.fromDER(U)
      } catch (ce) {
        if (!(ce instanceof Lf.Err)) throw ce;
        M = _.fromCompact(U)
      } else if (typeof U == "object" && typeof U.r == "bigint" && typeof U.s == "bigint") {
        const {
          r: ce,
          s: ue
        } = U;
        M = new _(ce, ue)
      } else throw new Error("PARSE");
      Q = l.fromHex(N)
    } catch (ce) {
      if (ce.message === "PARSE") throw new Error("signature must be Signature instance, Uint8Array or hex string");
      return !1
    }
    if (q && M.hasHighS()) return !1;
    W && (R = t.hash(R));
    const {
      r: he,
      s: H
    } = M, ne = w(R), X = c(H), Z = a(ne * X), te = a(he * X), F = (ie = l.BASE.multiplyAndAddUnsafe(Q, Z, te)) == null ? void 0 : ie.toAffine();
    return F ? a(F.x) === he : !1
  }
  return {
    CURVE: t,
    getPublicKey: v,
    getSharedSecret: I,
    sign: L,
    verify: b,
    ProjectivePoint: l,
    Signature: _,
    utils: p
  }
}

function FRe(e, t) {
  const n = e.ORDER;
  let r = fc;
  for (let y = n - Br; y % Qu === fc; y /= Qu) r += Br;
  const i = r,
    s = Qu << i - Br - Br,
    o = s * Qu,
    a = (n - Br) / o,
    c = (a - Br) / Qu,
    l = o - Br,
    u = s,
    f = e.pow(t, a),
    h = e.pow(t, (a + Br) / Qu);
  let g = (y, x) => {
    let k = f,
      _ = e.pow(x, l),
      p = e.sqr(_);
    p = e.mul(p, x);
    let v = e.mul(y, p);
    v = e.pow(v, c), v = e.mul(v, _), _ = e.mul(v, x), p = e.mul(v, y);
    let S = e.mul(p, _);
    v = e.pow(S, u);
    let I = e.eql(v, e.ONE);
    _ = e.mul(p, h), v = e.mul(S, k), p = e.cmov(_, p, I), S = e.cmov(v, S, I);
    for (let A = i; A > Br; A--) {
      let w = A - Qu;
      w = Qu << w - Br;
      let E = e.pow(S, w);
      const D = e.eql(E, e.ONE);
      _ = e.mul(p, k), k = e.mul(k, k), E = e.mul(S, k), p = e.cmov(_, p, D), S = e.cmov(E, S, D)
    }
    return {
      isValid: I,
      value: p
    }
  };
  if (e.ORDER % I$ === ox) {
    const y = (e.ORDER - ox) / I$,
      x = e.sqrt(e.neg(t));
    g = (k, _) => {
      let p = e.sqr(_);
      const v = e.mul(k, _);
      p = e.mul(p, v);
      let S = e.pow(p, y);
      S = e.mul(S, v);
      const I = e.mul(S, x),
        A = e.mul(e.sqr(S), _),
        w = e.eql(A, k);
      let E = e.cmov(I, S, w);
      return {
        isValid: w,
        value: E
      }
    }
  }
  return g
}

function jRe(e, t) {
  if (BQ(e), !e.isValid(t.A) || !e.isValid(t.B) || !e.isValid(t.Z)) throw new Error("mapToCurveSimpleSWU: invalid opts");
  const n = FRe(e, t.Z);
  if (!e.isOdd) throw new Error("Fp.isOdd is not implemented!");
  return r => {
    let i, s, o, a, c, l, u, f;
    i = e.sqr(r), i = e.mul(i, t.Z), s = e.sqr(i), s = e.add(s, i), o = e.add(s, e.ONE), o = e.mul(o, t.B), a = e.cmov(t.Z, e.neg(s), !e.eql(s, e.ZERO)), a = e.mul(a, t.A), s = e.sqr(o), l = e.sqr(a), c = e.mul(l, t.A), s = e.add(s, c), s = e.mul(s, o), l = e.mul(l, a), c = e.mul(l, t.B), s = e.add(s, c), u = e.mul(i, o);
    const {
      isValid: h,
      value: g
    } = n(s, l);
    f = e.mul(i, r), f = e.mul(f, g), u = e.cmov(u, o, h), f = e.cmov(f, g, h);
    const y = e.isOdd(r) === e.isOdd(f);
    return f = e.cmov(e.neg(f), f, y), u = e.div(u, a), {
      x: u,
      y: f
    }
  }
}

function URe(e) {
  if (e instanceof Uint8Array) return e;
  if (typeof e == "string") return W6(e);
  throw new Error("DST must be Uint8Array or string")
}
const zRe = Ps;

function td(e, t) {
  if (e < 0 || e >= 1 << 8 * t) throw new Error(`bad I2OSP call: value=${e} length=${t}`);
  const n = Array.from({
    length: t
  }).fill(0);
  for (let r = t - 1; r >= 0; r--) n[r] = e & 255, e >>>= 8;
  return new Uint8Array(n)
}

function HRe(e, t) {
  const n = new Uint8Array(e.length);
  for (let r = 0; r < e.length; r++) n[r] = e[r] ^ t[r];
  return n
}

function v2(e) {
  if (!(e instanceof Uint8Array)) throw new Error("Uint8Array expected")
}

function o_(e) {
  if (!Number.isSafeInteger(e)) throw new Error("number expected")
}

function VRe(e, t, n, r) {
  v2(e), v2(t), o_(n), t.length > 255 && (t = r(Do(W6("H2C-OVERSIZE-DST-"), t)));
  const {
    outputLen: i,
    blockLen: s
  } = r, o = Math.ceil(n / i);
  if (o > 255) throw new Error("Invalid xmd length");
  const a = Do(t, td(t.length, 1)),
    c = td(0, s),
    l = td(n, 2),
    u = new Array(o),
    f = r(Do(c, e, l, td(0, 1), a));
  u[0] = r(Do(f, td(1, 1), a));
  for (let g = 1; g <= o; g++) {
    const y = [HRe(f, u[g - 1]), td(g + 1, 1), a];
    u[g] = r(Do(...y))
  }
  return Do(...u).slice(0, n)
}

function WRe(e, t, n, r, i) {
  if (v2(e), v2(t), o_(n), t.length > 255) {
    const s = Math.ceil(2 * r / 8);
    t = i.create({
      dkLen: s
    }).update(W6("H2C-OVERSIZE-DST-")).update(t).digest()
  }
  if (n > 65535 || t.length > 255) throw new Error("expand_message_xof: invalid lenInBytes");
  return i.create({
    dkLen: n
  }).update(e).update(td(n, 2)).update(t).update(td(t.length, 1)).digest()
}

function P$(e, t, n) {
  jm(n, {
    DST: "stringOrUint8Array",
    p: "bigint",
    m: "isSafeInteger",
    k: "isSafeInteger",
    hash: "hash"
  });
  const {
    p: r,
    k: i,
    m: s,
    hash: o,
    expand: a,
    DST: c
  } = n;
  v2(e), o_(t);
  const l = URe(c),
    u = r.toString(2).length,
    f = Math.ceil((u + i) / 8),
    h = t * s * f;
  let g;
  if (a === "xmd") g = VRe(e, l, h, o);
  else if (a === "xof") g = WRe(e, l, h, i, o);
  else if (a === "_internal_pass") g = e;
  else throw new Error('expand must be "xmd" or "xof"');
  const y = new Array(t);
  for (let x = 0; x < t; x++) {
    const k = new Array(s);
    for (let _ = 0; _ < s; _++) {
      const p = f * (_ + x * s),
        v = g.subarray(p, p + f);
      k[_] = xi(zRe(v), r)
    }
    y[x] = k
  }
  return y
}

function qRe(e, t) {
  const n = t.map(r => Array.from(r).reverse());
  return (r, i) => {
    const [s, o, a, c] = n.map(l => l.reduce((u, f) => e.add(e.mul(u, r), f)));
    return r = e.div(s, o), i = e.mul(i, e.div(a, c)), {
      x: r,
      y: i
    }
  }
}

function GRe(e, t, n) {
  if (typeof t != "function") throw new Error("mapToCurve() must be defined");
  return {
    hashToCurve(r, i) {
      const s = P$(r, 2, {
          ...n,
          DST: n.DST,
          ...i
        }),
        o = e.fromAffine(t(s[0])),
        a = e.fromAffine(t(s[1])),
        c = o.add(a).clearCofactor();
      return c.assertValidity(), c
    },
    encodeToCurve(r, i) {
      const s = P$(r, 1, {
          ...n,
          DST: n.encodeDST,
          ...i
        }),
        o = e.fromAffine(t(s[0])).clearCofactor();
      return o.assertValidity(), o
    }
  }
}
let HQ = class extends o7 {
  constructor(t, n) {
    super(), this.finished = !1, this.destroyed = !1, ITe(t);
    const r = E6(n);
    if (this.iHash = t.create(), typeof this.iHash.update != "function") throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const i = this.blockLen,
      s = new Uint8Array(i);
    s.set(r.length > i ? t.create().update(r).digest() : r);
    for (let o = 0; o < s.length; o++) s[o] ^= 54;
    this.iHash.update(s), this.oHash = t.create();
    for (let o = 0; o < s.length; o++) s[o] ^= 106;
    this.oHash.update(s), s.fill(0)
  }
  update(t) {
    return jp(this), this.iHash.update(t), this
  }
  digestInto(t) {
    jp(this), s7(t, this.outputLen), this.finished = !0, this.iHash.digestInto(t), this.oHash.update(t), this.oHash.digestInto(t), this.destroy()
  }
  digest() {
    const t = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(t), t
  }
  _cloneInto(t) {
    t || (t = Object.create(Object.getPrototypeOf(this), {}));
    const {
      oHash: n,
      iHash: r,
      finished: i,
      destroyed: s,
      blockLen: o,
      outputLen: a
    } = this;
    return t = t, t.finished = i, t.destroyed = s, t.blockLen = o, t.outputLen = a, t.oHash = n._cloneInto(t.oHash), t.iHash = r._cloneInto(t.iHash), t
  }
  destroy() {
    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy()
  }
};
const VQ = (e, t, n) => new HQ(e, t).update(n).digest();
VQ.create = (e, t) => new HQ(e, t); /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function KRe(e) {
  return {
    hash: e,
    hmac: (t, ...n) => VQ(e, t, FTe(...n)),
    randomBytes: rK
  }
}

function QRe(e, t) {
  const n = r => BRe({
    ...e,
    ...KRe(r)
  });
  return Object.freeze({
    ...n(t),
    create: n
  })
} /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const q6 = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
  ax = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
  WQ = BigInt(1),
  cx = BigInt(2),
  R$ = (e, t) => (e + t / cx) / t;

function qQ(e) {
  const t = q6,
    n = BigInt(3),
    r = BigInt(6),
    i = BigInt(11),
    s = BigInt(22),
    o = BigInt(23),
    a = BigInt(44),
    c = BigInt(88),
    l = e * e * e % t,
    u = l * l * e % t,
    f = aa(u, n, t) * u % t,
    h = aa(f, n, t) * u % t,
    g = aa(h, cx, t) * l % t,
    y = aa(g, i, t) * g % t,
    x = aa(y, s, t) * y % t,
    k = aa(x, a, t) * x % t,
    _ = aa(k, c, t) * k % t,
    p = aa(_, a, t) * x % t,
    v = aa(p, n, t) * u % t,
    S = aa(v, o, t) * y % t,
    I = aa(S, r, t) * l % t,
    A = aa(I, cx, t);
  if (!Od.eql(Od.sqr(A), e)) throw new Error("Cannot find square root");
  return A
}
const Od = IRe(q6, void 0, void 0, {
    sqrt: qQ
  }),
  Cu = QRe({
    a: BigInt(0),
    b: BigInt(7),
    Fp: Od,
    n: ax,
    Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
    Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
    h: BigInt(1),
    lowS: !0,
    endo: {
      beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
      splitScalar: e => {
        const t = ax,
          n = BigInt("0x3086d221a7d46bcde86c90e49284eb15"),
          r = -WQ * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),
          i = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),
          s = n,
          o = BigInt("0x100000000000000000000000000000000"),
          a = R$(s * e, t),
          c = R$(-r * e, t);
        let l = xi(e - a * n - c * i, t),
          u = xi(-a * r - c * s, t);
        const f = l > o,
          h = u > o;
        if (f && (l = t - l), h && (u = t - u), l > o || u > o) throw new Error("splitScalar: Endomorphism failed, k=" + e);
        return {
          k1neg: f,
          k1: l,
          k2neg: h,
          k2: u
        }
      }
    }
  }, y2),
  G6 = BigInt(0),
  GQ = e => typeof e == "bigint" && G6 < e && e < q6,
  YRe = e => typeof e == "bigint" && G6 < e && e < ax,
  O$ = {};

function lx(e, ...t) {
  let n = O$[e];
  if (n === void 0) {
    const r = y2(Uint8Array.from(e, i => i.charCodeAt(0)));
    n = Do(r, r), O$[e] = n
  }
  return y2(Do(n, ...t))
}
const a_ = e => e.toRawBytes(!0).slice(1),
  FA = e => Rd(e, 32),
  c8 = e => xi(e, q6),
  b2 = e => xi(e, ax),
  c_ = Cu.ProjectivePoint,
  JRe = (e, t, n) => c_.BASE.multiplyAndAddUnsafe(e, t, n);

function jA(e) {
  let t = Cu.utils.normPrivateKeyToScalar(e),
    n = c_.fromPrivateKey(t);
  return {
    scalar: n.hasEvenY() ? t : b2(-t),
    bytes: a_(n)
  }
}

function KQ(e) {
  if (!GQ(e)) throw new Error("bad x: need 0 < x < p");
  const t = c8(e * e),
    n = c8(t * e + BigInt(7));
  let r = qQ(n);
  r % cx !== G6 && (r = c8(-r));
  const i = new c_(e, r, WQ);
  return i.assertValidity(), i
}

function QQ(...e) {
  return b2(Ps(lx("BIP0340/challenge", ...e)))
}

function XRe(e) {
  return jA(e).bytes
}

function ZRe(e, t, n = rK(32)) {
  const r = ns("message", e),
    {
      bytes: i,
      scalar: s
    } = jA(t),
    o = ns("auxRand", n, 32),
    a = FA(s ^ Ps(lx("BIP0340/aux", o))),
    c = lx("BIP0340/nonce", a, i, r),
    l = b2(Ps(c));
  if (l === G6) throw new Error("sign failed: k is zero");
  const {
    bytes: u,
    scalar: f
  } = jA(l), h = QQ(u, i, r), g = new Uint8Array(64);
  if (g.set(u, 0), g.set(FA(b2(f + h * s)), 32), !YQ(g, r, i)) throw new Error("sign: Invalid signature produced");
  return g
}

function YQ(e, t, n) {
  const r = ns("signature", e, 64),
    i = ns("message", t),
    s = ns("publicKey", n, 32);
  try {
    const o = KQ(Ps(s)),
      a = Ps(r.subarray(0, 32));
    if (!GQ(a)) return !1;
    const c = Ps(r.subarray(32, 64));
    if (!YRe(c)) return !1;
    const l = QQ(FA(a), a_(o), i),
      u = JRe(o, c, b2(-l));
    return !(!u || !u.hasEvenY() || u.toAffine().x !== a)
  } catch {
    return !1
  }
}
const eOe = {
    getPublicKey: XRe,
    sign: ZRe,
    verify: YQ,
    utils: {
      randomPrivateKey: Cu.utils.randomPrivateKey,
      lift_x: KQ,
      pointToBytes: a_,
      numberToBytesBE: Rd,
      bytesToNumberBE: Ps,
      taggedHash: lx,
      mod: xi
    }
  },
  tOe = qRe(Od, [
    ["0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7", "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581", "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262", "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"],
    ["0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b", "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14", "0x0000000000000000000000000000000000000000000000000000000000000001"],
    ["0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c", "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3", "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931", "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"],
    ["0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b", "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573", "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f", "0x0000000000000000000000000000000000000000000000000000000000000001"]
  ].map(e => e.map(t => BigInt(t)))),
  nOe = jRe(Od, {
    A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
    B: BigInt("1771"),
    Z: Od.create(BigInt("-11"))
  }),
  JQ = GRe(Cu.ProjectivePoint, e => {
    const {
      x: t,
      y: n
    } = nOe(Od.create(e[0]));
    return tOe(t, n)
  }, {
    DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
    encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
    p: Od.ORDER,
    m: 1,
    k: 128,
    expand: "xmd",
    hash: y2
  }),
  rOe = JQ.hashToCurve,
  iOe = JQ.encodeToCurve,
  sOe = Object.freeze(Object.defineProperty({
    __proto__: null,
    encodeToCurve: iOe,
    hashToCurve: rOe,
    schnorr: eOe,
    secp256k1: Cu
  }, Symbol.toStringTag, {
    value: "Module"
  }));

function oOe(e) {
  const {
    r: t,
    s: n
  } = Cu.Signature.fromCompact(e.slice(2, 130));
  return {
    r: Ct(t, {
      size: 32
    }),
    yParityAndS: Ct(n, {
      size: 32
    })
  }
}

function aOe(e) {
  const {
    r: t,
    s: n
  } = Cu.Signature.fromCompact(e.slice(2, 130)), r = BigInt(`0x${e.slice(130)}`);
  return {
    r: Ct(t, {
      size: 32
    }),
    s: Ct(n, {
      size: 32
    }),
    v: r
  }
}

function cOe(e) {
  const {
    r: t,
    s: n,
    v: r
  } = e, i = r - 27n;
  let s = n;
  if (i === 1n) {
    const o = wu(n);
    o[0] |= 128, s = mo(o)
  }
  return {
    r: t,
    yParityAndS: s
  }
}

function lOe({
  r: e,
  yParityAndS: t
}) {
  return `0x${new Cu.Signature(Jn(e),Jn(t)).toCompactHex()}`
}

function uOe({
  r: e,
  s: t,
  v: n
}) {
  return `0x${new Cu.Signature(Jn(e),Jn(t)).toCompactHex()}${yn(n).slice(2)}`
}
const dOe = Object.freeze(Object.defineProperty({
    __proto__: null,
    AbiConstructorNotFoundError: Yk,
    AbiConstructorParamsNotFoundError: m2,
    AbiDecodingDataSizeInvalidError: bTe,
    AbiDecodingDataSizeTooSmallError: b6,
    AbiDecodingZeroDataError: hy,
    AbiEncodingArrayLengthMismatchError: NG,
    AbiEncodingBytesSizeMismatchError: MG,
    AbiEncodingLengthMismatchError: Jk,
    AbiErrorInputsNotFoundError: $G,
    AbiErrorNotFoundError: kA,
    AbiErrorSignatureNotFoundError: Xk,
    AbiEventNotFoundError: _A,
    AbiEventSignatureEmptyTopicsError: LG,
    AbiEventSignatureNotFoundError: BG,
    AbiFunctionNotFoundError: mh,
    AbiFunctionOutputsNotFoundError: Zk,
    AbiFunctionSignatureNotFoundError: FG,
    BaseError: $e,
    BaseFeeScalarError: TK,
    BlockNotFoundError: E7,
    BytesSizeMismatchError: e7,
    CallExecutionError: w7,
    ChainDisconnectedError: Zp,
    ChainDoesNotSupportContract: ix,
    ChainMismatchError: MK,
    ChainNotFoundError: $K,
    CircularReferenceError: IG,
    ClientChainNotConfiguredError: P7,
    ContractFunctionExecutionError: wK,
    ContractFunctionRevertedError: G3,
    ContractFunctionZeroDataError: xK,
    DataLengthTooLongError: xTe,
    DataLengthTooShortError: ETe,
    DecodeLogDataMismatch: Td,
    DecodeLogTopicsMismatch: Oh,
    Eip1559FeesNotSupportedError: O6,
    EnsAvatarInvalidNftUriError: I0,
    EnsAvatarUnsupportedNamespaceError: WK,
    EnsAvatarUriResolutionError: j6,
    EstimateGasExecutionError: CK,
    ExecutionRevertedError: $f,
    FeeCapTooHighError: Id,
    FeeCapTooLowError: Q3,
    FeeConflictError: pK,
    FilterTypeNotSupportedError: WG,
    HttpRequestError: vd,
    InsufficientFundsError: Z3,
    IntegerOutOfRangeError: GG,
    InternalRpcError: gh,
    IntrinsicGasTooHighError: ex,
    IntrinsicGasTooLowError: tx,
    InvalidAbiDecodingTypeError: UG,
    InvalidAbiEncodingTypeError: jG,
    InvalidAbiItemError: vG,
    InvalidAbiParameterError: wG,
    InvalidAbiParametersError: xG,
    InvalidAbiTypeParameterError: TG,
    InvalidAddressError: go,
    InvalidArrayError: zG,
    InvalidBytesBooleanError: KG,
    InvalidChainIdError: M6,
    InvalidDefinitionTypeError: HG,
    InvalidFunctionModifierError: AG,
    InvalidHexBooleanError: QG,
    InvalidHexValueError: YG,
    InvalidInputRpcError: _d,
    InvalidLegacyVError: y7,
    InvalidModifierError: CG,
    InvalidParameterError: EG,
    InvalidParamsRpcError: Vp,
    InvalidParenthesisError: PG,
    InvalidRequestRpcError: zp,
    InvalidSerializableTransactionError: mK,
    InvalidSerializedTransactionError: k6,
    InvalidSerializedTransactionTypeError: gK,
    InvalidSignatureError: J0,
    InvalidStorageKeySizeError: yK,
    InvalidStructSignatureError: _G,
    JsonRpcVersionUnsupportedError: Yp,
    LimitExceededRpcError: Qp,
    MaxFeePerGasTooLowError: kK,
    MethodNotFoundRpcError: Hp,
    MethodNotSupportedRpcError: Kp,
    NonceMaxValueError: X3,
    NonceTooHighError: Y3,
    NonceTooLowError: J3,
    OffsetOutOfBoundsError: STe,
    ParseRpcError: Up,
    ProviderDisconnectedError: yh,
    ProviderRpcError: Nh,
    RawContractError: _6,
    ResourceNotFoundRpcError: Wp,
    ResourceUnavailableRpcError: qp,
    RpcError: Fs,
    RpcRequestError: I6,
    SizeExceedsPaddingSizeError: n7,
    SizeOverflowError: JG,
    SliceOffsetOutOfBoundsError: t7,
    SolidityProtectedKeywordError: SG,
    SwitchChainError: em,
    TimeoutError: K3,
    TipAboveFeeCapError: nm,
    TransactionExecutionError: vK,
    TransactionNotFoundError: v7,
    TransactionReceiptNotFoundError: b7,
    TransactionRejectedRpcError: Gp,
    TransactionTypeNotSupportedError: nx,
    UnauthorizedProviderError: Jp,
    UnknownNodeError: yy,
    UnknownRpcError: SK,
    UnknownSignatureError: kG,
    UnknownTypeError: bG,
    UnsupportedPackedAbiType: VG,
    UnsupportedProviderMethodError: Xp,
    UrlRequiredError: M7,
    UserRejectedRequestError: Gf,
    WaitForTransactionReceiptTimeoutError: bK,
    WebSocketRequestError: EK,
    assertCurrentChain: O7,
    assertRequest: Lm,
    assertTransactionEIP1559: Y7,
    assertTransactionEIP2930: J7,
    assertTransactionLegacy: X7,
    boolToBytes: XG,
    boolToHex: x6,
    bytesToBigInt: MA,
    bytesToBigint: MA,
    bytesToBool: fQ,
    bytesToHex: mo,
    bytesToNumber: hQ,
    bytesToRlp: B7e,
    bytesToString: pQ,
    ccipFetch: F7,
    checksumAddress: my,
    compactSignatureToHex: lOe,
    compactSignatureToSignature: xRe,
    concat: Da,
    concatBytes: aK,
    concatHex: xu,
    createClient: B6,
    createPublicClient: MQ,
    createTestClient: yIe,
    createTransport: Ey,
    createWalletClient: _Ie,
    custom: qke,
    decodeAbiParameters: Dh,
    decodeDeployData: wRe,
    decodeErrorResult: h7,
    decodeEventLog: Bm,
    decodeFunctionData: R7e,
    decodeFunctionResult: $h,
    defineBlock: IK,
    defineChain: fs,
    defineTransaction: _K,
    defineTransactionReceipt: dQ,
    defineTransactionRequest: xke,
    domainSeparator: P7e,
    encodeAbiParameters: Eu,
    encodeDeployData: H7,
    encodeErrorResult: O7e,
    encodeEventTopics: Mm,
    encodeFunctionData: Su,
    encodeFunctionResult: N7e,
    encodePacked: M7e,
    etherUnits: p7,
    extractChain: T7e,
    fallback: Gke,
    formatBlock: D6,
    formatEther: T6,
    formatGwei: Is,
    formatLog: Na,
    formatTransaction: vy,
    formatTransactionReceipt: V7,
    formatTransactionRequest: Mh,
    formatUnits: g7,
    fromBytes: V7e,
    fromHex: CTe,
    fromRlp: W7,
    getAbiItem: Hd,
    getAddress: kd,
    getChainContractAddress: Lh,
    getContract: Uke,
    getContractAddress: z7e,
    getContractError: tm,
    getCreate2Address: uQ,
    getCreateAddress: lQ,
    getEventSelector: S6,
    getEventSignature: eK,
    getFunctionSelector: Nm,
    getFunctionSignature: i7,
    getSerializedTransactionType: CQ,
    getTransactionType: A7,
    getTypesForEIP712Domain: z6,
    gweiUnits: m7,
    hashDomain: U7,
    hashMessage: Q7,
    hashTypedData: j7,
    hexToBigInt: Jn,
    hexToBool: r7,
    hexToBytes: wu,
    hexToCompactSignature: oOe,
    hexToNumber: Xn,
    hexToRlp: F7e,
    hexToSignature: aOe,
    hexToString: w6,
    http: zK,
    isAddress: Hi,
    isAddressEqual: U6,
    isBytes: NA,
    isHash: gQ,
    isHex: hn,
    keccak256: ii,
    labelhash: VK,
    maxInt104: HIe,
    maxInt112: VIe,
    maxInt120: WIe,
    maxInt128: qIe,
    maxInt136: GIe,
    maxInt144: KIe,
    maxInt152: QIe,
    maxInt16: OIe,
    maxInt160: YIe,
    maxInt168: JIe,
    maxInt176: XIe,
    maxInt184: ZIe,
    maxInt192: ePe,
    maxInt200: tPe,
    maxInt208: nPe,
    maxInt216: rPe,
    maxInt224: iPe,
    maxInt232: sPe,
    maxInt24: DIe,
    maxInt240: oPe,
    maxInt248: aPe,
    maxInt256: cPe,
    maxInt32: NIe,
    maxInt40: MIe,
    maxInt48: $Ie,
    maxInt56: LIe,
    maxInt64: BIe,
    maxInt72: FIe,
    maxInt8: RIe,
    maxInt80: jIe,
    maxInt88: UIe,
    maxInt96: zIe,
    maxUint104: ZPe,
    maxUint112: eRe,
    maxUint120: tRe,
    maxUint128: nRe,
    maxUint136: rRe,
    maxUint144: iRe,
    maxUint152: sRe,
    maxUint16: zPe,
    maxUint160: oRe,
    maxUint168: aRe,
    maxUint176: cRe,
    maxUint184: lRe,
    maxUint192: uRe,
    maxUint200: dRe,
    maxUint208: fRe,
    maxUint216: hRe,
    maxUint224: pRe,
    maxUint232: mRe,
    maxUint24: HPe,
    maxUint240: gRe,
    maxUint248: yRe,
    maxUint256: vRe,
    maxUint32: VPe,
    maxUint40: WPe,
    maxUint48: qPe,
    maxUint56: GPe,
    maxUint64: KPe,
    maxUint72: QPe,
    maxUint8: UPe,
    maxUint80: YPe,
    maxUint88: JPe,
    maxUint96: XPe,
    minInt104: xPe,
    minInt112: EPe,
    minInt120: SPe,
    minInt128: CPe,
    minInt136: APe,
    minInt144: TPe,
    minInt152: kPe,
    minInt16: uPe,
    minInt160: _Pe,
    minInt168: IPe,
    minInt176: PPe,
    minInt184: RPe,
    minInt192: OPe,
    minInt200: DPe,
    minInt208: NPe,
    minInt216: MPe,
    minInt224: $Pe,
    minInt232: LPe,
    minInt24: dPe,
    minInt240: BPe,
    minInt248: FPe,
    minInt256: jPe,
    minInt32: fPe,
    minInt40: hPe,
    minInt48: pPe,
    minInt56: mPe,
    minInt64: gPe,
    minInt72: yPe,
    minInt8: lPe,
    minInt80: vPe,
    minInt88: bPe,
    minInt96: wPe,
    multicall3Abi: rx,
    namehash: T1,
    numberToBytes: ZG,
    numberToHex: Ct,
    offchainLookup: XK,
    offchainLookupAbiItem: B7,
    offchainLookupSignature: JK,
    pad: bc,
    padBytes: qG,
    padHex: wc,
    parseAbi: dTe,
    parseAbiItem: fTe,
    parseAbiParameter: hTe,
    parseAbiParameters: pTe,
    parseEther: y_e,
    parseGwei: v_e,
    parseTransaction: l_e,
    parseUnits: e_,
    presignMessagePrefix: xQ,
    publicActions: NQ,
    recoverAddress: K7,
    recoverMessageAddress: EQ,
    recoverPublicKey: wQ,
    recoverTypedDataAddress: SQ,
    ripemd160: o_e,
    rpcTransactionType: AK,
    serializeAccessList: Z7,
    serializeTransaction: h_e,
    sha256: J7e,
    signatureToCompactSignature: cOe,
    signatureToHex: uOe,
    size: Qr,
    slice: Sr,
    sliceBytes: uK,
    sliceHex: l7,
    stringToBytes: ul,
    stringToHex: py,
    stringify: Ti,
    testActions: $Q,
    toBytes: Bi,
    toHex: yn,
    toRlp: Bh,
    transactionType: S7,
    trim: lo,
    validateTypedData: z7,
    verifyMessage: a_e,
    verifyTypedData: c_e,
    walletActions: LQ,
    webSocket: IIe,
    weiUnits: yke,
    zeroAddress: PIe,
    zeroHash: bRe
  }, Symbol.toStringTag, {
    value: "Module"
  })),
  fOe = Ds(dOe);
var sm = {};
Object.defineProperty(sm, "__esModule", {
  value: !0
});
sm.MAGIC_VALUE_BYTES = sm.MAGIC_VALUE = void 0;
const hOe = "0x1626ba7e";
sm.MAGIC_VALUE = hOe;
const pOe = "0x20c13b0b";
sm.MAGIC_VALUE_BYTES = pOe;
var l_ = {},
  Sy = {},
  vh = {};
Object.defineProperty(vh, "__esModule", {
  value: !0
});
vh.PermissionsError = vh.PERMISSIONS_REQUEST_REJECTED = void 0;
vh.PERMISSIONS_REQUEST_REJECTED = 4001;
class u_ extends Error {
  constructor(t, n, r) {
    super(t), this.code = n, this.data = r, Object.setPrototypeOf(this, u_.prototype)
  }
}
vh.PermissionsError = u_;
Object.defineProperty(Sy, "__esModule", {
  value: !0
});
Sy.Wallet = void 0;
const l8 = Rh,
  Nb = vh;
let mOe = class {
  constructor(t) {
    this.communicator = t
  }
  async getPermissions() {
    return (await this.communicator.send(l8.Methods.wallet_getPermissions, void 0)).data
  }
  async requestPermissions(t) {
    if (!this.isPermissionRequestValid(t)) throw new Nb.PermissionsError("Permissions request is invalid", Nb.PERMISSIONS_REQUEST_REJECTED);
    try {
      return (await this.communicator.send(l8.Methods.wallet_requestPermissions, t)).data
    } catch {
      throw new Nb.PermissionsError("Permissions rejected", Nb.PERMISSIONS_REQUEST_REJECTED)
    }
  }
  isPermissionRequestValid(t) {
    return t.every(n => typeof n == "object" ? Object.keys(n).every(r => !!Object.values(l8.RestrictedMethods).includes(r)) : !1)
  }
};
Sy.Wallet = mOe;
Object.defineProperty(l_, "__esModule", {
  value: !0
});
const gOe = Sy,
  D$ = vh,
  N$ = (e, t) => t.some(n => n.parentCapability === e),
  yOe = () => (e, t, n) => {
    const r = n.value;
    return n.value = async function () {
      const i = new gOe.Wallet(this.communicator);
      let s = await i.getPermissions();
      if (N$(t, s) || (s = await i.requestPermissions([{
          [t]: {}
        }])), !N$(t, s)) throw new D$.PermissionsError("Permissions rejected", D$.PERMISSIONS_REQUEST_REJECTED);
      return r.apply(this)
    }, n
  };
l_.default = yOe;
var vOe = rn && rn.__decorate || function (e, t, n, r) {
    var i = arguments.length,
      s = i < 3 ? t : r === null ? r = Object.getOwnPropertyDescriptor(t, n) : r,
      o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(e, t, n, r);
    else
      for (var a = e.length - 1; a >= 0; a--)(o = e[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(t, n, s) : o(t, n)) || s);
    return i > 3 && s && Object.defineProperty(t, n, s), s
  },
  bOe = rn && rn.__importDefault || function (e) {
    return e && e.__esModule ? e : {
      default: e
    }
  };
Object.defineProperty(g6, "__esModule", {
  value: !0
});
g6.Safe = void 0;
const Mb = fOe,
  M$ = sm,
  Yu = Rh,
  $$ = dy,
  wOe = d6,
  xOe = bOe(l_);
class XQ {
  constructor(t) {
    this.communicator = t
  }
  async getChainInfo() {
    return (await this.communicator.send(Yu.Methods.getChainInfo, void 0)).data
  }
  async getInfo() {
    return (await this.communicator.send(Yu.Methods.getSafeInfo, void 0)).data
  }
  async experimental_getBalances({
    currency: t = "usd"
  } = {}) {
    return (await this.communicator.send(Yu.Methods.getSafeBalances, {
      currency: t
    })).data
  }
  async check1271Signature(t, n = "0x") {
    const r = await this.getInfo(),
      i = (0, Mb.encodeFunctionData)({
        abi: [{
          constant: !1,
          inputs: [{
            name: "_dataHash",
            type: "bytes32"
          }, {
            name: "_signature",
            type: "bytes"
          }],
          name: "isValidSignature",
          outputs: [{
            name: "",
            type: "bytes4"
          }],
          payable: !1,
          stateMutability: "nonpayable",
          type: "function"
        }],
        functionName: "isValidSignature",
        args: [t, n]
      }),
      s = {
        call: $$.RPC_CALLS.eth_call,
        params: [{
          to: r.safeAddress,
          data: i
        }, "latest"]
      };
    try {
      return (await this.communicator.send(Yu.Methods.rpcCall, s)).data.slice(0, 10).toLowerCase() === M$.MAGIC_VALUE
    } catch {
      return !1
    }
  }
  async check1271SignatureBytes(t, n = "0x") {
    const r = await this.getInfo(),
      i = (0, Mb.encodeFunctionData)({
        abi: [{
          constant: !1,
          inputs: [{
            name: "_data",
            type: "bytes"
          }, {
            name: "_signature",
            type: "bytes"
          }],
          name: "isValidSignature",
          outputs: [{
            name: "",
            type: "bytes4"
          }],
          payable: !1,
          stateMutability: "nonpayable",
          type: "function"
        }],
        functionName: "isValidSignature",
        args: [t, n]
      }),
      s = {
        call: $$.RPC_CALLS.eth_call,
        params: [{
          to: r.safeAddress,
          data: i
        }, "latest"]
      };
    try {
      return (await this.communicator.send(Yu.Methods.rpcCall, s)).data.slice(0, 10).toLowerCase() === M$.MAGIC_VALUE_BYTES
    } catch {
      return !1
    }
  }
  calculateMessageHash(t) {
    return (0, Mb.hashMessage)(t)
  }
  calculateTypedMessageHash(t) {
    const n = typeof t.domain.chainId == "object" ? t.domain.chainId.toNumber() : Number(t.domain.chainId);
    let r = t.primaryType;
    if (!r) {
      const i = Object.values(t.types),
        s = Object.keys(t.types).filter(o => i.every(a => a.every(({
          type: c
        }) => c.replace("[", "").replace("]", "") !== o)));
      if (s.length === 0 || s.length > 1) throw new Error("Please specify primaryType");
      r = s[0]
    }
    return (0, Mb.hashTypedData)({
      message: t.message,
      domain: Object.assign(Object.assign({}, t.domain), {
        chainId: n,
        verifyingContract: t.domain.verifyingContract,
        salt: t.domain.salt
      }),
      types: t.types,
      primaryType: r
    })
  }
  async getOffChainSignature(t) {
    return (await this.communicator.send(Yu.Methods.getOffChainSignature, t)).data
  }
  async isMessageSigned(t, n = "0x") {
    let r;
    if (typeof t == "string" && (r = async () => {
        const i = this.calculateMessageHash(t);
        return await this.isMessageHashSigned(i, n)
      }), (0, wOe.isObjectEIP712TypedData)(t) && (r = async () => {
        const i = this.calculateTypedMessageHash(t);
        return await this.isMessageHashSigned(i, n)
      }), r) return await r();
    throw new Error("Invalid message type")
  }
  async isMessageHashSigned(t, n = "0x") {
    const r = [this.check1271Signature.bind(this), this.check1271SignatureBytes.bind(this)];
    for (const i of r)
      if (await i(t, n)) return !0;
    return !1
  }
  async getEnvironmentInfo() {
    return (await this.communicator.send(Yu.Methods.getEnvironmentInfo, void 0)).data
  }
  async requestAddressBook() {
    return (await this.communicator.send(Yu.Methods.requestAddressBook, void 0)).data
  }
}
vOe([(0, xOe.default)()], XQ.prototype, "requestAddressBook", null);
g6.Safe = XQ;
var EOe = rn && rn.__importDefault || function (e) {
  return e && e.__esModule ? e : {
    default: e
  }
};
Object.defineProperty(H3, "__esModule", {
  value: !0
});
const SOe = EOe(Kq),
  COe = u6,
  AOe = m6,
  TOe = g6,
  kOe = Sy;
let _Oe = class {
  constructor(t = {}) {
    const {
      allowedDomains: n = null,
      debug: r = !1
    } = t;
    this.communicator = new SOe.default(n, r), this.eth = new AOe.Eth(this.communicator), this.txs = new COe.TXs(this.communicator), this.safe = new TOe.Safe(this.communicator), this.wallet = new kOe.Wallet(this.communicator)
  }
};
H3.default = _Oe;
(function (e) {
  var t = rn && rn.__createBinding || (Object.create ? function (o, a, c, l) {
      l === void 0 && (l = c);
      var u = Object.getOwnPropertyDescriptor(a, c);
      (!u || ("get" in u ? !a.__esModule : u.writable || u.configurable)) && (u = {
        enumerable: !0,
        get: function () {
          return a[c]
        }
      }), Object.defineProperty(o, l, u)
    } : function (o, a, c, l) {
      l === void 0 && (l = c), o[l] = a[c]
    }),
    n = rn && rn.__exportStar || function (o, a) {
      for (var c in o) c !== "default" && !Object.prototype.hasOwnProperty.call(a, c) && t(a, o, c)
    },
    r = rn && rn.__importDefault || function (o) {
      return o && o.__esModule ? o : {
        default: o
      }
    };
  Object.defineProperty(e, "__esModule", {
    value: !0
  }), e.getSDKVersion = void 0;
  const i = r(H3);
  e.default = i.default, n(H3, e), n(d6, e), n(Rh, e), n(ly, e);
  var s = uy;
  Object.defineProperty(e, "getSDKVersion", {
    enumerable: !0,
    get: function () {
      return s.getSDKVersion
    }
  })
})(Gq);
const ZQ = Vo(Gq);
class Vn extends si.EventEmitter {
  constructor(t, n = window.ethereum, r = !1) {
    super(), this.isActivationInProgress = !1, this.initializeProvider(n), this.name = t.name, this.icon = t.icon, this.installed = t.installed
  }
  initializeProvider(t) {
    var n, r, i, s;
    if (window === void 0) throw new Error("window is not defined. This should not have happened.");
    this.windowProvider = t, (n = this.windowProvider) == null || n.on("connect", async ({
      chainId: o
    }) => {
      await this.calcAccountData()
    }), (r = this.windowProvider) == null || r.on("disconnect", async o => {
      await this.calcAccountData()
    }), (i = this.windowProvider) == null || i.on("chainChanged", async o => {
      await this.calcAccountData()
    }), (s = this.windowProvider) == null || s.on("accountsChanged", async o => {
      if (!o.length) {
        this.account = void 0, this.emit("walletAccountChanged", this);
        return
      }
      await this.calcAccountData()
    })
  }
  async autoConnect() {
    if (window === void 0) throw new Error("window is not defined. This should not have happened.");
    if (!this.windowProvider) throw new Error("provider is not defined.");
    if (!this.isActivationInProgress) try {
      const t = this.windowProvider.selectedAddress;
      vAe({
        address: t || "",
        name: this.name
      }) || await this.calcAccountData()
    } catch (t) {
      throw t
    }
  }
  async connect() {
    var t;
    if (window === void 0) throw new Error("window is not defined. This should not have happened.");
    if (!this.windowProvider) throw new Error("provider is not defined.");
    if (!this.isActivationInProgress) {
      this.isActivationInProgress = !0;
      try {
        await ((t = this.windowProvider) == null ? void 0 : t.request({
          method: "eth_requestAccounts"
        })), await this.calcAccountData()
      } catch (n) {
        throw this.isActivationInProgress = !1, n
      }
      this.isActivationInProgress = !1
    }
  }
  disconnect() {
    this.account = void 0, this.isActivationInProgress = !1
  }
  async switchChain(t) {
    var n, r;
    if (window === void 0) throw new Error("window is not defined. This should not have happened.");
    if (!((n = this.account) != null && n.provider)) throw new Error("provider is not defined.");
    return o6((r = this.account) == null ? void 0 : r.provider, t)
  }
  async addChain(t) {
    var n, r;
    if (window === void 0) throw new Error("window is not defined. This should not have happened.");
    if (!((n = this.account) != null && n.provider)) throw new Error("provider is not defined.");
    return a6((r = this.account) == null ? void 0 : r.provider, t)
  }
  async addToken(t, n) {
    var r, i;
    if (window === void 0) throw new Error("window is not defined. This should not have happened.");
    if (!((r = this.account) != null && r.provider)) throw new Error("provider is not defined.");
    return Kk((i = this.account) == null ? void 0 : i.provider, t, n)
  }
  async calcAccountData() {
    if (!this.windowProvider) throw new Error("provider is not defined.");
    const t = new Y5(this.windowProvider, "any");
    if (!(await t.listAccounts()).length) return;
    const r = t.getSigner();
    this.account = {
      chainId: await r.getChainId(),
      address: await r.getAddress(),
      signer: r,
      provider: t
    }, this.emit("walletAccountChanged", this)
  }
}
var eY = {},
  K6 = {},
  Q6 = {};
Object.defineProperty(Q6, "__esModule", {
  value: !0
});
Q6.getLowerCase = void 0;

function IOe(e) {
  return e && e.toLowerCase()
}
Q6.getLowerCase = IOe;
Object.defineProperty(K6, "__esModule", {
  value: !0
});
K6.SafeAppProvider = void 0;
const POe = si,
  $b = Q6;
class ROe extends POe.EventEmitter {
  constructor(t, n) {
    super(), this.submittedTxs = new Map, this.safe = t, this.sdk = n
  }
  async connect() {
    this.emit("connect", {
      chainId: this.chainId
    })
  }
  async disconnect() {}
  get chainId() {
    return this.safe.chainId
  }
  async request(t) {
    const {
      method: n,
      params: r = []
    } = t;
    switch (n) {
      case "eth_accounts":
        return [this.safe.safeAddress];
      case "net_version":
      case "eth_chainId":
        return `0x${this.chainId.toString(16)}`;
      case "personal_sign": {
        const [c, l] = r;
        if (this.safe.safeAddress.toLowerCase() !== l.toLowerCase()) throw new Error("The address or message hash is invalid");
        const u = await this.sdk.txs.signMessage(c);
        return ("signature" in u ? u.signature : void 0) || "0x"
      }
      case "eth_sign": {
        const [c, l] = r;
        if (this.safe.safeAddress.toLowerCase() !== c.toLowerCase() || !l.startsWith("0x")) throw new Error("The address or message hash is invalid");
        const u = await this.sdk.txs.signMessage(l);
        return ("signature" in u ? u.signature : void 0) || "0x"
      }
      case "eth_signTypedData":
      case "eth_signTypedData_v4": {
        const [c, l] = r, u = typeof l == "string" ? JSON.parse(l) : l;
        if (this.safe.safeAddress.toLowerCase() !== c.toLowerCase()) throw new Error("The address is invalid");
        const f = await this.sdk.txs.signTypedMessage(u);
        return ("signature" in f ? f.signature : void 0) || "0x"
      }
      case "eth_sendTransaction":
        const i = {
          ...r[0],
          value: r[0].value || "0",
          data: r[0].data || "0x"
        };
        typeof i.gas == "string" && i.gas.startsWith("0x") && (i.gas = parseInt(i.gas, 16));
        const s = await this.sdk.txs.send({
          txs: [i],
          params: {
            safeTxGas: i.gas
          }
        });
        return this.submittedTxs.set(s.safeTxHash, {
          from: this.safe.safeAddress,
          hash: s.safeTxHash,
          gas: 0,
          gasPrice: "0x00",
          nonce: 0,
          input: i.data,
          value: i.value,
          to: i.to,
          blockHash: null,
          blockNumber: null,
          transactionIndex: null
        }), s.safeTxHash;
      case "eth_blockNumber":
        return (await this.sdk.eth.getBlockByNumber(["latest"])).number;
      case "eth_getBalance":
        return this.sdk.eth.getBalance([(0, $b.getLowerCase)(r[0]), r[1]]);
      case "eth_getCode":
        return this.sdk.eth.getCode([(0, $b.getLowerCase)(r[0]), r[1]]);
      case "eth_getTransactionCount":
        return this.sdk.eth.getTransactionCount([(0, $b.getLowerCase)(r[0]), r[1]]);
      case "eth_getStorageAt":
        return this.sdk.eth.getStorageAt([(0, $b.getLowerCase)(r[0]), r[1], r[2]]);
      case "eth_getBlockByNumber":
        return this.sdk.eth.getBlockByNumber([r[0], r[1]]);
      case "eth_getBlockByHash":
        return this.sdk.eth.getBlockByHash([r[0], r[1]]);
      case "eth_getTransactionByHash":
        let a = r[0];
        try {
          a = (await this.sdk.txs.getBySafeTxHash(a)).txHash || a
        } catch {}
        return this.submittedTxs.has(a) ? this.submittedTxs.get(a) : this.sdk.eth.getTransactionByHash([a]).then(c => (c && (c.hash = r[0]), c));
      case "eth_getTransactionReceipt": {
        let c = r[0];
        try {
          c = (await this.sdk.txs.getBySafeTxHash(c)).txHash || c
        } catch {}
        return this.sdk.eth.getTransactionReceipt([c]).then(l => (l && (l.transactionHash = r[0]), l))
      }
      case "eth_estimateGas":
        return this.sdk.eth.getEstimateGas(r[0]);
      case "eth_call":
        return this.sdk.eth.call([r[0], r[1]]);
      case "eth_getLogs":
        return this.sdk.eth.getPastLogs([r[0]]);
      case "eth_gasPrice":
        return this.sdk.eth.getGasPrice();
      case "wallet_getPermissions":
        return this.sdk.wallet.getPermissions();
      case "wallet_requestPermissions":
        return this.sdk.wallet.requestPermissions(r[0]);
      case "safe_setSettings":
        return this.sdk.eth.setSafeSettings([r[0]]);
      default:
        throw Error(`"${t.method}" not implemented`)
    }
  }
  send(t, n) {
    t || n("Undefined request"), this.request(t).then(r => n(null, {
      jsonrpc: "2.0",
      id: t.id,
      result: r
    })).catch(r => n(r, null))
  }
}
K6.SafeAppProvider = ROe;
(function (e) {
  Object.defineProperty(e, "__esModule", {
    value: !0
  }), e.SafeAppProvider = void 0;
  var t = K6;
  Object.defineProperty(e, "SafeAppProvider", {
    enumerable: !0,
    get: function () {
      return t.SafeAppProvider
    }
  })
})(eY);
class OOe extends si.EventEmitter {
  constructor(t) {
    super(), this.isActivationInProgress = !1, this.autoConnect = async () => {
      await this.calcAccountData()
    }, this.disconnect = () => {
      this.account = void 0
    }, this.connect = async () => {
      await this.calcAccountData()
    }, this.switchChain = () => (console.warn("Method switchChain not allowed"), null), this.addChain = () => (console.warn("Method addChain not allowed"), null), this.addToken = () => (console.warn("Method addToken not allowed"), null), this.name = t.name, this.icon = t.icon, this.installed = t.installed, this.calcAccountData()
  }
  async calcAccountData() {
    const t = new ZQ,
      n = await t.safe.getInfo(),
      r = {
        safeAddress: n.safeAddress,
        chainId: n.chainId,
        threshold: n.threshold,
        owners: n.owners,
        isReadOnly: n.isReadOnly
      },
      i = new eY.SafeAppProvider(r, t),
      s = new Y5(i),
      o = s.getSigner();
    this.account = {
      chainId: n.chainId,
      address: n.safeAddress,
      signer: o,
      provider: s,
      isMultisigWallet: !0
    }, this.emit("walletAccountChanged", this)
  }
}
var d_ = {},
  Y6 = {},
  sn = {},
  tY = {};
(function (e) {
  Object.defineProperty(e, "__esModule", {
    value: !0
  });

  function t(a, c) {
    var l = a >>> 16 & 65535,
      u = a & 65535,
      f = c >>> 16 & 65535,
      h = c & 65535;
    return u * h + (l * h + u * f << 16 >>> 0) | 0
  }
  e.mul = Math.imul || t;

  function n(a, c) {
    return a + c | 0
  }
  e.add = n;

  function r(a, c) {
    return a - c | 0
  }
  e.sub = r;

  function i(a, c) {
    return a << c | a >>> 32 - c
  }
  e.rotl = i;

  function s(a, c) {
    return a << 32 - c | a >>> c
  }
  e.rotr = s;

  function o(a) {
    return typeof a == "number" && isFinite(a) && Math.floor(a) === a
  }
  e.isInteger = Number.isInteger || o, e.MAX_SAFE_INTEGER = 9007199254740991, e.isSafeInteger = function (a) {
    return e.isInteger(a) && a >= -e.MAX_SAFE_INTEGER && a <= e.MAX_SAFE_INTEGER
  }
})(tY);
Object.defineProperty(sn, "__esModule", {
  value: !0
});
var nY = tY;

function DOe(e, t) {
  return t === void 0 && (t = 0), (e[t + 0] << 8 | e[t + 1]) << 16 >> 16
}
sn.readInt16BE = DOe;

function NOe(e, t) {
  return t === void 0 && (t = 0), (e[t + 0] << 8 | e[t + 1]) >>> 0
}
sn.readUint16BE = NOe;

function MOe(e, t) {
  return t === void 0 && (t = 0), (e[t + 1] << 8 | e[t]) << 16 >> 16
}
sn.readInt16LE = MOe;

function $Oe(e, t) {
  return t === void 0 && (t = 0), (e[t + 1] << 8 | e[t]) >>> 0
}
sn.readUint16LE = $Oe;

function rY(e, t, n) {
  return t === void 0 && (t = new Uint8Array(2)), n === void 0 && (n = 0), t[n + 0] = e >>> 8, t[n + 1] = e >>> 0, t
}
sn.writeUint16BE = rY;
sn.writeInt16BE = rY;

function iY(e, t, n) {
  return t === void 0 && (t = new Uint8Array(2)), n === void 0 && (n = 0), t[n + 0] = e >>> 0, t[n + 1] = e >>> 8, t
}
sn.writeUint16LE = iY;
sn.writeInt16LE = iY;

function UA(e, t) {
  return t === void 0 && (t = 0), e[t] << 24 | e[t + 1] << 16 | e[t + 2] << 8 | e[t + 3]
}
sn.readInt32BE = UA;

function zA(e, t) {
  return t === void 0 && (t = 0), (e[t] << 24 | e[t + 1] << 16 | e[t + 2] << 8 | e[t + 3]) >>> 0
}
sn.readUint32BE = zA;

function HA(e, t) {
  return t === void 0 && (t = 0), e[t + 3] << 24 | e[t + 2] << 16 | e[t + 1] << 8 | e[t]
}
sn.readInt32LE = HA;

function VA(e, t) {
  return t === void 0 && (t = 0), (e[t + 3] << 24 | e[t + 2] << 16 | e[t + 1] << 8 | e[t]) >>> 0
}
sn.readUint32LE = VA;

function ux(e, t, n) {
  return t === void 0 && (t = new Uint8Array(4)), n === void 0 && (n = 0), t[n + 0] = e >>> 24, t[n + 1] = e >>> 16, t[n + 2] = e >>> 8, t[n + 3] = e >>> 0, t
}
sn.writeUint32BE = ux;
sn.writeInt32BE = ux;

function dx(e, t, n) {
  return t === void 0 && (t = new Uint8Array(4)), n === void 0 && (n = 0), t[n + 0] = e >>> 0, t[n + 1] = e >>> 8, t[n + 2] = e >>> 16, t[n + 3] = e >>> 24, t
}
sn.writeUint32LE = dx;
sn.writeInt32LE = dx;

function LOe(e, t) {
  t === void 0 && (t = 0);
  var n = UA(e, t),
    r = UA(e, t + 4);
  return n * 4294967296 + r - (r >> 31) * 4294967296
}
sn.readInt64BE = LOe;

function BOe(e, t) {
  t === void 0 && (t = 0);
  var n = zA(e, t),
    r = zA(e, t + 4);
  return n * 4294967296 + r
}
sn.readUint64BE = BOe;

function FOe(e, t) {
  t === void 0 && (t = 0);
  var n = HA(e, t),
    r = HA(e, t + 4);
  return r * 4294967296 + n - (n >> 31) * 4294967296
}
sn.readInt64LE = FOe;

function jOe(e, t) {
  t === void 0 && (t = 0);
  var n = VA(e, t),
    r = VA(e, t + 4);
  return r * 4294967296 + n
}
sn.readUint64LE = jOe;

function sY(e, t, n) {
  return t === void 0 && (t = new Uint8Array(8)), n === void 0 && (n = 0), ux(e / 4294967296 >>> 0, t, n), ux(e >>> 0, t, n + 4), t
}
sn.writeUint64BE = sY;
sn.writeInt64BE = sY;

function oY(e, t, n) {
  return t === void 0 && (t = new Uint8Array(8)), n === void 0 && (n = 0), dx(e >>> 0, t, n), dx(e / 4294967296 >>> 0, t, n + 4), t
}
sn.writeUint64LE = oY;
sn.writeInt64LE = oY;

function UOe(e, t, n) {
  if (n === void 0 && (n = 0), e % 8 !== 0) throw new Error("readUintBE supports only bitLengths divisible by 8");
  if (e / 8 > t.length - n) throw new Error("readUintBE: array is too short for the given bitLength");
  for (var r = 0, i = 1, s = e / 8 + n - 1; s >= n; s--) r += t[s] * i, i *= 256;
  return r
}
sn.readUintBE = UOe;

function zOe(e, t, n) {
  if (n === void 0 && (n = 0), e % 8 !== 0) throw new Error("readUintLE supports only bitLengths divisible by 8");
  if (e / 8 > t.length - n) throw new Error("readUintLE: array is too short for the given bitLength");
  for (var r = 0, i = 1, s = n; s < n + e / 8; s++) r += t[s] * i, i *= 256;
  return r
}
sn.readUintLE = zOe;

function HOe(e, t, n, r) {
  if (n === void 0 && (n = new Uint8Array(e / 8)), r === void 0 && (r = 0), e % 8 !== 0) throw new Error("writeUintBE supports only bitLengths divisible by 8");
  if (!nY.isSafeInteger(t)) throw new Error("writeUintBE value must be an integer");
  for (var i = 1, s = e / 8 + r - 1; s >= r; s--) n[s] = t / i & 255, i *= 256;
  return n
}
sn.writeUintBE = HOe;

function VOe(e, t, n, r) {
  if (n === void 0 && (n = new Uint8Array(e / 8)), r === void 0 && (r = 0), e % 8 !== 0) throw new Error("writeUintLE supports only bitLengths divisible by 8");
  if (!nY.isSafeInteger(t)) throw new Error("writeUintLE value must be an integer");
  for (var i = 1, s = r; s < r + e / 8; s++) n[s] = t / i & 255, i *= 256;
  return n
}
sn.writeUintLE = VOe;

function WOe(e, t) {
  t === void 0 && (t = 0);
  var n = new DataView(e.buffer, e.byteOffset, e.byteLength);
  return n.getFloat32(t)
}
sn.readFloat32BE = WOe;

function qOe(e, t) {
  t === void 0 && (t = 0);
  var n = new DataView(e.buffer, e.byteOffset, e.byteLength);
  return n.getFloat32(t, !0)
}
sn.readFloat32LE = qOe;

function GOe(e, t) {
  t === void 0 && (t = 0);
  var n = new DataView(e.buffer, e.byteOffset, e.byteLength);
  return n.getFloat64(t)
}
sn.readFloat64BE = GOe;

function KOe(e, t) {
  t === void 0 && (t = 0);
  var n = new DataView(e.buffer, e.byteOffset, e.byteLength);
  return n.getFloat64(t, !0)
}
sn.readFloat64LE = KOe;

function QOe(e, t, n) {
  t === void 0 && (t = new Uint8Array(4)), n === void 0 && (n = 0);
  var r = new DataView(t.buffer, t.byteOffset, t.byteLength);
  return r.setFloat32(n, e), t
}
sn.writeFloat32BE = QOe;

function YOe(e, t, n) {
  t === void 0 && (t = new Uint8Array(4)), n === void 0 && (n = 0);
  var r = new DataView(t.buffer, t.byteOffset, t.byteLength);
  return r.setFloat32(n, e, !0), t
}
sn.writeFloat32LE = YOe;

function JOe(e, t, n) {
  t === void 0 && (t = new Uint8Array(8)), n === void 0 && (n = 0);
  var r = new DataView(t.buffer, t.byteOffset, t.byteLength);
  return r.setFloat64(n, e), t
}
sn.writeFloat64BE = JOe;

function XOe(e, t, n) {
  t === void 0 && (t = new Uint8Array(8)), n === void 0 && (n = 0);
  var r = new DataView(t.buffer, t.byteOffset, t.byteLength);
  return r.setFloat64(n, e, !0), t
}
sn.writeFloat64LE = XOe;
var Qo = {};
Object.defineProperty(Qo, "__esModule", {
  value: !0
});

function ZOe(e) {
  for (var t = 0; t < e.length; t++) e[t] = 0;
  return e
}
Qo.wipe = ZOe;
Object.defineProperty(Y6, "__esModule", {
  value: !0
});
var Zi = sn,
  WA = Qo,
  eDe = 20;

function tDe(e, t, n) {
  for (var r = 1634760805, i = 857760878, s = 2036477234, o = 1797285236, a = n[3] << 24 | n[2] << 16 | n[1] << 8 | n[0], c = n[7] << 24 | n[6] << 16 | n[5] << 8 | n[4], l = n[11] << 24 | n[10] << 16 | n[9] << 8 | n[8], u = n[15] << 24 | n[14] << 16 | n[13] << 8 | n[12], f = n[19] << 24 | n[18] << 16 | n[17] << 8 | n[16], h = n[23] << 24 | n[22] << 16 | n[21] << 8 | n[20], g = n[27] << 24 | n[26] << 16 | n[25] << 8 | n[24], y = n[31] << 24 | n[30] << 16 | n[29] << 8 | n[28], x = t[3] << 24 | t[2] << 16 | t[1] << 8 | t[0], k = t[7] << 24 | t[6] << 16 | t[5] << 8 | t[4], _ = t[11] << 24 | t[10] << 16 | t[9] << 8 | t[8], p = t[15] << 24 | t[14] << 16 | t[13] << 8 | t[12], v = r, S = i, I = s, A = o, w = a, E = c, D = l, $ = u, V = f, G = h, L = g, b = y, T = x, R = k, N = _, O = p, U = 0; U < eDe; U += 2) v = v + w | 0, T ^= v, T = T >>> 16 | T << 16, V = V + T | 0, w ^= V, w = w >>> 20 | w << 12, S = S + E | 0, R ^= S, R = R >>> 16 | R << 16, G = G + R | 0, E ^= G, E = E >>> 20 | E << 12, I = I + D | 0, N ^= I, N = N >>> 16 | N << 16, L = L + N | 0, D ^= L, D = D >>> 20 | D << 12, A = A + $ | 0, O ^= A, O = O >>> 16 | O << 16, b = b + O | 0, $ ^= b, $ = $ >>> 20 | $ << 12, I = I + D | 0, N ^= I, N = N >>> 24 | N << 8, L = L + N | 0, D ^= L, D = D >>> 25 | D << 7, A = A + $ | 0, O ^= A, O = O >>> 24 | O << 8, b = b + O | 0, $ ^= b, $ = $ >>> 25 | $ << 7, S = S + E | 0, R ^= S, R = R >>> 24 | R << 8, G = G + R | 0, E ^= G, E = E >>> 25 | E << 7, v = v + w | 0, T ^= v, T = T >>> 24 | T << 8, V = V + T | 0, w ^= V, w = w >>> 25 | w << 7, v = v + E | 0, O ^= v, O = O >>> 16 | O << 16, L = L + O | 0, E ^= L, E = E >>> 20 | E << 12, S = S + D | 0, T ^= S, T = T >>> 16 | T << 16, b = b + T | 0, D ^= b, D = D >>> 20 | D << 12, I = I + $ | 0, R ^= I, R = R >>> 16 | R << 16, V = V + R | 0, $ ^= V, $ = $ >>> 20 | $ << 12, A = A + w | 0, N ^= A, N = N >>> 16 | N << 16, G = G + N | 0, w ^= G, w = w >>> 20 | w << 12, I = I + $ | 0, R ^= I, R = R >>> 24 | R << 8, V = V + R | 0, $ ^= V, $ = $ >>> 25 | $ << 7, A = A + w | 0, N ^= A, N = N >>> 24 | N << 8, G = G + N | 0, w ^= G, w = w >>> 25 | w << 7, S = S + D | 0, T ^= S, T = T >>> 24 | T << 8, b = b + T | 0, D ^= b, D = D >>> 25 | D << 7, v = v + E | 0, O ^= v, O = O >>> 24 | O << 8, L = L + O | 0, E ^= L, E = E >>> 25 | E << 7;
  Zi.writeUint32LE(v + r | 0, e, 0), Zi.writeUint32LE(S + i | 0, e, 4), Zi.writeUint32LE(I + s | 0, e, 8), Zi.writeUint32LE(A + o | 0, e, 12), Zi.writeUint32LE(w + a | 0, e, 16), Zi.writeUint32LE(E + c | 0, e, 20), Zi.writeUint32LE(D + l | 0, e, 24), Zi.writeUint32LE($ + u | 0, e, 28), Zi.writeUint32LE(V + f | 0, e, 32), Zi.writeUint32LE(G + h | 0, e, 36), Zi.writeUint32LE(L + g | 0, e, 40), Zi.writeUint32LE(b + y | 0, e, 44), Zi.writeUint32LE(T + x | 0, e, 48), Zi.writeUint32LE(R + k | 0, e, 52), Zi.writeUint32LE(N + _ | 0, e, 56), Zi.writeUint32LE(O + p | 0, e, 60)
}

function aY(e, t, n, r, i) {
  if (i === void 0 && (i = 0), e.length !== 32) throw new Error("ChaCha: key size must be 32 bytes");
  if (r.length < n.length) throw new Error("ChaCha: destination is shorter than source");
  var s, o;
  if (i === 0) {
    if (t.length !== 8 && t.length !== 12) throw new Error("ChaCha nonce must be 8 or 12 bytes");
    s = new Uint8Array(16), o = s.length - t.length, s.set(t, o)
  } else {
    if (t.length !== 16) throw new Error("ChaCha nonce with counter must be 16 bytes");
    s = t, o = i
  }
  for (var a = new Uint8Array(64), c = 0; c < n.length; c += 64) {
    tDe(a, s, e);
    for (var l = c; l < c + 64 && l < n.length; l++) r[l] = n[l] ^ a[l - c];
    rDe(s, 0, o)
  }
  return WA.wipe(a), i === 0 && WA.wipe(s), r
}
Y6.streamXOR = aY;

function nDe(e, t, n, r) {
  return r === void 0 && (r = 0), WA.wipe(n), aY(e, t, n, n, r)
}
Y6.stream = nDe;

function rDe(e, t, n) {
  for (var r = 1; n--;) r = r + (e[t] & 255) | 0, e[t] = r & 255, r >>>= 8, t++;
  if (r > 0) throw new Error("ChaCha: counter overflow")
}
var cY = {},
  Vd = {};
Object.defineProperty(Vd, "__esModule", {
  value: !0
});

function iDe(e, t, n) {
  return ~(e - 1) & t | e - 1 & n
}
Vd.select = iDe;

function sDe(e, t) {
  return (e | 0) - (t | 0) - 1 >>> 31 & 1
}
Vd.lessOrEqual = sDe;

function lY(e, t) {
  if (e.length !== t.length) return 0;
  for (var n = 0, r = 0; r < e.length; r++) n |= e[r] ^ t[r];
  return 1 & n - 1 >>> 8
}
Vd.compare = lY;

function oDe(e, t) {
  return e.length === 0 || t.length === 0 ? !1 : lY(e, t) !== 0
}
Vd.equal = oDe;
(function (e) {
  Object.defineProperty(e, "__esModule", {
    value: !0
  });
  var t = Vd,
    n = Qo;
  e.DIGEST_LENGTH = 16;
  var r = function () {
    function o(a) {
      this.digestLength = e.DIGEST_LENGTH, this._buffer = new Uint8Array(16), this._r = new Uint16Array(10), this._h = new Uint16Array(10), this._pad = new Uint16Array(8), this._leftover = 0, this._fin = 0, this._finished = !1;
      var c = a[0] | a[1] << 8;
      this._r[0] = c & 8191;
      var l = a[2] | a[3] << 8;
      this._r[1] = (c >>> 13 | l << 3) & 8191;
      var u = a[4] | a[5] << 8;
      this._r[2] = (l >>> 10 | u << 6) & 7939;
      var f = a[6] | a[7] << 8;
      this._r[3] = (u >>> 7 | f << 9) & 8191;
      var h = a[8] | a[9] << 8;
      this._r[4] = (f >>> 4 | h << 12) & 255, this._r[5] = h >>> 1 & 8190;
      var g = a[10] | a[11] << 8;
      this._r[6] = (h >>> 14 | g << 2) & 8191;
      var y = a[12] | a[13] << 8;
      this._r[7] = (g >>> 11 | y << 5) & 8065;
      var x = a[14] | a[15] << 8;
      this._r[8] = (y >>> 8 | x << 8) & 8191, this._r[9] = x >>> 5 & 127, this._pad[0] = a[16] | a[17] << 8, this._pad[1] = a[18] | a[19] << 8, this._pad[2] = a[20] | a[21] << 8, this._pad[3] = a[22] | a[23] << 8, this._pad[4] = a[24] | a[25] << 8, this._pad[5] = a[26] | a[27] << 8, this._pad[6] = a[28] | a[29] << 8, this._pad[7] = a[30] | a[31] << 8
    }
    return o.prototype._blocks = function (a, c, l) {
      for (var u = this._fin ? 0 : 2048, f = this._h[0], h = this._h[1], g = this._h[2], y = this._h[3], x = this._h[4], k = this._h[5], _ = this._h[6], p = this._h[7], v = this._h[8], S = this._h[9], I = this._r[0], A = this._r[1], w = this._r[2], E = this._r[3], D = this._r[4], $ = this._r[5], V = this._r[6], G = this._r[7], L = this._r[8], b = this._r[9]; l >= 16;) {
        var T = a[c + 0] | a[c + 1] << 8;
        f += T & 8191;
        var R = a[c + 2] | a[c + 3] << 8;
        h += (T >>> 13 | R << 3) & 8191;
        var N = a[c + 4] | a[c + 5] << 8;
        g += (R >>> 10 | N << 6) & 8191;
        var O = a[c + 6] | a[c + 7] << 8;
        y += (N >>> 7 | O << 9) & 8191;
        var U = a[c + 8] | a[c + 9] << 8;
        x += (O >>> 4 | U << 12) & 8191, k += U >>> 1 & 8191;
        var q = a[c + 10] | a[c + 11] << 8;
        _ += (U >>> 14 | q << 2) & 8191;
        var W = a[c + 12] | a[c + 13] << 8;
        p += (q >>> 11 | W << 5) & 8191;
        var M = a[c + 14] | a[c + 15] << 8;
        v += (W >>> 8 | M << 8) & 8191, S += M >>> 5 | u;
        var Q = 0,
          he = Q;
        he += f * I, he += h * (5 * b), he += g * (5 * L), he += y * (5 * G), he += x * (5 * V), Q = he >>> 13, he &= 8191, he += k * (5 * $), he += _ * (5 * D), he += p * (5 * E), he += v * (5 * w), he += S * (5 * A), Q += he >>> 13, he &= 8191;
        var H = Q;
        H += f * A, H += h * I, H += g * (5 * b), H += y * (5 * L), H += x * (5 * G), Q = H >>> 13, H &= 8191, H += k * (5 * V), H += _ * (5 * $), H += p * (5 * D), H += v * (5 * E), H += S * (5 * w), Q += H >>> 13, H &= 8191;
        var ne = Q;
        ne += f * w, ne += h * A, ne += g * I, ne += y * (5 * b), ne += x * (5 * L), Q = ne >>> 13, ne &= 8191, ne += k * (5 * G), ne += _ * (5 * V), ne += p * (5 * $), ne += v * (5 * D), ne += S * (5 * E), Q += ne >>> 13, ne &= 8191;
        var X = Q;
        X += f * E, X += h * w, X += g * A, X += y * I, X += x * (5 * b), Q = X >>> 13, X &= 8191, X += k * (5 * L), X += _ * (5 * G), X += p * (5 * V), X += v * (5 * $), X += S * (5 * D), Q += X >>> 13, X &= 8191;
        var Z = Q;
        Z += f * D, Z += h * E, Z += g * w, Z += y * A, Z += x * I, Q = Z >>> 13, Z &= 8191, Z += k * (5 * b), Z += _ * (5 * L), Z += p * (5 * G), Z += v * (5 * V), Z += S * (5 * $), Q += Z >>> 13, Z &= 8191;
        var te = Q;
        te += f * $, te += h * D, te += g * E, te += y * w, te += x * A, Q = te >>> 13, te &= 8191, te += k * I, te += _ * (5 * b), te += p * (5 * L), te += v * (5 * G), te += S * (5 * V), Q += te >>> 13, te &= 8191;
        var F = Q;
        F += f * V, F += h * $, F += g * D, F += y * E, F += x * w, Q = F >>> 13, F &= 8191, F += k * A, F += _ * I, F += p * (5 * b), F += v * (5 * L), F += S * (5 * G), Q += F >>> 13, F &= 8191;
        var J = Q;
        J += f * G, J += h * V, J += g * $, J += y * D, J += x * E, Q = J >>> 13, J &= 8191, J += k * w, J += _ * A, J += p * I, J += v * (5 * b), J += S * (5 * L), Q += J >>> 13, J &= 8191;
        var ie = Q;
        ie += f * L, ie += h * G, ie += g * V, ie += y * $, ie += x * D, Q = ie >>> 13, ie &= 8191, ie += k * E, ie += _ * w, ie += p * A, ie += v * I, ie += S * (5 * b), Q += ie >>> 13, ie &= 8191;
        var ce = Q;
        ce += f * b, ce += h * L, ce += g * G, ce += y * V, ce += x * $, Q = ce >>> 13, ce &= 8191, ce += k * D, ce += _ * E, ce += p * w, ce += v * A, ce += S * I, Q += ce >>> 13, ce &= 8191, Q = (Q << 2) + Q | 0, Q = Q + he | 0, he = Q & 8191, Q = Q >>> 13, H += Q, f = he, h = H, g = ne, y = X, x = Z, k = te, _ = F, p = J, v = ie, S = ce, c += 16, l -= 16
      }
      this._h[0] = f, this._h[1] = h, this._h[2] = g, this._h[3] = y, this._h[4] = x, this._h[5] = k, this._h[6] = _, this._h[7] = p, this._h[8] = v, this._h[9] = S
    }, o.prototype.finish = function (a, c) {
      c === void 0 && (c = 0);
      var l = new Uint16Array(10),
        u, f, h, g;
      if (this._leftover) {
        for (g = this._leftover, this._buffer[g++] = 1; g < 16; g++) this._buffer[g] = 0;
        this._fin = 1, this._blocks(this._buffer, 0, 16)
      }
      for (u = this._h[1] >>> 13, this._h[1] &= 8191, g = 2; g < 10; g++) this._h[g] += u, u = this._h[g] >>> 13, this._h[g] &= 8191;
      for (this._h[0] += u * 5, u = this._h[0] >>> 13, this._h[0] &= 8191, this._h[1] += u, u = this._h[1] >>> 13, this._h[1] &= 8191, this._h[2] += u, l[0] = this._h[0] + 5, u = l[0] >>> 13, l[0] &= 8191, g = 1; g < 10; g++) l[g] = this._h[g] + u, u = l[g] >>> 13, l[g] &= 8191;
      for (l[9] -= 8192, f = (u ^ 1) - 1, g = 0; g < 10; g++) l[g] &= f;
      for (f = ~f, g = 0; g < 10; g++) this._h[g] = this._h[g] & f | l[g];
      for (this._h[0] = (this._h[0] | this._h[1] << 13) & 65535, this._h[1] = (this._h[1] >>> 3 | this._h[2] << 10) & 65535, this._h[2] = (this._h[2] >>> 6 | this._h[3] << 7) & 65535, this._h[3] = (this._h[3] >>> 9 | this._h[4] << 4) & 65535, this._h[4] = (this._h[4] >>> 12 | this._h[5] << 1 | this._h[6] << 14) & 65535, this._h[5] = (this._h[6] >>> 2 | this._h[7] << 11) & 65535, this._h[6] = (this._h[7] >>> 5 | this._h[8] << 8) & 65535, this._h[7] = (this._h[8] >>> 8 | this._h[9] << 5) & 65535, h = this._h[0] + this._pad[0], this._h[0] = h & 65535, g = 1; g < 8; g++) h = (this._h[g] + this._pad[g] | 0) + (h >>> 16) | 0, this._h[g] = h & 65535;
      return a[c + 0] = this._h[0] >>> 0, a[c + 1] = this._h[0] >>> 8, a[c + 2] = this._h[1] >>> 0, a[c + 3] = this._h[1] >>> 8, a[c + 4] = this._h[2] >>> 0, a[c + 5] = this._h[2] >>> 8, a[c + 6] = this._h[3] >>> 0, a[c + 7] = this._h[3] >>> 8, a[c + 8] = this._h[4] >>> 0, a[c + 9] = this._h[4] >>> 8, a[c + 10] = this._h[5] >>> 0, a[c + 11] = this._h[5] >>> 8, a[c + 12] = this._h[6] >>> 0, a[c + 13] = this._h[6] >>> 8, a[c + 14] = this._h[7] >>> 0, a[c + 15] = this._h[7] >>> 8, this._finished = !0, this
    }, o.prototype.update = function (a) {
      var c = 0,
        l = a.length,
        u;
      if (this._leftover) {
        u = 16 - this._leftover, u > l && (u = l);
        for (var f = 0; f < u; f++) this._buffer[this._leftover + f] = a[c + f];
        if (l -= u, c += u, this._leftover += u, this._leftover < 16) return this;
        this._blocks(this._buffer, 0, 16), this._leftover = 0
      }
      if (l >= 16 && (u = l - l % 16, this._blocks(a, c, u), c += u, l -= u), l) {
        for (var f = 0; f < l; f++) this._buffer[this._leftover + f] = a[c + f];
        this._leftover += l
      }
      return this
    }, o.prototype.digest = function () {
      if (this._finished) throw new Error("Poly1305 was finished");
      var a = new Uint8Array(16);
      return this.finish(a), a
    }, o.prototype.clean = function () {
      return n.wipe(this._buffer), n.wipe(this._r), n.wipe(this._h), n.wipe(this._pad), this._leftover = 0, this._fin = 0, this._finished = !0, this
    }, o
  }();
  e.Poly1305 = r;

  function i(o, a) {
    var c = new r(o);
    c.update(a);
    var l = c.digest();
    return c.clean(), l
  }
  e.oneTimeAuth = i;

  function s(o, a) {
    return o.length !== e.DIGEST_LENGTH || a.length !== e.DIGEST_LENGTH ? !1 : t.equal(o, a)
  }
  e.equal = s
})(cY);
(function (e) {
  Object.defineProperty(e, "__esModule", {
    value: !0
  });
  var t = Y6,
    n = cY,
    r = Qo,
    i = sn,
    s = Vd;
  e.KEY_LENGTH = 32, e.NONCE_LENGTH = 12, e.TAG_LENGTH = 16;
  var o = new Uint8Array(16),
    a = function () {
      function c(l) {
        if (this.nonceLength = e.NONCE_LENGTH, this.tagLength = e.TAG_LENGTH, l.length !== e.KEY_LENGTH) throw new Error("ChaCha20Poly1305 needs 32-byte key");
        this._key = new Uint8Array(l)
      }
      return c.prototype.seal = function (l, u, f, h) {
        if (l.length > 16) throw new Error("ChaCha20Poly1305: incorrect nonce length");
        var g = new Uint8Array(16);
        g.set(l, g.length - l.length);
        var y = new Uint8Array(32);
        t.stream(this._key, g, y, 4);
        var x = u.length + this.tagLength,
          k;
        if (h) {
          if (h.length !== x) throw new Error("ChaCha20Poly1305: incorrect destination length");
          k = h
        } else k = new Uint8Array(x);
        return t.streamXOR(this._key, g, u, k, 4), this._authenticate(k.subarray(k.length - this.tagLength, k.length), y, k.subarray(0, k.length - this.tagLength), f), r.wipe(g), k
      }, c.prototype.open = function (l, u, f, h) {
        if (l.length > 16) throw new Error("ChaCha20Poly1305: incorrect nonce length");
        if (u.length < this.tagLength) return null;
        var g = new Uint8Array(16);
        g.set(l, g.length - l.length);
        var y = new Uint8Array(32);
        t.stream(this._key, g, y, 4);
        var x = new Uint8Array(this.tagLength);
        if (this._authenticate(x, y, u.subarray(0, u.length - this.tagLength), f), !s.equal(x, u.subarray(u.length - this.tagLength, u.length))) return null;
        var k = u.length - this.tagLength,
          _;
        if (h) {
          if (h.length !== k) throw new Error("ChaCha20Poly1305: incorrect destination length");
          _ = h
        } else _ = new Uint8Array(k);
        return t.streamXOR(this._key, g, u.subarray(0, u.length - this.tagLength), _, 4), r.wipe(g), _
      }, c.prototype.clean = function () {
        return r.wipe(this._key), this
      }, c.prototype._authenticate = function (l, u, f, h) {
        var g = new n.Poly1305(u);
        h && (g.update(h), h.length % 16 > 0 && g.update(o.subarray(h.length % 16))), g.update(f), f.length % 16 > 0 && g.update(o.subarray(f.length % 16));
        var y = new Uint8Array(8);
        h && i.writeUint64LE(h.length, y), g.update(y), i.writeUint64LE(f.length, y), g.update(y);
        for (var x = g.digest(), k = 0; k < x.length; k++) l[k] = x[k];
        g.clean(), r.wipe(x), r.wipe(y)
      }, c
    }();
  e.ChaCha20Poly1305 = a
})(d_);
var uY = {},
  Cy = {},
  f_ = {};
Object.defineProperty(f_, "__esModule", {
  value: !0
});

function aDe(e) {
  return typeof e.saveState < "u" && typeof e.restoreState < "u" && typeof e.cleanSavedState < "u"
}
f_.isSerializableHash = aDe;
Object.defineProperty(Cy, "__esModule", {
  value: !0
});
var Bc = f_,
  cDe = Vd,
  lDe = Qo,
  dY = function () {
    function e(t, n) {
      this._finished = !1, this._inner = new t, this._outer = new t, this.blockSize = this._outer.blockSize, this.digestLength = this._outer.digestLength;
      var r = new Uint8Array(this.blockSize);
      n.length > this.blockSize ? this._inner.update(n).finish(r).clean() : r.set(n);
      for (var i = 0; i < r.length; i++) r[i] ^= 54;
      this._inner.update(r);
      for (var i = 0; i < r.length; i++) r[i] ^= 106;
      this._outer.update(r), Bc.isSerializableHash(this._inner) && Bc.isSerializableHash(this._outer) && (this._innerKeyedState = this._inner.saveState(), this._outerKeyedState = this._outer.saveState()), lDe.wipe(r)
    }
    return e.prototype.reset = function () {
      if (!Bc.isSerializableHash(this._inner) || !Bc.isSerializableHash(this._outer)) throw new Error("hmac: can't reset() because hash doesn't implement restoreState()");
      return this._inner.restoreState(this._innerKeyedState), this._outer.restoreState(this._outerKeyedState), this._finished = !1, this
    }, e.prototype.clean = function () {
      Bc.isSerializableHash(this._inner) && this._inner.cleanSavedState(this._innerKeyedState), Bc.isSerializableHash(this._outer) && this._outer.cleanSavedState(this._outerKeyedState), this._inner.clean(), this._outer.clean()
    }, e.prototype.update = function (t) {
      return this._inner.update(t), this
    }, e.prototype.finish = function (t) {
      return this._finished ? (this._outer.finish(t), this) : (this._inner.finish(t), this._outer.update(t.subarray(0, this.digestLength)).finish(t), this._finished = !0, this)
    }, e.prototype.digest = function () {
      var t = new Uint8Array(this.digestLength);
      return this.finish(t), t
    }, e.prototype.saveState = function () {
      if (!Bc.isSerializableHash(this._inner)) throw new Error("hmac: can't saveState() because hash doesn't implement it");
      return this._inner.saveState()
    }, e.prototype.restoreState = function (t) {
      if (!Bc.isSerializableHash(this._inner) || !Bc.isSerializableHash(this._outer)) throw new Error("hmac: can't restoreState() because hash doesn't implement it");
      return this._inner.restoreState(t), this._outer.restoreState(this._outerKeyedState), this._finished = !1, this
    }, e.prototype.cleanSavedState = function (t) {
      if (!Bc.isSerializableHash(this._inner)) throw new Error("hmac: can't cleanSavedState() because hash doesn't implement it");
      this._inner.cleanSavedState(t)
    }, e
  }();
Cy.HMAC = dY;

function uDe(e, t, n) {
  var r = new dY(e, t);
  r.update(n);
  var i = r.digest();
  return r.clean(), i
}
Cy.hmac = uDe;
Cy.equal = cDe.equal;
Object.defineProperty(uY, "__esModule", {
  value: !0
});
var L$ = Cy,
  B$ = Qo,
  dDe = function () {
    function e(t, n, r, i) {
      r === void 0 && (r = new Uint8Array(0)), this._counter = new Uint8Array(1), this._hash = t, this._info = i;
      var s = L$.hmac(this._hash, r, n);
      this._hmac = new L$.HMAC(t, s), this._buffer = new Uint8Array(this._hmac.digestLength), this._bufpos = this._buffer.length
    }
    return e.prototype._fillBuffer = function () {
      this._counter[0]++;
      var t = this._counter[0];
      if (t === 0) throw new Error("hkdf: cannot expand more");
      this._hmac.reset(), t > 1 && this._hmac.update(this._buffer), this._info && this._hmac.update(this._info), this._hmac.update(this._counter), this._hmac.finish(this._buffer), this._bufpos = 0
    }, e.prototype.expand = function (t) {
      for (var n = new Uint8Array(t), r = 0; r < n.length; r++) this._bufpos === this._buffer.length && this._fillBuffer(), n[r] = this._buffer[this._bufpos++];
      return n
    }, e.prototype.clean = function () {
      this._hmac.clean(), B$.wipe(this._buffer), B$.wipe(this._counter), this._bufpos = 0
    }, e
  }(),
  fDe = uY.HKDF = dDe,
  Um = {},
  J6 = {},
  X6 = {};
Object.defineProperty(X6, "__esModule", {
  value: !0
});
X6.BrowserRandomSource = void 0;
const F$ = 65536;
class hDe {
  constructor() {
    this.isAvailable = !1, this.isInstantiated = !1;
    const t = typeof self < "u" ? self.crypto || self.msCrypto : null;
    t && t.getRandomValues !== void 0 && (this._crypto = t, this.isAvailable = !0, this.isInstantiated = !0)
  }
  randomBytes(t) {
    if (!this.isAvailable || !this._crypto) throw new Error("Browser random byte generator is not available.");
    const n = new Uint8Array(t);
    for (let r = 0; r < n.length; r += F$) this._crypto.getRandomValues(n.subarray(r, r + Math.min(n.length - r, F$)));
    return n
  }
}
X6.BrowserRandomSource = hDe;

function pDe(e) {
  throw new Error('Could not dynamically require "' + e + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.')
}
var Z6 = {};
Object.defineProperty(Z6, "__esModule", {
  value: !0
});
Z6.NodeRandomSource = void 0;
const mDe = Qo;
class gDe {
  constructor() {
    if (this.isAvailable = !1, this.isInstantiated = !1, typeof pDe < "u") {
      const t = SV;
      t && t.randomBytes && (this._crypto = t, this.isAvailable = !0, this.isInstantiated = !0)
    }
  }
  randomBytes(t) {
    if (!this.isAvailable || !this._crypto) throw new Error("Node.js random byte generator is not available.");
    let n = this._crypto.randomBytes(t);
    if (n.length !== t) throw new Error("NodeRandomSource: got fewer bytes than requested");
    const r = new Uint8Array(t);
    for (let i = 0; i < r.length; i++) r[i] = n[i];
    return (0, mDe.wipe)(n), r
  }
}
Z6.NodeRandomSource = gDe;
Object.defineProperty(J6, "__esModule", {
  value: !0
});
J6.SystemRandomSource = void 0;
const yDe = X6,
  vDe = Z6;
class bDe {
  constructor() {
    if (this.isAvailable = !1, this.name = "", this._source = new yDe.BrowserRandomSource, this._source.isAvailable) {
      this.isAvailable = !0, this.name = "Browser";
      return
    }
    if (this._source = new vDe.NodeRandomSource, this._source.isAvailable) {
      this.isAvailable = !0, this.name = "Node";
      return
    }
  }
  randomBytes(t) {
    if (!this.isAvailable) throw new Error("System random byte generator is not available.");
    return this._source.randomBytes(t)
  }
}
J6.SystemRandomSource = bDe;
(function (e) {
  Object.defineProperty(e, "__esModule", {
    value: !0
  }), e.randomStringForEntropy = e.randomString = e.randomUint32 = e.randomBytes = e.defaultRandomSource = void 0;
  const t = J6,
    n = sn,
    r = Qo;
  e.defaultRandomSource = new t.SystemRandomSource;

  function i(l, u = e.defaultRandomSource) {
    return u.randomBytes(l)
  }
  e.randomBytes = i;

  function s(l = e.defaultRandomSource) {
    const u = i(4, l),
      f = (0, n.readUint32LE)(u);
    return (0, r.wipe)(u), f
  }
  e.randomUint32 = s;
  const o = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";

  function a(l, u = o, f = e.defaultRandomSource) {
    if (u.length < 2) throw new Error("randomString charset is too short");
    if (u.length > 256) throw new Error("randomString charset is too long");
    let h = "";
    const g = u.length,
      y = 256 - 256 % g;
    for (; l > 0;) {
      const x = i(Math.ceil(l * 256 / y), f);
      for (let k = 0; k < x.length && l > 0; k++) {
        const _ = x[k];
        _ < y && (h += u.charAt(_ % g), l--)
      }(0, r.wipe)(x)
    }
    return h
  }
  e.randomString = a;

  function c(l, u = o, f = e.defaultRandomSource) {
    const h = Math.ceil(l / (Math.log(u.length) / Math.LN2));
    return a(h, u, f)
  }
  e.randomStringForEntropy = c
})(Um);
var Ay = {};
(function (e) {
  Object.defineProperty(e, "__esModule", {
    value: !0
  });
  var t = sn,
    n = Qo;
  e.DIGEST_LENGTH = 32, e.BLOCK_SIZE = 64;
  var r = function () {
    function a() {
      this.digestLength = e.DIGEST_LENGTH, this.blockSize = e.BLOCK_SIZE, this._state = new Int32Array(8), this._temp = new Int32Array(64), this._buffer = new Uint8Array(128), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this.reset()
    }
    return a.prototype._initState = function () {
      this._state[0] = 1779033703, this._state[1] = 3144134277, this._state[2] = 1013904242, this._state[3] = 2773480762, this._state[4] = 1359893119, this._state[5] = 2600822924, this._state[6] = 528734635, this._state[7] = 1541459225
    }, a.prototype.reset = function () {
      return this._initState(), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this
    }, a.prototype.clean = function () {
      n.wipe(this._buffer), n.wipe(this._temp), this.reset()
    }, a.prototype.update = function (c, l) {
      if (l === void 0 && (l = c.length), this._finished) throw new Error("SHA256: can't update because hash was finished.");
      var u = 0;
      if (this._bytesHashed += l, this._bufferLength > 0) {
        for (; this._bufferLength < this.blockSize && l > 0;) this._buffer[this._bufferLength++] = c[u++], l--;
        this._bufferLength === this.blockSize && (s(this._temp, this._state, this._buffer, 0, this.blockSize), this._bufferLength = 0)
      }
      for (l >= this.blockSize && (u = s(this._temp, this._state, c, u, l), l %= this.blockSize); l > 0;) this._buffer[this._bufferLength++] = c[u++], l--;
      return this
    }, a.prototype.finish = function (c) {
      if (!this._finished) {
        var l = this._bytesHashed,
          u = this._bufferLength,
          f = l / 536870912 | 0,
          h = l << 3,
          g = l % 64 < 56 ? 64 : 128;
        this._buffer[u] = 128;
        for (var y = u + 1; y < g - 8; y++) this._buffer[y] = 0;
        t.writeUint32BE(f, this._buffer, g - 8), t.writeUint32BE(h, this._buffer, g - 4), s(this._temp, this._state, this._buffer, 0, g), this._finished = !0
      }
      for (var y = 0; y < this.digestLength / 4; y++) t.writeUint32BE(this._state[y], c, y * 4);
      return this
    }, a.prototype.digest = function () {
      var c = new Uint8Array(this.digestLength);
      return this.finish(c), c
    }, a.prototype.saveState = function () {
      if (this._finished) throw new Error("SHA256: cannot save finished state");
      return {
        state: new Int32Array(this._state),
        buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
        bufferLength: this._bufferLength,
        bytesHashed: this._bytesHashed
      }
    }, a.prototype.restoreState = function (c) {
      return this._state.set(c.state), this._bufferLength = c.bufferLength, c.buffer && this._buffer.set(c.buffer), this._bytesHashed = c.bytesHashed, this._finished = !1, this
    }, a.prototype.cleanSavedState = function (c) {
      n.wipe(c.state), c.buffer && n.wipe(c.buffer), c.bufferLength = 0, c.bytesHashed = 0
    }, a
  }();
  e.SHA256 = r;
  var i = new Int32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]);

  function s(a, c, l, u, f) {
    for (; f >= 64;) {
      for (var h = c[0], g = c[1], y = c[2], x = c[3], k = c[4], _ = c[5], p = c[6], v = c[7], S = 0; S < 16; S++) {
        var I = u + S * 4;
        a[S] = t.readUint32BE(l, I)
      }
      for (var S = 16; S < 64; S++) {
        var A = a[S - 2],
          w = (A >>> 17 | A << 15) ^ (A >>> 19 | A << 13) ^ A >>> 10;
        A = a[S - 15];
        var E = (A >>> 7 | A << 25) ^ (A >>> 18 | A << 14) ^ A >>> 3;
        a[S] = (w + a[S - 7] | 0) + (E + a[S - 16] | 0)
      }
      for (var S = 0; S < 64; S++) {
        var w = (((k >>> 6 | k << 26) ^ (k >>> 11 | k << 21) ^ (k >>> 25 | k << 7)) + (k & _ ^ ~k & p) | 0) + (v + (i[S] + a[S] | 0) | 0) | 0,
          E = ((h >>> 2 | h << 30) ^ (h >>> 13 | h << 19) ^ (h >>> 22 | h << 10)) + (h & g ^ h & y ^ g & y) | 0;
        v = p, p = _, _ = k, k = x + w | 0, x = y, y = g, g = h, h = w + E | 0
      }
      c[0] += h, c[1] += g, c[2] += y, c[3] += x, c[4] += k, c[5] += _, c[6] += p, c[7] += v, u += 64, f -= 64
    }
    return u
  }

  function o(a) {
    var c = new r;
    c.update(a);
    var l = c.digest();
    return c.clean(), l
  }
  e.hash = o
})(Ay);
var h_ = {};
(function (e) {
  Object.defineProperty(e, "__esModule", {
    value: !0
  }), e.sharedKey = e.generateKeyPair = e.generateKeyPairFromSeed = e.scalarMultBase = e.scalarMult = e.SHARED_KEY_LENGTH = e.SECRET_KEY_LENGTH = e.PUBLIC_KEY_LENGTH = void 0;
  const t = Um,
    n = Qo;
  e.PUBLIC_KEY_LENGTH = 32, e.SECRET_KEY_LENGTH = 32, e.SHARED_KEY_LENGTH = 32;

  function r(S) {
    const I = new Float64Array(16);
    if (S)
      for (let A = 0; A < S.length; A++) I[A] = S[A];
    return I
  }
  const i = new Uint8Array(32);
  i[0] = 9;
  const s = r([56129, 1]);

  function o(S) {
    let I = 1;
    for (let A = 0; A < 16; A++) {
      let w = S[A] + I + 65535;
      I = Math.floor(w / 65536), S[A] = w - I * 65536
    }
    S[0] += I - 1 + 37 * (I - 1)
  }

  function a(S, I, A) {
    const w = ~(A - 1);
    for (let E = 0; E < 16; E++) {
      const D = w & (S[E] ^ I[E]);
      S[E] ^= D, I[E] ^= D
    }
  }

  function c(S, I) {
    const A = r(),
      w = r();
    for (let E = 0; E < 16; E++) w[E] = I[E];
    o(w), o(w), o(w);
    for (let E = 0; E < 2; E++) {
      A[0] = w[0] - 65517;
      for (let $ = 1; $ < 15; $++) A[$] = w[$] - 65535 - (A[$ - 1] >> 16 & 1), A[$ - 1] &= 65535;
      A[15] = w[15] - 32767 - (A[14] >> 16 & 1);
      const D = A[15] >> 16 & 1;
      A[14] &= 65535, a(w, A, 1 - D)
    }
    for (let E = 0; E < 16; E++) S[2 * E] = w[E] & 255, S[2 * E + 1] = w[E] >> 8
  }

  function l(S, I) {
    for (let A = 0; A < 16; A++) S[A] = I[2 * A] + (I[2 * A + 1] << 8);
    S[15] &= 32767
  }

  function u(S, I, A) {
    for (let w = 0; w < 16; w++) S[w] = I[w] + A[w]
  }

  function f(S, I, A) {
    for (let w = 0; w < 16; w++) S[w] = I[w] - A[w]
  }

  function h(S, I, A) {
    let w, E, D = 0,
      $ = 0,
      V = 0,
      G = 0,
      L = 0,
      b = 0,
      T = 0,
      R = 0,
      N = 0,
      O = 0,
      U = 0,
      q = 0,
      W = 0,
      M = 0,
      Q = 0,
      he = 0,
      H = 0,
      ne = 0,
      X = 0,
      Z = 0,
      te = 0,
      F = 0,
      J = 0,
      ie = 0,
      ce = 0,
      ue = 0,
      ge = 0,
      et = 0,
      He = 0,
      se = 0,
      pe = 0,
      de = A[0],
      we = A[1],
      Ce = A[2],
      be = A[3],
      Se = A[4],
      Fe = A[5],
      Ne = A[6],
      Me = A[7],
      We = A[8],
      ke = A[9],
      ze = A[10],
      ct = A[11],
      Xe = A[12],
      _e = A[13],
      Ze = A[14],
      Ee = A[15];
    w = I[0], D += w * de, $ += w * we, V += w * Ce, G += w * be, L += w * Se, b += w * Fe, T += w * Ne, R += w * Me, N += w * We, O += w * ke, U += w * ze, q += w * ct, W += w * Xe, M += w * _e, Q += w * Ze, he += w * Ee, w = I[1], $ += w * de, V += w * we, G += w * Ce, L += w * be, b += w * Se, T += w * Fe, R += w * Ne, N += w * Me, O += w * We, U += w * ke, q += w * ze, W += w * ct, M += w * Xe, Q += w * _e, he += w * Ze, H += w * Ee, w = I[2], V += w * de, G += w * we, L += w * Ce, b += w * be, T += w * Se, R += w * Fe, N += w * Ne, O += w * Me, U += w * We, q += w * ke, W += w * ze, M += w * ct, Q += w * Xe, he += w * _e, H += w * Ze, ne += w * Ee, w = I[3], G += w * de, L += w * we, b += w * Ce, T += w * be, R += w * Se, N += w * Fe, O += w * Ne, U += w * Me, q += w * We, W += w * ke, M += w * ze, Q += w * ct, he += w * Xe, H += w * _e, ne += w * Ze, X += w * Ee, w = I[4], L += w * de, b += w * we, T += w * Ce, R += w * be, N += w * Se, O += w * Fe, U += w * Ne, q += w * Me, W += w * We, M += w * ke, Q += w * ze, he += w * ct, H += w * Xe, ne += w * _e, X += w * Ze, Z += w * Ee, w = I[5], b += w * de, T += w * we, R += w * Ce, N += w * be, O += w * Se, U += w * Fe, q += w * Ne, W += w * Me, M += w * We, Q += w * ke, he += w * ze, H += w * ct, ne += w * Xe, X += w * _e, Z += w * Ze, te += w * Ee, w = I[6], T += w * de, R += w * we, N += w * Ce, O += w * be, U += w * Se, q += w * Fe, W += w * Ne, M += w * Me, Q += w * We, he += w * ke, H += w * ze, ne += w * ct, X += w * Xe, Z += w * _e, te += w * Ze, F += w * Ee, w = I[7], R += w * de, N += w * we, O += w * Ce, U += w * be, q += w * Se, W += w * Fe, M += w * Ne, Q += w * Me, he += w * We, H += w * ke, ne += w * ze, X += w * ct, Z += w * Xe, te += w * _e, F += w * Ze, J += w * Ee, w = I[8], N += w * de, O += w * we, U += w * Ce, q += w * be, W += w * Se, M += w * Fe, Q += w * Ne, he += w * Me, H += w * We, ne += w * ke, X += w * ze, Z += w * ct, te += w * Xe, F += w * _e, J += w * Ze, ie += w * Ee, w = I[9], O += w * de, U += w * we, q += w * Ce, W += w * be, M += w * Se, Q += w * Fe, he += w * Ne, H += w * Me, ne += w * We, X += w * ke, Z += w * ze, te += w * ct, F += w * Xe, J += w * _e, ie += w * Ze, ce += w * Ee, w = I[10], U += w * de, q += w * we, W += w * Ce, M += w * be, Q += w * Se, he += w * Fe, H += w * Ne, ne += w * Me, X += w * We, Z += w * ke, te += w * ze, F += w * ct, J += w * Xe, ie += w * _e, ce += w * Ze, ue += w * Ee, w = I[11], q += w * de, W += w * we, M += w * Ce, Q += w * be, he += w * Se, H += w * Fe, ne += w * Ne, X += w * Me, Z += w * We, te += w * ke, F += w * ze, J += w * ct, ie += w * Xe, ce += w * _e, ue += w * Ze, ge += w * Ee, w = I[12], W += w * de, M += w * we, Q += w * Ce, he += w * be, H += w * Se, ne += w * Fe, X += w * Ne, Z += w * Me, te += w * We, F += w * ke, J += w * ze, ie += w * ct, ce += w * Xe, ue += w * _e, ge += w * Ze, et += w * Ee, w = I[13], M += w * de, Q += w * we, he += w * Ce, H += w * be, ne += w * Se, X += w * Fe, Z += w * Ne, te += w * Me, F += w * We, J += w * ke, ie += w * ze, ce += w * ct, ue += w * Xe, ge += w * _e, et += w * Ze, He += w * Ee, w = I[14], Q += w * de, he += w * we, H += w * Ce, ne += w * be, X += w * Se, Z += w * Fe, te += w * Ne, F += w * Me, J += w * We, ie += w * ke, ce += w * ze, ue += w * ct, ge += w * Xe, et += w * _e, He += w * Ze, se += w * Ee, w = I[15], he += w * de, H += w * we, ne += w * Ce, X += w * be, Z += w * Se, te += w * Fe, F += w * Ne, J += w * Me, ie += w * We, ce += w * ke, ue += w * ze, ge += w * ct, et += w * Xe, He += w * _e, se += w * Ze, pe += w * Ee, D += 38 * H, $ += 38 * ne, V += 38 * X, G += 38 * Z, L += 38 * te, b += 38 * F, T += 38 * J, R += 38 * ie, N += 38 * ce, O += 38 * ue, U += 38 * ge, q += 38 * et, W += 38 * He, M += 38 * se, Q += 38 * pe, E = 1, w = D + E + 65535, E = Math.floor(w / 65536), D = w - E * 65536, w = $ + E + 65535, E = Math.floor(w / 65536), $ = w - E * 65536, w = V + E + 65535, E = Math.floor(w / 65536), V = w - E * 65536, w = G + E + 65535, E = Math.floor(w / 65536), G = w - E * 65536, w = L + E + 65535, E = Math.floor(w / 65536), L = w - E * 65536, w = b + E + 65535, E = Math.floor(w / 65536), b = w - E * 65536, w = T + E + 65535, E = Math.floor(w / 65536), T = w - E * 65536, w = R + E + 65535, E = Math.floor(w / 65536), R = w - E * 65536, w = N + E + 65535, E = Math.floor(w / 65536), N = w - E * 65536, w = O + E + 65535, E = Math.floor(w / 65536), O = w - E * 65536, w = U + E + 65535, E = Math.floor(w / 65536), U = w - E * 65536, w = q + E + 65535, E = Math.floor(w / 65536), q = w - E * 65536, w = W + E + 65535, E = Math.floor(w / 65536), W = w - E * 65536, w = M + E + 65535, E = Math.floor(w / 65536), M = w - E * 65536, w = Q + E + 65535, E = Math.floor(w / 65536), Q = w - E * 65536, w = he + E + 65535, E = Math.floor(w / 65536), he = w - E * 65536, D += E - 1 + 37 * (E - 1), E = 1, w = D + E + 65535, E = Math.floor(w / 65536), D = w - E * 65536, w = $ + E + 65535, E = Math.floor(w / 65536), $ = w - E * 65536, w = V + E + 65535, E = Math.floor(w / 65536), V = w - E * 65536, w = G + E + 65535, E = Math.floor(w / 65536), G = w - E * 65536, w = L + E + 65535, E = Math.floor(w / 65536), L = w - E * 65536, w = b + E + 65535, E = Math.floor(w / 65536), b = w - E * 65536, w = T + E + 65535, E = Math.floor(w / 65536), T = w - E * 65536, w = R + E + 65535, E = Math.floor(w / 65536), R = w - E * 65536, w = N + E + 65535, E = Math.floor(w / 65536), N = w - E * 65536, w = O + E + 65535, E = Math.floor(w / 65536), O = w - E * 65536, w = U + E + 65535, E = Math.floor(w / 65536), U = w - E * 65536, w = q + E + 65535, E = Math.floor(w / 65536), q = w - E * 65536, w = W + E + 65535, E = Math.floor(w / 65536), W = w - E * 65536, w = M + E + 65535, E = Math.floor(w / 65536), M = w - E * 65536, w = Q + E + 65535, E = Math.floor(w / 65536), Q = w - E * 65536, w = he + E + 65535, E = Math.floor(w / 65536), he = w - E * 65536, D += E - 1 + 37 * (E - 1), S[0] = D, S[1] = $, S[2] = V, S[3] = G, S[4] = L, S[5] = b, S[6] = T, S[7] = R, S[8] = N, S[9] = O, S[10] = U, S[11] = q, S[12] = W, S[13] = M, S[14] = Q, S[15] = he
  }

  function g(S, I) {
    h(S, I, I)
  }

  function y(S, I) {
    const A = r();
    for (let w = 0; w < 16; w++) A[w] = I[w];
    for (let w = 253; w >= 0; w--) g(A, A), w !== 2 && w !== 4 && h(A, A, I);
    for (let w = 0; w < 16; w++) S[w] = A[w]
  }

  function x(S, I) {
    const A = new Uint8Array(32),
      w = new Float64Array(80),
      E = r(),
      D = r(),
      $ = r(),
      V = r(),
      G = r(),
      L = r();
    for (let N = 0; N < 31; N++) A[N] = S[N];
    A[31] = S[31] & 127 | 64, A[0] &= 248, l(w, I);
    for (let N = 0; N < 16; N++) D[N] = w[N];
    E[0] = V[0] = 1;
    for (let N = 254; N >= 0; --N) {
      const O = A[N >>> 3] >>> (N & 7) & 1;
      a(E, D, O), a($, V, O), u(G, E, $), f(E, E, $), u($, D, V), f(D, D, V), g(V, G), g(L, E), h(E, $, E), h($, D, G), u(G, E, $), f(E, E, $), g(D, E), f($, V, L), h(E, $, s), u(E, E, V), h($, $, E), h(E, V, L), h(V, D, w), g(D, G), a(E, D, O), a($, V, O)
    }
    for (let N = 0; N < 16; N++) w[N + 16] = E[N], w[N + 32] = $[N], w[N + 48] = D[N], w[N + 64] = V[N];
    const b = w.subarray(32),
      T = w.subarray(16);
    y(b, b), h(T, T, b);
    const R = new Uint8Array(32);
    return c(R, T), R
  }
  e.scalarMult = x;

  function k(S) {
    return x(S, i)
  }
  e.scalarMultBase = k;

  function _(S) {
    if (S.length !== e.SECRET_KEY_LENGTH) throw new Error(`x25519: seed must be ${e.SECRET_KEY_LENGTH} bytes`);
    const I = new Uint8Array(S);
    return {
      publicKey: k(I),
      secretKey: I
    }
  }
  e.generateKeyPairFromSeed = _;

  function p(S) {
    const I = (0, t.randomBytes)(32, S),
      A = _(I);
    return (0, n.wipe)(I), A
  }
  e.generateKeyPair = p;

  function v(S, I, A = !1) {
    if (S.length !== e.PUBLIC_KEY_LENGTH) throw new Error("X25519: incorrect secret key length");
    if (I.length !== e.PUBLIC_KEY_LENGTH) throw new Error("X25519: incorrect public key length");
    const w = x(S, I);
    if (A) {
      let E = 0;
      for (let D = 0; D < w.length; D++) E |= w[D];
      if (E === 0) throw new Error("X25519: invalid shared key")
    }
    return w
  }
  e.sharedKey = v
})(h_);

function p_(e) {
  return globalThis.Buffer != null ? new Uint8Array(e.buffer, e.byteOffset, e.byteLength) : e
}

function fY(e = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? p_(globalThis.Buffer.allocUnsafe(e)) : new Uint8Array(e)
}

function qA(e, t) {
  t || (t = e.reduce((i, s) => i + s.length, 0));
  const n = fY(t);
  let r = 0;
  for (const i of e) n.set(i, r), r += i.length;
  return p_(n)
}

function wDe(e, t) {
  if (e.length >= 255) throw new TypeError("Alphabet too long");
  for (var n = new Uint8Array(256), r = 0; r < n.length; r++) n[r] = 255;
  for (var i = 0; i < e.length; i++) {
    var s = e.charAt(i),
      o = s.charCodeAt(0);
    if (n[o] !== 255) throw new TypeError(s + " is ambiguous");
    n[o] = i
  }
  var a = e.length,
    c = e.charAt(0),
    l = Math.log(a) / Math.log(256),
    u = Math.log(256) / Math.log(a);

  function f(y) {
    if (y instanceof Uint8Array || (ArrayBuffer.isView(y) ? y = new Uint8Array(y.buffer, y.byteOffset, y.byteLength) : Array.isArray(y) && (y = Uint8Array.from(y))), !(y instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
    if (y.length === 0) return "";
    for (var x = 0, k = 0, _ = 0, p = y.length; _ !== p && y[_] === 0;) _++, x++;
    for (var v = (p - _) * u + 1 >>> 0, S = new Uint8Array(v); _ !== p;) {
      for (var I = y[_], A = 0, w = v - 1;
        (I !== 0 || A < k) && w !== -1; w--, A++) I += 256 * S[w] >>> 0, S[w] = I % a >>> 0, I = I / a >>> 0;
      if (I !== 0) throw new Error("Non-zero carry");
      k = A, _++
    }
    for (var E = v - k; E !== v && S[E] === 0;) E++;
    for (var D = c.repeat(x); E < v; ++E) D += e.charAt(S[E]);
    return D
  }

  function h(y) {
    if (typeof y != "string") throw new TypeError("Expected String");
    if (y.length === 0) return new Uint8Array;
    var x = 0;
    if (y[x] !== " ") {
      for (var k = 0, _ = 0; y[x] === c;) k++, x++;
      for (var p = (y.length - x) * l + 1 >>> 0, v = new Uint8Array(p); y[x];) {
        var S = n[y.charCodeAt(x)];
        if (S === 255) return;
        for (var I = 0, A = p - 1;
          (S !== 0 || I < _) && A !== -1; A--, I++) S += a * v[A] >>> 0, v[A] = S % 256 >>> 0, S = S / 256 >>> 0;
        if (S !== 0) throw new Error("Non-zero carry");
        _ = I, x++
      }
      if (y[x] !== " ") {
        for (var w = p - _; w !== p && v[w] === 0;) w++;
        for (var E = new Uint8Array(k + (p - w)), D = k; w !== p;) E[D++] = v[w++];
        return E
      }
    }
  }

  function g(y) {
    var x = h(y);
    if (x) return x;
    throw new Error(`Non-${t} character`)
  }
  return {
    encode: f,
    decodeUnsafe: h,
    decode: g
  }
}
var xDe = wDe,
  EDe = xDe;
const SDe = e => {
    if (e instanceof Uint8Array && e.constructor.name === "Uint8Array") return e;
    if (e instanceof ArrayBuffer) return new Uint8Array(e);
    if (ArrayBuffer.isView(e)) return new Uint8Array(e.buffer, e.byteOffset, e.byteLength);
    throw new Error("Unknown type, must be binary type")
  },
  CDe = e => new TextEncoder().encode(e),
  ADe = e => new TextDecoder().decode(e);
class TDe {
  constructor(t, n, r) {
    this.name = t, this.prefix = n, this.baseEncode = r
  }
  encode(t) {
    if (t instanceof Uint8Array) return `${this.prefix}${this.baseEncode(t)}`;
    throw Error("Unknown type, must be binary type")
  }
}
class kDe {
  constructor(t, n, r) {
    if (this.name = t, this.prefix = n, n.codePointAt(0) === void 0) throw new Error("Invalid prefix character");
    this.prefixCodePoint = n.codePointAt(0), this.baseDecode = r
  }
  decode(t) {
    if (typeof t == "string") {
      if (t.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(t)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(t.slice(this.prefix.length))
    } else throw Error("Can only multibase decode strings")
  }
  or(t) {
    return hY(this, t)
  }
}
class _De {
  constructor(t) {
    this.decoders = t
  }
  or(t) {
    return hY(this, t)
  }
  decode(t) {
    const n = t[0],
      r = this.decoders[n];
    if (r) return r.decode(t);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(t)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)
  }
}
const hY = (e, t) => new _De({
  ...e.decoders || {
    [e.prefix]: e
  },
  ...t.decoders || {
    [t.prefix]: t
  }
});
class IDe {
  constructor(t, n, r, i) {
    this.name = t, this.prefix = n, this.baseEncode = r, this.baseDecode = i, this.encoder = new TDe(t, n, r), this.decoder = new kDe(t, n, i)
  }
  encode(t) {
    return this.encoder.encode(t)
  }
  decode(t) {
    return this.decoder.decode(t)
  }
}
const eE = ({
    name: e,
    prefix: t,
    encode: n,
    decode: r
  }) => new IDe(e, t, n, r),
  Ty = ({
    prefix: e,
    name: t,
    alphabet: n
  }) => {
    const {
      encode: r,
      decode: i
    } = EDe(n, t);
    return eE({
      prefix: e,
      name: t,
      encode: r,
      decode: s => SDe(i(s))
    })
  },
  PDe = (e, t, n, r) => {
    const i = {};
    for (let u = 0; u < t.length; ++u) i[t[u]] = u;
    let s = e.length;
    for (; e[s - 1] === "=";) --s;
    const o = new Uint8Array(s * n / 8 | 0);
    let a = 0,
      c = 0,
      l = 0;
    for (let u = 0; u < s; ++u) {
      const f = i[e[u]];
      if (f === void 0) throw new SyntaxError(`Non-${r} character`);
      c = c << n | f, a += n, a >= 8 && (a -= 8, o[l++] = 255 & c >> a)
    }
    if (a >= n || 255 & c << 8 - a) throw new SyntaxError("Unexpected end of data");
    return o
  },
  RDe = (e, t, n) => {
    const r = t[t.length - 1] === "=",
      i = (1 << n) - 1;
    let s = "",
      o = 0,
      a = 0;
    for (let c = 0; c < e.length; ++c)
      for (a = a << 8 | e[c], o += 8; o > n;) o -= n, s += t[i & a >> o];
    if (o && (s += t[i & a << n - o]), r)
      for (; s.length * n & 7;) s += "=";
    return s
  },
  qi = ({
    name: e,
    prefix: t,
    bitsPerChar: n,
    alphabet: r
  }) => eE({
    prefix: t,
    name: e,
    encode(i) {
      return RDe(i, r, n)
    },
    decode(i) {
      return PDe(i, r, n, e)
    }
  }),
  ODe = eE({
    prefix: "\0",
    name: "identity",
    encode: e => ADe(e),
    decode: e => CDe(e)
  }),
  DDe = Object.freeze(Object.defineProperty({
    __proto__: null,
    identity: ODe
  }, Symbol.toStringTag, {
    value: "Module"
  })),
  NDe = qi({
    prefix: "0",
    name: "base2",
    alphabet: "01",
    bitsPerChar: 1
  }),
  MDe = Object.freeze(Object.defineProperty({
    __proto__: null,
    base2: NDe
  }, Symbol.toStringTag, {
    value: "Module"
  })),
  $De = qi({
    prefix: "7",
    name: "base8",
    alphabet: "01234567",
    bitsPerChar: 3
  }),
  LDe = Object.freeze(Object.defineProperty({
    __proto__: null,
    base8: $De
  }, Symbol.toStringTag, {
    value: "Module"
  })),
  BDe = Ty({
    prefix: "9",
    name: "base10",
    alphabet: "0123456789"
  }),
  FDe = Object.freeze(Object.defineProperty({
    __proto__: null,
    base10: BDe
  }, Symbol.toStringTag, {
    value: "Module"
  })),
  jDe = qi({
    prefix: "f",
    name: "base16",
    alphabet: "0123456789abcdef",
    bitsPerChar: 4
  }),
  UDe = qi({
    prefix: "F",
    name: "base16upper",
    alphabet: "0123456789ABCDEF",
    bitsPerChar: 4
  }),
  zDe = Object.freeze(Object.defineProperty({
    __proto__: null,
    base16: jDe,
    base16upper: UDe
  }, Symbol.toStringTag, {
    value: "Module"
  })),
  HDe = qi({
    prefix: "b",
    name: "base32",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567",
    bitsPerChar: 5
  }),
  VDe = qi({
    prefix: "B",
    name: "base32upper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
    bitsPerChar: 5
  }),
  WDe = qi({
    prefix: "c",
    name: "base32pad",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
    bitsPerChar: 5
  }),
  qDe = qi({
    prefix: "C",
    name: "base32padupper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
    bitsPerChar: 5
  }),
  GDe = qi({
    prefix: "v",
    name: "base32hex",
    alphabet: "0123456789abcdefghijklmnopqrstuv",
    bitsPerChar: 5
  }),
  KDe = qi({
    prefix: "V",
    name: "base32hexupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
    bitsPerChar: 5
  }),
  QDe = qi({
    prefix: "t",
    name: "base32hexpad",
    alphabet: "0123456789abcdefghijklmnopqrstuv=",
    bitsPerChar: 5
  }),
  YDe = qi({
    prefix: "T",
    name: "base32hexpadupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
    bitsPerChar: 5
  }),
  JDe = qi({
    prefix: "h",
    name: "base32z",
    alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
    bitsPerChar: 5
  }),
  XDe = Object.freeze(Object.defineProperty({
    __proto__: null,
    base32: HDe,
    base32hex: GDe,
    base32hexpad: QDe,
    base32hexpadupper: YDe,
    base32hexupper: KDe,
    base32pad: WDe,
    base32padupper: qDe,
    base32upper: VDe,
    base32z: JDe
  }, Symbol.toStringTag, {
    value: "Module"
  })),
  ZDe = Ty({
    prefix: "k",
    name: "base36",
    alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
  }),
  eNe = Ty({
    prefix: "K",
    name: "base36upper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
  }),
  tNe = Object.freeze(Object.defineProperty({
    __proto__: null,
    base36: ZDe,
    base36upper: eNe
  }, Symbol.toStringTag, {
    value: "Module"
  })),
  nNe = Ty({
    name: "base58btc",
    prefix: "z",
    alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
  }),
  rNe = Ty({
    name: "base58flickr",
    prefix: "Z",
    alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
  }),
  iNe = Object.freeze(Object.defineProperty({
    __proto__: null,
    base58btc: nNe,
    base58flickr: rNe
  }, Symbol.toStringTag, {
    value: "Module"
  })),
  sNe = qi({
    prefix: "m",
    name: "base64",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
    bitsPerChar: 6
  }),
  oNe = qi({
    prefix: "M",
    name: "base64pad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
    bitsPerChar: 6
  }),
  aNe = qi({
    prefix: "u",
    name: "base64url",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
    bitsPerChar: 6
  }),
  cNe = qi({
    prefix: "U",
    name: "base64urlpad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
    bitsPerChar: 6
  }),
  lNe = Object.freeze(Object.defineProperty({
    __proto__: null,
    base64: sNe,
    base64pad: oNe,
    base64url: aNe,
    base64urlpad: cNe
  }, Symbol.toStringTag, {
    value: "Module"
  })),
  pY = Array.from("🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂"),
  uNe = pY.reduce((e, t, n) => (e[n] = t, e), []),
  dNe = pY.reduce((e, t, n) => (e[t.codePointAt(0)] = n, e), []);

function fNe(e) {
  return e.reduce((t, n) => (t += uNe[n], t), "")
}

function hNe(e) {
  const t = [];
  for (const n of e) {
    const r = dNe[n.codePointAt(0)];
    if (r === void 0) throw new Error(`Non-base256emoji character: ${n}`);
    t.push(r)
  }
  return new Uint8Array(t)
}
const pNe = eE({
    prefix: "🚀",
    name: "base256emoji",
    encode: fNe,
    decode: hNe
  }),
  mNe = Object.freeze(Object.defineProperty({
    __proto__: null,
    base256emoji: pNe
  }, Symbol.toStringTag, {
    value: "Module"
  }));
new TextEncoder;
new TextDecoder;
const j$ = {
  ...DDe,
  ...MDe,
  ...LDe,
  ...FDe,
  ...zDe,
  ...XDe,
  ...tNe,
  ...iNe,
  ...lNe,
  ...mNe
};

function mY(e, t, n, r) {
  return {
    name: e,
    prefix: t,
    encoder: {
      name: e,
      prefix: t,
      encode: n
    },
    decoder: {
      decode: r
    }
  }
}
const U$ = mY("utf8", "u", e => "u" + new TextDecoder("utf8").decode(e), e => new TextEncoder().encode(e.substring(1))),
  u8 = mY("ascii", "a", e => {
    let t = "a";
    for (let n = 0; n < e.length; n++) t += String.fromCharCode(e[n]);
    return t
  }, e => {
    e = e.substring(1);
    const t = fY(e.length);
    for (let n = 0; n < e.length; n++) t[n] = e.charCodeAt(n);
    return t
  }),
  gY = {
    utf8: U$,
    "utf-8": U$,
    hex: j$.base16,
    latin1: u8,
    ascii: u8,
    binary: u8,
    ...j$
  };

function As(e, t = "utf8") {
  const n = gY[t];
  if (!n) throw new Error(`Unsupported encoding "${t}"`);
  return (t === "utf8" || t === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? p_(globalThis.Buffer.from(e, "utf-8")) : n.decoder.decode(`${n.prefix}${e}`)
}

function us(e, t = "utf8") {
  const n = gY[t];
  if (!n) throw new Error(`Unsupported encoding "${t}"`);
  return (t === "utf8" || t === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(e.buffer, e.byteOffset, e.byteLength).toString("utf8") : n.encoder.encode(e).substring(1)
}
var z$ = function (e, t, n) {
    if (n || arguments.length === 2)
      for (var r = 0, i = t.length, s; r < i; r++)(s || !(r in t)) && (s || (s = Array.prototype.slice.call(t, 0, r)), s[r] = t[r]);
    return e.concat(s || Array.prototype.slice.call(t))
  },
  gNe = function () {
    function e(t, n, r) {
      this.name = t, this.version = n, this.os = r, this.type = "browser"
    }
    return e
  }(),
  yNe = function () {
    function e(t) {
      this.version = t, this.type = "node", this.name = "node", this.os = process.platform
    }
    return e
  }(),
  vNe = function () {
    function e(t, n, r, i) {
      this.name = t, this.version = n, this.os = r, this.bot = i, this.type = "bot-device"
    }
    return e
  }(),
  bNe = function () {
    function e() {
      this.type = "bot", this.bot = !0, this.name = "bot", this.version = null, this.os = null
    }
    return e
  }(),
  wNe = function () {
    function e() {
      this.type = "react-native", this.name = "react-native", this.version = null, this.os = null
    }
    return e
  }(),
  xNe = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/,
  ENe = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/,
  H$ = 3,
  SNe = [
    ["aol", /AOLShield\/([0-9\._]+)/],
    ["edge", /Edge\/([0-9\._]+)/],
    ["edge-ios", /EdgiOS\/([0-9\._]+)/],
    ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
    ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
    ["samsung", /SamsungBrowser\/([0-9\.]+)/],
    ["silk", /\bSilk\/([0-9._-]+)\b/],
    ["miui", /MiuiBrowser\/([0-9\.]+)$/],
    ["beaker", /BeakerBrowser\/([0-9\.]+)/],
    ["edge-chromium", /EdgA?\/([0-9\.]+)/],
    ["chromium-webview", /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
    ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
    ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
    ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
    ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
    ["fxios", /FxiOS\/([0-9\.]+)/],
    ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
    ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
    ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
    ["pie", /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],
    ["pie", /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],
    ["netfront", /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],
    ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
    ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
    ["ie", /MSIE\s(7\.0)/],
    ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
    ["android", /Android\s([0-9\.]+)/],
    ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
    ["safari", /Version\/([0-9\._]+).*Safari/],
    ["facebook", /FB[AS]V\/([0-9\.]+)/],
    ["instagram", /Instagram\s([0-9\.]+)/],
    ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
    ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
    ["curl", /^curl\/([0-9\.]+)$/],
    ["searchbot", xNe]
  ],
  V$ = [
    ["iOS", /iP(hone|od|ad)/],
    ["Android OS", /Android/],
    ["BlackBerry OS", /BlackBerry|BB10/],
    ["Windows Mobile", /IEMobile/],
    ["Amazon OS", /Kindle/],
    ["Windows 3.11", /Win16/],
    ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
    ["Windows 98", /(Windows 98)|(Win98)/],
    ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
    ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
    ["Windows Server 2003", /(Windows NT 5.2)/],
    ["Windows Vista", /(Windows NT 6.0)/],
    ["Windows 7", /(Windows NT 6.1)/],
    ["Windows 8", /(Windows NT 6.2)/],
    ["Windows 8.1", /(Windows NT 6.3)/],
    ["Windows 10", /(Windows NT 10.0)/],
    ["Windows ME", /Windows ME/],
    ["Windows CE", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],
    ["Open BSD", /OpenBSD/],
    ["Sun OS", /SunOS/],
    ["Chrome OS", /CrOS/],
    ["Linux", /(Linux)|(X11)/],
    ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
    ["QNX", /QNX/],
    ["BeOS", /BeOS/],
    ["OS/2", /OS\/2/]
  ];

function CNe(e) {
  return e ? W$(e) : typeof document > "u" && typeof navigator < "u" && navigator.product === "ReactNative" ? new wNe : typeof navigator < "u" ? W$(navigator.userAgent) : kNe()
}

function ANe(e) {
  return e !== "" && SNe.reduce(function (t, n) {
    var r = n[0],
      i = n[1];
    if (t) return t;
    var s = i.exec(e);
    return !!s && [r, s]
  }, !1)
}

function W$(e) {
  var t = ANe(e);
  if (!t) return null;
  var n = t[0],
    r = t[1];
  if (n === "searchbot") return new bNe;
  var i = r[1] && r[1].split(".").join("_").split("_").slice(0, 3);
  i ? i.length < H$ && (i = z$(z$([], i, !0), _Ne(H$ - i.length), !0)) : i = [];
  var s = i.join("."),
    o = TNe(e),
    a = ENe.exec(e);
  return a && a[1] ? new vNe(n, s, o, a[1]) : new gNe(n, s, o)
}

function TNe(e) {
  for (var t = 0, n = V$.length; t < n; t++) {
    var r = V$[t],
      i = r[0],
      s = r[1],
      o = s.exec(e);
    if (o) return i
  }
  return null
}

function kNe() {
  var e = typeof process < "u" && process.version;
  return e ? new yNe(process.version.slice(1)) : null
}

function _Ne(e) {
  for (var t = [], n = 0; n < e; n++) t.push("0");
  return t
}
var it = {};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var GA = function (e, t) {
  return GA = Object.setPrototypeOf || {
    __proto__: []
  }
  instanceof Array && function (n, r) {
    n.__proto__ = r
  } || function (n, r) {
    for (var i in r) r.hasOwnProperty(i) && (n[i] = r[i])
  }, GA(e, t)
};

function INe(e, t) {
  GA(e, t);

  function n() {
    this.constructor = e
  }
  e.prototype = t === null ? Object.create(t) : (n.prototype = t.prototype, new n)
}
var KA = function () {
  return KA = Object.assign || function (t) {
    for (var n, r = 1, i = arguments.length; r < i; r++) {
      n = arguments[r];
      for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (t[s] = n[s])
    }
    return t
  }, KA.apply(this, arguments)
};

function PNe(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++) t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]);
  return n
}

function RNe(e, t, n, r) {
  var i = arguments.length,
    s = i < 3 ? t : r === null ? r = Object.getOwnPropertyDescriptor(t, n) : r,
    o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(e, t, n, r);
  else
    for (var a = e.length - 1; a >= 0; a--)(o = e[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(t, n, s) : o(t, n)) || s);
  return i > 3 && s && Object.defineProperty(t, n, s), s
}

function ONe(e, t) {
  return function (n, r) {
    t(n, r, e)
  }
}

function DNe(e, t) {
  if (typeof Reflect == "object" && typeof Reflect.metadata == "function") return Reflect.metadata(e, t)
}

function NNe(e, t, n, r) {
  function i(s) {
    return s instanceof n ? s : new n(function (o) {
      o(s)
    })
  }
  return new(n || (n = Promise))(function (s, o) {
    function a(u) {
      try {
        l(r.next(u))
      } catch (f) {
        o(f)
      }
    }

    function c(u) {
      try {
        l(r.throw(u))
      } catch (f) {
        o(f)
      }
    }

    function l(u) {
      u.done ? s(u.value) : i(u.value).then(a, c)
    }
    l((r = r.apply(e, t || [])).next())
  })
}

function MNe(e, t) {
  var n = {
      label: 0,
      sent: function () {
        if (s[0] & 1) throw s[1];
        return s[1]
      },
      trys: [],
      ops: []
    },
    r, i, s, o;
  return o = {
    next: a(0),
    throw: a(1),
    return: a(2)
  }, typeof Symbol == "function" && (o[Symbol.iterator] = function () {
    return this
  }), o;

  function a(l) {
    return function (u) {
      return c([l, u])
    }
  }

  function c(l) {
    if (r) throw new TypeError("Generator is already executing.");
    for (; n;) try {
      if (r = 1, i && (s = l[0] & 2 ? i.return : l[0] ? i.throw || ((s = i.return) && s.call(i), 0) : i.next) && !(s = s.call(i, l[1])).done) return s;
      switch (i = 0, s && (l = [l[0] & 2, s.value]), l[0]) {
        case 0:
        case 1:
          s = l;
          break;
        case 4:
          return n.label++, {
            value: l[1],
            done: !1
          };
        case 5:
          n.label++, i = l[1], l = [0];
          continue;
        case 7:
          l = n.ops.pop(), n.trys.pop();
          continue;
        default:
          if (s = n.trys, !(s = s.length > 0 && s[s.length - 1]) && (l[0] === 6 || l[0] === 2)) {
            n = 0;
            continue
          }
          if (l[0] === 3 && (!s || l[1] > s[0] && l[1] < s[3])) {
            n.label = l[1];
            break
          }
          if (l[0] === 6 && n.label < s[1]) {
            n.label = s[1], s = l;
            break
          }
          if (s && n.label < s[2]) {
            n.label = s[2], n.ops.push(l);
            break
          }
          s[2] && n.ops.pop(), n.trys.pop();
          continue
      }
      l = t.call(e, n)
    } catch (u) {
      l = [6, u], i = 0
    } finally {
      r = s = 0
    }
    if (l[0] & 5) throw l[1];
    return {
      value: l[0] ? l[1] : void 0,
      done: !0
    }
  }
}

function $Ne(e, t, n, r) {
  r === void 0 && (r = n), e[r] = t[n]
}

function LNe(e, t) {
  for (var n in e) n !== "default" && !t.hasOwnProperty(n) && (t[n] = e[n])
}

function QA(e) {
  var t = typeof Symbol == "function" && Symbol.iterator,
    n = t && e[t],
    r = 0;
  if (n) return n.call(e);
  if (e && typeof e.length == "number") return {
    next: function () {
      return e && r >= e.length && (e = void 0), {
        value: e && e[r++],
        done: !e
      }
    }
  };
  throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.")
}

function yY(e, t) {
  var n = typeof Symbol == "function" && e[Symbol.iterator];
  if (!n) return e;
  var r = n.call(e),
    i, s = [],
    o;
  try {
    for (;
      (t === void 0 || t-- > 0) && !(i = r.next()).done;) s.push(i.value)
  } catch (a) {
    o = {
      error: a
    }
  } finally {
    try {
      i && !i.done && (n = r.return) && n.call(r)
    } finally {
      if (o) throw o.error
    }
  }
  return s
}

function BNe() {
  for (var e = [], t = 0; t < arguments.length; t++) e = e.concat(yY(arguments[t]));
  return e
}

function FNe() {
  for (var e = 0, t = 0, n = arguments.length; t < n; t++) e += arguments[t].length;
  for (var r = Array(e), i = 0, t = 0; t < n; t++)
    for (var s = arguments[t], o = 0, a = s.length; o < a; o++, i++) r[i] = s[o];
  return r
}

function w2(e) {
  return this instanceof w2 ? (this.v = e, this) : new w2(e)
}

function jNe(e, t, n) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var r = n.apply(e, t || []),
    i, s = [];
  return i = {}, o("next"), o("throw"), o("return"), i[Symbol.asyncIterator] = function () {
    return this
  }, i;

  function o(h) {
    r[h] && (i[h] = function (g) {
      return new Promise(function (y, x) {
        s.push([h, g, y, x]) > 1 || a(h, g)
      })
    })
  }

  function a(h, g) {
    try {
      c(r[h](g))
    } catch (y) {
      f(s[0][3], y)
    }
  }

  function c(h) {
    h.value instanceof w2 ? Promise.resolve(h.value.v).then(l, u) : f(s[0][2], h)
  }

  function l(h) {
    a("next", h)
  }

  function u(h) {
    a("throw", h)
  }

  function f(h, g) {
    h(g), s.shift(), s.length && a(s[0][0], s[0][1])
  }
}

function UNe(e) {
  var t, n;
  return t = {}, r("next"), r("throw", function (i) {
    throw i
  }), r("return"), t[Symbol.iterator] = function () {
    return this
  }, t;

  function r(i, s) {
    t[i] = e[i] ? function (o) {
      return (n = !n) ? {
        value: w2(e[i](o)),
        done: i === "return"
      } : s ? s(o) : o
    } : s
  }
}

function zNe(e) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var t = e[Symbol.asyncIterator],
    n;
  return t ? t.call(e) : (e = typeof QA == "function" ? QA(e) : e[Symbol.iterator](), n = {}, r("next"), r("throw"), r("return"), n[Symbol.asyncIterator] = function () {
    return this
  }, n);

  function r(s) {
    n[s] = e[s] && function (o) {
      return new Promise(function (a, c) {
        o = e[s](o), i(a, c, o.done, o.value)
      })
    }
  }

  function i(s, o, a, c) {
    Promise.resolve(c).then(function (l) {
      s({
        value: l,
        done: a
      })
    }, o)
  }
}

function HNe(e, t) {
  return Object.defineProperty ? Object.defineProperty(e, "raw", {
    value: t
  }) : e.raw = t, e
}

function VNe(e) {
  if (e && e.__esModule) return e;
  var t = {};
  if (e != null)
    for (var n in e) Object.hasOwnProperty.call(e, n) && (t[n] = e[n]);
  return t.default = e, t
}

function WNe(e) {
  return e && e.__esModule ? e : {
    default: e
  }
}

function qNe(e, t) {
  if (!t.has(e)) throw new TypeError("attempted to get private field on non-instance");
  return t.get(e)
}

function GNe(e, t, n) {
  if (!t.has(e)) throw new TypeError("attempted to set private field on non-instance");
  return t.set(e, n), n
}
const KNe = Object.freeze(Object.defineProperty({
    __proto__: null,
    get __assign() {
      return KA
    },
    __asyncDelegator: UNe,
    __asyncGenerator: jNe,
    __asyncValues: zNe,
    __await: w2,
    __awaiter: NNe,
    __classPrivateFieldGet: qNe,
    __classPrivateFieldSet: GNe,
    __createBinding: $Ne,
    __decorate: RNe,
    __exportStar: LNe,
    __extends: INe,
    __generator: MNe,
    __importDefault: WNe,
    __importStar: VNe,
    __makeTemplateObject: HNe,
    __metadata: DNe,
    __param: ONe,
    __read: yY,
    __rest: PNe,
    __spread: BNe,
    __spreadArrays: FNe,
    __values: QA
  }, Symbol.toStringTag, {
    value: "Module"
  })),
  Sl = Ds(KNe);
var d8 = {},
  Fg = {},
  q$;

function QNe() {
  if (q$) return Fg;
  q$ = 1, Object.defineProperty(Fg, "__esModule", {
    value: !0
  }), Fg.delay = void 0;

  function e(t) {
    return new Promise(n => {
      setTimeout(() => {
        n(!0)
      }, t)
    })
  }
  return Fg.delay = e, Fg
}
var mf = {},
  f8 = {},
  gf = {},
  G$;

function YNe() {
  return G$ || (G$ = 1, Object.defineProperty(gf, "__esModule", {
    value: !0
  }), gf.ONE_THOUSAND = gf.ONE_HUNDRED = void 0, gf.ONE_HUNDRED = 100, gf.ONE_THOUSAND = 1e3), gf
}
var h8 = {},
  K$;

function JNe() {
  return K$ || (K$ = 1, function (e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), e.ONE_YEAR = e.FOUR_WEEKS = e.THREE_WEEKS = e.TWO_WEEKS = e.ONE_WEEK = e.THIRTY_DAYS = e.SEVEN_DAYS = e.FIVE_DAYS = e.THREE_DAYS = e.ONE_DAY = e.TWENTY_FOUR_HOURS = e.TWELVE_HOURS = e.SIX_HOURS = e.THREE_HOURS = e.ONE_HOUR = e.SIXTY_MINUTES = e.THIRTY_MINUTES = e.TEN_MINUTES = e.FIVE_MINUTES = e.ONE_MINUTE = e.SIXTY_SECONDS = e.THIRTY_SECONDS = e.TEN_SECONDS = e.FIVE_SECONDS = e.ONE_SECOND = void 0, e.ONE_SECOND = 1, e.FIVE_SECONDS = 5, e.TEN_SECONDS = 10, e.THIRTY_SECONDS = 30, e.SIXTY_SECONDS = 60, e.ONE_MINUTE = e.SIXTY_SECONDS, e.FIVE_MINUTES = e.ONE_MINUTE * 5, e.TEN_MINUTES = e.ONE_MINUTE * 10, e.THIRTY_MINUTES = e.ONE_MINUTE * 30, e.SIXTY_MINUTES = e.ONE_MINUTE * 60, e.ONE_HOUR = e.SIXTY_MINUTES, e.THREE_HOURS = e.ONE_HOUR * 3, e.SIX_HOURS = e.ONE_HOUR * 6, e.TWELVE_HOURS = e.ONE_HOUR * 12, e.TWENTY_FOUR_HOURS = e.ONE_HOUR * 24, e.ONE_DAY = e.TWENTY_FOUR_HOURS, e.THREE_DAYS = e.ONE_DAY * 3, e.FIVE_DAYS = e.ONE_DAY * 5, e.SEVEN_DAYS = e.ONE_DAY * 7, e.THIRTY_DAYS = e.ONE_DAY * 30, e.ONE_WEEK = e.SEVEN_DAYS, e.TWO_WEEKS = e.ONE_WEEK * 2, e.THREE_WEEKS = e.ONE_WEEK * 3, e.FOUR_WEEKS = e.ONE_WEEK * 4, e.ONE_YEAR = e.ONE_DAY * 365
  }(h8)), h8
}
var Q$;

function vY() {
  return Q$ || (Q$ = 1, function (e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    });
    const t = Sl;
    t.__exportStar(YNe(), e), t.__exportStar(JNe(), e)
  }(f8)), f8
}
var Y$;

function XNe() {
  if (Y$) return mf;
  Y$ = 1, Object.defineProperty(mf, "__esModule", {
    value: !0
  }), mf.fromMiliseconds = mf.toMiliseconds = void 0;
  const e = vY();

  function t(r) {
    return r * e.ONE_THOUSAND
  }
  mf.toMiliseconds = t;

  function n(r) {
    return Math.floor(r / e.ONE_THOUSAND)
  }
  return mf.fromMiliseconds = n, mf
}
var J$;

function ZNe() {
  return J$ || (J$ = 1, function (e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    });
    const t = Sl;
    t.__exportStar(QNe(), e), t.__exportStar(XNe(), e)
  }(d8)), d8
}
var g0 = {},
  X$;

function eMe() {
  if (X$) return g0;
  X$ = 1, Object.defineProperty(g0, "__esModule", {
    value: !0
  }), g0.Watch = void 0;
  class e {
    constructor() {
      this.timestamps = new Map
    }
    start(n) {
      if (this.timestamps.has(n)) throw new Error(`Watch already started for label: ${n}`);
      this.timestamps.set(n, {
        started: Date.now()
      })
    }
    stop(n) {
      const r = this.get(n);
      if (typeof r.elapsed < "u") throw new Error(`Watch already stopped for label: ${n}`);
      const i = Date.now() - r.started;
      this.timestamps.set(n, {
        started: r.started,
        elapsed: i
      })
    }
    get(n) {
      const r = this.timestamps.get(n);
      if (typeof r > "u") throw new Error(`No timestamp found for label: ${n}`);
      return r
    }
    elapsed(n) {
      const r = this.get(n);
      return r.elapsed || Date.now() - r.started
    }
  }
  return g0.Watch = e, g0.default = e, g0
}
var p8 = {},
  jg = {},
  Z$;

function tMe() {
  if (Z$) return jg;
  Z$ = 1, Object.defineProperty(jg, "__esModule", {
    value: !0
  }), jg.IWatch = void 0;
  class e {}
  return jg.IWatch = e, jg
}
var eL;

function nMe() {
  return eL || (eL = 1, function (e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), Sl.__exportStar(tMe(), e)
  }(p8)), p8
}(function (e) {
  Object.defineProperty(e, "__esModule", {
    value: !0
  });
  const t = Sl;
  t.__exportStar(ZNe(), e), t.__exportStar(eMe(), e), t.__exportStar(nMe(), e), t.__exportStar(vY(), e)
})(it);
var ar = {};
Object.defineProperty(ar, "__esModule", {
  value: !0
});
ar.getLocalStorage = ar.getLocalStorageOrThrow = ar.getCrypto = ar.getCryptoOrThrow = bY = ar.getLocation = ar.getLocationOrThrow = _y = ar.getNavigator = ar.getNavigatorOrThrow = ky = ar.getDocument = ar.getDocumentOrThrow = ar.getFromWindowOrThrow = ar.getFromWindow = void 0;

function Fh(e) {
  let t;
  return typeof window < "u" && typeof window[e] < "u" && (t = window[e]), t
}
ar.getFromWindow = Fh;

function zm(e) {
  const t = Fh(e);
  if (!t) throw new Error(`${e} is not defined in Window`);
  return t
}
ar.getFromWindowOrThrow = zm;

function rMe() {
  return zm("document")
}
ar.getDocumentOrThrow = rMe;

function iMe() {
  return Fh("document")
}
var ky = ar.getDocument = iMe;

function sMe() {
  return zm("navigator")
}
ar.getNavigatorOrThrow = sMe;

function oMe() {
  return Fh("navigator")
}
var _y = ar.getNavigator = oMe;

function aMe() {
  return zm("location")
}
ar.getLocationOrThrow = aMe;

function cMe() {
  return Fh("location")
}
var bY = ar.getLocation = cMe;

function lMe() {
  return zm("crypto")
}
ar.getCryptoOrThrow = lMe;

function uMe() {
  return Fh("crypto")
}
ar.getCrypto = uMe;

function dMe() {
  return zm("localStorage")
}
ar.getLocalStorageOrThrow = dMe;

function fMe() {
  return Fh("localStorage")
}
ar.getLocalStorage = fMe;
var m_ = {};
Object.defineProperty(m_, "__esModule", {
  value: !0
});
var wY = m_.getWindowMetadata = void 0;
const tL = ar;

function hMe() {
  let e, t;
  try {
    e = tL.getDocumentOrThrow(), t = tL.getLocationOrThrow()
  } catch {
    return null
  }

  function n() {
    const f = e.getElementsByTagName("link"),
      h = [];
    for (let g = 0; g < f.length; g++) {
      const y = f[g],
        x = y.getAttribute("rel");
      if (x && x.toLowerCase().indexOf("icon") > -1) {
        const k = y.getAttribute("href");
        if (k)
          if (k.toLowerCase().indexOf("https:") === -1 && k.toLowerCase().indexOf("http:") === -1 && k.indexOf("//") !== 0) {
            let _ = t.protocol + "//" + t.host;
            if (k.indexOf("/") === 0) _ += k;
            else {
              const p = t.pathname.split("/");
              p.pop();
              const v = p.join("/");
              _ += v + "/" + k
            }
            h.push(_)
          } else if (k.indexOf("//") === 0) {
          const _ = t.protocol + k;
          h.push(_)
        } else h.push(k)
      }
    }
    return h
  }

  function r(...f) {
    const h = e.getElementsByTagName("meta");
    for (let g = 0; g < h.length; g++) {
      const y = h[g],
        x = ["itemprop", "property", "name"].map(k => y.getAttribute(k)).filter(k => k ? f.includes(k) : !1);
      if (x.length && x) {
        const k = y.getAttribute("content");
        if (k) return k
      }
    }
    return ""
  }

  function i() {
    let f = r("name", "og:site_name", "og:title", "twitter:title");
    return f || (f = e.title), f
  }

  function s() {
    return r("description", "og:description", "twitter:description", "keywords")
  }
  const o = i(),
    a = s(),
    c = t.origin,
    l = n();
  return {
    description: a,
    url: c,
    icons: l,
    name: o
  }
}
wY = m_.getWindowMetadata = hMe;
var pMe = {},
  tE = e => encodeURIComponent(e).replace(/[!'()*]/g, t => `%${t.charCodeAt(0).toString(16).toUpperCase()}`),
  xY = "%[a-f0-9]{2}",
  nL = new RegExp("(" + xY + ")|([^%]+?)", "gi"),
  rL = new RegExp("(" + xY + ")+", "gi");

function YA(e, t) {
  try {
    return [decodeURIComponent(e.join(""))]
  } catch {}
  if (e.length === 1) return e;
  t = t || 1;
  var n = e.slice(0, t),
    r = e.slice(t);
  return Array.prototype.concat.call([], YA(n), YA(r))
}

function mMe(e) {
  try {
    return decodeURIComponent(e)
  } catch {
    for (var t = e.match(nL) || [], n = 1; n < t.length; n++) e = YA(t, n).join(""), t = e.match(nL) || [];
    return e
  }
}

function gMe(e) {
  for (var t = {
      "%FE%FF": "��",
      "%FF%FE": "��"
    }, n = rL.exec(e); n;) {
    try {
      t[n[0]] = decodeURIComponent(n[0])
    } catch {
      var r = mMe(n[0]);
      r !== n[0] && (t[n[0]] = r)
    }
    n = rL.exec(e)
  }
  t["%C2"] = "�";
  for (var i = Object.keys(t), s = 0; s < i.length; s++) {
    var o = i[s];
    e = e.replace(new RegExp(o, "g"), t[o])
  }
  return e
}
var nE = function (e) {
    if (typeof e != "string") throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof e + "`");
    try {
      return e = e.replace(/\+/g, " "), decodeURIComponent(e)
    } catch {
      return gMe(e)
    }
  },
  rE = (e, t) => {
    if (!(typeof e == "string" && typeof t == "string")) throw new TypeError("Expected the arguments to be of type `string`");
    if (t === "") return [e];
    const n = e.indexOf(t);
    return n === -1 ? [e] : [e.slice(0, n), e.slice(n + t.length)]
  },
  iE = function (e, t) {
    for (var n = {}, r = Object.keys(e), i = Array.isArray(t), s = 0; s < r.length; s++) {
      var o = r[s],
        a = e[o];
      (i ? t.indexOf(o) !== -1 : t(o, a, e)) && (n[o] = a)
    }
    return n
  };
(function (e) {
  const t = tE,
    n = nE,
    r = rE,
    i = iE,
    s = p => p == null,
    o = Symbol("encodeFragmentIdentifier");

  function a(p) {
    switch (p.arrayFormat) {
      case "index":
        return v => (S, I) => {
          const A = S.length;
          return I === void 0 || p.skipNull && I === null || p.skipEmptyString && I === "" ? S : I === null ? [...S, [u(v, p), "[", A, "]"].join("")] : [...S, [u(v, p), "[", u(A, p), "]=", u(I, p)].join("")]
        };
      case "bracket":
        return v => (S, I) => I === void 0 || p.skipNull && I === null || p.skipEmptyString && I === "" ? S : I === null ? [...S, [u(v, p), "[]"].join("")] : [...S, [u(v, p), "[]=", u(I, p)].join("")];
      case "colon-list-separator":
        return v => (S, I) => I === void 0 || p.skipNull && I === null || p.skipEmptyString && I === "" ? S : I === null ? [...S, [u(v, p), ":list="].join("")] : [...S, [u(v, p), ":list=", u(I, p)].join("")];
      case "comma":
      case "separator":
      case "bracket-separator": {
        const v = p.arrayFormat === "bracket-separator" ? "[]=" : "=";
        return S => (I, A) => A === void 0 || p.skipNull && A === null || p.skipEmptyString && A === "" ? I : (A = A === null ? "" : A, I.length === 0 ? [
          [u(S, p), v, u(A, p)].join("")
        ] : [
          [I, u(A, p)].join(p.arrayFormatSeparator)
        ])
      }
      default:
        return v => (S, I) => I === void 0 || p.skipNull && I === null || p.skipEmptyString && I === "" ? S : I === null ? [...S, u(v, p)] : [...S, [u(v, p), "=", u(I, p)].join("")]
    }
  }

  function c(p) {
    let v;
    switch (p.arrayFormat) {
      case "index":
        return (S, I, A) => {
          if (v = /\[(\d*)\]$/.exec(S), S = S.replace(/\[\d*\]$/, ""), !v) {
            A[S] = I;
            return
          }
          A[S] === void 0 && (A[S] = {}), A[S][v[1]] = I
        };
      case "bracket":
        return (S, I, A) => {
          if (v = /(\[\])$/.exec(S), S = S.replace(/\[\]$/, ""), !v) {
            A[S] = I;
            return
          }
          if (A[S] === void 0) {
            A[S] = [I];
            return
          }
          A[S] = [].concat(A[S], I)
        };
      case "colon-list-separator":
        return (S, I, A) => {
          if (v = /(:list)$/.exec(S), S = S.replace(/:list$/, ""), !v) {
            A[S] = I;
            return
          }
          if (A[S] === void 0) {
            A[S] = [I];
            return
          }
          A[S] = [].concat(A[S], I)
        };
      case "comma":
      case "separator":
        return (S, I, A) => {
          const w = typeof I == "string" && I.includes(p.arrayFormatSeparator),
            E = typeof I == "string" && !w && f(I, p).includes(p.arrayFormatSeparator);
          I = E ? f(I, p) : I;
          const D = w || E ? I.split(p.arrayFormatSeparator).map($ => f($, p)) : I === null ? I : f(I, p);
          A[S] = D
        };
      case "bracket-separator":
        return (S, I, A) => {
          const w = /(\[\])$/.test(S);
          if (S = S.replace(/\[\]$/, ""), !w) {
            A[S] = I && f(I, p);
            return
          }
          const E = I === null ? [] : I.split(p.arrayFormatSeparator).map(D => f(D, p));
          if (A[S] === void 0) {
            A[S] = E;
            return
          }
          A[S] = [].concat(A[S], E)
        };
      default:
        return (S, I, A) => {
          if (A[S] === void 0) {
            A[S] = I;
            return
          }
          A[S] = [].concat(A[S], I)
        }
    }
  }

  function l(p) {
    if (typeof p != "string" || p.length !== 1) throw new TypeError("arrayFormatSeparator must be single character string")
  }

  function u(p, v) {
    return v.encode ? v.strict ? t(p) : encodeURIComponent(p) : p
  }

  function f(p, v) {
    return v.decode ? n(p) : p
  }

  function h(p) {
    return Array.isArray(p) ? p.sort() : typeof p == "object" ? h(Object.keys(p)).sort((v, S) => Number(v) - Number(S)).map(v => p[v]) : p
  }

  function g(p) {
    const v = p.indexOf("#");
    return v !== -1 && (p = p.slice(0, v)), p
  }

  function y(p) {
    let v = "";
    const S = p.indexOf("#");
    return S !== -1 && (v = p.slice(S)), v
  }

  function x(p) {
    p = g(p);
    const v = p.indexOf("?");
    return v === -1 ? "" : p.slice(v + 1)
  }

  function k(p, v) {
    return v.parseNumbers && !Number.isNaN(Number(p)) && typeof p == "string" && p.trim() !== "" ? p = Number(p) : v.parseBooleans && p !== null && (p.toLowerCase() === "true" || p.toLowerCase() === "false") && (p = p.toLowerCase() === "true"), p
  }

  function _(p, v) {
    v = Object.assign({
      decode: !0,
      sort: !0,
      arrayFormat: "none",
      arrayFormatSeparator: ",",
      parseNumbers: !1,
      parseBooleans: !1
    }, v), l(v.arrayFormatSeparator);
    const S = c(v),
      I = Object.create(null);
    if (typeof p != "string" || (p = p.trim().replace(/^[?#&]/, ""), !p)) return I;
    for (const A of p.split("&")) {
      if (A === "") continue;
      let [w, E] = r(v.decode ? A.replace(/\+/g, " ") : A, "=");
      E = E === void 0 ? null : ["comma", "separator", "bracket-separator"].includes(v.arrayFormat) ? E : f(E, v), S(f(w, v), E, I)
    }
    for (const A of Object.keys(I)) {
      const w = I[A];
      if (typeof w == "object" && w !== null)
        for (const E of Object.keys(w)) w[E] = k(w[E], v);
      else I[A] = k(w, v)
    }
    return v.sort === !1 ? I : (v.sort === !0 ? Object.keys(I).sort() : Object.keys(I).sort(v.sort)).reduce((A, w) => {
      const E = I[w];
      return E && typeof E == "object" && !Array.isArray(E) ? A[w] = h(E) : A[w] = E, A
    }, Object.create(null))
  }
  e.extract = x, e.parse = _, e.stringify = (p, v) => {
    if (!p) return "";
    v = Object.assign({
      encode: !0,
      strict: !0,
      arrayFormat: "none",
      arrayFormatSeparator: ","
    }, v), l(v.arrayFormatSeparator);
    const S = E => v.skipNull && s(p[E]) || v.skipEmptyString && p[E] === "",
      I = a(v),
      A = {};
    for (const E of Object.keys(p)) S(E) || (A[E] = p[E]);
    const w = Object.keys(A);
    return v.sort !== !1 && w.sort(v.sort), w.map(E => {
      const D = p[E];
      return D === void 0 ? "" : D === null ? u(E, v) : Array.isArray(D) ? D.length === 0 && v.arrayFormat === "bracket-separator" ? u(E, v) + "[]" : D.reduce(I(E), []).join("&") : u(E, v) + "=" + u(D, v)
    }).filter(E => E.length > 0).join("&")
  }, e.parseUrl = (p, v) => {
    v = Object.assign({
      decode: !0
    }, v);
    const [S, I] = r(p, "#");
    return Object.assign({
      url: S.split("?")[0] || "",
      query: _(x(p), v)
    }, v && v.parseFragmentIdentifier && I ? {
      fragmentIdentifier: f(I, v)
    } : {})
  }, e.stringifyUrl = (p, v) => {
    v = Object.assign({
      encode: !0,
      strict: !0,
      [o]: !0
    }, v);
    const S = g(p.url).split("?")[0] || "",
      I = e.extract(p.url),
      A = e.parse(I, {
        sort: !1
      }),
      w = Object.assign(A, p.query);
    let E = e.stringify(w, v);
    E && (E = `?${E}`);
    let D = y(p.url);
    return p.fragmentIdentifier && (D = `#${v[o]?u(p.fragmentIdentifier,v):p.fragmentIdentifier}`), `${S}${E}${D}`
  }, e.pick = (p, v, S) => {
    S = Object.assign({
      parseFragmentIdentifier: !0,
      [o]: !1
    }, S);
    const {
      url: I,
      query: A,
      fragmentIdentifier: w
    } = e.parseUrl(p, S);
    return e.stringifyUrl({
      url: I,
      query: i(A, v),
      fragmentIdentifier: w
    }, S)
  }, e.exclude = (p, v, S) => {
    const I = Array.isArray(v) ? A => !v.includes(A) : (A, w) => !v(A, w);
    return e.pick(p, I, S)
  }
})(pMe);
const yMe = {
  waku: {
    publish: "waku_publish",
    batchPublish: "waku_batchPublish",
    subscribe: "waku_subscribe",
    batchSubscribe: "waku_batchSubscribe",
    subscription: "waku_subscription",
    unsubscribe: "waku_unsubscribe",
    batchUnsubscribe: "waku_batchUnsubscribe"
  },
  irn: {
    publish: "irn_publish",
    batchPublish: "irn_batchPublish",
    subscribe: "irn_subscribe",
    batchSubscribe: "irn_batchSubscribe",
    subscription: "irn_subscription",
    unsubscribe: "irn_unsubscribe",
    batchUnsubscribe: "irn_batchUnsubscribe"
  },
  iridium: {
    publish: "iridium_publish",
    batchPublish: "iridium_batchPublish",
    subscribe: "iridium_subscribe",
    batchSubscribe: "iridium_batchSubscribe",
    subscription: "iridium_subscription",
    unsubscribe: "iridium_unsubscribe",
    batchUnsubscribe: "iridium_batchUnsubscribe"
  }
};

function vMe(e, t = []) {
  const n = [];
  return Object.keys(e).forEach(r => {
    if (t.length && !t.includes(r)) return;
    const i = e[r];
    n.push(...i.accounts)
  }), n
}
const bMe = {
  INVALID_METHOD: {
    message: "Invalid method.",
    code: 1001
  },
  INVALID_EVENT: {
    message: "Invalid event.",
    code: 1002
  },
  INVALID_UPDATE_REQUEST: {
    message: "Invalid update request.",
    code: 1003
  },
  INVALID_EXTEND_REQUEST: {
    message: "Invalid extend request.",
    code: 1004
  },
  INVALID_SESSION_SETTLE_REQUEST: {
    message: "Invalid session settle request.",
    code: 1005
  },
  UNAUTHORIZED_METHOD: {
    message: "Unauthorized method.",
    code: 3001
  },
  UNAUTHORIZED_EVENT: {
    message: "Unauthorized event.",
    code: 3002
  },
  UNAUTHORIZED_UPDATE_REQUEST: {
    message: "Unauthorized update request.",
    code: 3003
  },
  UNAUTHORIZED_EXTEND_REQUEST: {
    message: "Unauthorized extend request.",
    code: 3004
  },
  USER_REJECTED: {
    message: "User rejected.",
    code: 5e3
  },
  USER_REJECTED_CHAINS: {
    message: "User rejected chains.",
    code: 5001
  },
  USER_REJECTED_METHODS: {
    message: "User rejected methods.",
    code: 5002
  },
  USER_REJECTED_EVENTS: {
    message: "User rejected events.",
    code: 5003
  },
  UNSUPPORTED_CHAINS: {
    message: "Unsupported chains.",
    code: 5100
  },
  UNSUPPORTED_METHODS: {
    message: "Unsupported methods.",
    code: 5101
  },
  UNSUPPORTED_EVENTS: {
    message: "Unsupported events.",
    code: 5102
  },
  UNSUPPORTED_ACCOUNTS: {
    message: "Unsupported accounts.",
    code: 5103
  },
  UNSUPPORTED_NAMESPACE_KEY: {
    message: "Unsupported namespace key.",
    code: 5104
  },
  USER_DISCONNECTED: {
    message: "User disconnected.",
    code: 6e3
  },
  SESSION_SETTLEMENT_FAILED: {
    message: "Session settlement failed.",
    code: 7e3
  },
  WC_METHOD_UNSUPPORTED: {
    message: "Unsupported wc_ method.",
    code: 10001
  }
};

function wMe(e, t) {
  const {
    message: n,
    code: r
  } = bMe[e];
  return {
    message: t ? `${n} ${t}` : n,
    code: r
  }
}

function JA(e, t) {
  return Array.isArray(e) ? typeof t < "u" && e.length ? e.every(t) : !0 : !1
}
const xMe = /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/,
  EMe = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/,
  SMe = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;

function CMe(e, t) {
  if (e === "__proto__" || e === "constructor" && t && typeof t == "object" && "prototype" in t) {
    AMe(e);
    return
  }
  return t
}

function AMe(e) {
  console.warn(`[destr] Dropping "${e}" key to prevent prototype pollution.`)
}

function Lb(e, t = {}) {
  if (typeof e != "string") return e;
  const n = e.trim();
  if (e[0] === '"' && e.endsWith('"') && !e.includes("\\")) return n.slice(1, -1);
  if (n.length <= 9) {
    const r = n.toLowerCase();
    if (r === "true") return !0;
    if (r === "false") return !1;
    if (r === "undefined") return;
    if (r === "null") return null;
    if (r === "nan") return Number.NaN;
    if (r === "infinity") return Number.POSITIVE_INFINITY;
    if (r === "-infinity") return Number.NEGATIVE_INFINITY
  }
  if (!SMe.test(e)) {
    if (t.strict) throw new SyntaxError("[destr] Invalid JSON");
    return e
  }
  try {
    if (xMe.test(e) || EMe.test(e)) {
      if (t.strict) throw new Error("[destr] Possible prototype pollution");
      return JSON.parse(e, CMe)
    }
    return JSON.parse(e)
  } catch (r) {
    if (t.strict) throw r;
    return e
  }
}

function TMe(e) {
  return !e || typeof e.then != "function" ? Promise.resolve(e) : e
}

function vi(e, ...t) {
  try {
    return TMe(e(...t))
  } catch (n) {
    return Promise.reject(n)
  }
}

function kMe(e) {
  const t = typeof e;
  return e === null || t !== "object" && t !== "function"
}

function _Me(e) {
  const t = Object.getPrototypeOf(e);
  return !t || t.isPrototypeOf(Object)
}

function Tw(e) {
  if (kMe(e)) return String(e);
  if (_Me(e) || Array.isArray(e)) return JSON.stringify(e);
  if (typeof e.toJSON == "function") return Tw(e.toJSON());
  throw new Error("[unstorage] Cannot stringify value!")
}

function EY() {
  if (typeof Buffer === void 0) throw new TypeError("[unstorage] Buffer is not supported!")
}
const XA = "base64:";

function IMe(e) {
  if (typeof e == "string") return e;
  EY();
  const t = Buffer.from(e).toString("base64");
  return XA + t
}

function PMe(e) {
  return typeof e != "string" || !e.startsWith(XA) ? e : (EY(), Buffer.from(e.slice(XA.length), "base64"))
}

function Js(e) {
  return e ? e.split("?")[0].replace(/[/\\]/g, ":").replace(/:+/g, ":").replace(/^:|:$/g, "") : ""
}

function RMe(...e) {
  return Js(e.join(":"))
}

function Bb(e) {
  return e = Js(e), e ? e + ":" : ""
}
const OMe = "memory",
  DMe = () => {
    const e = new Map;
    return {
      name: OMe,
      options: {},
      hasItem(t) {
        return e.has(t)
      },
      getItem(t) {
        return e.get(t) ?? null
      },
      getItemRaw(t) {
        return e.get(t) ?? null
      },
      setItem(t, n) {
        e.set(t, n)
      },
      setItemRaw(t, n) {
        e.set(t, n)
      },
      removeItem(t) {
        e.delete(t)
      },
      getKeys() {
        return Array.from(e.keys())
      },
      clear() {
        e.clear()
      },
      dispose() {
        e.clear()
      }
    }
  };

function NMe(e = {}) {
  const t = {
      mounts: {
        "": e.driver || DMe()
      },
      mountpoints: [""],
      watching: !1,
      watchListeners: [],
      unwatch: {}
    },
    n = l => {
      for (const u of t.mountpoints)
        if (l.startsWith(u)) return {
          base: u,
          relativeKey: l.slice(u.length),
          driver: t.mounts[u]
        };
      return {
        base: "",
        relativeKey: l,
        driver: t.mounts[""]
      }
    },
    r = (l, u) => t.mountpoints.filter(f => f.startsWith(l) || u && l.startsWith(f)).map(f => ({
      relativeBase: l.length > f.length ? l.slice(f.length) : void 0,
      mountpoint: f,
      driver: t.mounts[f]
    })),
    i = (l, u) => {
      if (t.watching) {
        u = Js(u);
        for (const f of t.watchListeners) f(l, u)
      }
    },
    s = async () => {
      if (!t.watching) {
        t.watching = !0;
        for (const l in t.mounts) t.unwatch[l] = await iL(t.mounts[l], i, l)
      }
    }, o = async () => {
      if (t.watching) {
        for (const l in t.unwatch) await t.unwatch[l]();
        t.unwatch = {}, t.watching = !1
      }
    }, a = (l, u, f) => {
      const h = new Map,
        g = y => {
          let x = h.get(y.base);
          return x || (x = {
            driver: y.driver,
            base: y.base,
            items: []
          }, h.set(y.base, x)), x
        };
      for (const y of l) {
        const x = typeof y == "string",
          k = Js(x ? y : y.key),
          _ = x ? void 0 : y.value,
          p = x || !y.options ? u : {
            ...u,
            ...y.options
          },
          v = n(k);
        g(v).items.push({
          key: k,
          value: _,
          relativeKey: v.relativeKey,
          options: p
        })
      }
      return Promise.all([...h.values()].map(y => f(y))).then(y => y.flat())
    }, c = {
      hasItem(l, u = {}) {
        l = Js(l);
        const {
          relativeKey: f,
          driver: h
        } = n(l);
        return vi(h.hasItem, f, u)
      },
      getItem(l, u = {}) {
        l = Js(l);
        const {
          relativeKey: f,
          driver: h
        } = n(l);
        return vi(h.getItem, f, u).then(g => Lb(g))
      },
      getItems(l, u) {
        return a(l, u, f => f.driver.getItems ? vi(f.driver.getItems, f.items.map(h => ({
          key: h.relativeKey,
          options: h.options
        })), u).then(h => h.map(g => ({
          key: RMe(f.base, g.key),
          value: Lb(g.value)
        }))) : Promise.all(f.items.map(h => vi(f.driver.getItem, h.relativeKey, h.options).then(g => ({
          key: h.key,
          value: Lb(g)
        })))))
      },
      getItemRaw(l, u = {}) {
        l = Js(l);
        const {
          relativeKey: f,
          driver: h
        } = n(l);
        return h.getItemRaw ? vi(h.getItemRaw, f, u) : vi(h.getItem, f, u).then(g => PMe(g))
      },
      async setItem(l, u, f = {}) {
        if (u === void 0) return c.removeItem(l);
        l = Js(l);
        const {
          relativeKey: h,
          driver: g
        } = n(l);
        g.setItem && (await vi(g.setItem, h, Tw(u), f), g.watch || i("update", l))
      },
      async setItems(l, u) {
        await a(l, u, async f => {
          if (f.driver.setItems) return vi(f.driver.setItems, f.items.map(h => ({
            key: h.relativeKey,
            value: Tw(h.value),
            options: h.options
          })), u);
          f.driver.setItem && await Promise.all(f.items.map(h => vi(f.driver.setItem, h.relativeKey, Tw(h.value), h.options)))
        })
      },
      async setItemRaw(l, u, f = {}) {
        if (u === void 0) return c.removeItem(l, f);
        l = Js(l);
        const {
          relativeKey: h,
          driver: g
        } = n(l);
        if (g.setItemRaw) await vi(g.setItemRaw, h, u, f);
        else if (g.setItem) await vi(g.setItem, h, IMe(u), f);
        else return;
        g.watch || i("update", l)
      },
      async removeItem(l, u = {}) {
        typeof u == "boolean" && (u = {
          removeMeta: u
        }), l = Js(l);
        const {
          relativeKey: f,
          driver: h
        } = n(l);
        h.removeItem && (await vi(h.removeItem, f, u), (u.removeMeta || u.removeMata) && await vi(h.removeItem, f + "$", u), h.watch || i("remove", l))
      },
      async getMeta(l, u = {}) {
        typeof u == "boolean" && (u = {
          nativeOnly: u
        }), l = Js(l);
        const {
          relativeKey: f,
          driver: h
        } = n(l), g = Object.create(null);
        if (h.getMeta && Object.assign(g, await vi(h.getMeta, f, u)), !u.nativeOnly) {
          const y = await vi(h.getItem, f + "$", u).then(x => Lb(x));
          y && typeof y == "object" && (typeof y.atime == "string" && (y.atime = new Date(y.atime)), typeof y.mtime == "string" && (y.mtime = new Date(y.mtime)), Object.assign(g, y))
        }
        return g
      },
      setMeta(l, u, f = {}) {
        return this.setItem(l + "$", u, f)
      },
      removeMeta(l, u = {}) {
        return this.removeItem(l + "$", u)
      },
      async getKeys(l, u = {}) {
        l = Bb(l);
        const f = r(l, !0);
        let h = [];
        const g = [];
        for (const y of f) {
          const k = (await vi(y.driver.getKeys, y.relativeBase, u)).map(_ => y.mountpoint + Js(_)).filter(_ => !h.some(p => _.startsWith(p)));
          g.push(...k), h = [y.mountpoint, ...h.filter(_ => !_.startsWith(y.mountpoint))]
        }
        return l ? g.filter(y => y.startsWith(l) && !y.endsWith("$")) : g.filter(y => !y.endsWith("$"))
      },
      async clear(l, u = {}) {
        l = Bb(l), await Promise.all(r(l, !1).map(async f => {
          if (f.driver.clear) return vi(f.driver.clear, f.relativeBase, u);
          if (f.driver.removeItem) {
            const h = await f.driver.getKeys(f.relativeBase || "", u);
            return Promise.all(h.map(g => f.driver.removeItem(g, u)))
          }
        }))
      },
      async dispose() {
        await Promise.all(Object.values(t.mounts).map(l => sL(l)))
      },
      async watch(l) {
        return await s(), t.watchListeners.push(l), async () => {
          t.watchListeners = t.watchListeners.filter(u => u !== l), t.watchListeners.length === 0 && await o()
        }
      },
      async unwatch() {
        t.watchListeners = [], await o()
      },
      mount(l, u) {
        if (l = Bb(l), l && t.mounts[l]) throw new Error(`already mounted at ${l}`);
        return l && (t.mountpoints.push(l), t.mountpoints.sort((f, h) => h.length - f.length)), t.mounts[l] = u, t.watching && Promise.resolve(iL(u, i, l)).then(f => {
          t.unwatch[l] = f
        }).catch(console.error), c
      },
      async unmount(l, u = !0) {
        l = Bb(l), !(!l || !t.mounts[l]) && (t.watching && l in t.unwatch && (t.unwatch[l](), delete t.unwatch[l]), u && await sL(t.mounts[l]), t.mountpoints = t.mountpoints.filter(f => f !== l), delete t.mounts[l])
      },
      getMount(l = "") {
        l = Js(l) + ":";
        const u = n(l);
        return {
          driver: u.driver,
          base: u.base
        }
      },
      getMounts(l = "", u = {}) {
        return l = Js(l), r(l, u.parents).map(h => ({
          driver: h.driver,
          base: h.mountpoint
        }))
      }
    };
  return c
}

function iL(e, t, n) {
  return e.watch ? e.watch((r, i) => t(r, n + i)) : () => {}
}
async function sL(e) {
  typeof e.dispose == "function" && await vi(e.dispose)
}

function jh(e) {
  return new Promise((t, n) => {
    e.oncomplete = e.onsuccess = () => t(e.result), e.onabort = e.onerror = () => n(e.error)
  })
}

function SY(e, t) {
  const n = indexedDB.open(e);
  n.onupgradeneeded = () => n.result.createObjectStore(t);
  const r = jh(n);
  return (i, s) => r.then(o => s(o.transaction(t, i).objectStore(t)))
}
let m8;

function Iy() {
  return m8 || (m8 = SY("keyval-store", "keyval")), m8
}

function oL(e, t = Iy()) {
  return t("readonly", n => jh(n.get(e)))
}

function MMe(e, t, n = Iy()) {
  return n("readwrite", r => (r.put(t, e), jh(r.transaction)))
}

function $Me(e, t = Iy()) {
  return t("readwrite", n => (n.delete(e), jh(n.transaction)))
}

function LMe(e = Iy()) {
  return e("readwrite", t => (t.clear(), jh(t.transaction)))
}

function BMe(e, t) {
  return e.openCursor().onsuccess = function () {
    this.result && (t(this.result), this.result.continue())
  }, jh(e.transaction)
}

function FMe(e = Iy()) {
  return e("readonly", t => {
    if (t.getAllKeys) return jh(t.getAllKeys());
    const n = [];
    return BMe(t, r => n.push(r.key)).then(() => n)
  })
}
const jMe = e => JSON.stringify(e, (t, n) => typeof n == "bigint" ? n.toString() + "n" : n),
  UMe = e => {
    const t = /([\[:])?(\d{17,}|(?:[9](?:[1-9]07199254740991|0[1-9]7199254740991|00[8-9]199254740991|007[2-9]99254740991|007199[3-9]54740991|0071992[6-9]4740991|00719925[5-9]740991|007199254[8-9]40991|0071992547[5-9]0991|00719925474[1-9]991|00719925474099[2-9])))([,\}\]])/g,
      n = e.replace(t, '$1"$2n"$3');
    return JSON.parse(n, (r, i) => typeof i == "string" && i.match(/^\d+n$/) ? BigInt(i.substring(0, i.length - 1)) : i)
  };

function Py(e) {
  if (typeof e != "string") throw new Error(`Cannot safe json parse value of type ${typeof e}`);
  try {
    return UMe(e)
  } catch {
    return e
  }
}

function bh(e) {
  return typeof e == "string" ? e : jMe(e) || ""
}
const zMe = "idb-keyval";
var HMe = (e = {}) => {
  const t = e.base && e.base.length > 0 ? `${e.base}:` : "",
    n = i => t + i;
  let r;
  return e.dbName && e.storeName && (r = SY(e.dbName, e.storeName)), {
    name: zMe,
    options: e,
    async hasItem(i) {
      return !(typeof await oL(n(i), r) > "u")
    },
    async getItem(i) {
      return await oL(n(i), r) ?? null
    },
    setItem(i, s) {
      return MMe(n(i), s, r)
    },
    removeItem(i) {
      return $Me(n(i), r)
    },
    getKeys() {
      return FMe(r)
    },
    clear() {
      return LMe(r)
    }
  }
};
const VMe = "WALLET_CONNECT_V2_INDEXED_DB",
  WMe = "keyvaluestorage";
let qMe = class {
  constructor() {
    this.indexedDb = NMe({
      driver: HMe({
        dbName: VMe,
        storeName: WMe
      })
    })
  }
  async getKeys() {
    return this.indexedDb.getKeys()
  }
  async getEntries() {
    return (await this.indexedDb.getItems(await this.indexedDb.getKeys())).map(t => [t.key, t.value])
  }
  async getItem(t) {
    const n = await this.indexedDb.getItem(t);
    if (n !== null) return n
  }
  async setItem(t, n) {
    await this.indexedDb.setItem(t, bh(n))
  }
  async removeItem(t) {
    await this.indexedDb.removeItem(t)
  }
};
var g8 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {},
  kw = {
    exports: {}
  };
(function () {
  let e;

  function t() {}
  e = t, e.prototype.getItem = function (n) {
    return this.hasOwnProperty(n) ? String(this[n]) : null
  }, e.prototype.setItem = function (n, r) {
    this[n] = String(r)
  }, e.prototype.removeItem = function (n) {
    delete this[n]
  }, e.prototype.clear = function () {
    const n = this;
    Object.keys(n).forEach(function (r) {
      n[r] = void 0, delete n[r]
    })
  }, e.prototype.key = function (n) {
    return n = n || 0, Object.keys(this)[n]
  }, e.prototype.__defineGetter__("length", function () {
    return Object.keys(this).length
  }), typeof g8 < "u" && g8.localStorage ? kw.exports = g8.localStorage : typeof window < "u" && window.localStorage ? kw.exports = window.localStorage : kw.exports = new t
})();

function GMe(e) {
  var t;
  return [e[0], Py((t = e[1]) != null ? t : "")]
}
let KMe = class {
  constructor() {
    this.localStorage = kw.exports
  }
  async getKeys() {
    return Object.keys(this.localStorage)
  }
  async getEntries() {
    return Object.entries(this.localStorage).map(GMe)
  }
  async getItem(t) {
    const n = this.localStorage.getItem(t);
    if (n !== null) return Py(n)
  }
  async setItem(t, n) {
    this.localStorage.setItem(t, bh(n))
  }
  async removeItem(t) {
    this.localStorage.removeItem(t)
  }
};
const QMe = "wc_storage_version",
  aL = 1,
  YMe = async (e, t, n) => {
    const r = QMe,
      i = await t.getItem(r);
    if (i && i >= aL) {
      n(t);
      return
    }
    const s = await e.getKeys();
    if (!s.length) {
      n(t);
      return
    }
    const o = [];
    for (; s.length;) {
      const a = s.shift();
      if (!a) continue;
      const c = a.toLowerCase();
      if (c.includes("wc@") || c.includes("walletconnect") || c.includes("wc_") || c.includes("wallet_connect")) {
        const l = await e.getItem(a);
        await t.setItem(a, l), o.push(a)
      }
    }
    await t.setItem(r, aL), n(t), JMe(e, o)
  }, JMe = async (e, t) => {
    t.length && t.forEach(async n => {
      await e.removeItem(n)
    })
  };
let XMe = class {
  constructor() {
    this.initialized = !1, this.setInitialized = n => {
      this.storage = n, this.initialized = !0
    };
    const t = new KMe;
    this.storage = t;
    try {
      const n = new qMe;
      YMe(t, n, this.setInitialized)
    } catch {
      this.initialized = !0
    }
  }
  async getKeys() {
    return await this.initialize(), this.storage.getKeys()
  }
  async getEntries() {
    return await this.initialize(), this.storage.getEntries()
  }
  async getItem(t) {
    return await this.initialize(), this.storage.getItem(t)
  }
  async setItem(t, n) {
    return await this.initialize(), this.storage.setItem(t, n)
  }
  async removeItem(t) {
    return await this.initialize(), this.storage.removeItem(t)
  }
  async initialize() {
    this.initialized || await new Promise(t => {
      const n = setInterval(() => {
        this.initialized && (clearInterval(n), t())
      }, 20)
    })
  }
};
var Hm = {},
  Ug = {},
  y8 = {},
  zg = {};
let Uh = class {};
const ZMe = Object.freeze(Object.defineProperty({
    __proto__: null,
    IEvents: Uh
  }, Symbol.toStringTag, {
    value: "Module"
  })),
  e$e = Ds(ZMe);
var cL;

function t$e() {
  if (cL) return zg;
  cL = 1, Object.defineProperty(zg, "__esModule", {
    value: !0
  }), zg.IHeartBeat = void 0;
  const e = e$e;
  class t extends e.IEvents {
    constructor(r) {
      super()
    }
  }
  return zg.IHeartBeat = t, zg
}
var lL;

function CY() {
  return lL || (lL = 1, function (e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), Sl.__exportStar(t$e(), e)
  }(y8)), y8
}
var v8 = {},
  yf = {},
  uL;

function n$e() {
  if (uL) return yf;
  uL = 1, Object.defineProperty(yf, "__esModule", {
    value: !0
  }), yf.HEARTBEAT_EVENTS = yf.HEARTBEAT_INTERVAL = void 0;
  const e = it;
  return yf.HEARTBEAT_INTERVAL = e.FIVE_SECONDS, yf.HEARTBEAT_EVENTS = {
    pulse: "heartbeat_pulse"
  }, yf
}
var dL;

function AY() {
  return dL || (dL = 1, function (e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), Sl.__exportStar(n$e(), e)
  }(v8)), v8
}
var fL;

function r$e() {
  if (fL) return Ug;
  fL = 1, Object.defineProperty(Ug, "__esModule", {
    value: !0
  }), Ug.HeartBeat = void 0;
  const e = Sl,
    t = si,
    n = it,
    r = CY(),
    i = AY();
  class s extends r.IHeartBeat {
    constructor(a) {
      super(a), this.events = new t.EventEmitter, this.interval = i.HEARTBEAT_INTERVAL, this.interval = (a == null ? void 0 : a.interval) || i.HEARTBEAT_INTERVAL
    }
    static init(a) {
      return e.__awaiter(this, void 0, void 0, function* () {
        const c = new s(a);
        return yield c.init(), c
      })
    }
    init() {
      return e.__awaiter(this, void 0, void 0, function* () {
        yield this.initialize()
      })
    }
    stop() {
      clearInterval(this.intervalRef)
    }
    on(a, c) {
      this.events.on(a, c)
    }
    once(a, c) {
      this.events.once(a, c)
    }
    off(a, c) {
      this.events.off(a, c)
    }
    removeListener(a, c) {
      this.events.removeListener(a, c)
    }
    initialize() {
      return e.__awaiter(this, void 0, void 0, function* () {
        this.intervalRef = setInterval(() => this.pulse(), n.toMiliseconds(this.interval))
      })
    }
    pulse() {
      this.events.emit(i.HEARTBEAT_EVENTS.pulse)
    }
  }
  return Ug.HeartBeat = s, Ug
}(function (e) {
  Object.defineProperty(e, "__esModule", {
    value: !0
  });
  const t = Sl;
  t.__exportStar(r$e(), e), t.__exportStar(CY(), e), t.__exportStar(AY(), e)
})(Hm);
var vn = {},
  b8, hL;

function i$e() {
  if (hL) return b8;
  hL = 1;

  function e(n) {
    try {
      return JSON.stringify(n)
    } catch {
      return '"[Circular]"'
    }
  }
  b8 = t;

  function t(n, r, i) {
    var s = i && i.stringify || e,
      o = 1;
    if (typeof n == "object" && n !== null) {
      var a = r.length + o;
      if (a === 1) return n;
      var c = new Array(a);
      c[0] = s(n);
      for (var l = 1; l < a; l++) c[l] = s(r[l]);
      return c.join(" ")
    }
    if (typeof n != "string") return n;
    var u = r.length;
    if (u === 0) return n;
    for (var f = "", h = 1 - o, g = -1, y = n && n.length || 0, x = 0; x < y;) {
      if (n.charCodeAt(x) === 37 && x + 1 < y) {
        switch (g = g > -1 ? g : 0, n.charCodeAt(x + 1)) {
          case 100:
          case 102:
            if (h >= u || r[h] == null) break;
            g < x && (f += n.slice(g, x)), f += Number(r[h]), g = x + 2, x++;
            break;
          case 105:
            if (h >= u || r[h] == null) break;
            g < x && (f += n.slice(g, x)), f += Math.floor(Number(r[h])), g = x + 2, x++;
            break;
          case 79:
          case 111:
          case 106:
            if (h >= u || r[h] === void 0) break;
            g < x && (f += n.slice(g, x));
            var k = typeof r[h];
            if (k === "string") {
              f += "'" + r[h] + "'", g = x + 2, x++;
              break
            }
            if (k === "function") {
              f += r[h].name || "<anonymous>", g = x + 2, x++;
              break
            }
            f += s(r[h]), g = x + 2, x++;
            break;
          case 115:
            if (h >= u) break;
            g < x && (f += n.slice(g, x)), f += String(r[h]), g = x + 2, x++;
            break;
          case 37:
            g < x && (f += n.slice(g, x)), f += "%", g = x + 2, x++, h--;
            break
        }++h
      }++x
    }
    return g === -1 ? n : (g < y && (f += n.slice(g)), f)
  }
  return b8
}
var w8, pL;

function s$e() {
  if (pL) return w8;
  pL = 1;
  const e = i$e();
  w8 = i;
  const t = I().console || {},
    n = {
      mapHttpRequest: y,
      mapHttpResponse: y,
      wrapRequestSerializer: x,
      wrapResponseSerializer: x,
      wrapErrorSerializer: x,
      req: y,
      res: y,
      err: h
    };

  function r(A, w) {
    return Array.isArray(A) ? A.filter(function (D) {
      return D !== "!stdSerializers.err"
    }) : A === !0 ? Object.keys(w) : !1
  }

  function i(A) {
    A = A || {}, A.browser = A.browser || {};
    const w = A.browser.transmit;
    if (w && typeof w.send != "function") throw Error("pino: transmit option must have a send function");
    const E = A.browser.write || t;
    A.browser.write && (A.browser.asObject = !0);
    const D = A.serializers || {},
      $ = r(A.browser.serialize, D);
    let V = A.browser.serialize;
    Array.isArray(A.browser.serialize) && A.browser.serialize.indexOf("!stdSerializers.err") > -1 && (V = !1);
    const G = ["error", "fatal", "warn", "info", "debug", "trace"];
    typeof E == "function" && (E.error = E.fatal = E.warn = E.info = E.debug = E.trace = E), A.enabled === !1 && (A.level = "silent");
    const L = A.level || "info",
      b = Object.create(E);
    b.log || (b.log = k), Object.defineProperty(b, "levelVal", {
      get: R
    }), Object.defineProperty(b, "level", {
      get: N,
      set: O
    });
    const T = {
      transmit: w,
      serialize: $,
      asObject: A.browser.asObject,
      levels: G,
      timestamp: g(A)
    };
    b.levels = i.levels, b.level = L, b.setMaxListeners = b.getMaxListeners = b.emit = b.addListener = b.on = b.prependListener = b.once = b.prependOnceListener = b.removeListener = b.removeAllListeners = b.listeners = b.listenerCount = b.eventNames = b.write = b.flush = k, b.serializers = D, b._serialize = $, b._stdErrSerialize = V, b.child = U, w && (b._logEvent = f());

    function R() {
      return this.level === "silent" ? 1 / 0 : this.levels.values[this.level]
    }

    function N() {
      return this._level
    }

    function O(q) {
      if (q !== "silent" && !this.levels.values[q]) throw Error("unknown level " + q);
      this._level = q, s(T, b, "error", "log"), s(T, b, "fatal", "error"), s(T, b, "warn", "error"), s(T, b, "info", "log"), s(T, b, "debug", "log"), s(T, b, "trace", "log")
    }

    function U(q, W) {
      if (!q) throw new Error("missing bindings for child Pino");
      W = W || {}, $ && q.serializers && (W.serializers = q.serializers);
      const M = W.serializers;
      if ($ && M) {
        var Q = Object.assign({}, D, M),
          he = A.browser.serialize === !0 ? Object.keys(Q) : $;
        delete q.serializers, c([q], he, Q, this._stdErrSerialize)
      }

      function H(ne) {
        this._childLevel = (ne._childLevel | 0) + 1, this.error = l(ne, q, "error"), this.fatal = l(ne, q, "fatal"), this.warn = l(ne, q, "warn"), this.info = l(ne, q, "info"), this.debug = l(ne, q, "debug"), this.trace = l(ne, q, "trace"), Q && (this.serializers = Q, this._serialize = he), w && (this._logEvent = f([].concat(ne._logEvent.bindings, q)))
      }
      return H.prototype = this, new H(this)
    }
    return b
  }
  i.levels = {
    values: {
      fatal: 60,
      error: 50,
      warn: 40,
      info: 30,
      debug: 20,
      trace: 10
    },
    labels: {
      10: "trace",
      20: "debug",
      30: "info",
      40: "warn",
      50: "error",
      60: "fatal"
    }
  }, i.stdSerializers = n, i.stdTimeFunctions = Object.assign({}, {
    nullTime: _,
    epochTime: p,
    unixTime: v,
    isoTime: S
  });

  function s(A, w, E, D) {
    const $ = Object.getPrototypeOf(w);
    w[E] = w.levelVal > w.levels.values[E] ? k : $[E] ? $[E] : t[E] || t[D] || k, o(A, w, E)
  }

  function o(A, w, E) {
    !A.transmit && w[E] === k || (w[E] = function (D) {
      return function () {
        const V = A.timestamp(),
          G = new Array(arguments.length),
          L = Object.getPrototypeOf && Object.getPrototypeOf(this) === t ? t : this;
        for (var b = 0; b < G.length; b++) G[b] = arguments[b];
        if (A.serialize && !A.asObject && c(G, this._serialize, this.serializers, this._stdErrSerialize), A.asObject ? D.call(L, a(this, E, G, V)) : D.apply(L, G), A.transmit) {
          const T = A.transmit.level || w.level,
            R = i.levels.values[T],
            N = i.levels.values[E];
          if (N < R) return;
          u(this, {
            ts: V,
            methodLevel: E,
            methodValue: N,
            transmitLevel: T,
            transmitValue: i.levels.values[A.transmit.level || w.level],
            send: A.transmit.send,
            val: w.levelVal
          }, G)
        }
      }
    }(w[E]))
  }

  function a(A, w, E, D) {
    A._serialize && c(E, A._serialize, A.serializers, A._stdErrSerialize);
    const $ = E.slice();
    let V = $[0];
    const G = {};
    D && (G.time = D), G.level = i.levels.values[w];
    let L = (A._childLevel | 0) + 1;
    if (L < 1 && (L = 1), V !== null && typeof V == "object") {
      for (; L-- && typeof $[0] == "object";) Object.assign(G, $.shift());
      V = $.length ? e($.shift(), $) : void 0
    } else typeof V == "string" && (V = e($.shift(), $));
    return V !== void 0 && (G.msg = V), G
  }

  function c(A, w, E, D) {
    for (const $ in A)
      if (D && A[$] instanceof Error) A[$] = i.stdSerializers.err(A[$]);
      else if (typeof A[$] == "object" && !Array.isArray(A[$]))
      for (const V in A[$]) w && w.indexOf(V) > -1 && V in E && (A[$][V] = E[V](A[$][V]))
  }

  function l(A, w, E) {
    return function () {
      const D = new Array(1 + arguments.length);
      D[0] = w;
      for (var $ = 1; $ < D.length; $++) D[$] = arguments[$ - 1];
      return A[E].apply(this, D)
    }
  }

  function u(A, w, E) {
    const D = w.send,
      $ = w.ts,
      V = w.methodLevel,
      G = w.methodValue,
      L = w.val,
      b = A._logEvent.bindings;
    c(E, A._serialize || Object.keys(A.serializers), A.serializers, A._stdErrSerialize === void 0 ? !0 : A._stdErrSerialize), A._logEvent.ts = $, A._logEvent.messages = E.filter(function (T) {
      return b.indexOf(T) === -1
    }), A._logEvent.level.label = V, A._logEvent.level.value = G, D(V, A._logEvent, L), A._logEvent = f(b)
  }

  function f(A) {
    return {
      ts: 0,
      messages: [],
      bindings: A || [],
      level: {
        label: "",
        value: 0
      }
    }
  }

  function h(A) {
    const w = {
      type: A.constructor.name,
      msg: A.message,
      stack: A.stack
    };
    for (const E in A) w[E] === void 0 && (w[E] = A[E]);
    return w
  }

  function g(A) {
    return typeof A.timestamp == "function" ? A.timestamp : A.timestamp === !1 ? _ : p
  }

  function y() {
    return {}
  }

  function x(A) {
    return A
  }

  function k() {}

  function _() {
    return !1
  }

  function p() {
    return Date.now()
  }

  function v() {
    return Math.round(Date.now() / 1e3)
  }

  function S() {
    return new Date(Date.now()).toISOString()
  }

  function I() {
    function A(w) {
      return typeof w < "u" && w
    }
    try {
      return typeof globalThis < "u" || Object.defineProperty(Object.prototype, "globalThis", {
        get: function () {
          return delete Object.prototype.globalThis, this.globalThis = this
        },
        configurable: !0
      }), globalThis
    } catch {
      return A(self) || A(window) || A(this) || {}
    }
  }
  return w8
}
var vf = {},
  mL;

function TY() {
  return mL || (mL = 1, Object.defineProperty(vf, "__esModule", {
    value: !0
  }), vf.PINO_CUSTOM_CONTEXT_KEY = vf.PINO_LOGGER_DEFAULTS = void 0, vf.PINO_LOGGER_DEFAULTS = {
    level: "info"
  }, vf.PINO_CUSTOM_CONTEXT_KEY = "custom_context"), vf
}
var bs = {},
  gL;

function o$e() {
  if (gL) return bs;
  gL = 1, Object.defineProperty(bs, "__esModule", {
    value: !0
  }), bs.generateChildLogger = bs.formatChildLoggerContext = bs.getLoggerContext = bs.setBrowserLoggerContext = bs.getBrowserLoggerContext = bs.getDefaultLoggerOptions = void 0;
  const e = TY();

  function t(a) {
    return Object.assign(Object.assign({}, a), {
      level: (a == null ? void 0 : a.level) || e.PINO_LOGGER_DEFAULTS.level
    })
  }
  bs.getDefaultLoggerOptions = t;

  function n(a, c = e.PINO_CUSTOM_CONTEXT_KEY) {
    return a[c] || ""
  }
  bs.getBrowserLoggerContext = n;

  function r(a, c, l = e.PINO_CUSTOM_CONTEXT_KEY) {
    return a[l] = c, a
  }
  bs.setBrowserLoggerContext = r;

  function i(a, c = e.PINO_CUSTOM_CONTEXT_KEY) {
    let l = "";
    return typeof a.bindings > "u" ? l = n(a, c) : l = a.bindings().context || "", l
  }
  bs.getLoggerContext = i;

  function s(a, c, l = e.PINO_CUSTOM_CONTEXT_KEY) {
    const u = i(a, l);
    return u.trim() ? `${u}/${c}` : c
  }
  bs.formatChildLoggerContext = s;

  function o(a, c, l = e.PINO_CUSTOM_CONTEXT_KEY) {
    const u = s(a, c, l),
      f = a.child({
        context: u
      });
    return r(f, u, l)
  }
  return bs.generateChildLogger = o, bs
}(function (e) {
  Object.defineProperty(e, "__esModule", {
    value: !0
  }), e.pino = void 0;
  const t = Sl,
    n = t.__importDefault(s$e());
  Object.defineProperty(e, "pino", {
    enumerable: !0,
    get: function () {
      return n.default
    }
  }), t.__exportStar(TY(), e), t.__exportStar(o$e(), e)
})(vn);
class a$e extends Uh {
  constructor(t) {
    super(), this.opts = t, this.protocol = "wc", this.version = 2
  }
}
let c$e = class extends Uh {
    constructor(t, n) {
      super(), this.core = t, this.logger = n, this.records = new Map
    }
  },
  l$e = class {
    constructor(t, n) {
      this.logger = t, this.core = n
    }
  },
  u$e = class extends Uh {
    constructor(t, n) {
      super(), this.relayer = t, this.logger = n
    }
  },
  d$e = class extends Uh {
    constructor(t) {
      super()
    }
  },
  f$e = class {
    constructor(t, n, r, i) {
      this.core = t, this.logger = n, this.name = r
    }
  };
class h$e extends Uh {
  constructor(t, n) {
    super(), this.relayer = t, this.logger = n
  }
}
let p$e = class extends Uh {
    constructor(t, n) {
      super(), this.core = t, this.logger = n
    }
  },
  m$e = class {
    constructor(t, n) {
      this.projectId = t, this.logger = n
    }
  },
  g$e = class {
    constructor(t, n) {
      this.projectId = t, this.logger = n
    }
  },
  y$e = class {
    constructor(t) {
      this.opts = t, this.protocol = "wc", this.version = 2
    }
  },
  v$e = class {
    constructor(t) {
      this.client = t
    }
  };
var g_ = {},
  kY = {};
(function (e) {
  Object.defineProperty(e, "__esModule", {
    value: !0
  });
  var t = sn,
    n = Qo;
  e.DIGEST_LENGTH = 64, e.BLOCK_SIZE = 128;
  var r = function () {
    function a() {
      this.digestLength = e.DIGEST_LENGTH, this.blockSize = e.BLOCK_SIZE, this._stateHi = new Int32Array(8), this._stateLo = new Int32Array(8), this._tempHi = new Int32Array(16), this._tempLo = new Int32Array(16), this._buffer = new Uint8Array(256), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this.reset()
    }
    return a.prototype._initState = function () {
      this._stateHi[0] = 1779033703, this._stateHi[1] = 3144134277, this._stateHi[2] = 1013904242, this._stateHi[3] = 2773480762, this._stateHi[4] = 1359893119, this._stateHi[5] = 2600822924, this._stateHi[6] = 528734635, this._stateHi[7] = 1541459225, this._stateLo[0] = 4089235720, this._stateLo[1] = 2227873595, this._stateLo[2] = 4271175723, this._stateLo[3] = 1595750129, this._stateLo[4] = 2917565137, this._stateLo[5] = 725511199, this._stateLo[6] = 4215389547, this._stateLo[7] = 327033209
    }, a.prototype.reset = function () {
      return this._initState(), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this
    }, a.prototype.clean = function () {
      n.wipe(this._buffer), n.wipe(this._tempHi), n.wipe(this._tempLo), this.reset()
    }, a.prototype.update = function (c, l) {
      if (l === void 0 && (l = c.length), this._finished) throw new Error("SHA512: can't update because hash was finished.");
      var u = 0;
      if (this._bytesHashed += l, this._bufferLength > 0) {
        for (; this._bufferLength < e.BLOCK_SIZE && l > 0;) this._buffer[this._bufferLength++] = c[u++], l--;
        this._bufferLength === this.blockSize && (s(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, this.blockSize), this._bufferLength = 0)
      }
      for (l >= this.blockSize && (u = s(this._tempHi, this._tempLo, this._stateHi, this._stateLo, c, u, l), l %= this.blockSize); l > 0;) this._buffer[this._bufferLength++] = c[u++], l--;
      return this
    }, a.prototype.finish = function (c) {
      if (!this._finished) {
        var l = this._bytesHashed,
          u = this._bufferLength,
          f = l / 536870912 | 0,
          h = l << 3,
          g = l % 128 < 112 ? 128 : 256;
        this._buffer[u] = 128;
        for (var y = u + 1; y < g - 8; y++) this._buffer[y] = 0;
        t.writeUint32BE(f, this._buffer, g - 8), t.writeUint32BE(h, this._buffer, g - 4), s(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, g), this._finished = !0
      }
      for (var y = 0; y < this.digestLength / 8; y++) t.writeUint32BE(this._stateHi[y], c, y * 8), t.writeUint32BE(this._stateLo[y], c, y * 8 + 4);
      return this
    }, a.prototype.digest = function () {
      var c = new Uint8Array(this.digestLength);
      return this.finish(c), c
    }, a.prototype.saveState = function () {
      if (this._finished) throw new Error("SHA256: cannot save finished state");
      return {
        stateHi: new Int32Array(this._stateHi),
        stateLo: new Int32Array(this._stateLo),
        buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
        bufferLength: this._bufferLength,
        bytesHashed: this._bytesHashed
      }
    }, a.prototype.restoreState = function (c) {
      return this._stateHi.set(c.stateHi), this._stateLo.set(c.stateLo), this._bufferLength = c.bufferLength, c.buffer && this._buffer.set(c.buffer), this._bytesHashed = c.bytesHashed, this._finished = !1, this
    }, a.prototype.cleanSavedState = function (c) {
      n.wipe(c.stateHi), n.wipe(c.stateLo), c.buffer && n.wipe(c.buffer), c.bufferLength = 0, c.bytesHashed = 0
    }, a
  }();
  e.SHA512 = r;
  var i = new Int32Array([1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591]);

  function s(a, c, l, u, f, h, g) {
    for (var y = l[0], x = l[1], k = l[2], _ = l[3], p = l[4], v = l[5], S = l[6], I = l[7], A = u[0], w = u[1], E = u[2], D = u[3], $ = u[4], V = u[5], G = u[6], L = u[7], b, T, R, N, O, U, q, W; g >= 128;) {
      for (var M = 0; M < 16; M++) {
        var Q = 8 * M + h;
        a[M] = t.readUint32BE(f, Q), c[M] = t.readUint32BE(f, Q + 4)
      }
      for (var M = 0; M < 80; M++) {
        var he = y,
          H = x,
          ne = k,
          X = _,
          Z = p,
          te = v,
          F = S,
          J = I,
          ie = A,
          ce = w,
          ue = E,
          ge = D,
          et = $,
          He = V,
          se = G,
          pe = L;
        if (b = I, T = L, O = T & 65535, U = T >>> 16, q = b & 65535, W = b >>> 16, b = (p >>> 14 | $ << 18) ^ (p >>> 18 | $ << 14) ^ ($ >>> 9 | p << 23), T = ($ >>> 14 | p << 18) ^ ($ >>> 18 | p << 14) ^ (p >>> 9 | $ << 23), O += T & 65535, U += T >>> 16, q += b & 65535, W += b >>> 16, b = p & v ^ ~p & S, T = $ & V ^ ~$ & G, O += T & 65535, U += T >>> 16, q += b & 65535, W += b >>> 16, b = i[M * 2], T = i[M * 2 + 1], O += T & 65535, U += T >>> 16, q += b & 65535, W += b >>> 16, b = a[M % 16], T = c[M % 16], O += T & 65535, U += T >>> 16, q += b & 65535, W += b >>> 16, U += O >>> 16, q += U >>> 16, W += q >>> 16, R = q & 65535 | W << 16, N = O & 65535 | U << 16, b = R, T = N, O = T & 65535, U = T >>> 16, q = b & 65535, W = b >>> 16, b = (y >>> 28 | A << 4) ^ (A >>> 2 | y << 30) ^ (A >>> 7 | y << 25), T = (A >>> 28 | y << 4) ^ (y >>> 2 | A << 30) ^ (y >>> 7 | A << 25), O += T & 65535, U += T >>> 16, q += b & 65535, W += b >>> 16, b = y & x ^ y & k ^ x & k, T = A & w ^ A & E ^ w & E, O += T & 65535, U += T >>> 16, q += b & 65535, W += b >>> 16, U += O >>> 16, q += U >>> 16, W += q >>> 16, J = q & 65535 | W << 16, pe = O & 65535 | U << 16, b = X, T = ge, O = T & 65535, U = T >>> 16, q = b & 65535, W = b >>> 16, b = R, T = N, O += T & 65535, U += T >>> 16, q += b & 65535, W += b >>> 16, U += O >>> 16, q += U >>> 16, W += q >>> 16, X = q & 65535 | W << 16, ge = O & 65535 | U << 16, x = he, k = H, _ = ne, p = X, v = Z, S = te, I = F, y = J, w = ie, E = ce, D = ue, $ = ge, V = et, G = He, L = se, A = pe, M % 16 === 15)
          for (var Q = 0; Q < 16; Q++) b = a[Q], T = c[Q], O = T & 65535, U = T >>> 16, q = b & 65535, W = b >>> 16, b = a[(Q + 9) % 16], T = c[(Q + 9) % 16], O += T & 65535, U += T >>> 16, q += b & 65535, W += b >>> 16, R = a[(Q + 1) % 16], N = c[(Q + 1) % 16], b = (R >>> 1 | N << 31) ^ (R >>> 8 | N << 24) ^ R >>> 7, T = (N >>> 1 | R << 31) ^ (N >>> 8 | R << 24) ^ (N >>> 7 | R << 25), O += T & 65535, U += T >>> 16, q += b & 65535, W += b >>> 16, R = a[(Q + 14) % 16], N = c[(Q + 14) % 16], b = (R >>> 19 | N << 13) ^ (N >>> 29 | R << 3) ^ R >>> 6, T = (N >>> 19 | R << 13) ^ (R >>> 29 | N << 3) ^ (N >>> 6 | R << 26), O += T & 65535, U += T >>> 16, q += b & 65535, W += b >>> 16, U += O >>> 16, q += U >>> 16, W += q >>> 16, a[Q] = q & 65535 | W << 16, c[Q] = O & 65535 | U << 16
      }
      b = y, T = A, O = T & 65535, U = T >>> 16, q = b & 65535, W = b >>> 16, b = l[0], T = u[0], O += T & 65535, U += T >>> 16, q += b & 65535, W += b >>> 16, U += O >>> 16, q += U >>> 16, W += q >>> 16, l[0] = y = q & 65535 | W << 16, u[0] = A = O & 65535 | U << 16, b = x, T = w, O = T & 65535, U = T >>> 16, q = b & 65535, W = b >>> 16, b = l[1], T = u[1], O += T & 65535, U += T >>> 16, q += b & 65535, W += b >>> 16, U += O >>> 16, q += U >>> 16, W += q >>> 16, l[1] = x = q & 65535 | W << 16, u[1] = w = O & 65535 | U << 16, b = k, T = E, O = T & 65535, U = T >>> 16, q = b & 65535, W = b >>> 16, b = l[2], T = u[2], O += T & 65535, U += T >>> 16, q += b & 65535, W += b >>> 16, U += O >>> 16, q += U >>> 16, W += q >>> 16, l[2] = k = q & 65535 | W << 16, u[2] = E = O & 65535 | U << 16, b = _, T = D, O = T & 65535, U = T >>> 16, q = b & 65535, W = b >>> 16, b = l[3], T = u[3], O += T & 65535, U += T >>> 16, q += b & 65535, W += b >>> 16, U += O >>> 16, q += U >>> 16, W += q >>> 16, l[3] = _ = q & 65535 | W << 16, u[3] = D = O & 65535 | U << 16, b = p, T = $, O = T & 65535, U = T >>> 16, q = b & 65535, W = b >>> 16, b = l[4], T = u[4], O += T & 65535, U += T >>> 16, q += b & 65535, W += b >>> 16, U += O >>> 16, q += U >>> 16, W += q >>> 16, l[4] = p = q & 65535 | W << 16, u[4] = $ = O & 65535 | U << 16, b = v, T = V, O = T & 65535, U = T >>> 16, q = b & 65535, W = b >>> 16, b = l[5], T = u[5], O += T & 65535, U += T >>> 16, q += b & 65535, W += b >>> 16, U += O >>> 16, q += U >>> 16, W += q >>> 16, l[5] = v = q & 65535 | W << 16, u[5] = V = O & 65535 | U << 16, b = S, T = G, O = T & 65535, U = T >>> 16, q = b & 65535, W = b >>> 16, b = l[6], T = u[6], O += T & 65535, U += T >>> 16, q += b & 65535, W += b >>> 16, U += O >>> 16, q += U >>> 16, W += q >>> 16, l[6] = S = q & 65535 | W << 16, u[6] = G = O & 65535 | U << 16, b = I, T = L, O = T & 65535, U = T >>> 16, q = b & 65535, W = b >>> 16, b = l[7], T = u[7], O += T & 65535, U += T >>> 16, q += b & 65535, W += b >>> 16, U += O >>> 16, q += U >>> 16, W += q >>> 16, l[7] = I = q & 65535 | W << 16, u[7] = L = O & 65535 | U << 16, h += 128, g -= 128
    }
    return h
  }

  function o(a) {
    var c = new r;
    c.update(a);
    var l = c.digest();
    return c.clean(), l
  }
  e.hash = o
})(kY);
(function (e) {
  Object.defineProperty(e, "__esModule", {
    value: !0
  }), e.convertSecretKeyToX25519 = e.convertPublicKeyToX25519 = e.verify = e.sign = e.extractPublicKeyFromSecretKey = e.generateKeyPair = e.generateKeyPairFromSeed = e.SEED_LENGTH = e.SECRET_KEY_LENGTH = e.PUBLIC_KEY_LENGTH = e.SIGNATURE_LENGTH = void 0;
  const t = Um,
    n = kY,
    r = Qo;
  e.SIGNATURE_LENGTH = 64, e.PUBLIC_KEY_LENGTH = 32, e.SECRET_KEY_LENGTH = 64, e.SEED_LENGTH = 32;

  function i(X) {
    const Z = new Float64Array(16);
    if (X)
      for (let te = 0; te < X.length; te++) Z[te] = X[te];
    return Z
  }
  const s = new Uint8Array(32);
  s[0] = 9;
  const o = i(),
    a = i([1]),
    c = i([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]),
    l = i([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]),
    u = i([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]),
    f = i([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]),
    h = i([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);

  function g(X, Z) {
    for (let te = 0; te < 16; te++) X[te] = Z[te] | 0
  }

  function y(X) {
    let Z = 1;
    for (let te = 0; te < 16; te++) {
      let F = X[te] + Z + 65535;
      Z = Math.floor(F / 65536), X[te] = F - Z * 65536
    }
    X[0] += Z - 1 + 37 * (Z - 1)
  }

  function x(X, Z, te) {
    const F = ~(te - 1);
    for (let J = 0; J < 16; J++) {
      const ie = F & (X[J] ^ Z[J]);
      X[J] ^= ie, Z[J] ^= ie
    }
  }

  function k(X, Z) {
    const te = i(),
      F = i();
    for (let J = 0; J < 16; J++) F[J] = Z[J];
    y(F), y(F), y(F);
    for (let J = 0; J < 2; J++) {
      te[0] = F[0] - 65517;
      for (let ce = 1; ce < 15; ce++) te[ce] = F[ce] - 65535 - (te[ce - 1] >> 16 & 1), te[ce - 1] &= 65535;
      te[15] = F[15] - 32767 - (te[14] >> 16 & 1);
      const ie = te[15] >> 16 & 1;
      te[14] &= 65535, x(F, te, 1 - ie)
    }
    for (let J = 0; J < 16; J++) X[2 * J] = F[J] & 255, X[2 * J + 1] = F[J] >> 8
  }

  function _(X, Z) {
    let te = 0;
    for (let F = 0; F < 32; F++) te |= X[F] ^ Z[F];
    return (1 & te - 1 >>> 8) - 1
  }

  function p(X, Z) {
    const te = new Uint8Array(32),
      F = new Uint8Array(32);
    return k(te, X), k(F, Z), _(te, F)
  }

  function v(X) {
    const Z = new Uint8Array(32);
    return k(Z, X), Z[0] & 1
  }

  function S(X, Z) {
    for (let te = 0; te < 16; te++) X[te] = Z[2 * te] + (Z[2 * te + 1] << 8);
    X[15] &= 32767
  }

  function I(X, Z, te) {
    for (let F = 0; F < 16; F++) X[F] = Z[F] + te[F]
  }

  function A(X, Z, te) {
    for (let F = 0; F < 16; F++) X[F] = Z[F] - te[F]
  }

  function w(X, Z, te) {
    let F, J, ie = 0,
      ce = 0,
      ue = 0,
      ge = 0,
      et = 0,
      He = 0,
      se = 0,
      pe = 0,
      de = 0,
      we = 0,
      Ce = 0,
      be = 0,
      Se = 0,
      Fe = 0,
      Ne = 0,
      Me = 0,
      We = 0,
      ke = 0,
      ze = 0,
      ct = 0,
      Xe = 0,
      _e = 0,
      Ze = 0,
      Ee = 0,
      Oe = 0,
      yt = 0,
      tt = 0,
      dt = 0,
      xn = 0,
      Ht = 0,
      en = 0,
      tn = te[0],
      Et = te[1],
      Ot = te[2],
      kn = te[3],
      Dt = te[4],
      Pt = te[5],
      _n = te[6],
      zt = te[7],
      kt = te[8],
      In = te[9],
      vt = te[10],
      _t = te[11],
      Pn = te[12],
      wt = te[13],
      $t = te[14],
      Mn = te[15];
    F = Z[0], ie += F * tn, ce += F * Et, ue += F * Ot, ge += F * kn, et += F * Dt, He += F * Pt, se += F * _n, pe += F * zt, de += F * kt, we += F * In, Ce += F * vt, be += F * _t, Se += F * Pn, Fe += F * wt, Ne += F * $t, Me += F * Mn, F = Z[1], ce += F * tn, ue += F * Et, ge += F * Ot, et += F * kn, He += F * Dt, se += F * Pt, pe += F * _n, de += F * zt, we += F * kt, Ce += F * In, be += F * vt, Se += F * _t, Fe += F * Pn, Ne += F * wt, Me += F * $t, We += F * Mn, F = Z[2], ue += F * tn, ge += F * Et, et += F * Ot, He += F * kn, se += F * Dt, pe += F * Pt, de += F * _n, we += F * zt, Ce += F * kt, be += F * In, Se += F * vt, Fe += F * _t, Ne += F * Pn, Me += F * wt, We += F * $t, ke += F * Mn, F = Z[3], ge += F * tn, et += F * Et, He += F * Ot, se += F * kn, pe += F * Dt, de += F * Pt, we += F * _n, Ce += F * zt, be += F * kt, Se += F * In, Fe += F * vt, Ne += F * _t, Me += F * Pn, We += F * wt, ke += F * $t, ze += F * Mn, F = Z[4], et += F * tn, He += F * Et, se += F * Ot, pe += F * kn, de += F * Dt, we += F * Pt, Ce += F * _n, be += F * zt, Se += F * kt, Fe += F * In, Ne += F * vt, Me += F * _t, We += F * Pn, ke += F * wt, ze += F * $t, ct += F * Mn, F = Z[5], He += F * tn, se += F * Et, pe += F * Ot, de += F * kn, we += F * Dt, Ce += F * Pt, be += F * _n, Se += F * zt, Fe += F * kt, Ne += F * In, Me += F * vt, We += F * _t, ke += F * Pn, ze += F * wt, ct += F * $t, Xe += F * Mn, F = Z[6], se += F * tn, pe += F * Et, de += F * Ot, we += F * kn, Ce += F * Dt, be += F * Pt, Se += F * _n, Fe += F * zt, Ne += F * kt, Me += F * In, We += F * vt, ke += F * _t, ze += F * Pn, ct += F * wt, Xe += F * $t, _e += F * Mn, F = Z[7], pe += F * tn, de += F * Et, we += F * Ot, Ce += F * kn, be += F * Dt, Se += F * Pt, Fe += F * _n, Ne += F * zt, Me += F * kt, We += F * In, ke += F * vt, ze += F * _t, ct += F * Pn, Xe += F * wt, _e += F * $t, Ze += F * Mn, F = Z[8], de += F * tn, we += F * Et, Ce += F * Ot, be += F * kn, Se += F * Dt, Fe += F * Pt, Ne += F * _n, Me += F * zt, We += F * kt, ke += F * In, ze += F * vt, ct += F * _t, Xe += F * Pn, _e += F * wt, Ze += F * $t, Ee += F * Mn, F = Z[9], we += F * tn, Ce += F * Et, be += F * Ot, Se += F * kn, Fe += F * Dt, Ne += F * Pt, Me += F * _n, We += F * zt, ke += F * kt, ze += F * In, ct += F * vt, Xe += F * _t, _e += F * Pn, Ze += F * wt, Ee += F * $t, Oe += F * Mn, F = Z[10], Ce += F * tn, be += F * Et, Se += F * Ot, Fe += F * kn, Ne += F * Dt, Me += F * Pt, We += F * _n, ke += F * zt, ze += F * kt, ct += F * In, Xe += F * vt, _e += F * _t, Ze += F * Pn, Ee += F * wt, Oe += F * $t, yt += F * Mn, F = Z[11], be += F * tn, Se += F * Et, Fe += F * Ot, Ne += F * kn, Me += F * Dt, We += F * Pt, ke += F * _n, ze += F * zt, ct += F * kt, Xe += F * In, _e += F * vt, Ze += F * _t, Ee += F * Pn, Oe += F * wt, yt += F * $t, tt += F * Mn, F = Z[12], Se += F * tn, Fe += F * Et, Ne += F * Ot, Me += F * kn, We += F * Dt, ke += F * Pt, ze += F * _n, ct += F * zt, Xe += F * kt, _e += F * In, Ze += F * vt, Ee += F * _t, Oe += F * Pn, yt += F * wt, tt += F * $t, dt += F * Mn, F = Z[13], Fe += F * tn, Ne += F * Et, Me += F * Ot, We += F * kn, ke += F * Dt, ze += F * Pt, ct += F * _n, Xe += F * zt, _e += F * kt, Ze += F * In, Ee += F * vt, Oe += F * _t, yt += F * Pn, tt += F * wt, dt += F * $t, xn += F * Mn, F = Z[14], Ne += F * tn, Me += F * Et, We += F * Ot, ke += F * kn, ze += F * Dt, ct += F * Pt, Xe += F * _n, _e += F * zt, Ze += F * kt, Ee += F * In, Oe += F * vt, yt += F * _t, tt += F * Pn, dt += F * wt, xn += F * $t, Ht += F * Mn, F = Z[15], Me += F * tn, We += F * Et, ke += F * Ot, ze += F * kn, ct += F * Dt, Xe += F * Pt, _e += F * _n, Ze += F * zt, Ee += F * kt, Oe += F * In, yt += F * vt, tt += F * _t, dt += F * Pn, xn += F * wt, Ht += F * $t, en += F * Mn, ie += 38 * We, ce += 38 * ke, ue += 38 * ze, ge += 38 * ct, et += 38 * Xe, He += 38 * _e, se += 38 * Ze, pe += 38 * Ee, de += 38 * Oe, we += 38 * yt, Ce += 38 * tt, be += 38 * dt, Se += 38 * xn, Fe += 38 * Ht, Ne += 38 * en, J = 1, F = ie + J + 65535, J = Math.floor(F / 65536), ie = F - J * 65536, F = ce + J + 65535, J = Math.floor(F / 65536), ce = F - J * 65536, F = ue + J + 65535, J = Math.floor(F / 65536), ue = F - J * 65536, F = ge + J + 65535, J = Math.floor(F / 65536), ge = F - J * 65536, F = et + J + 65535, J = Math.floor(F / 65536), et = F - J * 65536, F = He + J + 65535, J = Math.floor(F / 65536), He = F - J * 65536, F = se + J + 65535, J = Math.floor(F / 65536), se = F - J * 65536, F = pe + J + 65535, J = Math.floor(F / 65536), pe = F - J * 65536, F = de + J + 65535, J = Math.floor(F / 65536), de = F - J * 65536, F = we + J + 65535, J = Math.floor(F / 65536), we = F - J * 65536, F = Ce + J + 65535, J = Math.floor(F / 65536), Ce = F - J * 65536, F = be + J + 65535, J = Math.floor(F / 65536), be = F - J * 65536, F = Se + J + 65535, J = Math.floor(F / 65536), Se = F - J * 65536, F = Fe + J + 65535, J = Math.floor(F / 65536), Fe = F - J * 65536, F = Ne + J + 65535, J = Math.floor(F / 65536), Ne = F - J * 65536, F = Me + J + 65535, J = Math.floor(F / 65536), Me = F - J * 65536, ie += J - 1 + 37 * (J - 1), J = 1, F = ie + J + 65535, J = Math.floor(F / 65536), ie = F - J * 65536, F = ce + J + 65535, J = Math.floor(F / 65536), ce = F - J * 65536, F = ue + J + 65535, J = Math.floor(F / 65536), ue = F - J * 65536, F = ge + J + 65535, J = Math.floor(F / 65536), ge = F - J * 65536, F = et + J + 65535, J = Math.floor(F / 65536), et = F - J * 65536, F = He + J + 65535, J = Math.floor(F / 65536), He = F - J * 65536, F = se + J + 65535, J = Math.floor(F / 65536), se = F - J * 65536, F = pe + J + 65535, J = Math.floor(F / 65536), pe = F - J * 65536, F = de + J + 65535, J = Math.floor(F / 65536), de = F - J * 65536, F = we + J + 65535, J = Math.floor(F / 65536), we = F - J * 65536, F = Ce + J + 65535, J = Math.floor(F / 65536), Ce = F - J * 65536, F = be + J + 65535, J = Math.floor(F / 65536), be = F - J * 65536, F = Se + J + 65535, J = Math.floor(F / 65536), Se = F - J * 65536, F = Fe + J + 65535, J = Math.floor(F / 65536), Fe = F - J * 65536, F = Ne + J + 65535, J = Math.floor(F / 65536), Ne = F - J * 65536, F = Me + J + 65535, J = Math.floor(F / 65536), Me = F - J * 65536, ie += J - 1 + 37 * (J - 1), X[0] = ie, X[1] = ce, X[2] = ue, X[3] = ge, X[4] = et, X[5] = He, X[6] = se, X[7] = pe, X[8] = de, X[9] = we, X[10] = Ce, X[11] = be, X[12] = Se, X[13] = Fe, X[14] = Ne, X[15] = Me
  }

  function E(X, Z) {
    w(X, Z, Z)
  }

  function D(X, Z) {
    const te = i();
    let F;
    for (F = 0; F < 16; F++) te[F] = Z[F];
    for (F = 253; F >= 0; F--) E(te, te), F !== 2 && F !== 4 && w(te, te, Z);
    for (F = 0; F < 16; F++) X[F] = te[F]
  }

  function $(X, Z) {
    const te = i();
    let F;
    for (F = 0; F < 16; F++) te[F] = Z[F];
    for (F = 250; F >= 0; F--) E(te, te), F !== 1 && w(te, te, Z);
    for (F = 0; F < 16; F++) X[F] = te[F]
  }

  function V(X, Z) {
    const te = i(),
      F = i(),
      J = i(),
      ie = i(),
      ce = i(),
      ue = i(),
      ge = i(),
      et = i(),
      He = i();
    A(te, X[1], X[0]), A(He, Z[1], Z[0]), w(te, te, He), I(F, X[0], X[1]), I(He, Z[0], Z[1]), w(F, F, He), w(J, X[3], Z[3]), w(J, J, l), w(ie, X[2], Z[2]), I(ie, ie, ie), A(ce, F, te), A(ue, ie, J), I(ge, ie, J), I(et, F, te), w(X[0], ce, ue), w(X[1], et, ge), w(X[2], ge, ue), w(X[3], ce, et)
  }

  function G(X, Z, te) {
    for (let F = 0; F < 4; F++) x(X[F], Z[F], te)
  }

  function L(X, Z) {
    const te = i(),
      F = i(),
      J = i();
    D(J, Z[2]), w(te, Z[0], J), w(F, Z[1], J), k(X, F), X[31] ^= v(te) << 7
  }

  function b(X, Z, te) {
    g(X[0], o), g(X[1], a), g(X[2], a), g(X[3], o);
    for (let F = 255; F >= 0; --F) {
      const J = te[F / 8 | 0] >> (F & 7) & 1;
      G(X, Z, J), V(Z, X), V(X, X), G(X, Z, J)
    }
  }

  function T(X, Z) {
    const te = [i(), i(), i(), i()];
    g(te[0], u), g(te[1], f), g(te[2], a), w(te[3], u, f), b(X, te, Z)
  }

  function R(X) {
    if (X.length !== e.SEED_LENGTH) throw new Error(`ed25519: seed must be ${e.SEED_LENGTH} bytes`);
    const Z = (0, n.hash)(X);
    Z[0] &= 248, Z[31] &= 127, Z[31] |= 64;
    const te = new Uint8Array(32),
      F = [i(), i(), i(), i()];
    T(F, Z), L(te, F);
    const J = new Uint8Array(64);
    return J.set(X), J.set(te, 32), {
      publicKey: te,
      secretKey: J
    }
  }
  e.generateKeyPairFromSeed = R;

  function N(X) {
    const Z = (0, t.randomBytes)(32, X),
      te = R(Z);
    return (0, r.wipe)(Z), te
  }
  e.generateKeyPair = N;

  function O(X) {
    if (X.length !== e.SECRET_KEY_LENGTH) throw new Error(`ed25519: secret key must be ${e.SECRET_KEY_LENGTH} bytes`);
    return new Uint8Array(X.subarray(32))
  }
  e.extractPublicKeyFromSecretKey = O;
  const U = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);

  function q(X, Z) {
    let te, F, J, ie;
    for (F = 63; F >= 32; --F) {
      for (te = 0, J = F - 32, ie = F - 12; J < ie; ++J) Z[J] += te - 16 * Z[F] * U[J - (F - 32)], te = Math.floor((Z[J] + 128) / 256), Z[J] -= te * 256;
      Z[J] += te, Z[F] = 0
    }
    for (te = 0, J = 0; J < 32; J++) Z[J] += te - (Z[31] >> 4) * U[J], te = Z[J] >> 8, Z[J] &= 255;
    for (J = 0; J < 32; J++) Z[J] -= te * U[J];
    for (F = 0; F < 32; F++) Z[F + 1] += Z[F] >> 8, X[F] = Z[F] & 255
  }

  function W(X) {
    const Z = new Float64Array(64);
    for (let te = 0; te < 64; te++) Z[te] = X[te];
    for (let te = 0; te < 64; te++) X[te] = 0;
    q(X, Z)
  }

  function M(X, Z) {
    const te = new Float64Array(64),
      F = [i(), i(), i(), i()],
      J = (0, n.hash)(X.subarray(0, 32));
    J[0] &= 248, J[31] &= 127, J[31] |= 64;
    const ie = new Uint8Array(64);
    ie.set(J.subarray(32), 32);
    const ce = new n.SHA512;
    ce.update(ie.subarray(32)), ce.update(Z);
    const ue = ce.digest();
    ce.clean(), W(ue), T(F, ue), L(ie, F), ce.reset(), ce.update(ie.subarray(0, 32)), ce.update(X.subarray(32)), ce.update(Z);
    const ge = ce.digest();
    W(ge);
    for (let et = 0; et < 32; et++) te[et] = ue[et];
    for (let et = 0; et < 32; et++)
      for (let He = 0; He < 32; He++) te[et + He] += ge[et] * J[He];
    return q(ie.subarray(32), te), ie
  }
  e.sign = M;

  function Q(X, Z) {
    const te = i(),
      F = i(),
      J = i(),
      ie = i(),
      ce = i(),
      ue = i(),
      ge = i();
    return g(X[2], a), S(X[1], Z), E(J, X[1]), w(ie, J, c), A(J, J, X[2]), I(ie, X[2], ie), E(ce, ie), E(ue, ce), w(ge, ue, ce), w(te, ge, J), w(te, te, ie), $(te, te), w(te, te, J), w(te, te, ie), w(te, te, ie), w(X[0], te, ie), E(F, X[0]), w(F, F, ie), p(F, J) && w(X[0], X[0], h), E(F, X[0]), w(F, F, ie), p(F, J) ? -1 : (v(X[0]) === Z[31] >> 7 && A(X[0], o, X[0]), w(X[3], X[0], X[1]), 0)
  }

  function he(X, Z, te) {
    const F = new Uint8Array(32),
      J = [i(), i(), i(), i()],
      ie = [i(), i(), i(), i()];
    if (te.length !== e.SIGNATURE_LENGTH) throw new Error(`ed25519: signature must be ${e.SIGNATURE_LENGTH} bytes`);
    if (Q(ie, X)) return !1;
    const ce = new n.SHA512;
    ce.update(te.subarray(0, 32)), ce.update(X), ce.update(Z);
    const ue = ce.digest();
    return W(ue), b(J, ie, ue), T(ie, te.subarray(32)), V(J, ie), L(F, J), !_(te, F)
  }
  e.verify = he;

  function H(X) {
    let Z = [i(), i(), i(), i()];
    if (Q(Z, X)) throw new Error("Ed25519: invalid public key");
    let te = i(),
      F = i(),
      J = Z[1];
    I(te, a, J), A(F, a, J), D(F, F), w(te, te, F);
    let ie = new Uint8Array(32);
    return k(ie, te), ie
  }
  e.convertPublicKeyToX25519 = H;

  function ne(X) {
    const Z = (0, n.hash)(X.subarray(0, 32));
    Z[0] &= 248, Z[31] &= 127, Z[31] |= 64;
    const te = new Uint8Array(Z.subarray(0, 32));
    return (0, r.wipe)(Z), te
  }
  e.convertSecretKeyToX25519 = ne
})(g_);
const b$e = "EdDSA",
  w$e = "JWT",
  _Y = ".",
  IY = "base64url",
  x$e = "utf8",
  E$e = "utf8",
  S$e = ":",
  C$e = "did",
  A$e = "key",
  yL = "base58btc",
  T$e = "z",
  k$e = "K36",
  _$e = 32;

function fx(e) {
  return us(As(bh(e), x$e), IY)
}

function PY(e) {
  const t = As(k$e, yL),
    n = T$e + us(qA([t, e]), yL);
  return [C$e, A$e, n].join(S$e)
}

function I$e(e) {
  return us(e, IY)
}

function P$e(e) {
  return As([fx(e.header), fx(e.payload)].join(_Y), E$e)
}

function R$e(e) {
  return [fx(e.header), fx(e.payload), I$e(e.signature)].join(_Y)
}

function vL(e = Um.randomBytes(_$e)) {
  return g_.generateKeyPairFromSeed(e)
}
async function O$e(e, t, n, r, i = it.fromMiliseconds(Date.now())) {
  const s = {
      alg: b$e,
      typ: w$e
    },
    o = PY(r.publicKey),
    a = i + n,
    c = {
      iss: o,
      sub: e,
      aud: t,
      iat: i,
      exp: a
    },
    l = P$e({
      header: s,
      payload: c
    }),
    u = g_.sign(r.secretKey, l);
  return R$e({
    header: s,
    payload: c,
    signature: u
  })
}
var x2 = {};
(function (e) {
  const t = tE,
    n = nE,
    r = rE,
    i = iE,
    s = p => p == null,
    o = Symbol("encodeFragmentIdentifier");

  function a(p) {
    switch (p.arrayFormat) {
      case "index":
        return v => (S, I) => {
          const A = S.length;
          return I === void 0 || p.skipNull && I === null || p.skipEmptyString && I === "" ? S : I === null ? [...S, [u(v, p), "[", A, "]"].join("")] : [...S, [u(v, p), "[", u(A, p), "]=", u(I, p)].join("")]
        };
      case "bracket":
        return v => (S, I) => I === void 0 || p.skipNull && I === null || p.skipEmptyString && I === "" ? S : I === null ? [...S, [u(v, p), "[]"].join("")] : [...S, [u(v, p), "[]=", u(I, p)].join("")];
      case "colon-list-separator":
        return v => (S, I) => I === void 0 || p.skipNull && I === null || p.skipEmptyString && I === "" ? S : I === null ? [...S, [u(v, p), ":list="].join("")] : [...S, [u(v, p), ":list=", u(I, p)].join("")];
      case "comma":
      case "separator":
      case "bracket-separator": {
        const v = p.arrayFormat === "bracket-separator" ? "[]=" : "=";
        return S => (I, A) => A === void 0 || p.skipNull && A === null || p.skipEmptyString && A === "" ? I : (A = A === null ? "" : A, I.length === 0 ? [
          [u(S, p), v, u(A, p)].join("")
        ] : [
          [I, u(A, p)].join(p.arrayFormatSeparator)
        ])
      }
      default:
        return v => (S, I) => I === void 0 || p.skipNull && I === null || p.skipEmptyString && I === "" ? S : I === null ? [...S, u(v, p)] : [...S, [u(v, p), "=", u(I, p)].join("")]
    }
  }

  function c(p) {
    let v;
    switch (p.arrayFormat) {
      case "index":
        return (S, I, A) => {
          if (v = /\[(\d*)\]$/.exec(S), S = S.replace(/\[\d*\]$/, ""), !v) {
            A[S] = I;
            return
          }
          A[S] === void 0 && (A[S] = {}), A[S][v[1]] = I
        };
      case "bracket":
        return (S, I, A) => {
          if (v = /(\[\])$/.exec(S), S = S.replace(/\[\]$/, ""), !v) {
            A[S] = I;
            return
          }
          if (A[S] === void 0) {
            A[S] = [I];
            return
          }
          A[S] = [].concat(A[S], I)
        };
      case "colon-list-separator":
        return (S, I, A) => {
          if (v = /(:list)$/.exec(S), S = S.replace(/:list$/, ""), !v) {
            A[S] = I;
            return
          }
          if (A[S] === void 0) {
            A[S] = [I];
            return
          }
          A[S] = [].concat(A[S], I)
        };
      case "comma":
      case "separator":
        return (S, I, A) => {
          const w = typeof I == "string" && I.includes(p.arrayFormatSeparator),
            E = typeof I == "string" && !w && f(I, p).includes(p.arrayFormatSeparator);
          I = E ? f(I, p) : I;
          const D = w || E ? I.split(p.arrayFormatSeparator).map($ => f($, p)) : I === null ? I : f(I, p);
          A[S] = D
        };
      case "bracket-separator":
        return (S, I, A) => {
          const w = /(\[\])$/.test(S);
          if (S = S.replace(/\[\]$/, ""), !w) {
            A[S] = I && f(I, p);
            return
          }
          const E = I === null ? [] : I.split(p.arrayFormatSeparator).map(D => f(D, p));
          if (A[S] === void 0) {
            A[S] = E;
            return
          }
          A[S] = [].concat(A[S], E)
        };
      default:
        return (S, I, A) => {
          if (A[S] === void 0) {
            A[S] = I;
            return
          }
          A[S] = [].concat(A[S], I)
        }
    }
  }

  function l(p) {
    if (typeof p != "string" || p.length !== 1) throw new TypeError("arrayFormatSeparator must be single character string")
  }

  function u(p, v) {
    return v.encode ? v.strict ? t(p) : encodeURIComponent(p) : p
  }

  function f(p, v) {
    return v.decode ? n(p) : p
  }

  function h(p) {
    return Array.isArray(p) ? p.sort() : typeof p == "object" ? h(Object.keys(p)).sort((v, S) => Number(v) - Number(S)).map(v => p[v]) : p
  }

  function g(p) {
    const v = p.indexOf("#");
    return v !== -1 && (p = p.slice(0, v)), p
  }

  function y(p) {
    let v = "";
    const S = p.indexOf("#");
    return S !== -1 && (v = p.slice(S)), v
  }

  function x(p) {
    p = g(p);
    const v = p.indexOf("?");
    return v === -1 ? "" : p.slice(v + 1)
  }

  function k(p, v) {
    return v.parseNumbers && !Number.isNaN(Number(p)) && typeof p == "string" && p.trim() !== "" ? p = Number(p) : v.parseBooleans && p !== null && (p.toLowerCase() === "true" || p.toLowerCase() === "false") && (p = p.toLowerCase() === "true"), p
  }

  function _(p, v) {
    v = Object.assign({
      decode: !0,
      sort: !0,
      arrayFormat: "none",
      arrayFormatSeparator: ",",
      parseNumbers: !1,
      parseBooleans: !1
    }, v), l(v.arrayFormatSeparator);
    const S = c(v),
      I = Object.create(null);
    if (typeof p != "string" || (p = p.trim().replace(/^[?#&]/, ""), !p)) return I;
    for (const A of p.split("&")) {
      if (A === "") continue;
      let [w, E] = r(v.decode ? A.replace(/\+/g, " ") : A, "=");
      E = E === void 0 ? null : ["comma", "separator", "bracket-separator"].includes(v.arrayFormat) ? E : f(E, v), S(f(w, v), E, I)
    }
    for (const A of Object.keys(I)) {
      const w = I[A];
      if (typeof w == "object" && w !== null)
        for (const E of Object.keys(w)) w[E] = k(w[E], v);
      else I[A] = k(w, v)
    }
    return v.sort === !1 ? I : (v.sort === !0 ? Object.keys(I).sort() : Object.keys(I).sort(v.sort)).reduce((A, w) => {
      const E = I[w];
      return E && typeof E == "object" && !Array.isArray(E) ? A[w] = h(E) : A[w] = E, A
    }, Object.create(null))
  }
  e.extract = x, e.parse = _, e.stringify = (p, v) => {
    if (!p) return "";
    v = Object.assign({
      encode: !0,
      strict: !0,
      arrayFormat: "none",
      arrayFormatSeparator: ","
    }, v), l(v.arrayFormatSeparator);
    const S = E => v.skipNull && s(p[E]) || v.skipEmptyString && p[E] === "",
      I = a(v),
      A = {};
    for (const E of Object.keys(p)) S(E) || (A[E] = p[E]);
    const w = Object.keys(A);
    return v.sort !== !1 && w.sort(v.sort), w.map(E => {
      const D = p[E];
      return D === void 0 ? "" : D === null ? u(E, v) : Array.isArray(D) ? D.length === 0 && v.arrayFormat === "bracket-separator" ? u(E, v) + "[]" : D.reduce(I(E), []).join("&") : u(E, v) + "=" + u(D, v)
    }).filter(E => E.length > 0).join("&")
  }, e.parseUrl = (p, v) => {
    v = Object.assign({
      decode: !0
    }, v);
    const [S, I] = r(p, "#");
    return Object.assign({
      url: S.split("?")[0] || "",
      query: _(x(p), v)
    }, v && v.parseFragmentIdentifier && I ? {
      fragmentIdentifier: f(I, v)
    } : {})
  }, e.stringifyUrl = (p, v) => {
    v = Object.assign({
      encode: !0,
      strict: !0,
      [o]: !0
    }, v);
    const S = g(p.url).split("?")[0] || "",
      I = e.extract(p.url),
      A = e.parse(I, {
        sort: !1
      }),
      w = Object.assign(A, p.query);
    let E = e.stringify(w, v);
    E && (E = `?${E}`);
    let D = y(p.url);
    return p.fragmentIdentifier && (D = `#${v[o]?u(p.fragmentIdentifier,v):p.fragmentIdentifier}`), `${S}${E}${D}`
  }, e.pick = (p, v, S) => {
    S = Object.assign({
      parseFragmentIdentifier: !0,
      [o]: !1
    }, S);
    const {
      url: I,
      query: A,
      fragmentIdentifier: w
    } = e.parseUrl(p, S);
    return e.stringifyUrl({
      url: I,
      query: i(A, v),
      fragmentIdentifier: w
    }, S)
  }, e.exclude = (p, v, S) => {
    const I = Array.isArray(v) ? A => !v.includes(A) : (A, w) => !v(A, w);
    return e.pick(p, I, S)
  }
})(x2);
const RY = "base10",
  Rs = "base16",
  ZA = "base64pad",
  y_ = "utf8",
  OY = 0,
  Vm = 1,
  D$e = 0,
  bL = 1,
  e9 = 12,
  v_ = 32;

function N$e() {
  const e = h_.generateKeyPair();
  return {
    privateKey: us(e.secretKey, Rs),
    publicKey: us(e.publicKey, Rs)
  }
}

function t9() {
  const e = Um.randomBytes(v_);
  return us(e, Rs)
}

function M$e(e, t) {
  const n = h_.sharedKey(As(e, Rs), As(t, Rs), !0),
    r = new fDe(Ay.SHA256, n).expand(v_);
  return us(r, Rs)
}

function $$e(e) {
  const t = Ay.hash(As(e, Rs));
  return us(t, Rs)
}

function n9(e) {
  const t = Ay.hash(As(e, y_));
  return us(t, Rs)
}

function L$e(e) {
  return As(`${e}`, RY)
}

function Ry(e) {
  return Number(us(e, RY))
}

function B$e(e) {
  const t = L$e(typeof e.type < "u" ? e.type : OY);
  if (Ry(t) === Vm && typeof e.senderPublicKey > "u") throw new Error("Missing sender public key for type 1 envelope");
  const n = typeof e.senderPublicKey < "u" ? As(e.senderPublicKey, Rs) : void 0,
    r = typeof e.iv < "u" ? As(e.iv, Rs) : Um.randomBytes(e9),
    i = new d_.ChaCha20Poly1305(As(e.symKey, Rs)).seal(r, As(e.message, y_));
  return j$e({
    type: t,
    sealed: i,
    iv: r,
    senderPublicKey: n
  })
}

function F$e(e) {
  const t = new d_.ChaCha20Poly1305(As(e.symKey, Rs)),
    {
      sealed: n,
      iv: r
    } = hx(e.encoded),
    i = t.open(r, n);
  if (i === null) throw new Error("Failed to decrypt");
  return us(i, y_)
}

function j$e(e) {
  if (Ry(e.type) === Vm) {
    if (typeof e.senderPublicKey > "u") throw new Error("Missing sender public key for type 1 envelope");
    return us(qA([e.type, e.senderPublicKey, e.iv, e.sealed]), ZA)
  }
  return us(qA([e.type, e.iv, e.sealed]), ZA)
}

function hx(e) {
  const t = As(e, ZA),
    n = t.slice(D$e, bL),
    r = bL;
  if (Ry(n) === Vm) {
    const a = r + v_,
      c = a + e9,
      l = t.slice(r, a),
      u = t.slice(a, c),
      f = t.slice(c);
    return {
      type: n,
      sealed: f,
      iv: u,
      senderPublicKey: l
    }
  }
  const i = r + e9,
    s = t.slice(r, i),
    o = t.slice(i);
  return {
    type: n,
    sealed: o,
    iv: s
  }
}

function U$e(e, t) {
  const n = hx(e);
  return DY({
    type: Ry(n.type),
    senderPublicKey: typeof n.senderPublicKey < "u" ? us(n.senderPublicKey, Rs) : void 0,
    receiverPublicKey: t == null ? void 0 : t.receiverPublicKey
  })
}

function DY(e) {
  const t = (e == null ? void 0 : e.type) || OY;
  if (t === Vm) {
    if (typeof (e == null ? void 0 : e.senderPublicKey) > "u") throw new Error("missing sender public key");
    if (typeof (e == null ? void 0 : e.receiverPublicKey) > "u") throw new Error("missing receiver public key")
  }
  return {
    type: t,
    senderPublicKey: e == null ? void 0 : e.senderPublicKey,
    receiverPublicKey: e == null ? void 0 : e.receiverPublicKey
  }
}

function wL(e) {
  return e.type === Vm && typeof e.senderPublicKey == "string" && typeof e.receiverPublicKey == "string"
}
var z$e = Object.defineProperty,
  xL = Object.getOwnPropertySymbols,
  H$e = Object.prototype.hasOwnProperty,
  V$e = Object.prototype.propertyIsEnumerable,
  EL = (e, t, n) => t in e ? z$e(e, t, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: n
  }) : e[t] = n,
  SL = (e, t) => {
    for (var n in t || (t = {})) H$e.call(t, n) && EL(e, n, t[n]);
    if (xL)
      for (var n of xL(t)) V$e.call(t, n) && EL(e, n, t[n]);
    return e
  };
const W$e = "ReactNative",
  mc = {
    reactNative: "react-native",
    node: "node",
    browser: "browser",
    unknown: "unknown"
  },
  q$e = "js";

function E2() {
  return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u"
}

function Wm() {
  return !ky() && !!_y() && navigator.product === W$e
}

function sE() {
  return !E2() && !!_y() && !!ky()
}

function oE() {
  return Wm() ? mc.reactNative : E2() ? mc.node : sE() ? mc.browser : mc.unknown
}

function G$e() {
  var e;
  try {
    return Wm() && typeof global < "u" && typeof (global == null ? void 0 : global.Application) < "u" ? (e = global.Application) == null ? void 0 : e.applicationId : void 0
  } catch {
    return
  }
}

function K$e(e, t) {
  let n = x2.parse(e);
  return n = SL(SL({}, n), t), e = x2.stringify(n), e
}

function Q$e() {
  if (oE() === mc.reactNative && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u") {
    const {
      OS: n,
      Version: r
    } = global.Platform;
    return [n, r].join("-")
  }
  const e = CNe();
  if (e === null) return "unknown";
  const t = e.os ? e.os.replace(" ", "").toLowerCase() : "unknown";
  return e.type === "browser" ? [t, e.name, e.version].join("-") : [t, e.version].join("-")
}

function Y$e() {
  var e;
  const t = oE();
  return t === mc.browser ? [t, ((e = bY()) == null ? void 0 : e.host) || "unknown"].join(":") : t
}

function J$e(e, t, n) {
  const r = Q$e(),
    i = Y$e();
  return [
    [e, t].join("-"), [q$e, n].join("-"), r, i
  ].join("/")
}

function X$e({
  protocol: e,
  version: t,
  relayUrl: n,
  sdkVersion: r,
  auth: i,
  projectId: s,
  useOnCloseEvent: o,
  bundleId: a
}) {
  const c = n.split("?"),
    l = J$e(e, t, r),
    u = {
      auth: i,
      ua: l,
      projectId: s,
      useOnCloseEvent: o || void 0,
      origin: a || void 0
    },
    f = K$e(c[1] || "", u);
  return c[0] + "?" + f
}

function NY(e) {
  return Object.fromEntries(e.entries())
}

function MY(e) {
  return new Map(Object.entries(e))
}

function Z$e(e = it.FIVE_MINUTES, t) {
  const n = it.toMiliseconds(e || it.FIVE_MINUTES);
  let r, i, s;
  return {
    resolve: o => {
      s && r && (clearTimeout(s), r(o))
    },
    reject: o => {
      s && i && (clearTimeout(s), i(o))
    },
    done: () => new Promise((o, a) => {
      s = setTimeout(() => {
        a(new Error(t))
      }, n), r = o, i = a
    })
  }
}

function S2(e, t, n) {
  return new Promise(async (r, i) => {
    const s = setTimeout(() => i(new Error(n)), t);
    try {
      const o = await e;
      r(o)
    } catch (o) {
      i(o)
    }
    clearTimeout(s)
  })
}

function $Y(e, t) {
  if (typeof t == "string" && t.startsWith(`${e}:`)) return t;
  if (e.toLowerCase() === "topic") {
    if (typeof t != "string") throw new Error('Value must be "string" for expirer target type: topic');
    return `topic:${t}`
  } else if (e.toLowerCase() === "id") {
    if (typeof t != "number") throw new Error('Value must be "number" for expirer target type: id');
    return `id:${t}`
  }
  throw new Error(`Unknown expirer target type: ${e}`)
}

function eLe(e) {
  return $Y("topic", e)
}

function tLe(e) {
  return $Y("id", e)
}

function nLe(e) {
  const [t, n] = e.split(":"), r = {
    id: void 0,
    topic: void 0
  };
  if (t === "topic" && typeof n == "string") r.topic = n;
  else if (t === "id" && Number.isInteger(Number(n))) r.id = Number(n);
  else throw new Error(`Invalid target, expected id:number or topic:string, got ${t}:${n}`);
  return r
}

function _w(e, t) {
  return it.fromMiliseconds((t || Date.now()) + it.toMiliseconds(e))
}

function CL(e) {
  return Date.now() >= it.toMiliseconds(e)
}

function x8(e, t) {
  return `${e}${t?`:${t}`:""}`
}
const rLe = "irn";

function r9(e) {
  return (e == null ? void 0 : e.relay) || {
    protocol: rLe
  }
}

function Iw(e) {
  const t = yMe[e];
  if (typeof t > "u") throw new Error(`Relay Protocol not supported: ${e}`);
  return t
}
var iLe = Object.defineProperty,
  sLe = Object.defineProperties,
  oLe = Object.getOwnPropertyDescriptors,
  AL = Object.getOwnPropertySymbols,
  aLe = Object.prototype.hasOwnProperty,
  cLe = Object.prototype.propertyIsEnumerable,
  TL = (e, t, n) => t in e ? iLe(e, t, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: n
  }) : e[t] = n,
  lLe = (e, t) => {
    for (var n in t || (t = {})) aLe.call(t, n) && TL(e, n, t[n]);
    if (AL)
      for (var n of AL(t)) cLe.call(t, n) && TL(e, n, t[n]);
    return e
  },
  uLe = (e, t) => sLe(e, oLe(t));

function dLe(e, t = "-") {
  const n = {},
    r = "relay" + t;
  return Object.keys(e).forEach(i => {
    if (i.startsWith(r)) {
      const s = i.replace(r, ""),
        o = e[i];
      n[s] = o
    }
  }), n
}

function kL(e) {
  e = e.includes("wc://") ? e.replace("wc://", "") : e, e = e.includes("wc:") ? e.replace("wc:", "") : e;
  const t = e.indexOf(":"),
    n = e.indexOf("?") !== -1 ? e.indexOf("?") : void 0,
    r = e.substring(0, t),
    i = e.substring(t + 1, n).split("@"),
    s = typeof n < "u" ? e.substring(n) : "",
    o = x2.parse(s);
  return {
    protocol: r,
    topic: fLe(i[0]),
    version: parseInt(i[1], 10),
    symKey: o.symKey,
    relay: dLe(o),
    expiryTimestamp: o.expiryTimestamp ? parseInt(o.expiryTimestamp, 10) : void 0
  }
}

function fLe(e) {
  return e.startsWith("//") ? e.substring(2) : e
}

function hLe(e, t = "-") {
  const n = "relay",
    r = {};
  return Object.keys(e).forEach(i => {
    const s = n + t + i;
    e[i] && (r[s] = e[i])
  }), r
}

function pLe(e) {
  return `${e.protocol}:${e.topic}@${e.version}?` + x2.stringify(uLe(lLe({
    symKey: e.symKey
  }, hLe(e.relay)), {
    expiryTimestamp: e.expiryTimestamp
  }))
}
const mLe = {
    INVALID_METHOD: {
      message: "Invalid method.",
      code: 1001
    },
    INVALID_EVENT: {
      message: "Invalid event.",
      code: 1002
    },
    INVALID_UPDATE_REQUEST: {
      message: "Invalid update request.",
      code: 1003
    },
    INVALID_EXTEND_REQUEST: {
      message: "Invalid extend request.",
      code: 1004
    },
    INVALID_SESSION_SETTLE_REQUEST: {
      message: "Invalid session settle request.",
      code: 1005
    },
    UNAUTHORIZED_METHOD: {
      message: "Unauthorized method.",
      code: 3001
    },
    UNAUTHORIZED_EVENT: {
      message: "Unauthorized event.",
      code: 3002
    },
    UNAUTHORIZED_UPDATE_REQUEST: {
      message: "Unauthorized update request.",
      code: 3003
    },
    UNAUTHORIZED_EXTEND_REQUEST: {
      message: "Unauthorized extend request.",
      code: 3004
    },
    USER_REJECTED: {
      message: "User rejected.",
      code: 5e3
    },
    USER_REJECTED_CHAINS: {
      message: "User rejected chains.",
      code: 5001
    },
    USER_REJECTED_METHODS: {
      message: "User rejected methods.",
      code: 5002
    },
    USER_REJECTED_EVENTS: {
      message: "User rejected events.",
      code: 5003
    },
    UNSUPPORTED_CHAINS: {
      message: "Unsupported chains.",
      code: 5100
    },
    UNSUPPORTED_METHODS: {
      message: "Unsupported methods.",
      code: 5101
    },
    UNSUPPORTED_EVENTS: {
      message: "Unsupported events.",
      code: 5102
    },
    UNSUPPORTED_ACCOUNTS: {
      message: "Unsupported accounts.",
      code: 5103
    },
    UNSUPPORTED_NAMESPACE_KEY: {
      message: "Unsupported namespace key.",
      code: 5104
    },
    USER_DISCONNECTED: {
      message: "User disconnected.",
      code: 6e3
    },
    SESSION_SETTLEMENT_FAILED: {
      message: "Session settlement failed.",
      code: 7e3
    },
    WC_METHOD_UNSUPPORTED: {
      message: "Unsupported wc_ method.",
      code: 10001
    }
  },
  gLe = {
    NOT_INITIALIZED: {
      message: "Not initialized.",
      code: 1
    },
    NO_MATCHING_KEY: {
      message: "No matching key.",
      code: 2
    },
    RESTORE_WILL_OVERRIDE: {
      message: "Restore will override.",
      code: 3
    },
    RESUBSCRIBED: {
      message: "Resubscribed.",
      code: 4
    },
    MISSING_OR_INVALID: {
      message: "Missing or invalid.",
      code: 5
    },
    EXPIRED: {
      message: "Expired.",
      code: 6
    },
    UNKNOWN_TYPE: {
      message: "Unknown type.",
      code: 7
    },
    MISMATCHED_TOPIC: {
      message: "Mismatched topic.",
      code: 8
    },
    NON_CONFORMING_NAMESPACES: {
      message: "Non conforming namespaces.",
      code: 9
    }
  };

function Hn(e, t) {
  const {
    message: n,
    code: r
  } = gLe[e];
  return {
    message: t ? `${n} ${t}` : n,
    code: r
  }
}

function i1(e, t) {
  const {
    message: n,
    code: r
  } = mLe[e];
  return {
    message: t ? `${n} ${t}` : n,
    code: r
  }
}

function yLe(e, t) {
  return Array.isArray(e) ? typeof t < "u" && e.length ? e.every(t) : !0 : !1
}

function px(e) {
  return typeof e > "u"
}

function LY(e, t) {
  return t && px(e) ? !0 : typeof e == "string" && !!e.trim().length
}

function vLe(e) {
  if (LY(e, !1)) try {
    return typeof new URL(e) < "u"
  } catch {
    return !1
  }
  return !1
}

function bLe(e) {
  var t;
  return (t = e == null ? void 0 : e.proposer) == null ? void 0 : t.publicKey
}

function wLe(e) {
  return e == null ? void 0 : e.topic
}

function E8(e) {
  return typeof e < "u" && typeof e !== null
}

function _L() {
  const e = oE();
  return new Promise(t => {
    switch (e) {
      case mc.browser:
        t(xLe());
        break;
      case mc.reactNative:
        t(ELe());
        break;
      case mc.node:
        t(SLe());
        break;
      default:
        t(!0)
    }
  })
}

function xLe() {
  return sE() && (navigator == null ? void 0 : navigator.onLine)
}
async function ELe() {
  if (Wm() && typeof global < "u" && global != null && global.NetInfo) {
    const e = await (global == null ? void 0 : global.NetInfo.fetch());
    return e == null ? void 0 : e.isConnected
  }
  return !0
}

function SLe() {
  return !0
}

function CLe(e) {
  switch (oE()) {
    case mc.browser:
      ALe(e);
      break;
    case mc.reactNative:
      TLe(e);
      break
  }
}

function ALe(e) {
  !Wm() && sE() && (window.addEventListener("online", () => e(!0)), window.addEventListener("offline", () => e(!1)))
}

function TLe(e) {
  Wm() && typeof global < "u" && global != null && global.NetInfo && (global == null || global.NetInfo.addEventListener(t => e(t == null ? void 0 : t.isConnected)))
}
const kLe = "PARSE_ERROR",
  _Le = "INVALID_REQUEST",
  ILe = "METHOD_NOT_FOUND",
  PLe = "INVALID_PARAMS",
  BY = "INTERNAL_ERROR",
  b_ = "SERVER_ERROR",
  RLe = [-32700, -32600, -32601, -32602, -32603],
  k1 = {
    [kLe]: {
      code: -32700,
      message: "Parse error"
    },
    [_Le]: {
      code: -32600,
      message: "Invalid Request"
    },
    [ILe]: {
      code: -32601,
      message: "Method not found"
    },
    [PLe]: {
      code: -32602,
      message: "Invalid params"
    },
    [BY]: {
      code: -32603,
      message: "Internal error"
    },
    [b_]: {
      code: -32e3,
      message: "Server error"
    }
  },
  FY = b_;

function OLe(e) {
  return RLe.includes(e)
}

function IL(e) {
  return Object.keys(k1).includes(e) ? k1[e] : k1[FY]
}

function DLe(e) {
  const t = Object.values(k1).find(n => n.code === e);
  return t || k1[FY]
}

function jY(e, t, n) {
  return e.message.includes("getaddrinfo ENOTFOUND") || e.message.includes("connect ECONNREFUSED") ? new Error(`Unavailable ${n} RPC url at ${t}`) : e
}
var UY = {},
  Bl = {},
  PL;

function NLe() {
  if (PL) return Bl;
  PL = 1, Object.defineProperty(Bl, "__esModule", {
    value: !0
  }), Bl.isBrowserCryptoAvailable = Bl.getSubtleCrypto = Bl.getBrowerCrypto = void 0;

  function e() {
    return (rn == null ? void 0 : rn.crypto) || (rn == null ? void 0 : rn.msCrypto) || {}
  }
  Bl.getBrowerCrypto = e;

  function t() {
    const r = e();
    return r.subtle || r.webkitSubtle
  }
  Bl.getSubtleCrypto = t;

  function n() {
    return !!e() && !!t()
  }
  return Bl.isBrowserCryptoAvailable = n, Bl
}
var Fl = {},
  RL;

function MLe() {
  if (RL) return Fl;
  RL = 1, Object.defineProperty(Fl, "__esModule", {
    value: !0
  }), Fl.isBrowser = Fl.isNode = Fl.isReactNative = void 0;

  function e() {
    return typeof document > "u" && typeof navigator < "u" && navigator.product === "ReactNative"
  }
  Fl.isReactNative = e;

  function t() {
    return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u"
  }
  Fl.isNode = t;

  function n() {
    return !e() && !t()
  }
  return Fl.isBrowser = n, Fl
}(function (e) {
  Object.defineProperty(e, "__esModule", {
    value: !0
  });
  const t = Sl;
  t.__exportStar(NLe(), e), t.__exportStar(MLe(), e)
})(UY);

function X0(e = 3) {
  const t = Date.now() * Math.pow(10, e),
    n = Math.floor(Math.random() * Math.pow(10, e));
  return t + n
}

function Bf(e = 6) {
  return BigInt(X0(e))
}

function vp(e, t, n) {
  return {
    id: n || X0(),
    jsonrpc: "2.0",
    method: e,
    params: t
  }
}

function aE(e, t) {
  return {
    id: e,
    jsonrpc: "2.0",
    result: t
  }
}

function cE(e, t, n) {
  return {
    id: e,
    jsonrpc: "2.0",
    error: $Le(t, n)
  }
}

function $Le(e, t) {
  return typeof e > "u" ? IL(BY) : (typeof e == "string" && (e = Object.assign(Object.assign({}, IL(b_)), {
    message: e
  })), typeof t < "u" && (e.data = t), OLe(e.code) && (e = DLe(e.code)), e)
}
class LLe {}
class BLe extends LLe {
  constructor() {
    super()
  }
}
class FLe extends BLe {
  constructor(t) {
    super()
  }
}
const jLe = "^https?:",
  ULe = "^wss?:";

function zLe(e) {
  const t = e.match(new RegExp(/^\w+:/, "gi"));
  if (!(!t || !t.length)) return t[0]
}

function zY(e, t) {
  const n = zLe(e);
  return typeof n > "u" ? !1 : new RegExp(t).test(n)
}

function OL(e) {
  return zY(e, jLe)
}

function DL(e) {
  return zY(e, ULe)
}

function HLe(e) {
  return new RegExp("wss?://localhost(:d{2,5})?").test(e)
}

function HY(e) {
  return typeof e == "object" && "id" in e && "jsonrpc" in e && e.jsonrpc === "2.0"
}

function w_(e) {
  return HY(e) && "method" in e
}

function lE(e) {
  return HY(e) && (Kl(e) || oc(e))
}

function Kl(e) {
  return "result" in e
}

function oc(e) {
  return "error" in e
}
class Au extends FLe {
  constructor(t) {
    super(t), this.events = new si.EventEmitter, this.hasRegisteredEventListeners = !1, this.connection = this.setConnection(t), this.connection.connected && this.registerEventListeners()
  }
  async connect(t = this.connection) {
    await this.open(t)
  }
  async disconnect() {
    await this.close()
  }
  on(t, n) {
    this.events.on(t, n)
  }
  once(t, n) {
    this.events.once(t, n)
  }
  off(t, n) {
    this.events.off(t, n)
  }
  removeListener(t, n) {
    this.events.removeListener(t, n)
  }
  async request(t, n) {
    return this.requestStrict(vp(t.method, t.params || [], t.id || Bf().toString()), n)
  }
  async requestStrict(t, n) {
    return new Promise(async (r, i) => {
      if (!this.connection.connected) try {
        await this.open()
      } catch (s) {
        i(s)
      }
      this.events.on(`${t.id}`, s => {
        oc(s) ? i(s.error) : r(s.result)
      });
      try {
        await this.connection.send(t, n)
      } catch (s) {
        i(s)
      }
    })
  }
  setConnection(t = this.connection) {
    return t
  }
  onPayload(t) {
    this.events.emit("payload", t), lE(t) ? this.events.emit(`${t.id}`, t) : this.events.emit("message", {
      type: t.method,
      data: t.params
    })
  }
  onClose(t) {
    t && t.code === 3e3 && this.events.emit("error", new Error(`WebSocket connection closed abnormally with code: ${t.code} ${t.reason?`(${t.reason})`:""}`)), this.events.emit("disconnect")
  }
  async open(t = this.connection) {
    this.connection === t && this.connection.connected || (this.connection.connected && this.close(), typeof t == "string" && (await this.connection.open(t), t = this.connection), this.connection = this.setConnection(t), await this.connection.open(), this.registerEventListeners(), this.events.emit("connect"))
  }
  async close() {
    await this.connection.close()
  }
  registerEventListeners() {
    this.hasRegisteredEventListeners || (this.connection.on("payload", t => this.onPayload(t)), this.connection.on("close", t => this.onClose(t)), this.connection.on("error", t => this.events.emit("error", t)), this.connection.on("register_error", t => this.onClose()), this.hasRegisteredEventListeners = !0)
  }
}
const VLe = () => typeof WebSocket < "u" ? WebSocket : typeof global < "u" && typeof global.WebSocket < "u" ? global.WebSocket : typeof window < "u" && typeof window.WebSocket < "u" ? window.WebSocket : typeof self < "u" && typeof self.WebSocket < "u" ? self.WebSocket : require("ws"),
  WLe = () => typeof WebSocket < "u" || typeof global < "u" && typeof global.WebSocket < "u" || typeof window < "u" && typeof window.WebSocket < "u" || typeof self < "u" && typeof self.WebSocket < "u",
  NL = e => e.split("?")[0],
  ML = 10,
  qLe = VLe();
let GLe = class {
  constructor(t) {
    if (this.url = t, this.events = new si.EventEmitter, this.registering = !1, !DL(t)) throw new Error(`Provided URL is not compatible with WebSocket connection: ${t}`);
    this.url = t
  }
  get connected() {
    return typeof this.socket < "u"
  }
  get connecting() {
    return this.registering
  }
  on(t, n) {
    this.events.on(t, n)
  }
  once(t, n) {
    this.events.once(t, n)
  }
  off(t, n) {
    this.events.off(t, n)
  }
  removeListener(t, n) {
    this.events.removeListener(t, n)
  }
  async open(t = this.url) {
    await this.register(t)
  }
  async close() {
    return new Promise((t, n) => {
      if (typeof this.socket > "u") {
        n(new Error("Connection already closed"));
        return
      }
      this.socket.onclose = r => {
        this.onClose(r), t()
      }, this.socket.close()
    })
  }
  async send(t) {
    typeof this.socket > "u" && (this.socket = await this.register());
    try {
      this.socket.send(bh(t))
    } catch (n) {
      this.onError(t.id, n)
    }
  }
  register(t = this.url) {
    if (!DL(t)) throw new Error(`Provided URL is not compatible with WebSocket connection: ${t}`);
    if (this.registering) {
      const n = this.events.getMaxListeners();
      return (this.events.listenerCount("register_error") >= n || this.events.listenerCount("open") >= n) && this.events.setMaxListeners(n + 1), new Promise((r, i) => {
        this.events.once("register_error", s => {
          this.resetMaxListeners(), i(s)
        }), this.events.once("open", () => {
          if (this.resetMaxListeners(), typeof this.socket > "u") return i(new Error("WebSocket connection is missing or invalid"));
          r(this.socket)
        })
      })
    }
    return this.url = t, this.registering = !0, new Promise((n, r) => {
      const i = new URLSearchParams(t).get("origin"),
        s = UY.isReactNative() ? {
          headers: {
            origin: i
          }
        } : {
          rejectUnauthorized: !HLe(t)
        },
        o = new qLe(t, [], s);
      WLe() ? o.onerror = a => {
        const c = a;
        r(this.emitError(c.error))
      } : o.on("error", a => {
        r(this.emitError(a))
      }), o.onopen = () => {
        this.onOpen(o), n(o)
      }
    })
  }
  onOpen(t) {
    t.onmessage = n => this.onPayload(n), t.onclose = n => this.onClose(n), this.socket = t, this.registering = !1, this.events.emit("open")
  }
  onClose(t) {
    this.socket = void 0, this.registering = !1, this.events.emit("close", t)
  }
  onPayload(t) {
    if (typeof t.data > "u") return;
    const n = typeof t.data == "string" ? Py(t.data) : t.data;
    this.events.emit("payload", n)
  }
  onError(t, n) {
    const r = this.parseError(n),
      i = r.message || r.toString(),
      s = cE(t, i);
    this.events.emit("payload", s)
  }
  parseError(t, n = this.url) {
    return jY(t, NL(n), "WS")
  }
  resetMaxListeners() {
    this.events.getMaxListeners() > ML && this.events.setMaxListeners(ML)
  }
  emitError(t) {
    const n = this.parseError(new Error((t == null ? void 0 : t.message) || `WebSocket connection failed for host: ${NL(this.url)}`));
    return this.events.emit("register_error", n), n
  }
};
var mx = {
  exports: {}
};
mx.exports;
(function (e, t) {
  var n = 200,
    r = "__lodash_hash_undefined__",
    i = 1,
    s = 2,
    o = 9007199254740991,
    a = "[object Arguments]",
    c = "[object Array]",
    l = "[object AsyncFunction]",
    u = "[object Boolean]",
    f = "[object Date]",
    h = "[object Error]",
    g = "[object Function]",
    y = "[object GeneratorFunction]",
    x = "[object Map]",
    k = "[object Number]",
    _ = "[object Null]",
    p = "[object Object]",
    v = "[object Promise]",
    S = "[object Proxy]",
    I = "[object RegExp]",
    A = "[object Set]",
    w = "[object String]",
    E = "[object Symbol]",
    D = "[object Undefined]",
    $ = "[object WeakMap]",
    V = "[object ArrayBuffer]",
    G = "[object DataView]",
    L = "[object Float32Array]",
    b = "[object Float64Array]",
    T = "[object Int8Array]",
    R = "[object Int16Array]",
    N = "[object Int32Array]",
    O = "[object Uint8Array]",
    U = "[object Uint8ClampedArray]",
    q = "[object Uint16Array]",
    W = "[object Uint32Array]",
    M = /[\\^$.*+?()[\]{}|]/g,
    Q = /^\[object .+?Constructor\]$/,
    he = /^(?:0|[1-9]\d*)$/,
    H = {};
  H[L] = H[b] = H[T] = H[R] = H[N] = H[O] = H[U] = H[q] = H[W] = !0, H[a] = H[c] = H[V] = H[u] = H[G] = H[f] = H[h] = H[g] = H[x] = H[k] = H[p] = H[I] = H[A] = H[w] = H[$] = !1;
  var ne = typeof rn == "object" && rn && rn.Object === Object && rn,
    X = typeof self == "object" && self && self.Object === Object && self,
    Z = ne || X || Function("return this")(),
    te = t && !t.nodeType && t,
    F = te && !0 && e && !e.nodeType && e,
    J = F && F.exports === te,
    ie = J && ne.process,
    ce = function () {
      try {
        return ie && ie.binding && ie.binding("util")
      } catch {}
    }(),
    ue = ce && ce.isTypedArray;

  function ge(oe, ye) {
    for (var Le = -1, at = oe == null ? 0 : oe.length, tr = 0, Kt = []; ++Le < at;) {
      var fr = oe[Le];
      ye(fr, Le, oe) && (Kt[tr++] = fr)
    }
    return Kt
  }

  function et(oe, ye) {
    for (var Le = -1, at = ye.length, tr = oe.length; ++Le < at;) oe[tr + Le] = ye[Le];
    return oe
  }

  function He(oe, ye) {
    for (var Le = -1, at = oe == null ? 0 : oe.length; ++Le < at;)
      if (ye(oe[Le], Le, oe)) return !0;
    return !1
  }

  function se(oe, ye) {
    for (var Le = -1, at = Array(oe); ++Le < oe;) at[Le] = ye(Le);
    return at
  }

  function pe(oe) {
    return function (ye) {
      return oe(ye)
    }
  }

  function de(oe, ye) {
    return oe.has(ye)
  }

  function we(oe, ye) {
    return oe == null ? void 0 : oe[ye]
  }

  function Ce(oe) {
    var ye = -1,
      Le = Array(oe.size);
    return oe.forEach(function (at, tr) {
      Le[++ye] = [tr, at]
    }), Le
  }

  function be(oe, ye) {
    return function (Le) {
      return oe(ye(Le))
    }
  }

  function Se(oe) {
    var ye = -1,
      Le = Array(oe.size);
    return oe.forEach(function (at) {
      Le[++ye] = at
    }), Le
  }
  var Fe = Array.prototype,
    Ne = Function.prototype,
    Me = Object.prototype,
    We = Z["__core-js_shared__"],
    ke = Ne.toString,
    ze = Me.hasOwnProperty,
    ct = function () {
      var oe = /[^.]+$/.exec(We && We.keys && We.keys.IE_PROTO || "");
      return oe ? "Symbol(src)_1." + oe : ""
    }(),
    Xe = Me.toString,
    _e = RegExp("^" + ke.call(ze).replace(M, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"),
    Ze = J ? Z.Buffer : void 0,
    Ee = Z.Symbol,
    Oe = Z.Uint8Array,
    yt = Me.propertyIsEnumerable,
    tt = Fe.splice,
    dt = Ee ? Ee.toStringTag : void 0,
    xn = Object.getOwnPropertySymbols,
    Ht = Ze ? Ze.isBuffer : void 0,
    en = be(Object.keys, Object),
    tn = bo(Z, "DataView"),
    Et = bo(Z, "Map"),
    Ot = bo(Z, "Promise"),
    kn = bo(Z, "Set"),
    Dt = bo(Z, "WeakMap"),
    Pt = bo(Object, "create"),
    _n = Cl(tn),
    zt = Cl(Et),
    kt = Cl(Ot),
    In = Cl(kn),
    vt = Cl(Dt),
    _t = Ee ? Ee.prototype : void 0,
    Pn = _t ? _t.valueOf : void 0;

  function wt(oe) {
    var ye = -1,
      Le = oe == null ? 0 : oe.length;
    for (this.clear(); ++ye < Le;) {
      var at = oe[ye];
      this.set(at[0], at[1])
    }
  }

  function $t() {
    this.__data__ = Pt ? Pt(null) : {}, this.size = 0
  }

  function Mn(oe) {
    var ye = this.has(oe) && delete this.__data__[oe];
    return this.size -= ye ? 1 : 0, ye
  }

  function Rn(oe) {
    var ye = this.__data__;
    if (Pt) {
      var Le = ye[oe];
      return Le === r ? void 0 : Le
    }
    return ze.call(ye, oe) ? ye[oe] : void 0
  }

  function On(oe) {
    var ye = this.__data__;
    return Pt ? ye[oe] !== void 0 : ze.call(ye, oe)
  }

  function js(oe, ye) {
    var Le = this.__data__;
    return this.size += this.has(oe) ? 0 : 1, Le[oe] = Pt && ye === void 0 ? r : ye, this
  }
  wt.prototype.clear = $t, wt.prototype.delete = Mn, wt.prototype.get = Rn, wt.prototype.has = On, wt.prototype.set = js;

  function cn(oe) {
    var ye = -1,
      Le = oe == null ? 0 : oe.length;
    for (this.clear(); ++ye < Le;) {
      var at = oe[ye];
      this.set(at[0], at[1])
    }
  }

  function $n() {
    this.__data__ = [], this.size = 0
  }

  function Us(oe) {
    var ye = this.__data__,
      Le = Zd(ye, oe);
    if (Le < 0) return !1;
    var at = ye.length - 1;
    return Le == at ? ye.pop() : tt.call(ye, Le, 1), --this.size, !0
  }

  function zs(oe) {
    var ye = this.__data__,
      Le = Zd(ye, oe);
    return Le < 0 ? void 0 : ye[Le][1]
  }

  function Ut(oe) {
    return Zd(this.__data__, oe) > -1
  }

  function or(oe, ye) {
    var Le = this.__data__,
      at = Zd(Le, oe);
    return at < 0 ? (++this.size, Le.push([oe, ye])) : Le[at][1] = ye, this
  }
  cn.prototype.clear = $n, cn.prototype.delete = Us, cn.prototype.get = zs, cn.prototype.has = Ut, cn.prototype.set = or;

  function pi(oe) {
    var ye = -1,
      Le = oe == null ? 0 : oe.length;
    for (this.clear(); ++ye < Le;) {
      var at = oe[ye];
      this.set(at[0], at[1])
    }
  }

  function _c() {
    this.size = 0, this.__data__ = {
      hash: new wt,
      map: new(Et || cn),
      string: new wt
    }
  }

  function qd(oe) {
    var ye = Ru(this, oe).delete(oe);
    return this.size -= ye ? 1 : 0, ye
  }

  function Ic(oe) {
    return Ru(this, oe).get(oe)
  }

  function Gd(oe) {
    return Ru(this, oe).has(oe)
  }

  function Kd(oe, ye) {
    var Le = Ru(this, oe),
      at = Le.size;
    return Le.set(oe, ye), this.size += Le.size == at ? 0 : 1, this
  }
  pi.prototype.clear = _c, pi.prototype.delete = qd, pi.prototype.get = Ic, pi.prototype.has = Gd, pi.prototype.set = Kd;

  function Pc(oe) {
    var ye = -1,
      Le = oe == null ? 0 : oe.length;
    for (this.__data__ = new pi; ++ye < Le;) this.add(oe[ye])
  }

  function _u(oe) {
    return this.__data__.set(oe, r), this
  }

  function Iu(oe) {
    return this.__data__.has(oe)
  }
  Pc.prototype.add = Pc.prototype.push = _u, Pc.prototype.has = Iu;

  function ps(oe) {
    var ye = this.__data__ = new cn(oe);
    this.size = ye.size
  }

  function Qd() {
    this.__data__ = new cn, this.size = 0
  }

  function Yd(oe) {
    var ye = this.__data__,
      Le = ye.delete(oe);
    return this.size = ye.size, Le
  }

  function Jd(oe) {
    return this.__data__.get(oe)
  }

  function Xd(oe) {
    return this.__data__.has(oe)
  }

  function Pu(oe, ye) {
    var Le = this.__data__;
    if (Le instanceof cn) {
      var at = Le.__data__;
      if (!Et || at.length < n - 1) return at.push([oe, ye]), this.size = ++Le.size, this;
      Le = this.__data__ = new pi(at)
    }
    return Le.set(oe, ye), this.size = Le.size, this
  }
  ps.prototype.clear = Qd, ps.prototype.delete = Yd, ps.prototype.get = Jd, ps.prototype.has = Xd, ps.prototype.set = Pu;

  function By(oe, ye) {
    var Le = Wh(oe),
      at = !Le && Yy(oe),
      tr = !Le && !at && Ym(oe),
      Kt = !Le && !at && !tr && Zy(oe),
      fr = Le || at || tr || Kt,
      Xr = fr ? se(oe.length, String) : [],
      En = Xr.length;
    for (var nr in oe)(ye || ze.call(oe, nr)) && !(fr && (nr == "length" || tr && (nr == "offset" || nr == "parent") || Kt && (nr == "buffer" || nr == "byteLength" || nr == "byteOffset") || Wy(nr, En))) && Xr.push(nr);
    return Xr
  }

  function Zd(oe, ye) {
    for (var Le = oe.length; Le--;)
      if (Qy(oe[Le][0], ye)) return Le;
    return -1
  }

  function Km(oe, ye, Le) {
    var at = ye(oe);
    return Wh(oe) ? at : et(at, Le(oe))
  }

  function ef(oe) {
    return oe == null ? oe === void 0 ? D : _ : dt && dt in Object(oe) ? Hy(oe) : SE(oe)
  }

  function Qm(oe) {
    return nf(oe) && ef(oe) == a
  }

  function tf(oe, ye, Le, at, tr) {
    return oe === ye ? !0 : oe == null || ye == null || !nf(oe) && !nf(ye) ? oe !== oe && ye !== ye : Fy(oe, ye, Le, at, tf, tr)
  }

  function Fy(oe, ye, Le, at, tr, Kt) {
    var fr = Wh(oe),
      Xr = Wh(ye),
      En = fr ? c : Rc(oe),
      nr = Xr ? c : Rc(ye);
    En = En == a ? p : En, nr = nr == a ? p : nr;
    var Hr = En == p,
      Hs = nr == p,
      Zr = En == nr;
    if (Zr && Ym(oe)) {
      if (!Ym(ye)) return !1;
      fr = !0, Hr = !1
    }
    if (Zr && !Hr) return Kt || (Kt = new ps), fr || Zy(oe) ? Hh(oe, ye, Le, at, tr, Kt) : EE(oe, ye, En, Le, at, tr, Kt);
    if (!(Le & i)) {
      var hr = Hr && ze.call(oe, "__wrapped__"),
        ms = Hs && ze.call(ye, "__wrapped__");
      if (hr || ms) {
        var Va = hr ? oe.value() : oe,
          Yo = ms ? ye.value() : ye;
        return Kt || (Kt = new ps), tr(Va, Yo, Le, at, Kt)
      }
    }
    return Zr ? (Kt || (Kt = new ps), zy(oe, ye, Le, at, tr, Kt)) : !1
  }

  function xE(oe) {
    if (!Xy(oe) || Gy(oe)) return !1;
    var ye = qh(oe) ? _e : Q;
    return ye.test(Cl(oe))
  }

  function jy(oe) {
    return nf(oe) && Jy(oe.length) && !!H[ef(oe)]
  }

  function Uy(oe) {
    if (!Ky(oe)) return en(oe);
    var ye = [];
    for (var Le in Object(oe)) ze.call(oe, Le) && Le != "constructor" && ye.push(Le);
    return ye
  }

  function Hh(oe, ye, Le, at, tr, Kt) {
    var fr = Le & i,
      Xr = oe.length,
      En = ye.length;
    if (Xr != En && !(fr && En > Xr)) return !1;
    var nr = Kt.get(oe);
    if (nr && Kt.get(ye)) return nr == ye;
    var Hr = -1,
      Hs = !0,
      Zr = Le & s ? new Pc : void 0;
    for (Kt.set(oe, ye), Kt.set(ye, oe); ++Hr < Xr;) {
      var hr = oe[Hr],
        ms = ye[Hr];
      if (at) var Va = fr ? at(ms, hr, Hr, ye, oe, Kt) : at(hr, ms, Hr, oe, ye, Kt);
      if (Va !== void 0) {
        if (Va) continue;
        Hs = !1;
        break
      }
      if (Zr) {
        if (!He(ye, function (Yo, Oc) {
            if (!de(Zr, Oc) && (hr === Yo || tr(hr, Yo, Le, at, Kt))) return Zr.push(Oc)
          })) {
          Hs = !1;
          break
        }
      } else if (!(hr === ms || tr(hr, ms, Le, at, Kt))) {
        Hs = !1;
        break
      }
    }
    return Kt.delete(oe), Kt.delete(ye), Hs
  }

  function EE(oe, ye, Le, at, tr, Kt, fr) {
    switch (Le) {
      case G:
        if (oe.byteLength != ye.byteLength || oe.byteOffset != ye.byteOffset) return !1;
        oe = oe.buffer, ye = ye.buffer;
      case V:
        return !(oe.byteLength != ye.byteLength || !Kt(new Oe(oe), new Oe(ye)));
      case u:
      case f:
      case k:
        return Qy(+oe, +ye);
      case h:
        return oe.name == ye.name && oe.message == ye.message;
      case I:
      case w:
        return oe == ye + "";
      case x:
        var Xr = Ce;
      case A:
        var En = at & i;
        if (Xr || (Xr = Se), oe.size != ye.size && !En) return !1;
        var nr = fr.get(oe);
        if (nr) return nr == ye;
        at |= s, fr.set(oe, ye);
        var Hr = Hh(Xr(oe), Xr(ye), at, tr, Kt, fr);
        return fr.delete(oe), Hr;
      case E:
        if (Pn) return Pn.call(oe) == Pn.call(ye)
    }
    return !1
  }

  function zy(oe, ye, Le, at, tr, Kt) {
    var fr = Le & i,
      Xr = Vh(oe),
      En = Xr.length,
      nr = Vh(ye),
      Hr = nr.length;
    if (En != Hr && !fr) return !1;
    for (var Hs = En; Hs--;) {
      var Zr = Xr[Hs];
      if (!(fr ? Zr in ye : ze.call(ye, Zr))) return !1
    }
    var hr = Kt.get(oe);
    if (hr && Kt.get(ye)) return hr == ye;
    var ms = !0;
    Kt.set(oe, ye), Kt.set(ye, oe);
    for (var Va = fr; ++Hs < En;) {
      Zr = Xr[Hs];
      var Yo = oe[Zr],
        Oc = ye[Zr];
      if (at) var Jm = fr ? at(Oc, Yo, Zr, ye, oe, Kt) : at(Yo, Oc, Zr, oe, ye, Kt);
      if (!(Jm === void 0 ? Yo === Oc || tr(Yo, Oc, Le, at, Kt) : Jm)) {
        ms = !1;
        break
      }
      Va || (Va = Zr == "constructor")
    }
    if (ms && !Va) {
      var rf = oe.constructor,
        mi = ye.constructor;
      rf != mi && "constructor" in oe && "constructor" in ye && !(typeof rf == "function" && rf instanceof rf && typeof mi == "function" && mi instanceof mi) && (ms = !1)
    }
    return Kt.delete(oe), Kt.delete(ye), ms
  }

  function Vh(oe) {
    return Km(oe, TE, Vy)
  }

  function Ru(oe, ye) {
    var Le = oe.__data__;
    return qy(ye) ? Le[typeof ye == "string" ? "string" : "hash"] : Le.map
  }

  function bo(oe, ye) {
    var Le = we(oe, ye);
    return xE(Le) ? Le : void 0
  }

  function Hy(oe) {
    var ye = ze.call(oe, dt),
      Le = oe[dt];
    try {
      oe[dt] = void 0;
      var at = !0
    } catch {}
    var tr = Xe.call(oe);
    return at && (ye ? oe[dt] = Le : delete oe[dt]), tr
  }
  var Vy = xn ? function (oe) {
      return oe == null ? [] : (oe = Object(oe), ge(xn(oe), function (ye) {
        return yt.call(oe, ye)
      }))
    } : er,
    Rc = ef;
  (tn && Rc(new tn(new ArrayBuffer(1))) != G || Et && Rc(new Et) != x || Ot && Rc(Ot.resolve()) != v || kn && Rc(new kn) != A || Dt && Rc(new Dt) != $) && (Rc = function (oe) {
    var ye = ef(oe),
      Le = ye == p ? oe.constructor : void 0,
      at = Le ? Cl(Le) : "";
    if (at) switch (at) {
      case _n:
        return G;
      case zt:
        return x;
      case kt:
        return v;
      case In:
        return A;
      case vt:
        return $
    }
    return ye
  });

  function Wy(oe, ye) {
    return ye = ye ?? o, !!ye && (typeof oe == "number" || he.test(oe)) && oe > -1 && oe % 1 == 0 && oe < ye
  }

  function qy(oe) {
    var ye = typeof oe;
    return ye == "string" || ye == "number" || ye == "symbol" || ye == "boolean" ? oe !== "__proto__" : oe === null
  }

  function Gy(oe) {
    return !!ct && ct in oe
  }

  function Ky(oe) {
    var ye = oe && oe.constructor,
      Le = typeof ye == "function" && ye.prototype || Me;
    return oe === Le
  }

  function SE(oe) {
    return Xe.call(oe)
  }

  function Cl(oe) {
    if (oe != null) {
      try {
        return ke.call(oe)
      } catch {}
      try {
        return oe + ""
      } catch {}
    }
    return ""
  }

  function Qy(oe, ye) {
    return oe === ye || oe !== oe && ye !== ye
  }
  var Yy = Qm(function () {
      return arguments
    }()) ? Qm : function (oe) {
      return nf(oe) && ze.call(oe, "callee") && !yt.call(oe, "callee")
    },
    Wh = Array.isArray;

  function CE(oe) {
    return oe != null && Jy(oe.length) && !qh(oe)
  }
  var Ym = Ht || Yn;

  function AE(oe, ye) {
    return tf(oe, ye)
  }

  function qh(oe) {
    if (!Xy(oe)) return !1;
    var ye = ef(oe);
    return ye == g || ye == y || ye == l || ye == S
  }

  function Jy(oe) {
    return typeof oe == "number" && oe > -1 && oe % 1 == 0 && oe <= o
  }

  function Xy(oe) {
    var ye = typeof oe;
    return oe != null && (ye == "object" || ye == "function")
  }

  function nf(oe) {
    return oe != null && typeof oe == "object"
  }
  var Zy = ue ? pe(ue) : jy;

  function TE(oe) {
    return CE(oe) ? By(oe) : Uy(oe)
  }

  function er() {
    return []
  }

  function Yn() {
    return !1
  }
  e.exports = AE
})(mx, mx.exports);
var KLe = mx.exports;
const QLe = Vo(KLe);

function YLe(e, t) {
  return t = t || {}, new Promise(function (n, r) {
    var i = new XMLHttpRequest,
      s = [],
      o = [],
      a = {},
      c = function () {
        return {
          ok: (i.status / 100 | 0) == 2,
          statusText: i.statusText,
          status: i.status,
          url: i.responseURL,
          text: function () {
            return Promise.resolve(i.responseText)
          },
          json: function () {
            return Promise.resolve(i.responseText).then(JSON.parse)
          },
          blob: function () {
            return Promise.resolve(new Blob([i.response]))
          },
          clone: c,
          headers: {
            keys: function () {
              return s
            },
            entries: function () {
              return o
            },
            get: function (u) {
              return a[u.toLowerCase()]
            },
            has: function (u) {
              return u.toLowerCase() in a
            }
          }
        }
      };
    for (var l in i.open(t.method || "get", e, !0), i.onload = function () {
        i.getAllResponseHeaders().replace(/^(.*?):[^\S\n]*([\s\S]*?)$/gm, function (u, f, h) {
          s.push(f = f.toLowerCase()), o.push([f, h]), a[f] = a[f] ? a[f] + "," + h : h
        }), n(c())
      }, i.onerror = r, i.withCredentials = t.credentials == "include", t.headers) i.setRequestHeader(l, t.headers[l]);
    i.send(t.body || null)
  })
}
const JLe = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: YLe
  }, Symbol.toStringTag, {
    value: "Module"
  })),
  $L = Ds(JLe);
var XLe = self.fetch || (self.fetch = $L.default || $L);
const ZLe = Vo(XLe);
var eBe = {};

function tBe(e, t) {
  if (e.length >= 255) throw new TypeError("Alphabet too long");
  for (var n = new Uint8Array(256), r = 0; r < n.length; r++) n[r] = 255;
  for (var i = 0; i < e.length; i++) {
    var s = e.charAt(i),
      o = s.charCodeAt(0);
    if (n[o] !== 255) throw new TypeError(s + " is ambiguous");
    n[o] = i
  }
  var a = e.length,
    c = e.charAt(0),
    l = Math.log(a) / Math.log(256),
    u = Math.log(256) / Math.log(a);

  function f(y) {
    if (y instanceof Uint8Array || (ArrayBuffer.isView(y) ? y = new Uint8Array(y.buffer, y.byteOffset, y.byteLength) : Array.isArray(y) && (y = Uint8Array.from(y))), !(y instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
    if (y.length === 0) return "";
    for (var x = 0, k = 0, _ = 0, p = y.length; _ !== p && y[_] === 0;) _++, x++;
    for (var v = (p - _) * u + 1 >>> 0, S = new Uint8Array(v); _ !== p;) {
      for (var I = y[_], A = 0, w = v - 1;
        (I !== 0 || A < k) && w !== -1; w--, A++) I += 256 * S[w] >>> 0, S[w] = I % a >>> 0, I = I / a >>> 0;
      if (I !== 0) throw new Error("Non-zero carry");
      k = A, _++
    }
    for (var E = v - k; E !== v && S[E] === 0;) E++;
    for (var D = c.repeat(x); E < v; ++E) D += e.charAt(S[E]);
    return D
  }

  function h(y) {
    if (typeof y != "string") throw new TypeError("Expected String");
    if (y.length === 0) return new Uint8Array;
    var x = 0;
    if (y[x] !== " ") {
      for (var k = 0, _ = 0; y[x] === c;) k++, x++;
      for (var p = (y.length - x) * l + 1 >>> 0, v = new Uint8Array(p); y[x];) {
        var S = n[y.charCodeAt(x)];
        if (S === 255) return;
        for (var I = 0, A = p - 1;
          (S !== 0 || I < _) && A !== -1; A--, I++) S += a * v[A] >>> 0, v[A] = S % 256 >>> 0, S = S / 256 >>> 0;
        if (S !== 0) throw new Error("Non-zero carry");
        _ = I, x++
      }
      if (y[x] !== " ") {
        for (var w = p - _; w !== p && v[w] === 0;) w++;
        for (var E = new Uint8Array(k + (p - w)), D = k; w !== p;) E[D++] = v[w++];
        return E
      }
    }
  }

  function g(y) {
    var x = h(y);
    if (x) return x;
    throw new Error(`Non-${t} character`)
  }
  return {
    encode: f,
    decodeUnsafe: h,
    decode: g
  }
}
var nBe = tBe,
  rBe = nBe;
const VY = e => {
    if (e instanceof Uint8Array && e.constructor.name === "Uint8Array") return e;
    if (e instanceof ArrayBuffer) return new Uint8Array(e);
    if (ArrayBuffer.isView(e)) return new Uint8Array(e.buffer, e.byteOffset, e.byteLength);
    throw new Error("Unknown type, must be binary type")
  },
  iBe = e => new TextEncoder().encode(e),
  sBe = e => new TextDecoder().decode(e);
class oBe {
  constructor(t, n, r) {
    this.name = t, this.prefix = n, this.baseEncode = r
  }
  encode(t) {
    if (t instanceof Uint8Array) return `${this.prefix}${this.baseEncode(t)}`;
    throw Error("Unknown type, must be binary type")
  }
}
let aBe = class {
  constructor(t, n, r) {
    if (this.name = t, this.prefix = n, n.codePointAt(0) === void 0) throw new Error("Invalid prefix character");
    this.prefixCodePoint = n.codePointAt(0), this.baseDecode = r
  }
  decode(t) {
    if (typeof t == "string") {
      if (t.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(t)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(t.slice(this.prefix.length))
    } else throw Error("Can only multibase decode strings")
  }
  or(t) {
    return WY(this, t)
  }
};
class cBe {
  constructor(t) {
    this.decoders = t
  }
  or(t) {
    return WY(this, t)
  }
  decode(t) {
    const n = t[0],
      r = this.decoders[n];
    if (r) return r.decode(t);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(t)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)
  }
}
const WY = (e, t) => new cBe({
  ...e.decoders || {
    [e.prefix]: e
  },
  ...t.decoders || {
    [t.prefix]: t
  }
});
class lBe {
  constructor(t, n, r, i) {
    this.name = t, this.prefix = n, this.baseEncode = r, this.baseDecode = i, this.encoder = new oBe(t, n, r), this.decoder = new aBe(t, n, i)
  }
  encode(t) {
    return this.encoder.encode(t)
  }
  decode(t) {
    return this.decoder.decode(t)
  }
}
const uE = ({
    name: e,
    prefix: t,
    encode: n,
    decode: r
  }) => new lBe(e, t, n, r),
  Oy = ({
    prefix: e,
    name: t,
    alphabet: n
  }) => {
    const {
      encode: r,
      decode: i
    } = rBe(n, t);
    return uE({
      prefix: e,
      name: t,
      encode: r,
      decode: s => VY(i(s))
    })
  },
  uBe = (e, t, n, r) => {
    const i = {};
    for (let u = 0; u < t.length; ++u) i[t[u]] = u;
    let s = e.length;
    for (; e[s - 1] === "=";) --s;
    const o = new Uint8Array(s * n / 8 | 0);
    let a = 0,
      c = 0,
      l = 0;
    for (let u = 0; u < s; ++u) {
      const f = i[e[u]];
      if (f === void 0) throw new SyntaxError(`Non-${r} character`);
      c = c << n | f, a += n, a >= 8 && (a -= 8, o[l++] = 255 & c >> a)
    }
    if (a >= n || 255 & c << 8 - a) throw new SyntaxError("Unexpected end of data");
    return o
  },
  dBe = (e, t, n) => {
    const r = t[t.length - 1] === "=",
      i = (1 << n) - 1;
    let s = "",
      o = 0,
      a = 0;
    for (let c = 0; c < e.length; ++c)
      for (a = a << 8 | e[c], o += 8; o > n;) o -= n, s += t[i & a >> o];
    if (o && (s += t[i & a << n - o]), r)
      for (; s.length * n & 7;) s += "=";
    return s
  },
  Gi = ({
    name: e,
    prefix: t,
    bitsPerChar: n,
    alphabet: r
  }) => uE({
    prefix: t,
    name: e,
    encode(i) {
      return dBe(i, r, n)
    },
    decode(i) {
      return uBe(i, r, n, e)
    }
  }),
  fBe = uE({
    prefix: "\0",
    name: "identity",
    encode: e => sBe(e),
    decode: e => iBe(e)
  });
var hBe = Object.freeze({
  __proto__: null,
  identity: fBe
});
const pBe = Gi({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});
var mBe = Object.freeze({
  __proto__: null,
  base2: pBe
});
const gBe = Gi({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});
var yBe = Object.freeze({
  __proto__: null,
  base8: gBe
});
const vBe = Oy({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});
var bBe = Object.freeze({
  __proto__: null,
  base10: vBe
});
const wBe = Gi({
    prefix: "f",
    name: "base16",
    alphabet: "0123456789abcdef",
    bitsPerChar: 4
  }),
  xBe = Gi({
    prefix: "F",
    name: "base16upper",
    alphabet: "0123456789ABCDEF",
    bitsPerChar: 4
  });
var EBe = Object.freeze({
  __proto__: null,
  base16: wBe,
  base16upper: xBe
});
const SBe = Gi({
    prefix: "b",
    name: "base32",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567",
    bitsPerChar: 5
  }),
  CBe = Gi({
    prefix: "B",
    name: "base32upper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
    bitsPerChar: 5
  }),
  ABe = Gi({
    prefix: "c",
    name: "base32pad",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
    bitsPerChar: 5
  }),
  TBe = Gi({
    prefix: "C",
    name: "base32padupper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
    bitsPerChar: 5
  }),
  kBe = Gi({
    prefix: "v",
    name: "base32hex",
    alphabet: "0123456789abcdefghijklmnopqrstuv",
    bitsPerChar: 5
  }),
  _Be = Gi({
    prefix: "V",
    name: "base32hexupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
    bitsPerChar: 5
  }),
  IBe = Gi({
    prefix: "t",
    name: "base32hexpad",
    alphabet: "0123456789abcdefghijklmnopqrstuv=",
    bitsPerChar: 5
  }),
  PBe = Gi({
    prefix: "T",
    name: "base32hexpadupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
    bitsPerChar: 5
  }),
  RBe = Gi({
    prefix: "h",
    name: "base32z",
    alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
    bitsPerChar: 5
  });
var OBe = Object.freeze({
  __proto__: null,
  base32: SBe,
  base32upper: CBe,
  base32pad: ABe,
  base32padupper: TBe,
  base32hex: kBe,
  base32hexupper: _Be,
  base32hexpad: IBe,
  base32hexpadupper: PBe,
  base32z: RBe
});
const DBe = Oy({
    prefix: "k",
    name: "base36",
    alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
  }),
  NBe = Oy({
    prefix: "K",
    name: "base36upper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
  });
var MBe = Object.freeze({
  __proto__: null,
  base36: DBe,
  base36upper: NBe
});
const $Be = Oy({
    name: "base58btc",
    prefix: "z",
    alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
  }),
  LBe = Oy({
    name: "base58flickr",
    prefix: "Z",
    alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
  });
var BBe = Object.freeze({
  __proto__: null,
  base58btc: $Be,
  base58flickr: LBe
});
const FBe = Gi({
    prefix: "m",
    name: "base64",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
    bitsPerChar: 6
  }),
  jBe = Gi({
    prefix: "M",
    name: "base64pad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
    bitsPerChar: 6
  }),
  UBe = Gi({
    prefix: "u",
    name: "base64url",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
    bitsPerChar: 6
  }),
  zBe = Gi({
    prefix: "U",
    name: "base64urlpad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
    bitsPerChar: 6
  });
var HBe = Object.freeze({
  __proto__: null,
  base64: FBe,
  base64pad: jBe,
  base64url: UBe,
  base64urlpad: zBe
});
const qY = Array.from("🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂"),
  VBe = qY.reduce((e, t, n) => (e[n] = t, e), []),
  WBe = qY.reduce((e, t, n) => (e[t.codePointAt(0)] = n, e), []);

function qBe(e) {
  return e.reduce((t, n) => (t += VBe[n], t), "")
}

function GBe(e) {
  const t = [];
  for (const n of e) {
    const r = WBe[n.codePointAt(0)];
    if (r === void 0) throw new Error(`Non-base256emoji character: ${n}`);
    t.push(r)
  }
  return new Uint8Array(t)
}
const KBe = uE({
  prefix: "🚀",
  name: "base256emoji",
  encode: qBe,
  decode: GBe
});
var QBe = Object.freeze({
    __proto__: null,
    base256emoji: KBe
  }),
  YBe = GY,
  LL = 128,
  JBe = 127,
  XBe = ~JBe,
  ZBe = Math.pow(2, 31);

function GY(e, t, n) {
  t = t || [], n = n || 0;
  for (var r = n; e >= ZBe;) t[n++] = e & 255 | LL, e /= 128;
  for (; e & XBe;) t[n++] = e & 255 | LL, e >>>= 7;
  return t[n] = e | 0, GY.bytes = n - r + 1, t
}
var eFe = i9,
  tFe = 128,
  BL = 127;

function i9(e, r) {
  var n = 0,
    r = r || 0,
    i = 0,
    s = r,
    o, a = e.length;
  do {
    if (s >= a) throw i9.bytes = 0, new RangeError("Could not decode varint");
    o = e[s++], n += i < 28 ? (o & BL) << i : (o & BL) * Math.pow(2, i), i += 7
  } while (o >= tFe);
  return i9.bytes = s - r, n
}
var nFe = Math.pow(2, 7),
  rFe = Math.pow(2, 14),
  iFe = Math.pow(2, 21),
  sFe = Math.pow(2, 28),
  oFe = Math.pow(2, 35),
  aFe = Math.pow(2, 42),
  cFe = Math.pow(2, 49),
  lFe = Math.pow(2, 56),
  uFe = Math.pow(2, 63),
  dFe = function (e) {
    return e < nFe ? 1 : e < rFe ? 2 : e < iFe ? 3 : e < sFe ? 4 : e < oFe ? 5 : e < aFe ? 6 : e < cFe ? 7 : e < lFe ? 8 : e < uFe ? 9 : 10
  },
  fFe = {
    encode: YBe,
    decode: eFe,
    encodingLength: dFe
  },
  KY = fFe;
const FL = (e, t, n = 0) => (KY.encode(e, t, n), t),
  jL = e => KY.encodingLength(e),
  s9 = (e, t) => {
    const n = t.byteLength,
      r = jL(e),
      i = r + jL(n),
      s = new Uint8Array(i + n);
    return FL(e, s, 0), FL(n, s, r), s.set(t, i), new hFe(e, n, t, s)
  };
class hFe {
  constructor(t, n, r, i) {
    this.code = t, this.size = n, this.digest = r, this.bytes = i
  }
}
const QY = ({
  name: e,
  code: t,
  encode: n
}) => new pFe(e, t, n);
class pFe {
  constructor(t, n, r) {
    this.name = t, this.code = n, this.encode = r
  }
  digest(t) {
    if (t instanceof Uint8Array) {
      const n = this.encode(t);
      return n instanceof Uint8Array ? s9(this.code, n) : n.then(r => s9(this.code, r))
    } else throw Error("Unknown type, must be binary type")
  }
}
const YY = e => async t => new Uint8Array(await crypto.subtle.digest(e, t)), mFe = QY({
  name: "sha2-256",
  code: 18,
  encode: YY("SHA-256")
}), gFe = QY({
  name: "sha2-512",
  code: 19,
  encode: YY("SHA-512")
});
var yFe = Object.freeze({
  __proto__: null,
  sha256: mFe,
  sha512: gFe
});
const JY = 0,
  vFe = "identity",
  XY = VY,
  bFe = e => s9(JY, XY(e)),
  wFe = {
    code: JY,
    name: vFe,
    encode: XY,
    digest: bFe
  };
var xFe = Object.freeze({
  __proto__: null,
  identity: wFe
});
new TextEncoder, new TextDecoder;
const UL = {
  ...hBe,
  ...mBe,
  ...yBe,
  ...bBe,
  ...EBe,
  ...OBe,
  ...MBe,
  ...BBe,
  ...HBe,
  ...QBe
};
({
  ...yFe,
  ...xFe
});

function ZY(e) {
  return globalThis.Buffer != null ? new Uint8Array(e.buffer, e.byteOffset, e.byteLength) : e
}

function EFe(e = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? ZY(globalThis.Buffer.allocUnsafe(e)) : new Uint8Array(e)
}

function eJ(e, t, n, r) {
  return {
    name: e,
    prefix: t,
    encoder: {
      name: e,
      prefix: t,
      encode: n
    },
    decoder: {
      decode: r
    }
  }
}
const zL = eJ("utf8", "u", e => "u" + new TextDecoder("utf8").decode(e), e => new TextEncoder().encode(e.substring(1))),
  S8 = eJ("ascii", "a", e => {
    let t = "a";
    for (let n = 0; n < e.length; n++) t += String.fromCharCode(e[n]);
    return t
  }, e => {
    e = e.substring(1);
    const t = EFe(e.length);
    for (let n = 0; n < e.length; n++) t[n] = e.charCodeAt(n);
    return t
  }),
  SFe = {
    utf8: zL,
    "utf-8": zL,
    hex: UL.base16,
    latin1: S8,
    ascii: S8,
    binary: S8,
    ...UL
  };

function CFe(e, t = "utf8") {
  const n = SFe[t];
  if (!n) throw new Error(`Unsupported encoding "${t}"`);
  return (t === "utf8" || t === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? ZY(globalThis.Buffer.from(e, "utf-8")) : n.decoder.decode(`${n.prefix}${e}`)
}
const tJ = "wc",
  AFe = 2,
  x_ = "core",
  Dd = `${tJ}@2:${x_}:`,
  TFe = {
    name: x_,
    logger: "error"
  },
  kFe = {
    database: ":memory:"
  },
  _Fe = "crypto",
  HL = "client_ed25519_seed",
  IFe = it.ONE_DAY,
  PFe = "keychain",
  RFe = "0.3",
  OFe = "messages",
  DFe = "0.3",
  NFe = it.SIX_HOURS,
  MFe = "publisher",
  nJ = "irn",
  $Fe = "error",
  rJ = "wss://relay.walletconnect.com",
  VL = "wss://relay.walletconnect.org",
  LFe = "relayer",
  $o = {
    message: "relayer_message",
    message_ack: "relayer_message_ack",
    connect: "relayer_connect",
    disconnect: "relayer_disconnect",
    error: "relayer_error",
    connection_stalled: "relayer_connection_stalled",
    transport_closed: "relayer_transport_closed",
    publish: "relayer_publish"
  },
  BFe = "_subscription",
  ca = {
    payload: "payload",
    connect: "connect",
    disconnect: "disconnect",
    error: "error"
  },
  FFe = it.ONE_SECOND,
  jFe = "2.11.3",
  UFe = 1e4,
  zFe = "0.3",
  HFe = "WALLETCONNECT_CLIENT_ID",
  zc = {
    created: "subscription_created",
    deleted: "subscription_deleted",
    expired: "subscription_expired",
    disabled: "subscription_disabled",
    sync: "subscription_sync",
    resubscribed: "subscription_resubscribed"
  },
  VFe = "subscription",
  WFe = "0.3",
  qFe = it.FIVE_SECONDS * 1e3,
  GFe = "pairing",
  KFe = "0.3",
  Hg = {
    wc_pairingDelete: {
      req: {
        ttl: it.ONE_DAY,
        prompt: !1,
        tag: 1e3
      },
      res: {
        ttl: it.ONE_DAY,
        prompt: !1,
        tag: 1001
      }
    },
    wc_pairingPing: {
      req: {
        ttl: it.THIRTY_SECONDS,
        prompt: !1,
        tag: 1002
      },
      res: {
        ttl: it.THIRTY_SECONDS,
        prompt: !1,
        tag: 1003
      }
    },
    unregistered_method: {
      req: {
        ttl: it.ONE_DAY,
        prompt: !1,
        tag: 0
      },
      res: {
        ttl: it.ONE_DAY,
        prompt: !1,
        tag: 0
      }
    }
  },
  Z0 = {
    create: "pairing_create",
    expire: "pairing_expire",
    delete: "pairing_delete",
    ping: "pairing_ping"
  },
  Fc = {
    created: "history_created",
    updated: "history_updated",
    deleted: "history_deleted",
    sync: "history_sync"
  },
  QFe = "history",
  YFe = "0.3",
  JFe = "expirer",
  fa = {
    created: "expirer_created",
    deleted: "expirer_deleted",
    expired: "expirer_expired",
    sync: "expirer_sync"
  },
  XFe = "0.3",
  C8 = "verify-api",
  ep = "https://verify.walletconnect.com",
  o9 = "https://verify.walletconnect.org",
  ZFe = [ep, o9],
  eje = "echo",
  tje = "https://echo.walletconnect.com";
class nje {
  constructor(t, n) {
    this.core = t, this.logger = n, this.keychain = new Map, this.name = PFe, this.version = RFe, this.initialized = !1, this.storagePrefix = Dd, this.init = async () => {
      if (!this.initialized) {
        const r = await this.getKeyChain();
        typeof r < "u" && (this.keychain = r), this.initialized = !0
      }
    }, this.has = r => (this.isInitialized(), this.keychain.has(r)), this.set = async (r, i) => {
      this.isInitialized(), this.keychain.set(r, i), await this.persist()
    }, this.get = r => {
      this.isInitialized();
      const i = this.keychain.get(r);
      if (typeof i > "u") {
        const {
          message: s
        } = Hn("NO_MATCHING_KEY", `${this.name}: ${r}`);
        throw new Error(s)
      }
      return i
    }, this.del = async r => {
      this.isInitialized(), this.keychain.delete(r), await this.persist()
    }, this.core = t, this.logger = vn.generateChildLogger(n, this.name)
  }
  get context() {
    return vn.getLoggerContext(this.logger)
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name
  }
  async setKeyChain(t) {
    await this.core.storage.setItem(this.storageKey, NY(t))
  }
  async getKeyChain() {
    const t = await this.core.storage.getItem(this.storageKey);
    return typeof t < "u" ? MY(t) : void 0
  }
  async persist() {
    await this.setKeyChain(this.keychain)
  }
  isInitialized() {
    if (!this.initialized) {
      const {
        message: t
      } = Hn("NOT_INITIALIZED", this.name);
      throw new Error(t)
    }
  }
}
let rje = class {
  constructor(t, n, r) {
    this.core = t, this.logger = n, this.name = _Fe, this.initialized = !1, this.init = async () => {
      this.initialized || (await this.keychain.init(), this.initialized = !0)
    }, this.hasKeys = i => (this.isInitialized(), this.keychain.has(i)), this.getClientId = async () => {
      this.isInitialized();
      const i = await this.getClientSeed(),
        s = vL(i);
      return PY(s.publicKey)
    }, this.generateKeyPair = () => {
      this.isInitialized();
      const i = N$e();
      return this.setPrivateKey(i.publicKey, i.privateKey)
    }, this.signJWT = async i => {
      this.isInitialized();
      const s = await this.getClientSeed(),
        o = vL(s),
        a = t9();
      return await O$e(a, i, IFe, o)
    }, this.generateSharedKey = (i, s, o) => {
      this.isInitialized();
      const a = this.getPrivateKey(i),
        c = M$e(a, s);
      return this.setSymKey(c, o)
    }, this.setSymKey = async (i, s) => {
      this.isInitialized();
      const o = s || $$e(i);
      return await this.keychain.set(o, i), o
    }, this.deleteKeyPair = async i => {
      this.isInitialized(), await this.keychain.del(i)
    }, this.deleteSymKey = async i => {
      this.isInitialized(), await this.keychain.del(i)
    }, this.encode = async (i, s, o) => {
      this.isInitialized();
      const a = DY(o),
        c = bh(s);
      if (wL(a)) {
        const h = a.senderPublicKey,
          g = a.receiverPublicKey;
        i = await this.generateSharedKey(h, g)
      }
      const l = this.getSymKey(i),
        {
          type: u,
          senderPublicKey: f
        } = a;
      return B$e({
        type: u,
        symKey: l,
        message: c,
        senderPublicKey: f
      })
    }, this.decode = async (i, s, o) => {
      this.isInitialized();
      const a = U$e(s, o);
      if (wL(a)) {
        const c = a.receiverPublicKey,
          l = a.senderPublicKey;
        i = await this.generateSharedKey(c, l)
      }
      try {
        const c = this.getSymKey(i),
          l = F$e({
            symKey: c,
            encoded: s
          });
        return Py(l)
      } catch (c) {
        this.logger.error(`Failed to decode message from topic: '${i}', clientId: '${await this.getClientId()}'`), this.logger.error(c)
      }
    }, this.getPayloadType = i => {
      const s = hx(i);
      return Ry(s.type)
    }, this.getPayloadSenderPublicKey = i => {
      const s = hx(i);
      return s.senderPublicKey ? us(s.senderPublicKey, Rs) : void 0
    }, this.core = t, this.logger = vn.generateChildLogger(n, this.name), this.keychain = r || new nje(this.core, this.logger)
  }
  get context() {
    return vn.getLoggerContext(this.logger)
  }
  async setPrivateKey(t, n) {
    return await this.keychain.set(t, n), t
  }
  getPrivateKey(t) {
    return this.keychain.get(t)
  }
  async getClientSeed() {
    let t = "";
    try {
      t = this.keychain.get(HL)
    } catch {
      t = t9(), await this.keychain.set(HL, t)
    }
    return CFe(t, "base16")
  }
  getSymKey(t) {
    return this.keychain.get(t)
  }
  isInitialized() {
    if (!this.initialized) {
      const {
        message: t
      } = Hn("NOT_INITIALIZED", this.name);
      throw new Error(t)
    }
  }
};
class ije extends l$e {
  constructor(t, n) {
    super(t, n), this.logger = t, this.core = n, this.messages = new Map, this.name = OFe, this.version = DFe, this.initialized = !1, this.storagePrefix = Dd, this.init = async () => {
      if (!this.initialized) {
        this.logger.trace("Initialized");
        try {
          const r = await this.getRelayerMessages();
          typeof r < "u" && (this.messages = r), this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({
            type: "method",
            method: "restore",
            size: this.messages.size
          })
        } catch (r) {
          this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(r)
        } finally {
          this.initialized = !0
        }
      }
    }, this.set = async (r, i) => {
      this.isInitialized();
      const s = n9(i);
      let o = this.messages.get(r);
      return typeof o > "u" && (o = {}), typeof o[s] < "u" || (o[s] = i, this.messages.set(r, o), await this.persist()), s
    }, this.get = r => {
      this.isInitialized();
      let i = this.messages.get(r);
      return typeof i > "u" && (i = {}), i
    }, this.has = (r, i) => {
      this.isInitialized();
      const s = this.get(r),
        o = n9(i);
      return typeof s[o] < "u"
    }, this.del = async r => {
      this.isInitialized(), this.messages.delete(r), await this.persist()
    }, this.logger = vn.generateChildLogger(t, this.name), this.core = n
  }
  get context() {
    return vn.getLoggerContext(this.logger)
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name
  }
  async setRelayerMessages(t) {
    await this.core.storage.setItem(this.storageKey, NY(t))
  }
  async getRelayerMessages() {
    const t = await this.core.storage.getItem(this.storageKey);
    return typeof t < "u" ? MY(t) : void 0
  }
  async persist() {
    await this.setRelayerMessages(this.messages)
  }
  isInitialized() {
    if (!this.initialized) {
      const {
        message: t
      } = Hn("NOT_INITIALIZED", this.name);
      throw new Error(t)
    }
  }
}
class sje extends u$e {
  constructor(t, n) {
    super(t, n), this.relayer = t, this.logger = n, this.events = new si.EventEmitter, this.name = MFe, this.queue = new Map, this.publishTimeout = it.toMiliseconds(it.ONE_MINUTE), this.failedPublishTimeout = it.toMiliseconds(it.ONE_SECOND), this.needsTransportRestart = !1, this.publish = async (r, i, s) => {
      var o;
      this.logger.debug("Publishing Payload"), this.logger.trace({
        type: "method",
        method: "publish",
        params: {
          topic: r,
          message: i,
          opts: s
        }
      });
      const a = (s == null ? void 0 : s.ttl) || NFe,
        c = r9(s),
        l = (s == null ? void 0 : s.prompt) || !1,
        u = (s == null ? void 0 : s.tag) || 0,
        f = (s == null ? void 0 : s.id) || Bf().toString(),
        h = {
          topic: r,
          message: i,
          opts: {
            ttl: a,
            relay: c,
            prompt: l,
            tag: u,
            id: f
          }
        },
        g = `Failed to publish payload, please try again. id:${f} tag:${u}`,
        y = Date.now();
      let x, k = 1;
      try {
        for (; x === void 0;) {
          if (Date.now() - y > this.publishTimeout) throw new Error(g);
          this.logger.trace({
            id: f,
            attempts: k
          }, `publisher.publish - attempt ${k}`), x = await await S2(this.rpcPublish(r, i, a, c, l, u, f).catch(_ => this.logger.warn(_)), this.publishTimeout, g), k++, x || await new Promise(_ => setTimeout(_, this.failedPublishTimeout))
        }
        this.relayer.events.emit($o.publish, h), this.logger.debug("Successfully Published Payload"), this.logger.trace({
          type: "method",
          method: "publish",
          params: {
            id: f,
            topic: r,
            message: i,
            opts: s
          }
        })
      } catch (_) {
        if (this.logger.debug("Failed to Publish Payload"), this.logger.error(_), (o = s == null ? void 0 : s.internal) != null && o.throwOnFailedPublish) throw _;
        this.queue.set(f, h)
      }
    }, this.on = (r, i) => {
      this.events.on(r, i)
    }, this.once = (r, i) => {
      this.events.once(r, i)
    }, this.off = (r, i) => {
      this.events.off(r, i)
    }, this.removeListener = (r, i) => {
      this.events.removeListener(r, i)
    }, this.relayer = t, this.logger = vn.generateChildLogger(n, this.name), this.registerEventListeners()
  }
  get context() {
    return vn.getLoggerContext(this.logger)
  }
  rpcPublish(t, n, r, i, s, o, a) {
    var c, l, u, f;
    const h = {
      method: Iw(i.protocol).publish,
      params: {
        topic: t,
        message: n,
        ttl: r,
        prompt: s,
        tag: o
      },
      id: a
    };
    return px((c = h.params) == null ? void 0 : c.prompt) && ((l = h.params) == null || delete l.prompt), px((u = h.params) == null ? void 0 : u.tag) && ((f = h.params) == null || delete f.tag), this.logger.debug("Outgoing Relay Payload"), this.logger.trace({
      type: "message",
      direction: "outgoing",
      request: h
    }), this.relayer.request(h)
  }
  removeRequestFromQueue(t) {
    this.queue.delete(t)
  }
  checkQueue() {
    this.queue.forEach(async t => {
      const {
        topic: n,
        message: r,
        opts: i
      } = t;
      await this.publish(n, r, i)
    })
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(Hm.HEARTBEAT_EVENTS.pulse, () => {
      if (this.needsTransportRestart) {
        this.needsTransportRestart = !1, this.relayer.events.emit($o.connection_stalled);
        return
      }
      this.checkQueue()
    }), this.relayer.on($o.message_ack, t => {
      this.removeRequestFromQueue(t.id.toString())
    })
  }
}
class oje {
  constructor() {
    this.map = new Map, this.set = (t, n) => {
      const r = this.get(t);
      this.exists(t, n) || this.map.set(t, [...r, n])
    }, this.get = t => this.map.get(t) || [], this.exists = (t, n) => this.get(t).includes(n), this.delete = (t, n) => {
      if (typeof n > "u") {
        this.map.delete(t);
        return
      }
      if (!this.map.has(t)) return;
      const r = this.get(t);
      if (!this.exists(t, n)) return;
      const i = r.filter(s => s !== n);
      if (!i.length) {
        this.map.delete(t);
        return
      }
      this.map.set(t, i)
    }, this.clear = () => {
      this.map.clear()
    }
  }
  get topics() {
    return Array.from(this.map.keys())
  }
}
var aje = Object.defineProperty,
  cje = Object.defineProperties,
  lje = Object.getOwnPropertyDescriptors,
  WL = Object.getOwnPropertySymbols,
  uje = Object.prototype.hasOwnProperty,
  dje = Object.prototype.propertyIsEnumerable,
  qL = (e, t, n) => t in e ? aje(e, t, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: n
  }) : e[t] = n,
  Vg = (e, t) => {
    for (var n in t || (t = {})) uje.call(t, n) && qL(e, n, t[n]);
    if (WL)
      for (var n of WL(t)) dje.call(t, n) && qL(e, n, t[n]);
    return e
  },
  A8 = (e, t) => cje(e, lje(t));
class fje extends h$e {
  constructor(t, n) {
    super(t, n), this.relayer = t, this.logger = n, this.subscriptions = new Map, this.topicMap = new oje, this.events = new si.EventEmitter, this.name = VFe, this.version = WFe, this.pending = new Map, this.cached = [], this.initialized = !1, this.pendingSubscriptionWatchLabel = "pending_sub_watch_label", this.pollingInterval = 20, this.storagePrefix = Dd, this.subscribeTimeout = it.toMiliseconds(it.ONE_MINUTE), this.restartInProgress = !1, this.batchSubscribeTopicsLimit = 500, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), this.registerEventListeners(), this.clientId = await this.relayer.core.crypto.getClientId())
    }, this.subscribe = async (r, i) => {
      await this.restartToComplete(), this.isInitialized(), this.logger.debug("Subscribing Topic"), this.logger.trace({
        type: "method",
        method: "subscribe",
        params: {
          topic: r,
          opts: i
        }
      });
      try {
        const s = r9(i),
          o = {
            topic: r,
            relay: s
          };
        this.pending.set(r, o);
        const a = await this.rpcSubscribe(r, s);
        return typeof a == "string" && (this.onSubscribe(a, o), this.logger.debug("Successfully Subscribed Topic"), this.logger.trace({
          type: "method",
          method: "subscribe",
          params: {
            topic: r,
            opts: i
          }
        })), a
      } catch (s) {
        throw this.logger.debug("Failed to Subscribe Topic"), this.logger.error(s), s
      }
    }, this.unsubscribe = async (r, i) => {
      await this.restartToComplete(), this.isInitialized(), typeof (i == null ? void 0 : i.id) < "u" ? await this.unsubscribeById(r, i.id, i) : await this.unsubscribeByTopic(r, i)
    }, this.isSubscribed = async r => {
      if (this.topics.includes(r)) return !0;
      const i = `${this.pendingSubscriptionWatchLabel}_${r}`;
      return await new Promise((s, o) => {
        const a = new it.Watch;
        a.start(i);
        const c = setInterval(() => {
          !this.pending.has(r) && this.topics.includes(r) && (clearInterval(c), a.stop(i), s(!0)), a.elapsed(i) >= qFe && (clearInterval(c), a.stop(i), o(new Error("Subscription resolution timeout")))
        }, this.pollingInterval)
      }).catch(() => !1)
    }, this.on = (r, i) => {
      this.events.on(r, i)
    }, this.once = (r, i) => {
      this.events.once(r, i)
    }, this.off = (r, i) => {
      this.events.off(r, i)
    }, this.removeListener = (r, i) => {
      this.events.removeListener(r, i)
    }, this.start = async () => {
      await this.onConnect()
    }, this.stop = async () => {
      await this.onDisconnect()
    }, this.restart = async () => {
      this.restartInProgress = !0, await this.restore(), await this.reset(), this.restartInProgress = !1
    }, this.relayer = t, this.logger = vn.generateChildLogger(n, this.name), this.clientId = ""
  }
  get context() {
    return vn.getLoggerContext(this.logger)
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.relayer.core.customStoragePrefix + "//" + this.name
  }
  get length() {
    return this.subscriptions.size
  }
  get ids() {
    return Array.from(this.subscriptions.keys())
  }
  get values() {
    return Array.from(this.subscriptions.values())
  }
  get topics() {
    return this.topicMap.topics
  }
  hasSubscription(t, n) {
    let r = !1;
    try {
      r = this.getSubscription(t).topic === n
    } catch {}
    return r
  }
  onEnable() {
    this.cached = [], this.initialized = !0
  }
  onDisable() {
    this.cached = this.values, this.subscriptions.clear(), this.topicMap.clear()
  }
  async unsubscribeByTopic(t, n) {
    const r = this.topicMap.get(t);
    await Promise.all(r.map(async i => await this.unsubscribeById(t, i, n)))
  }
  async unsubscribeById(t, n, r) {
    this.logger.debug("Unsubscribing Topic"), this.logger.trace({
      type: "method",
      method: "unsubscribe",
      params: {
        topic: t,
        id: n,
        opts: r
      }
    });
    try {
      const i = r9(r);
      await this.rpcUnsubscribe(t, n, i);
      const s = i1("USER_DISCONNECTED", `${this.name}, ${t}`);
      await this.onUnsubscribe(t, n, s), this.logger.debug("Successfully Unsubscribed Topic"), this.logger.trace({
        type: "method",
        method: "unsubscribe",
        params: {
          topic: t,
          id: n,
          opts: r
        }
      })
    } catch (i) {
      throw this.logger.debug("Failed to Unsubscribe Topic"), this.logger.error(i), i
    }
  }
  async rpcSubscribe(t, n) {
    const r = {
      method: Iw(n.protocol).subscribe,
      params: {
        topic: t
      }
    };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({
      type: "payload",
      direction: "outgoing",
      request: r
    });
    try {
      return await await S2(this.relayer.request(r).catch(i => this.logger.warn(i)), this.subscribeTimeout) ? n9(t + this.clientId) : null
    } catch {
      this.logger.debug("Outgoing Relay Subscribe Payload stalled"), this.relayer.events.emit($o.connection_stalled)
    }
    return null
  }
  async rpcBatchSubscribe(t) {
    if (!t.length) return;
    const n = t[0].relay,
      r = {
        method: Iw(n.protocol).batchSubscribe,
        params: {
          topics: t.map(i => i.topic)
        }
      };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({
      type: "payload",
      direction: "outgoing",
      request: r
    });
    try {
      return await await S2(this.relayer.request(r).catch(i => this.logger.warn(i)), this.subscribeTimeout)
    } catch {
      this.relayer.events.emit($o.connection_stalled)
    }
  }
  rpcUnsubscribe(t, n, r) {
    const i = {
      method: Iw(r.protocol).unsubscribe,
      params: {
        topic: t,
        id: n
      }
    };
    return this.logger.debug("Outgoing Relay Payload"), this.logger.trace({
      type: "payload",
      direction: "outgoing",
      request: i
    }), this.relayer.request(i)
  }
  onSubscribe(t, n) {
    this.setSubscription(t, A8(Vg({}, n), {
      id: t
    })), this.pending.delete(n.topic)
  }
  onBatchSubscribe(t) {
    t.length && t.forEach(n => {
      this.setSubscription(n.id, Vg({}, n)), this.pending.delete(n.topic)
    })
  }
  async onUnsubscribe(t, n, r) {
    this.events.removeAllListeners(n), this.hasSubscription(n, t) && this.deleteSubscription(n, r), await this.relayer.messages.del(t)
  }
  async setRelayerSubscriptions(t) {
    await this.relayer.core.storage.setItem(this.storageKey, t)
  }
  async getRelayerSubscriptions() {
    return await this.relayer.core.storage.getItem(this.storageKey)
  }
  setSubscription(t, n) {
    this.logger.debug("Setting subscription"), this.logger.trace({
      type: "method",
      method: "setSubscription",
      id: t,
      subscription: n
    }), this.addSubscription(t, n)
  }
  addSubscription(t, n) {
    this.subscriptions.set(t, Vg({}, n)), this.topicMap.set(n.topic, t), this.events.emit(zc.created, n)
  }
  getSubscription(t) {
    this.logger.debug("Getting subscription"), this.logger.trace({
      type: "method",
      method: "getSubscription",
      id: t
    });
    const n = this.subscriptions.get(t);
    if (!n) {
      const {
        message: r
      } = Hn("NO_MATCHING_KEY", `${this.name}: ${t}`);
      throw new Error(r)
    }
    return n
  }
  deleteSubscription(t, n) {
    this.logger.debug("Deleting subscription"), this.logger.trace({
      type: "method",
      method: "deleteSubscription",
      id: t,
      reason: n
    });
    const r = this.getSubscription(t);
    this.subscriptions.delete(t), this.topicMap.delete(r.topic, t), this.events.emit(zc.deleted, A8(Vg({}, r), {
      reason: n
    }))
  }
  async persist() {
    await this.setRelayerSubscriptions(this.values), this.events.emit(zc.sync)
  }
  async reset() {
    if (this.cached.length) {
      const t = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);
      for (let n = 0; n < t; n++) {
        const r = this.cached.splice(0, this.batchSubscribeTopicsLimit);
        await this.batchSubscribe(r)
      }
    }
    this.events.emit(zc.resubscribed)
  }
  async restore() {
    try {
      const t = await this.getRelayerSubscriptions();
      if (typeof t > "u" || !t.length) return;
      if (this.subscriptions.size) {
        const {
          message: n
        } = Hn("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(n), this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`), new Error(n)
      }
      this.cached = t, this.logger.debug(`Successfully Restored subscriptions for ${this.name}`), this.logger.trace({
        type: "method",
        method: "restore",
        subscriptions: this.values
      })
    } catch (t) {
      this.logger.debug(`Failed to Restore subscriptions for ${this.name}`), this.logger.error(t)
    }
  }
  async batchSubscribe(t) {
    if (!t.length) return;
    const n = await this.rpcBatchSubscribe(t);
    yLe(n) && this.onBatchSubscribe(n.map((r, i) => A8(Vg({}, t[i]), {
      id: r
    })))
  }
  async onConnect() {
    await this.restart(), this.onEnable()
  }
  onDisconnect() {
    this.onDisable()
  }
  async checkPending() {
    if (!this.initialized || !this.relayer.connected) return;
    const t = [];
    this.pending.forEach(n => {
      t.push(n)
    }), await this.batchSubscribe(t)
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(Hm.HEARTBEAT_EVENTS.pulse, async () => {
      await this.checkPending()
    }), this.events.on(zc.created, async t => {
      const n = zc.created;
      this.logger.info(`Emitting ${n}`), this.logger.debug({
        type: "event",
        event: n,
        data: t
      }), await this.persist()
    }), this.events.on(zc.deleted, async t => {
      const n = zc.deleted;
      this.logger.info(`Emitting ${n}`), this.logger.debug({
        type: "event",
        event: n,
        data: t
      }), await this.persist()
    })
  }
  isInitialized() {
    if (!this.initialized) {
      const {
        message: t
      } = Hn("NOT_INITIALIZED", this.name);
      throw new Error(t)
    }
  }
  async restartToComplete() {
    this.restartInProgress && await new Promise(t => {
      const n = setInterval(() => {
        this.restartInProgress || (clearInterval(n), t())
      }, this.pollingInterval)
    })
  }
}
var hje = Object.defineProperty,
  GL = Object.getOwnPropertySymbols,
  pje = Object.prototype.hasOwnProperty,
  mje = Object.prototype.propertyIsEnumerable,
  KL = (e, t, n) => t in e ? hje(e, t, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: n
  }) : e[t] = n,
  gje = (e, t) => {
    for (var n in t || (t = {})) pje.call(t, n) && KL(e, n, t[n]);
    if (GL)
      for (var n of GL(t)) mje.call(t, n) && KL(e, n, t[n]);
    return e
  };
let yje = class extends d$e {
  constructor(t) {
    super(t), this.protocol = "wc", this.version = 2, this.events = new si.EventEmitter, this.name = LFe, this.transportExplicitlyClosed = !1, this.initialized = !1, this.connectionAttemptInProgress = !1, this.connectionStatusPollingInterval = 20, this.staleConnectionErrors = ["socket hang up", "socket stalled", "interrupted"], this.hasExperiencedNetworkDisruption = !1, this.requestsInFlight = new Map, this.heartBeatTimeout = it.toMiliseconds(it.THIRTY_SECONDS + it.ONE_SECOND), this.request = async n => {
      var r, i;
      this.logger.debug("Publishing Request Payload");
      const s = n.id || Bf().toString();
      await this.toEstablishConnection();
      try {
        const o = this.provider.request(n);
        this.requestsInFlight.set(s, {
          promise: o,
          request: n
        }), this.logger.trace({
          id: s,
          method: n.method,
          topic: (r = n.params) == null ? void 0 : r.topic
        }, "relayer.request - attempt to publish...");
        const a = await new Promise(async (c, l) => {
          const u = () => {
            l(new Error(`relayer.request - publish interrupted, id: ${s}`))
          };
          this.provider.on(ca.disconnect, u);
          const f = await o;
          this.provider.off(ca.disconnect, u), c(f)
        });
        return this.logger.trace({
          id: s,
          method: n.method,
          topic: (i = n.params) == null ? void 0 : i.topic
        }, "relayer.request - published"), a
      } catch (o) {
        throw this.logger.debug(`Failed to Publish Request: ${s}`), o
      } finally {
        this.requestsInFlight.delete(s)
      }
    }, this.resetPingTimeout = () => {
      if (E2()) try {
        clearTimeout(this.pingTimeout), this.pingTimeout = setTimeout(() => {
          var n, r, i;
          (i = (r = (n = this.provider) == null ? void 0 : n.connection) == null ? void 0 : r.socket) == null || i.terminate()
        }, this.heartBeatTimeout)
      } catch (n) {
        this.logger.warn(n)
      }
    }, this.onPayloadHandler = n => {
      this.onProviderPayload(n), this.resetPingTimeout()
    }, this.onConnectHandler = () => {
      this.startPingTimeout(), this.events.emit($o.connect)
    }, this.onDisconnectHandler = () => {
      this.onProviderDisconnect()
    }, this.onProviderErrorHandler = n => {
      this.logger.error(n), this.events.emit($o.error, n), this.logger.info("Fatal socket error received, closing transport"), this.transportClose()
    }, this.registerProviderListeners = () => {
      this.provider.on(ca.payload, this.onPayloadHandler), this.provider.on(ca.connect, this.onConnectHandler), this.provider.on(ca.disconnect, this.onDisconnectHandler), this.provider.on(ca.error, this.onProviderErrorHandler)
    }, this.core = t.core, this.logger = typeof t.logger < "u" && typeof t.logger != "string" ? vn.generateChildLogger(t.logger, this.name) : vn.pino(vn.getDefaultLoggerOptions({
      level: t.logger || $Fe
    })), this.messages = new ije(this.logger, t.core), this.subscriber = new fje(this, this.logger), this.publisher = new sje(this, this.logger), this.relayUrl = (t == null ? void 0 : t.relayUrl) || rJ, this.projectId = t.projectId, this.bundleId = G$e(), this.provider = {}
  }
  async init() {
    this.logger.trace("Initialized"), this.registerEventListeners(), await this.createProvider(), await Promise.all([this.messages.init(), this.subscriber.init()]);
    try {
      await this.transportOpen()
    } catch {
      this.logger.warn(`Connection via ${this.relayUrl} failed, attempting to connect via failover domain ${VL}...`), await this.restartTransport(VL)
    }
    this.initialized = !0, setTimeout(async () => {
      this.subscriber.topics.length === 0 && this.subscriber.pending.size === 0 && (this.logger.info("No topics subscribed to after init, closing transport"), await this.transportClose(), this.transportExplicitlyClosed = !1)
    }, UFe)
  }
  get context() {
    return vn.getLoggerContext(this.logger)
  }
  get connected() {
    var t, n, r;
    return ((r = (n = (t = this.provider) == null ? void 0 : t.connection) == null ? void 0 : n.socket) == null ? void 0 : r.readyState) === 1
  }
  get connecting() {
    var t, n, r;
    return ((r = (n = (t = this.provider) == null ? void 0 : t.connection) == null ? void 0 : n.socket) == null ? void 0 : r.readyState) === 0
  }
  async publish(t, n, r) {
    this.isInitialized(), await this.publisher.publish(t, n, r), await this.recordMessageEvent({
      topic: t,
      message: n,
      publishedAt: Date.now()
    })
  }
  async subscribe(t, n) {
    var r;
    this.isInitialized();
    let i = ((r = this.subscriber.topicMap.get(t)) == null ? void 0 : r[0]) || "",
      s;
    const o = a => {
      a.topic === t && (this.subscriber.off(zc.created, o), s())
    };
    return await Promise.all([new Promise(a => {
      s = a, this.subscriber.on(zc.created, o)
    }), new Promise(async a => {
      i = await this.subscriber.subscribe(t, n) || i, a()
    })]), i
  }
  async unsubscribe(t, n) {
    this.isInitialized(), await this.subscriber.unsubscribe(t, n)
  }
  on(t, n) {
    this.events.on(t, n)
  }
  once(t, n) {
    this.events.once(t, n)
  }
  off(t, n) {
    this.events.off(t, n)
  }
  removeListener(t, n) {
    this.events.removeListener(t, n)
  }
  async transportDisconnect() {
    if (!this.hasExperiencedNetworkDisruption && this.connected && this.requestsInFlight.size > 0) try {
      await Promise.all(Array.from(this.requestsInFlight.values()).map(t => t.promise))
    } catch (t) {
      this.logger.warn(t)
    }
    this.hasExperiencedNetworkDisruption || this.connected ? await S2(this.provider.disconnect(), 2e3, "provider.disconnect()").catch(() => this.onProviderDisconnect()) : this.onProviderDisconnect()
  }
  async transportClose() {
    this.transportExplicitlyClosed = !0, await this.transportDisconnect()
  }
  async transportOpen(t) {
    await this.confirmOnlineStateOrThrow(), t && t !== this.relayUrl && (this.relayUrl = t, await this.transportDisconnect(), await this.createProvider()), this.connectionAttemptInProgress = !0, this.transportExplicitlyClosed = !1;
    try {
      await new Promise(async (n, r) => {
        const i = () => {
          this.provider.off(ca.disconnect, i), r(new Error("Connection interrupted while trying to subscribe"))
        };
        this.provider.on(ca.disconnect, i), await S2(this.provider.connect(), it.toMiliseconds(it.ONE_MINUTE), `Socket stalled when trying to connect to ${this.relayUrl}`).catch(s => {
          r(s)
        }), await this.subscriber.start(), this.hasExperiencedNetworkDisruption = !1, n()
      })
    } catch (n) {
      this.logger.error(n);
      const r = n;
      if (!this.isConnectionStalled(r.message)) throw n
    } finally {
      this.connectionAttemptInProgress = !1
    }
  }
  async restartTransport(t) {
    this.connectionAttemptInProgress || (this.relayUrl = t || this.relayUrl, await this.confirmOnlineStateOrThrow(), await this.transportClose(), await this.createProvider(), await this.transportOpen())
  }
  async confirmOnlineStateOrThrow() {
    if (!await _L()) throw new Error("No internet connection detected. Please restart your network and try again.")
  }
  startPingTimeout() {
    var t, n, r, i, s;
    if (E2()) try {
      (n = (t = this.provider) == null ? void 0 : t.connection) != null && n.socket && ((s = (i = (r = this.provider) == null ? void 0 : r.connection) == null ? void 0 : i.socket) == null || s.once("ping", () => {
        this.resetPingTimeout()
      })), this.resetPingTimeout()
    } catch (o) {
      this.logger.warn(o)
    }
  }
  isConnectionStalled(t) {
    return this.staleConnectionErrors.some(n => t.includes(n))
  }
  async createProvider() {
    this.provider.connection && this.unregisterProviderListeners();
    const t = await this.core.crypto.signJWT(this.relayUrl);
    this.provider = new Au(new GLe(X$e({
      sdkVersion: jFe,
      protocol: this.protocol,
      version: this.version,
      relayUrl: this.relayUrl,
      projectId: this.projectId,
      auth: t,
      useOnCloseEvent: !0,
      bundleId: this.bundleId
    }))), this.registerProviderListeners()
  }
  async recordMessageEvent(t) {
    const {
      topic: n,
      message: r
    } = t;
    await this.messages.set(n, r)
  }
  async shouldIgnoreMessageEvent(t) {
    const {
      topic: n,
      message: r
    } = t;
    if (!r || r.length === 0) return this.logger.debug(`Ignoring invalid/empty message: ${r}`), !0;
    if (!await this.subscriber.isSubscribed(n)) return this.logger.debug(`Ignoring message for non-subscribed topic ${n}`), !0;
    const i = this.messages.has(n, r);
    return i && this.logger.debug(`Ignoring duplicate message: ${r}`), i
  }
  async onProviderPayload(t) {
    if (this.logger.debug("Incoming Relay Payload"), this.logger.trace({
        type: "payload",
        direction: "incoming",
        payload: t
      }), w_(t)) {
      if (!t.method.endsWith(BFe)) return;
      const n = t.params,
        {
          topic: r,
          message: i,
          publishedAt: s
        } = n.data,
        o = {
          topic: r,
          message: i,
          publishedAt: s
        };
      this.logger.debug("Emitting Relayer Payload"), this.logger.trace(gje({
        type: "event",
        event: n.id
      }, o)), this.events.emit(n.id, o), await this.acknowledgePayload(t), await this.onMessageEvent(o)
    } else lE(t) && this.events.emit($o.message_ack, t)
  }
  async onMessageEvent(t) {
    await this.shouldIgnoreMessageEvent(t) || (this.events.emit($o.message, t), await this.recordMessageEvent(t))
  }
  async acknowledgePayload(t) {
    const n = aE(t.id, !0);
    await this.provider.connection.send(n)
  }
  unregisterProviderListeners() {
    this.provider.off(ca.payload, this.onPayloadHandler), this.provider.off(ca.connect, this.onConnectHandler), this.provider.off(ca.disconnect, this.onDisconnectHandler), this.provider.off(ca.error, this.onProviderErrorHandler)
  }
  async registerEventListeners() {
    let t = await _L();
    CLe(async n => {
      t !== n && (t = n, n ? await this.restartTransport().catch(r => this.logger.error(r)) : (this.hasExperiencedNetworkDisruption = !0, await this.transportDisconnect(), this.transportExplicitlyClosed = !1))
    })
  }
  async onProviderDisconnect() {
    await this.subscriber.stop(), this.events.emit($o.disconnect), this.connectionAttemptInProgress = !1, !this.transportExplicitlyClosed && setTimeout(async () => {
      await this.transportOpen().catch(t => this.logger.error(t))
    }, it.toMiliseconds(FFe))
  }
  isInitialized() {
    if (!this.initialized) {
      const {
        message: t
      } = Hn("NOT_INITIALIZED", this.name);
      throw new Error(t)
    }
  }
  async toEstablishConnection() {
    await this.confirmOnlineStateOrThrow(), !this.connected && (this.connectionAttemptInProgress && await new Promise(t => {
      const n = setInterval(() => {
        this.connected && (clearInterval(n), t())
      }, this.connectionStatusPollingInterval)
    }), await this.transportOpen())
  }
};
var vje = Object.defineProperty,
  QL = Object.getOwnPropertySymbols,
  bje = Object.prototype.hasOwnProperty,
  wje = Object.prototype.propertyIsEnumerable,
  YL = (e, t, n) => t in e ? vje(e, t, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: n
  }) : e[t] = n,
  JL = (e, t) => {
    for (var n in t || (t = {})) bje.call(t, n) && YL(e, n, t[n]);
    if (QL)
      for (var n of QL(t)) wje.call(t, n) && YL(e, n, t[n]);
    return e
  };
let dE = class extends f$e {
  constructor(t, n, r, i = Dd, s = void 0) {
    super(t, n, r, i), this.core = t, this.logger = n, this.name = r, this.map = new Map, this.version = zFe, this.cached = [], this.initialized = !1, this.storagePrefix = Dd, this.recentlyDeleted = [], this.recentlyDeletedLimit = 200, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach(o => {
        this.getKey && o !== null && !px(o) ? this.map.set(this.getKey(o), o) : bLe(o) ? this.map.set(o.id, o) : wLe(o) && this.map.set(o.topic, o)
      }), this.cached = [], this.initialized = !0)
    }, this.set = async (o, a) => {
      this.isInitialized(), this.map.has(o) ? await this.update(o, a) : (this.logger.debug("Setting value"), this.logger.trace({
        type: "method",
        method: "set",
        key: o,
        value: a
      }), this.map.set(o, a), await this.persist())
    }, this.get = o => (this.isInitialized(), this.logger.debug("Getting value"), this.logger.trace({
      type: "method",
      method: "get",
      key: o
    }), this.getData(o)), this.getAll = o => (this.isInitialized(), o ? this.values.filter(a => Object.keys(o).every(c => QLe(a[c], o[c]))) : this.values), this.update = async (o, a) => {
      this.isInitialized(), this.logger.debug("Updating value"), this.logger.trace({
        type: "method",
        method: "update",
        key: o,
        update: a
      });
      const c = JL(JL({}, this.getData(o)), a);
      this.map.set(o, c), await this.persist()
    }, this.delete = async (o, a) => {
      this.isInitialized(), this.map.has(o) && (this.logger.debug("Deleting value"), this.logger.trace({
        type: "method",
        method: "delete",
        key: o,
        reason: a
      }), this.map.delete(o), this.addToRecentlyDeleted(o), await this.persist())
    }, this.logger = vn.generateChildLogger(n, this.name), this.storagePrefix = i, this.getKey = s
  }
  get context() {
    return vn.getLoggerContext(this.logger)
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name
  }
  get length() {
    return this.map.size
  }
  get keys() {
    return Array.from(this.map.keys())
  }
  get values() {
    return Array.from(this.map.values())
  }
  addToRecentlyDeleted(t) {
    this.recentlyDeleted.push(t), this.recentlyDeleted.length >= this.recentlyDeletedLimit && this.recentlyDeleted.splice(0, this.recentlyDeletedLimit / 2)
  }
  async setDataStore(t) {
    await this.core.storage.setItem(this.storageKey, t)
  }
  async getDataStore() {
    return await this.core.storage.getItem(this.storageKey)
  }
  getData(t) {
    const n = this.map.get(t);
    if (!n) {
      if (this.recentlyDeleted.includes(t)) {
        const {
          message: i
        } = Hn("MISSING_OR_INVALID", `Record was recently deleted - ${this.name}: ${t}`);
        throw this.logger.error(i), new Error(i)
      }
      const {
        message: r
      } = Hn("NO_MATCHING_KEY", `${this.name}: ${t}`);
      throw this.logger.error(r), new Error(r)
    }
    return n
  }
  async persist() {
    await this.setDataStore(this.values)
  }
  async restore() {
    try {
      const t = await this.getDataStore();
      if (typeof t > "u" || !t.length) return;
      if (this.map.size) {
        const {
          message: n
        } = Hn("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(n), new Error(n)
      }
      this.cached = t, this.logger.debug(`Successfully Restored value for ${this.name}`), this.logger.trace({
        type: "method",
        method: "restore",
        value: this.values
      })
    } catch (t) {
      this.logger.debug(`Failed to Restore value for ${this.name}`), this.logger.error(t)
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const {
        message: t
      } = Hn("NOT_INITIALIZED", this.name);
      throw new Error(t)
    }
  }
};
class xje {
  constructor(t, n) {
    this.core = t, this.logger = n, this.name = GFe, this.version = KFe, this.events = new Wk, this.initialized = !1, this.storagePrefix = Dd, this.ignoredPayloadTypes = [Vm], this.registeredMethods = [], this.init = async () => {
      this.initialized || (await this.pairings.init(), await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.initialized = !0, this.logger.trace("Initialized"))
    }, this.register = ({
      methods: r
    }) => {
      this.isInitialized(), this.registeredMethods = [...new Set([...this.registeredMethods, ...r])]
    }, this.create = async () => {
      this.isInitialized();
      const r = t9(),
        i = await this.core.crypto.setSymKey(r),
        s = _w(it.FIVE_MINUTES),
        o = {
          protocol: nJ
        },
        a = {
          topic: i,
          expiry: s,
          relay: o,
          active: !1
        },
        c = pLe({
          protocol: this.core.protocol,
          version: this.core.version,
          topic: i,
          symKey: r,
          relay: o,
          expiryTimestamp: s
        });
      return await this.pairings.set(i, a), await this.core.relayer.subscribe(i), this.core.expirer.set(i, s), {
        topic: i,
        uri: c
      }
    }, this.pair = async r => {
      this.isInitialized(), this.isValidPair(r);
      const {
        topic: i,
        symKey: s,
        relay: o,
        expiryTimestamp: a
      } = kL(r.uri);
      let c;
      if (this.pairings.keys.includes(i) && (c = this.pairings.get(i), c.active)) throw new Error(`Pairing already exists: ${i}. Please try again with a new connection URI.`);
      const l = a || _w(it.FIVE_MINUTES),
        u = {
          topic: i,
          relay: o,
          expiry: l,
          active: !1
        };
      return await this.pairings.set(i, u), this.core.expirer.set(i, l), r.activatePairing && await this.activate({
        topic: i
      }), this.events.emit(Z0.create, u), this.core.crypto.keychain.has(i) || await this.core.crypto.setSymKey(s, i), await this.core.relayer.subscribe(i, {
        relay: o
      }), u
    }, this.activate = async ({
      topic: r
    }) => {
      this.isInitialized();
      const i = _w(it.THIRTY_DAYS);
      await this.pairings.update(r, {
        active: !0,
        expiry: i
      }), this.core.expirer.set(r, i)
    }, this.ping = async r => {
      this.isInitialized(), await this.isValidPing(r);
      const {
        topic: i
      } = r;
      if (this.pairings.keys.includes(i)) {
        const s = await this.sendRequest(i, "wc_pairingPing", {}),
          {
            done: o,
            resolve: a,
            reject: c
          } = Z$e();
        this.events.once(x8("pairing_ping", s), ({
          error: l
        }) => {
          l ? c(l) : a()
        }), await o()
      }
    }, this.updateExpiry = async ({
      topic: r,
      expiry: i
    }) => {
      this.isInitialized(), await this.pairings.update(r, {
        expiry: i
      })
    }, this.updateMetadata = async ({
      topic: r,
      metadata: i
    }) => {
      this.isInitialized(), await this.pairings.update(r, {
        peerMetadata: i
      })
    }, this.getPairings = () => (this.isInitialized(), this.pairings.values), this.disconnect = async r => {
      this.isInitialized(), await this.isValidDisconnect(r);
      const {
        topic: i
      } = r;
      this.pairings.keys.includes(i) && (await this.sendRequest(i, "wc_pairingDelete", i1("USER_DISCONNECTED")), await this.deletePairing(i))
    }, this.sendRequest = async (r, i, s) => {
      const o = vp(i, s),
        a = await this.core.crypto.encode(r, o),
        c = Hg[i].req;
      return this.core.history.set(r, o), this.core.relayer.publish(r, a, c), o.id
    }, this.sendResult = async (r, i, s) => {
      const o = aE(r, s),
        a = await this.core.crypto.encode(i, o),
        c = await this.core.history.get(i, r),
        l = Hg[c.request.method].res;
      await this.core.relayer.publish(i, a, l), await this.core.history.resolve(o)
    }, this.sendError = async (r, i, s) => {
      const o = cE(r, s),
        a = await this.core.crypto.encode(i, o),
        c = await this.core.history.get(i, r),
        l = Hg[c.request.method] ? Hg[c.request.method].res : Hg.unregistered_method.res;
      await this.core.relayer.publish(i, a, l), await this.core.history.resolve(o)
    }, this.deletePairing = async (r, i) => {
      await this.core.relayer.unsubscribe(r), await Promise.all([this.pairings.delete(r, i1("USER_DISCONNECTED")), this.core.crypto.deleteSymKey(r), i ? Promise.resolve() : this.core.expirer.del(r)])
    }, this.cleanup = async () => {
      const r = this.pairings.getAll().filter(i => CL(i.expiry));
      await Promise.all(r.map(i => this.deletePairing(i.topic)))
    }, this.onRelayEventRequest = r => {
      const {
        topic: i,
        payload: s
      } = r;
      switch (s.method) {
        case "wc_pairingPing":
          return this.onPairingPingRequest(i, s);
        case "wc_pairingDelete":
          return this.onPairingDeleteRequest(i, s);
        default:
          return this.onUnknownRpcMethodRequest(i, s)
      }
    }, this.onRelayEventResponse = async r => {
      const {
        topic: i,
        payload: s
      } = r, o = (await this.core.history.get(i, s.id)).request.method;
      switch (o) {
        case "wc_pairingPing":
          return this.onPairingPingResponse(i, s);
        default:
          return this.onUnknownRpcMethodResponse(o)
      }
    }, this.onPairingPingRequest = async (r, i) => {
      const {
        id: s
      } = i;
      try {
        this.isValidPing({
          topic: r
        }), await this.sendResult(s, r, !0), this.events.emit(Z0.ping, {
          id: s,
          topic: r
        })
      } catch (o) {
        await this.sendError(s, r, o), this.logger.error(o)
      }
    }, this.onPairingPingResponse = (r, i) => {
      const {
        id: s
      } = i;
      setTimeout(() => {
        Kl(i) ? this.events.emit(x8("pairing_ping", s), {}) : oc(i) && this.events.emit(x8("pairing_ping", s), {
          error: i.error
        })
      }, 500)
    }, this.onPairingDeleteRequest = async (r, i) => {
      const {
        id: s
      } = i;
      try {
        this.isValidDisconnect({
          topic: r
        }), await this.deletePairing(r), this.events.emit(Z0.delete, {
          id: s,
          topic: r
        })
      } catch (o) {
        await this.sendError(s, r, o), this.logger.error(o)
      }
    }, this.onUnknownRpcMethodRequest = async (r, i) => {
      const {
        id: s,
        method: o
      } = i;
      try {
        if (this.registeredMethods.includes(o)) return;
        const a = i1("WC_METHOD_UNSUPPORTED", o);
        await this.sendError(s, r, a), this.logger.error(a)
      } catch (a) {
        await this.sendError(s, r, a), this.logger.error(a)
      }
    }, this.onUnknownRpcMethodResponse = r => {
      this.registeredMethods.includes(r) || this.logger.error(i1("WC_METHOD_UNSUPPORTED", r))
    }, this.isValidPair = r => {
      var i;
      if (!E8(r)) {
        const {
          message: o
        } = Hn("MISSING_OR_INVALID", `pair() params: ${r}`);
        throw new Error(o)
      }
      if (!vLe(r.uri)) {
        const {
          message: o
        } = Hn("MISSING_OR_INVALID", `pair() uri: ${r.uri}`);
        throw new Error(o)
      }
      const s = kL(r.uri);
      if (!((i = s == null ? void 0 : s.relay) != null && i.protocol)) {
        const {
          message: o
        } = Hn("MISSING_OR_INVALID", "pair() uri#relay-protocol");
        throw new Error(o)
      }
      if (!(s != null && s.symKey)) {
        const {
          message: o
        } = Hn("MISSING_OR_INVALID", "pair() uri#symKey");
        throw new Error(o)
      }
      if (s != null && s.expiryTimestamp && it.toMiliseconds(s == null ? void 0 : s.expiryTimestamp) < Date.now()) {
        const {
          message: o
        } = Hn("EXPIRED", "pair() URI has expired. Please try again with a new connection URI.");
        throw new Error(o)
      }
    }, this.isValidPing = async r => {
      if (!E8(r)) {
        const {
          message: s
        } = Hn("MISSING_OR_INVALID", `ping() params: ${r}`);
        throw new Error(s)
      }
      const {
        topic: i
      } = r;
      await this.isValidPairingTopic(i)
    }, this.isValidDisconnect = async r => {
      if (!E8(r)) {
        const {
          message: s
        } = Hn("MISSING_OR_INVALID", `disconnect() params: ${r}`);
        throw new Error(s)
      }
      const {
        topic: i
      } = r;
      await this.isValidPairingTopic(i)
    }, this.isValidPairingTopic = async r => {
      if (!LY(r, !1)) {
        const {
          message: i
        } = Hn("MISSING_OR_INVALID", `pairing topic should be a string: ${r}`);
        throw new Error(i)
      }
      if (!this.pairings.keys.includes(r)) {
        const {
          message: i
        } = Hn("NO_MATCHING_KEY", `pairing topic doesn't exist: ${r}`);
        throw new Error(i)
      }
      if (CL(this.pairings.get(r).expiry)) {
        await this.deletePairing(r);
        const {
          message: i
        } = Hn("EXPIRED", `pairing topic: ${r}`);
        throw new Error(i)
      }
    }, this.core = t, this.logger = vn.generateChildLogger(n, this.name), this.pairings = new dE(this.core, this.logger, this.name, this.storagePrefix)
  }
  get context() {
    return vn.getLoggerContext(this.logger)
  }
  isInitialized() {
    if (!this.initialized) {
      const {
        message: t
      } = Hn("NOT_INITIALIZED", this.name);
      throw new Error(t)
    }
  }
  registerRelayerEvents() {
    this.core.relayer.on($o.message, async t => {
      const {
        topic: n,
        message: r
      } = t;
      if (!this.pairings.keys.includes(n) || this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(r))) return;
      const i = await this.core.crypto.decode(n, r);
      try {
        w_(i) ? (this.core.history.set(n, i), this.onRelayEventRequest({
          topic: n,
          payload: i
        })) : lE(i) && (await this.core.history.resolve(i), await this.onRelayEventResponse({
          topic: n,
          payload: i
        }), this.core.history.delete(n, i.id))
      } catch (s) {
        this.logger.error(s)
      }
    })
  }
  registerExpirerEvents() {
    this.core.expirer.on(fa.expired, async t => {
      const {
        topic: n
      } = nLe(t.target);
      n && this.pairings.keys.includes(n) && (await this.deletePairing(n, !0), this.events.emit(Z0.expire, {
        topic: n
      }))
    })
  }
}
let Eje = class extends c$e {
    constructor(t, n) {
      super(t, n), this.core = t, this.logger = n, this.records = new Map, this.events = new si.EventEmitter, this.name = QFe, this.version = YFe, this.cached = [], this.initialized = !1, this.storagePrefix = Dd, this.init = async () => {
        this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach(r => this.records.set(r.id, r)), this.cached = [], this.registerEventListeners(), this.initialized = !0)
      }, this.set = (r, i, s) => {
        if (this.isInitialized(), this.logger.debug("Setting JSON-RPC request history record"), this.logger.trace({
            type: "method",
            method: "set",
            topic: r,
            request: i,
            chainId: s
          }), this.records.has(i.id)) return;
        const o = {
          id: i.id,
          topic: r,
          request: {
            method: i.method,
            params: i.params || null
          },
          chainId: s,
          expiry: _w(it.THIRTY_DAYS)
        };
        this.records.set(o.id, o), this.events.emit(Fc.created, o)
      }, this.resolve = async r => {
        if (this.isInitialized(), this.logger.debug("Updating JSON-RPC response history record"), this.logger.trace({
            type: "method",
            method: "update",
            response: r
          }), !this.records.has(r.id)) return;
        const i = await this.getRecord(r.id);
        typeof i.response > "u" && (i.response = oc(r) ? {
          error: r.error
        } : {
          result: r.result
        }, this.records.set(i.id, i), this.events.emit(Fc.updated, i))
      }, this.get = async (r, i) => (this.isInitialized(), this.logger.debug("Getting record"), this.logger.trace({
        type: "method",
        method: "get",
        topic: r,
        id: i
      }), await this.getRecord(i)), this.delete = (r, i) => {
        this.isInitialized(), this.logger.debug("Deleting record"), this.logger.trace({
          type: "method",
          method: "delete",
          id: i
        }), this.values.forEach(s => {
          if (s.topic === r) {
            if (typeof i < "u" && s.id !== i) return;
            this.records.delete(s.id), this.events.emit(Fc.deleted, s)
          }
        })
      }, this.exists = async (r, i) => (this.isInitialized(), this.records.has(i) ? (await this.getRecord(i)).topic === r : !1), this.on = (r, i) => {
        this.events.on(r, i)
      }, this.once = (r, i) => {
        this.events.once(r, i)
      }, this.off = (r, i) => {
        this.events.off(r, i)
      }, this.removeListener = (r, i) => {
        this.events.removeListener(r, i)
      }, this.logger = vn.generateChildLogger(n, this.name)
    }
    get context() {
      return vn.getLoggerContext(this.logger)
    }
    get storageKey() {
      return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name
    }
    get size() {
      return this.records.size
    }
    get keys() {
      return Array.from(this.records.keys())
    }
    get values() {
      return Array.from(this.records.values())
    }
    get pending() {
      const t = [];
      return this.values.forEach(n => {
        if (typeof n.response < "u") return;
        const r = {
          topic: n.topic,
          request: vp(n.request.method, n.request.params, n.id),
          chainId: n.chainId
        };
        return t.push(r)
      }), t
    }
    async setJsonRpcRecords(t) {
      await this.core.storage.setItem(this.storageKey, t)
    }
    async getJsonRpcRecords() {
      return await this.core.storage.getItem(this.storageKey)
    }
    getRecord(t) {
      this.isInitialized();
      const n = this.records.get(t);
      if (!n) {
        const {
          message: r
        } = Hn("NO_MATCHING_KEY", `${this.name}: ${t}`);
        throw new Error(r)
      }
      return n
    }
    async persist() {
      await this.setJsonRpcRecords(this.values), this.events.emit(Fc.sync)
    }
    async restore() {
      try {
        const t = await this.getJsonRpcRecords();
        if (typeof t > "u" || !t.length) return;
        if (this.records.size) {
          const {
            message: n
          } = Hn("RESTORE_WILL_OVERRIDE", this.name);
          throw this.logger.error(n), new Error(n)
        }
        this.cached = t, this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({
          type: "method",
          method: "restore",
          records: this.values
        })
      } catch (t) {
        this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(t)
      }
    }
    registerEventListeners() {
      this.events.on(Fc.created, t => {
        const n = Fc.created;
        this.logger.info(`Emitting ${n}`), this.logger.debug({
          type: "event",
          event: n,
          record: t
        }), this.persist()
      }), this.events.on(Fc.updated, t => {
        const n = Fc.updated;
        this.logger.info(`Emitting ${n}`), this.logger.debug({
          type: "event",
          event: n,
          record: t
        }), this.persist()
      }), this.events.on(Fc.deleted, t => {
        const n = Fc.deleted;
        this.logger.info(`Emitting ${n}`), this.logger.debug({
          type: "event",
          event: n,
          record: t
        }), this.persist()
      }), this.core.heartbeat.on(Hm.HEARTBEAT_EVENTS.pulse, () => {
        this.cleanup()
      })
    }
    cleanup() {
      try {
        this.records.forEach(t => {
          it.toMiliseconds(t.expiry || 0) - Date.now() <= 0 && (this.logger.info(`Deleting expired history log: ${t.id}`), this.delete(t.topic, t.id))
        })
      } catch (t) {
        this.logger.warn(t)
      }
    }
    isInitialized() {
      if (!this.initialized) {
        const {
          message: t
        } = Hn("NOT_INITIALIZED", this.name);
        throw new Error(t)
      }
    }
  },
  Sje = class extends p$e {
    constructor(t, n) {
      super(t, n), this.core = t, this.logger = n, this.expirations = new Map, this.events = new si.EventEmitter, this.name = JFe, this.version = XFe, this.cached = [], this.initialized = !1, this.storagePrefix = Dd, this.init = async () => {
        this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach(r => this.expirations.set(r.target, r)), this.cached = [], this.registerEventListeners(), this.initialized = !0)
      }, this.has = r => {
        try {
          const i = this.formatTarget(r);
          return typeof this.getExpiration(i) < "u"
        } catch {
          return !1
        }
      }, this.set = (r, i) => {
        this.isInitialized();
        const s = this.formatTarget(r),
          o = {
            target: s,
            expiry: i
          };
        this.expirations.set(s, o), this.checkExpiry(s, o), this.events.emit(fa.created, {
          target: s,
          expiration: o
        })
      }, this.get = r => {
        this.isInitialized();
        const i = this.formatTarget(r);
        return this.getExpiration(i)
      }, this.del = r => {
        if (this.isInitialized(), this.has(r)) {
          const i = this.formatTarget(r),
            s = this.getExpiration(i);
          this.expirations.delete(i), this.events.emit(fa.deleted, {
            target: i,
            expiration: s
          })
        }
      }, this.on = (r, i) => {
        this.events.on(r, i)
      }, this.once = (r, i) => {
        this.events.once(r, i)
      }, this.off = (r, i) => {
        this.events.off(r, i)
      }, this.removeListener = (r, i) => {
        this.events.removeListener(r, i)
      }, this.logger = vn.generateChildLogger(n, this.name)
    }
    get context() {
      return vn.getLoggerContext(this.logger)
    }
    get storageKey() {
      return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name
    }
    get length() {
      return this.expirations.size
    }
    get keys() {
      return Array.from(this.expirations.keys())
    }
    get values() {
      return Array.from(this.expirations.values())
    }
    formatTarget(t) {
      if (typeof t == "string") return eLe(t);
      if (typeof t == "number") return tLe(t);
      const {
        message: n
      } = Hn("UNKNOWN_TYPE", `Target type: ${typeof t}`);
      throw new Error(n)
    }
    async setExpirations(t) {
      await this.core.storage.setItem(this.storageKey, t)
    }
    async getExpirations() {
      return await this.core.storage.getItem(this.storageKey)
    }
    async persist() {
      await this.setExpirations(this.values), this.events.emit(fa.sync)
    }
    async restore() {
      try {
        const t = await this.getExpirations();
        if (typeof t > "u" || !t.length) return;
        if (this.expirations.size) {
          const {
            message: n
          } = Hn("RESTORE_WILL_OVERRIDE", this.name);
          throw this.logger.error(n), new Error(n)
        }
        this.cached = t, this.logger.debug(`Successfully Restored expirations for ${this.name}`), this.logger.trace({
          type: "method",
          method: "restore",
          expirations: this.values
        })
      } catch (t) {
        this.logger.debug(`Failed to Restore expirations for ${this.name}`), this.logger.error(t)
      }
    }
    getExpiration(t) {
      const n = this.expirations.get(t);
      if (!n) {
        const {
          message: r
        } = Hn("NO_MATCHING_KEY", `${this.name}: ${t}`);
        throw this.logger.warn(r), new Error(r)
      }
      return n
    }
    checkExpiry(t, n) {
      const {
        expiry: r
      } = n;
      it.toMiliseconds(r) - Date.now() <= 0 && this.expire(t, n)
    }
    expire(t, n) {
      this.expirations.delete(t), this.events.emit(fa.expired, {
        target: t,
        expiration: n
      })
    }
    checkExpirations() {
      this.core.relayer.connected && this.expirations.forEach((t, n) => this.checkExpiry(n, t))
    }
    registerEventListeners() {
      this.core.heartbeat.on(Hm.HEARTBEAT_EVENTS.pulse, () => this.checkExpirations()), this.events.on(fa.created, t => {
        const n = fa.created;
        this.logger.info(`Emitting ${n}`), this.logger.debug({
          type: "event",
          event: n,
          data: t
        }), this.persist()
      }), this.events.on(fa.expired, t => {
        const n = fa.expired;
        this.logger.info(`Emitting ${n}`), this.logger.debug({
          type: "event",
          event: n,
          data: t
        }), this.persist()
      }), this.events.on(fa.deleted, t => {
        const n = fa.deleted;
        this.logger.info(`Emitting ${n}`), this.logger.debug({
          type: "event",
          event: n,
          data: t
        }), this.persist()
      })
    }
    isInitialized() {
      if (!this.initialized) {
        const {
          message: t
        } = Hn("NOT_INITIALIZED", this.name);
        throw new Error(t)
      }
    }
  },
  Cje = class extends m$e {
    constructor(t, n) {
      super(t, n), this.projectId = t, this.logger = n, this.name = C8, this.initialized = !1, this.queue = [], this.verifyDisabled = !1, this.init = async r => {
        if (this.verifyDisabled || Wm() || !sE()) return;
        const i = this.getVerifyUrl(r == null ? void 0 : r.verifyUrl);
        this.verifyUrl !== i && this.removeIframe(), this.verifyUrl = i;
        try {
          await this.createIframe()
        } catch (s) {
          this.logger.info(`Verify iframe failed to load: ${this.verifyUrl}`), this.logger.info(s)
        }
        if (!this.initialized) {
          this.removeIframe(), this.verifyUrl = o9;
          try {
            await this.createIframe()
          } catch (s) {
            this.logger.info(`Verify iframe failed to load: ${this.verifyUrl}`), this.logger.info(s), this.verifyDisabled = !0
          }
        }
      }, this.register = async r => {
        this.initialized ? this.sendPost(r.attestationId) : (this.addToQueue(r.attestationId), await this.init())
      }, this.resolve = async r => {
        if (this.isDevEnv) return "";
        const i = this.getVerifyUrl(r == null ? void 0 : r.verifyUrl);
        let s;
        try {
          s = await this.fetchAttestation(r.attestationId, i)
        } catch (o) {
          this.logger.info(`failed to resolve attestation: ${r.attestationId} from url: ${i}`), this.logger.info(o), s = await this.fetchAttestation(r.attestationId, o9)
        }
        return s
      }, this.fetchAttestation = async (r, i) => {
        this.logger.info(`resolving attestation: ${r} from url: ${i}`);
        const s = this.startAbortTimer(it.ONE_SECOND * 2),
          o = await fetch(`${i}/attestation/${r}`, {
            signal: this.abortController.signal
          });
        return clearTimeout(s), o.status === 200 ? await o.json() : void 0
      }, this.addToQueue = r => {
        this.queue.push(r)
      }, this.processQueue = () => {
        this.queue.length !== 0 && (this.queue.forEach(r => this.sendPost(r)), this.queue = [])
      }, this.sendPost = r => {
        var i;
        try {
          if (!this.iframe) return;
          (i = this.iframe.contentWindow) == null || i.postMessage(r, "*"), this.logger.info(`postMessage sent: ${r} ${this.verifyUrl}`)
        } catch {}
      }, this.createIframe = async () => {
        let r;
        const i = s => {
          s.data === "verify_ready" && (this.onInit(), window.removeEventListener("message", i), r())
        };
        await Promise.race([new Promise(s => {
          const o = document.getElementById(C8);
          if (o) return this.iframe = o, this.onInit(), s();
          window.addEventListener("message", i);
          const a = document.createElement("iframe");
          a.id = C8, a.src = `${this.verifyUrl}/${this.projectId}`, a.style.display = "none", document.body.append(a), this.iframe = a, r = s
        }), new Promise((s, o) => setTimeout(() => {
          window.removeEventListener("message", i), o("verify iframe load timeout")
        }, it.toMiliseconds(it.FIVE_SECONDS)))])
      }, this.onInit = () => {
        this.initialized = !0, this.processQueue()
      }, this.removeIframe = () => {
        this.iframe && (this.iframe.remove(), this.iframe = void 0, this.initialized = !1)
      }, this.getVerifyUrl = r => {
        let i = r || ep;
        return ZFe.includes(i) || (this.logger.info(`verify url: ${i}, not included in trusted list, assigning default: ${ep}`), i = ep), i
      }, this.logger = vn.generateChildLogger(n, this.name), this.verifyUrl = ep, this.abortController = new AbortController, this.isDevEnv = E2() && eBe.IS_VITEST
    }
    get context() {
      return vn.getLoggerContext(this.logger)
    }
    startAbortTimer(t) {
      return this.abortController = new AbortController, setTimeout(() => this.abortController.abort(), it.toMiliseconds(t))
    }
  },
  Aje = class extends g$e {
    constructor(t, n) {
      super(t, n), this.projectId = t, this.logger = n, this.context = eje, this.registerDeviceToken = async r => {
        const {
          clientId: i,
          token: s,
          notificationType: o,
          enableEncrypted: a = !1
        } = r, c = `${tje}/${this.projectId}/clients`;
        await ZLe(c, {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            client_id: i,
            type: o,
            token: s,
            always_raw: a
          })
        })
      }, this.logger = vn.generateChildLogger(n, this.context)
    }
  };
var Tje = Object.defineProperty,
  XL = Object.getOwnPropertySymbols,
  kje = Object.prototype.hasOwnProperty,
  _je = Object.prototype.propertyIsEnumerable,
  ZL = (e, t, n) => t in e ? Tje(e, t, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: n
  }) : e[t] = n,
  eB = (e, t) => {
    for (var n in t || (t = {})) kje.call(t, n) && ZL(e, n, t[n]);
    if (XL)
      for (var n of XL(t)) _je.call(t, n) && ZL(e, n, t[n]);
    return e
  };
let Ije = class iJ extends a$e {
  constructor(t) {
    super(t), this.protocol = tJ, this.version = AFe, this.name = x_, this.events = new si.EventEmitter, this.initialized = !1, this.on = (r, i) => this.events.on(r, i), this.once = (r, i) => this.events.once(r, i), this.off = (r, i) => this.events.off(r, i), this.removeListener = (r, i) => this.events.removeListener(r, i), this.projectId = t == null ? void 0 : t.projectId, this.relayUrl = (t == null ? void 0 : t.relayUrl) || rJ, this.customStoragePrefix = t != null && t.customStoragePrefix ? `:${t.customStoragePrefix}` : "";
    const n = typeof (t == null ? void 0 : t.logger) < "u" && typeof (t == null ? void 0 : t.logger) != "string" ? t.logger : vn.pino(vn.getDefaultLoggerOptions({
      level: (t == null ? void 0 : t.logger) || TFe.logger
    }));
    this.logger = vn.generateChildLogger(n, this.name), this.heartbeat = new Hm.HeartBeat, this.crypto = new rje(this, this.logger, t == null ? void 0 : t.keychain), this.history = new Eje(this, this.logger), this.expirer = new Sje(this, this.logger), this.storage = t != null && t.storage ? t.storage : new XMe(eB(eB({}, kFe), t == null ? void 0 : t.storageOptions)), this.relayer = new yje({
      core: this,
      logger: this.logger,
      relayUrl: this.relayUrl,
      projectId: this.projectId
    }), this.pairing = new xje(this, this.logger), this.verify = new Cje(this.projectId || "", this.logger), this.echoClient = new Aje(this.projectId || "", this.logger)
  }
  static async init(t) {
    const n = new iJ(t);
    await n.initialize();
    const r = await n.crypto.getClientId();
    return await n.storage.setItem(HFe, r), n
  }
  get context() {
    return vn.getLoggerContext(this.logger)
  }
  async start() {
    this.initialized || await this.initialize()
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.crypto.init(), await this.history.init(), await this.expirer.init(), await this.relayer.init(), await this.heartbeat.init(), await this.pairing.init(), this.initialized = !0, this.logger.info("Core Initialization Success")
    } catch (t) {
      throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, t), this.logger.error(t.message), t
    }
  }
};
const Pje = Ije;
var Rje = {};
(function (e) {
  const t = tE,
    n = nE,
    r = rE,
    i = iE,
    s = p => p == null,
    o = Symbol("encodeFragmentIdentifier");

  function a(p) {
    switch (p.arrayFormat) {
      case "index":
        return v => (S, I) => {
          const A = S.length;
          return I === void 0 || p.skipNull && I === null || p.skipEmptyString && I === "" ? S : I === null ? [...S, [u(v, p), "[", A, "]"].join("")] : [...S, [u(v, p), "[", u(A, p), "]=", u(I, p)].join("")]
        };
      case "bracket":
        return v => (S, I) => I === void 0 || p.skipNull && I === null || p.skipEmptyString && I === "" ? S : I === null ? [...S, [u(v, p), "[]"].join("")] : [...S, [u(v, p), "[]=", u(I, p)].join("")];
      case "colon-list-separator":
        return v => (S, I) => I === void 0 || p.skipNull && I === null || p.skipEmptyString && I === "" ? S : I === null ? [...S, [u(v, p), ":list="].join("")] : [...S, [u(v, p), ":list=", u(I, p)].join("")];
      case "comma":
      case "separator":
      case "bracket-separator": {
        const v = p.arrayFormat === "bracket-separator" ? "[]=" : "=";
        return S => (I, A) => A === void 0 || p.skipNull && A === null || p.skipEmptyString && A === "" ? I : (A = A === null ? "" : A, I.length === 0 ? [
          [u(S, p), v, u(A, p)].join("")
        ] : [
          [I, u(A, p)].join(p.arrayFormatSeparator)
        ])
      }
      default:
        return v => (S, I) => I === void 0 || p.skipNull && I === null || p.skipEmptyString && I === "" ? S : I === null ? [...S, u(v, p)] : [...S, [u(v, p), "=", u(I, p)].join("")]
    }
  }

  function c(p) {
    let v;
    switch (p.arrayFormat) {
      case "index":
        return (S, I, A) => {
          if (v = /\[(\d*)\]$/.exec(S), S = S.replace(/\[\d*\]$/, ""), !v) {
            A[S] = I;
            return
          }
          A[S] === void 0 && (A[S] = {}), A[S][v[1]] = I
        };
      case "bracket":
        return (S, I, A) => {
          if (v = /(\[\])$/.exec(S), S = S.replace(/\[\]$/, ""), !v) {
            A[S] = I;
            return
          }
          if (A[S] === void 0) {
            A[S] = [I];
            return
          }
          A[S] = [].concat(A[S], I)
        };
      case "colon-list-separator":
        return (S, I, A) => {
          if (v = /(:list)$/.exec(S), S = S.replace(/:list$/, ""), !v) {
            A[S] = I;
            return
          }
          if (A[S] === void 0) {
            A[S] = [I];
            return
          }
          A[S] = [].concat(A[S], I)
        };
      case "comma":
      case "separator":
        return (S, I, A) => {
          const w = typeof I == "string" && I.includes(p.arrayFormatSeparator),
            E = typeof I == "string" && !w && f(I, p).includes(p.arrayFormatSeparator);
          I = E ? f(I, p) : I;
          const D = w || E ? I.split(p.arrayFormatSeparator).map($ => f($, p)) : I === null ? I : f(I, p);
          A[S] = D
        };
      case "bracket-separator":
        return (S, I, A) => {
          const w = /(\[\])$/.test(S);
          if (S = S.replace(/\[\]$/, ""), !w) {
            A[S] = I && f(I, p);
            return
          }
          const E = I === null ? [] : I.split(p.arrayFormatSeparator).map(D => f(D, p));
          if (A[S] === void 0) {
            A[S] = E;
            return
          }
          A[S] = [].concat(A[S], E)
        };
      default:
        return (S, I, A) => {
          if (A[S] === void 0) {
            A[S] = I;
            return
          }
          A[S] = [].concat(A[S], I)
        }
    }
  }

  function l(p) {
    if (typeof p != "string" || p.length !== 1) throw new TypeError("arrayFormatSeparator must be single character string")
  }

  function u(p, v) {
    return v.encode ? v.strict ? t(p) : encodeURIComponent(p) : p
  }

  function f(p, v) {
    return v.decode ? n(p) : p
  }

  function h(p) {
    return Array.isArray(p) ? p.sort() : typeof p == "object" ? h(Object.keys(p)).sort((v, S) => Number(v) - Number(S)).map(v => p[v]) : p
  }

  function g(p) {
    const v = p.indexOf("#");
    return v !== -1 && (p = p.slice(0, v)), p
  }

  function y(p) {
    let v = "";
    const S = p.indexOf("#");
    return S !== -1 && (v = p.slice(S)), v
  }

  function x(p) {
    p = g(p);
    const v = p.indexOf("?");
    return v === -1 ? "" : p.slice(v + 1)
  }

  function k(p, v) {
    return v.parseNumbers && !Number.isNaN(Number(p)) && typeof p == "string" && p.trim() !== "" ? p = Number(p) : v.parseBooleans && p !== null && (p.toLowerCase() === "true" || p.toLowerCase() === "false") && (p = p.toLowerCase() === "true"), p
  }

  function _(p, v) {
    v = Object.assign({
      decode: !0,
      sort: !0,
      arrayFormat: "none",
      arrayFormatSeparator: ",",
      parseNumbers: !1,
      parseBooleans: !1
    }, v), l(v.arrayFormatSeparator);
    const S = c(v),
      I = Object.create(null);
    if (typeof p != "string" || (p = p.trim().replace(/^[?#&]/, ""), !p)) return I;
    for (const A of p.split("&")) {
      if (A === "") continue;
      let [w, E] = r(v.decode ? A.replace(/\+/g, " ") : A, "=");
      E = E === void 0 ? null : ["comma", "separator", "bracket-separator"].includes(v.arrayFormat) ? E : f(E, v), S(f(w, v), E, I)
    }
    for (const A of Object.keys(I)) {
      const w = I[A];
      if (typeof w == "object" && w !== null)
        for (const E of Object.keys(w)) w[E] = k(w[E], v);
      else I[A] = k(w, v)
    }
    return v.sort === !1 ? I : (v.sort === !0 ? Object.keys(I).sort() : Object.keys(I).sort(v.sort)).reduce((A, w) => {
      const E = I[w];
      return E && typeof E == "object" && !Array.isArray(E) ? A[w] = h(E) : A[w] = E, A
    }, Object.create(null))
  }
  e.extract = x, e.parse = _, e.stringify = (p, v) => {
    if (!p) return "";
    v = Object.assign({
      encode: !0,
      strict: !0,
      arrayFormat: "none",
      arrayFormatSeparator: ","
    }, v), l(v.arrayFormatSeparator);
    const S = E => v.skipNull && s(p[E]) || v.skipEmptyString && p[E] === "",
      I = a(v),
      A = {};
    for (const E of Object.keys(p)) S(E) || (A[E] = p[E]);
    const w = Object.keys(A);
    return v.sort !== !1 && w.sort(v.sort), w.map(E => {
      const D = p[E];
      return D === void 0 ? "" : D === null ? u(E, v) : Array.isArray(D) ? D.length === 0 && v.arrayFormat === "bracket-separator" ? u(E, v) + "[]" : D.reduce(I(E), []).join("&") : u(E, v) + "=" + u(D, v)
    }).filter(E => E.length > 0).join("&")
  }, e.parseUrl = (p, v) => {
    v = Object.assign({
      decode: !0
    }, v);
    const [S, I] = r(p, "#");
    return Object.assign({
      url: S.split("?")[0] || "",
      query: _(x(p), v)
    }, v && v.parseFragmentIdentifier && I ? {
      fragmentIdentifier: f(I, v)
    } : {})
  }, e.stringifyUrl = (p, v) => {
    v = Object.assign({
      encode: !0,
      strict: !0,
      [o]: !0
    }, v);
    const S = g(p.url).split("?")[0] || "",
      I = e.extract(p.url),
      A = e.parse(I, {
        sort: !1
      }),
      w = Object.assign(A, p.query);
    let E = e.stringify(w, v);
    E && (E = `?${E}`);
    let D = y(p.url);
    return p.fragmentIdentifier && (D = `#${v[o]?u(p.fragmentIdentifier,v):p.fragmentIdentifier}`), `${S}${E}${D}`
  }, e.pick = (p, v, S) => {
    S = Object.assign({
      parseFragmentIdentifier: !0,
      [o]: !1
    }, S);
    const {
      url: I,
      query: A,
      fragmentIdentifier: w
    } = e.parseUrl(p, S);
    return e.stringifyUrl({
      url: I,
      query: i(A, v),
      fragmentIdentifier: w
    }, S)
  }, e.exclude = (p, v, S) => {
    const I = Array.isArray(v) ? A => !v.includes(A) : (A, w) => !v(A, w);
    return e.pick(p, I, S)
  }
})(Rje);

function sJ(e, t) {
  return e.includes(":") ? [e] : t.chains || []
}
const Oje = "base16",
  Dje = "utf8",
  Nje = 1;

function T8(e) {
  const t = Ay.hash(As(e, Dje));
  return us(t, Oje)
}
const Mje = "ReactNative",
  tp = {
    reactNative: "react-native",
    node: "node",
    browser: "browser",
    unknown: "unknown"
  };

function oJ() {
  return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u"
}

function $je() {
  return !ky() && !!_y() && navigator.product === Mje
}

function E_() {
  return !oJ() && !!_y() && !!ky()
}

function Lje() {
  return $je() ? tp.reactNative : oJ() ? tp.node : E_() ? tp.browser : tp.unknown
}

function Bje() {
  return wY() || {
    name: "",
    description: "",
    url: "",
    icons: [""]
  }
}

function Ff(e, t) {
  return e.filter(n => t.includes(n)).length === e.length
}

function Wg(e = it.FIVE_MINUTES, t) {
  const n = it.toMiliseconds(e || it.FIVE_MINUTES);
  let r, i, s;
  return {
    resolve: o => {
      s && r && (clearTimeout(s), r(o))
    },
    reject: o => {
      s && i && (clearTimeout(s), i(o))
    },
    done: () => new Promise((o, a) => {
      s = setTimeout(() => {
        a(new Error(t))
      }, n), r = o, i = a
    })
  }
}

function Fje(e) {
  const [t, n] = e.split(":"), r = {
    id: void 0,
    topic: void 0
  };
  if (t === "topic" && typeof n == "string") r.topic = n;
  else if (t === "id" && Number.isInteger(Number(n))) r.id = Number(n);
  else throw new Error(`Invalid target, expected id:number or topic:string, got ${t}:${n}`);
  return r
}

function jl(e, t) {
  return it.fromMiliseconds((t || Date.now()) + it.toMiliseconds(e))
}

function y0(e) {
  return Date.now() >= it.toMiliseconds(e)
}

function pr(e, t) {
  return `${e}${t?`:${t}`:""}`
}
async function jje({
  id: e,
  topic: t,
  wcDeepLink: n
}) {
  try {
    if (!n) return;
    const r = typeof n == "string" ? JSON.parse(n) : n;
    let i = r == null ? void 0 : r.href;
    if (typeof i != "string") return;
    i.endsWith("/") && (i = i.slice(0, -1));
    const s = `${i}/wc?requestId=${e}&sessionTopic=${t}`,
      o = Lje();
    o === tp.browser ? s.startsWith("https://") ? window.open(s, "_blank", "noreferrer noopener") : window.open(s, "_self", "noreferrer noopener") : o === tp.reactNative && typeof (global == null ? void 0 : global.Linking) < "u" && await global.Linking.openURL(s)
  } catch (r) {
    console.error(r)
  }
}
async function Uje(e, t) {
  try {
    return await e.getItem(t) || (E_() ? localStorage.getItem(t) : void 0)
  } catch (n) {
    console.error(n)
  }
}

function qm(e) {
  const t = [];
  return e.forEach(n => {
    const [r, i] = n.split(":");
    t.push(`${r}:${i}`)
  }), t
}

function zje(e) {
  const t = [];
  return Object.values(e).forEach(n => {
    t.push(...qm(n.accounts))
  }), t
}

function Hje(e, t) {
  const n = [];
  return Object.values(e).forEach(r => {
    qm(r.accounts).includes(t) && n.push(...r.methods)
  }), n
}

function Vje(e, t) {
  const n = [];
  return Object.values(e).forEach(r => {
    qm(r.accounts).includes(t) && n.push(...r.events)
  }), n
}
const Wje = {
    INVALID_METHOD: {
      message: "Invalid method.",
      code: 1001
    },
    INVALID_EVENT: {
      message: "Invalid event.",
      code: 1002
    },
    INVALID_UPDATE_REQUEST: {
      message: "Invalid update request.",
      code: 1003
    },
    INVALID_EXTEND_REQUEST: {
      message: "Invalid extend request.",
      code: 1004
    },
    INVALID_SESSION_SETTLE_REQUEST: {
      message: "Invalid session settle request.",
      code: 1005
    },
    UNAUTHORIZED_METHOD: {
      message: "Unauthorized method.",
      code: 3001
    },
    UNAUTHORIZED_EVENT: {
      message: "Unauthorized event.",
      code: 3002
    },
    UNAUTHORIZED_UPDATE_REQUEST: {
      message: "Unauthorized update request.",
      code: 3003
    },
    UNAUTHORIZED_EXTEND_REQUEST: {
      message: "Unauthorized extend request.",
      code: 3004
    },
    USER_REJECTED: {
      message: "User rejected.",
      code: 5e3
    },
    USER_REJECTED_CHAINS: {
      message: "User rejected chains.",
      code: 5001
    },
    USER_REJECTED_METHODS: {
      message: "User rejected methods.",
      code: 5002
    },
    USER_REJECTED_EVENTS: {
      message: "User rejected events.",
      code: 5003
    },
    UNSUPPORTED_CHAINS: {
      message: "Unsupported chains.",
      code: 5100
    },
    UNSUPPORTED_METHODS: {
      message: "Unsupported methods.",
      code: 5101
    },
    UNSUPPORTED_EVENTS: {
      message: "Unsupported events.",
      code: 5102
    },
    UNSUPPORTED_ACCOUNTS: {
      message: "Unsupported accounts.",
      code: 5103
    },
    UNSUPPORTED_NAMESPACE_KEY: {
      message: "Unsupported namespace key.",
      code: 5104
    },
    USER_DISCONNECTED: {
      message: "User disconnected.",
      code: 6e3
    },
    SESSION_SETTLEMENT_FAILED: {
      message: "Session settlement failed.",
      code: 7e3
    },
    WC_METHOD_UNSUPPORTED: {
      message: "Unsupported wc_ method.",
      code: 10001
    }
  },
  qje = {
    NOT_INITIALIZED: {
      message: "Not initialized.",
      code: 1
    },
    NO_MATCHING_KEY: {
      message: "No matching key.",
      code: 2
    },
    RESTORE_WILL_OVERRIDE: {
      message: "Restore will override.",
      code: 3
    },
    RESUBSCRIBED: {
      message: "Resubscribed.",
      code: 4
    },
    MISSING_OR_INVALID: {
      message: "Missing or invalid.",
      code: 5
    },
    EXPIRED: {
      message: "Expired.",
      code: 6
    },
    UNKNOWN_TYPE: {
      message: "Unknown type.",
      code: 7
    },
    MISMATCHED_TOPIC: {
      message: "Mismatched topic.",
      code: 8
    },
    NON_CONFORMING_NAMESPACES: {
      message: "Non conforming namespaces.",
      code: 9
    }
  };

function Mt(e, t) {
  const {
    message: n,
    code: r
  } = qje[e];
  return {
    message: t ? `${n} ${t}` : n,
    code: r
  }
}

function $i(e, t) {
  const {
    message: n,
    code: r
  } = Wje[e];
  return {
    message: t ? `${n} ${t}` : n,
    code: r
  }
}

function fE(e, t) {
  return Array.isArray(e) ? typeof t < "u" && e.length ? e.every(t) : !0 : !1
}

function gx(e) {
  return Object.getPrototypeOf(e) === Object.prototype && Object.keys(e).length
}

function wa(e) {
  return typeof e > "u"
}

function os(e, t) {
  return t && wa(e) ? !0 : typeof e == "string" && !!e.trim().length
}

function S_(e, t) {
  return t && wa(e) ? !0 : typeof e == "number" && !isNaN(e)
}

function Gje(e, t) {
  const {
    requiredNamespaces: n
  } = t, r = Object.keys(e.namespaces), i = Object.keys(n);
  let s = !0;
  return Ff(i, r) ? (r.forEach(o => {
    const {
      accounts: a,
      methods: c,
      events: l
    } = e.namespaces[o], u = qm(a), f = n[o];
    (!Ff(sJ(o, f), u) || !Ff(f.methods, c) || !Ff(f.events, l)) && (s = !1)
  }), s) : !1
}

function yx(e) {
  return os(e, !1) && e.includes(":") ? e.split(":").length === 2 : !1
}

function Kje(e) {
  if (os(e, !1) && e.includes(":")) {
    const t = e.split(":");
    if (t.length === 3) {
      const n = t[0] + ":" + t[1];
      return !!t[2] && yx(n)
    }
  }
  return !1
}

function Qje(e, t) {
  let n = null;
  return os(e == null ? void 0 : e.publicKey, !1) || (n = Mt("MISSING_OR_INVALID", `${t} controller public key should be a string`)), n
}

function tB(e) {
  let t = !0;
  return fE(e) ? e.length && (t = e.every(n => os(n, !1))) : t = !1, t
}

function Yje(e, t, n) {
  let r = null;
  return fE(t) && t.length ? t.forEach(i => {
    r || yx(i) || (r = $i("UNSUPPORTED_CHAINS", `${n}, chain ${i} should be a string and conform to "namespace:chainId" format`))
  }) : yx(e) || (r = $i("UNSUPPORTED_CHAINS", `${n}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`)), r
}

function Jje(e, t, n) {
  let r = null;
  return Object.entries(e).forEach(([i, s]) => {
    if (r) return;
    const o = Yje(i, sJ(i, s), `${t} ${n}`);
    o && (r = o)
  }), r
}

function Xje(e, t) {
  let n = null;
  return fE(e) ? e.forEach(r => {
    n || Kje(r) || (n = $i("UNSUPPORTED_ACCOUNTS", `${t}, account ${r} should be a string and conform to "namespace:chainId:address" format`))
  }) : n = $i("UNSUPPORTED_ACCOUNTS", `${t}, accounts should be an array of strings conforming to "namespace:chainId:address" format`), n
}

function Zje(e, t) {
  let n = null;
  return Object.values(e).forEach(r => {
    if (n) return;
    const i = Xje(r == null ? void 0 : r.accounts, `${t} namespace`);
    i && (n = i)
  }), n
}

function eUe(e, t) {
  let n = null;
  return tB(e == null ? void 0 : e.methods) ? tB(e == null ? void 0 : e.events) || (n = $i("UNSUPPORTED_EVENTS", `${t}, events should be an array of strings or empty array for no events`)) : n = $i("UNSUPPORTED_METHODS", `${t}, methods should be an array of strings or empty array for no methods`), n
}

function aJ(e, t) {
  let n = null;
  return Object.values(e).forEach(r => {
    if (n) return;
    const i = eUe(r, `${t}, namespace`);
    i && (n = i)
  }), n
}

function tUe(e, t, n) {
  let r = null;
  if (e && gx(e)) {
    const i = aJ(e, t);
    i && (r = i);
    const s = Jje(e, t, n);
    s && (r = s)
  } else r = Mt("MISSING_OR_INVALID", `${t}, ${n} should be an object with data`);
  return r
}

function k8(e, t) {
  let n = null;
  if (e && gx(e)) {
    const r = aJ(e, t);
    r && (n = r);
    const i = Zje(e, t);
    i && (n = i)
  } else n = Mt("MISSING_OR_INVALID", `${t}, namespaces should be an object with data`);
  return n
}

function cJ(e) {
  return os(e.protocol, !0)
}

function nUe(e, t) {
  let n = !1;
  return t && !e ? n = !0 : e && fE(e) && e.length && e.forEach(r => {
    n = cJ(r)
  }), n
}

function rUe(e) {
  return typeof e == "number"
}

function Za(e) {
  return typeof e < "u" && typeof e !== null
}

function iUe(e) {
  return !(!e || typeof e != "object" || !e.code || !S_(e.code, !1) || !e.message || !os(e.message, !1))
}

function sUe(e) {
  return !(wa(e) || !os(e.method, !1))
}

function oUe(e) {
  return !(wa(e) || wa(e.result) && wa(e.error) || !S_(e.id, !1) || !os(e.jsonrpc, !1))
}

function aUe(e) {
  return !(wa(e) || !os(e.name, !1))
}

function nB(e, t) {
  return !(!yx(t) || !zje(e).includes(t))
}

function cUe(e, t, n) {
  return os(n, !1) ? Hje(e, t).includes(n) : !1
}

function lUe(e, t, n) {
  return os(n, !1) ? Vje(e, t).includes(n) : !1
}

function rB(e, t, n) {
  let r = null;
  const i = uUe(e),
    s = dUe(t),
    o = Object.keys(i),
    a = Object.keys(s),
    c = iB(Object.keys(e)),
    l = iB(Object.keys(t)),
    u = c.filter(f => !l.includes(f));
  return u.length && (r = Mt("NON_CONFORMING_NAMESPACES", `${n} namespaces keys don't satisfy requiredNamespaces.
      Required: ${u.toString()}
      Received: ${Object.keys(t).toString()}`)), Ff(o, a) || (r = Mt("NON_CONFORMING_NAMESPACES", `${n} namespaces chains don't satisfy required namespaces.
      Required: ${o.toString()}
      Approved: ${a.toString()}`)), Object.keys(t).forEach(f => {
    if (!f.includes(":") || r) return;
    const h = qm(t[f].accounts);
    h.includes(f) || (r = Mt("NON_CONFORMING_NAMESPACES", `${n} namespaces accounts don't satisfy namespace accounts for ${f}
        Required: ${f}
        Approved: ${h.toString()}`))
  }), o.forEach(f => {
    r || (Ff(i[f].methods, s[f].methods) ? Ff(i[f].events, s[f].events) || (r = Mt("NON_CONFORMING_NAMESPACES", `${n} namespaces events don't satisfy namespace events for ${f}`)) : r = Mt("NON_CONFORMING_NAMESPACES", `${n} namespaces methods don't satisfy namespace methods for ${f}`))
  }), r
}

function uUe(e) {
  const t = {};
  return Object.keys(e).forEach(n => {
    var r;
    n.includes(":") ? t[n] = e[n] : (r = e[n].chains) == null || r.forEach(i => {
      t[i] = {
        methods: e[n].methods,
        events: e[n].events
      }
    })
  }), t
}

function iB(e) {
  return [...new Set(e.map(t => t.includes(":") ? t.split(":")[0] : t))]
}

function dUe(e) {
  const t = {};
  return Object.keys(e).forEach(n => {
    if (n.includes(":")) t[n] = e[n];
    else {
      const r = qm(e[n].accounts);
      r == null || r.forEach(i => {
        t[i] = {
          accounts: e[n].accounts.filter(s => s.includes(`${i}:`)),
          methods: e[n].methods,
          events: e[n].events
        }
      })
    }
  }), t
}

function fUe(e, t) {
  return S_(e, !1) && e <= t.max && e >= t.min
}
const _8 = {};
class qg {
  static get(t) {
    return _8[t]
  }
  static set(t, n) {
    _8[t] = n
  }
  static delete(t) {
    delete _8[t]
  }
}
const lJ = "wc",
  uJ = 2,
  dJ = "client",
  C_ = `${lJ}@${uJ}:${dJ}:`,
  I8 = {
    name: dJ,
    logger: "error",
    controller: !1,
    relayUrl: "wss://relay.walletconnect.com"
  },
  sB = "WALLETCONNECT_DEEPLINK_CHOICE",
  hUe = "proposal",
  fJ = "Proposal expired",
  pUe = "session",
  Fb = it.SEVEN_DAYS,
  mUe = "engine",
  Ul = {
    wc_sessionPropose: {
      req: {
        ttl: it.FIVE_MINUTES,
        prompt: !0,
        tag: 1100
      },
      res: {
        ttl: it.FIVE_MINUTES,
        prompt: !1,
        tag: 1101
      }
    },
    wc_sessionSettle: {
      req: {
        ttl: it.FIVE_MINUTES,
        prompt: !1,
        tag: 1102
      },
      res: {
        ttl: it.FIVE_MINUTES,
        prompt: !1,
        tag: 1103
      }
    },
    wc_sessionUpdate: {
      req: {
        ttl: it.ONE_DAY,
        prompt: !1,
        tag: 1104
      },
      res: {
        ttl: it.ONE_DAY,
        prompt: !1,
        tag: 1105
      }
    },
    wc_sessionExtend: {
      req: {
        ttl: it.ONE_DAY,
        prompt: !1,
        tag: 1106
      },
      res: {
        ttl: it.ONE_DAY,
        prompt: !1,
        tag: 1107
      }
    },
    wc_sessionRequest: {
      req: {
        ttl: it.FIVE_MINUTES,
        prompt: !0,
        tag: 1108
      },
      res: {
        ttl: it.FIVE_MINUTES,
        prompt: !1,
        tag: 1109
      }
    },
    wc_sessionEvent: {
      req: {
        ttl: it.FIVE_MINUTES,
        prompt: !0,
        tag: 1110
      },
      res: {
        ttl: it.FIVE_MINUTES,
        prompt: !1,
        tag: 1111
      }
    },
    wc_sessionDelete: {
      req: {
        ttl: it.ONE_DAY,
        prompt: !1,
        tag: 1112
      },
      res: {
        ttl: it.ONE_DAY,
        prompt: !1,
        tag: 1113
      }
    },
    wc_sessionPing: {
      req: {
        ttl: it.ONE_DAY,
        prompt: !1,
        tag: 1114
      },
      res: {
        ttl: it.ONE_DAY,
        prompt: !1,
        tag: 1115
      }
    }
  },
  P8 = {
    min: it.FIVE_MINUTES,
    max: it.SEVEN_DAYS
  },
  zl = {
    idle: "IDLE",
    active: "ACTIVE"
  },
  gUe = "request",
  yUe = ["wc_sessionPropose", "wc_sessionRequest", "wc_authRequest"];
var vUe = Object.defineProperty,
  bUe = Object.defineProperties,
  wUe = Object.getOwnPropertyDescriptors,
  oB = Object.getOwnPropertySymbols,
  xUe = Object.prototype.hasOwnProperty,
  EUe = Object.prototype.propertyIsEnumerable,
  aB = (e, t, n) => t in e ? vUe(e, t, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: n
  }) : e[t] = n,
  ws = (e, t) => {
    for (var n in t || (t = {})) xUe.call(t, n) && aB(e, n, t[n]);
    if (oB)
      for (var n of oB(t)) EUe.call(t, n) && aB(e, n, t[n]);
    return e
  },
  v0 = (e, t) => bUe(e, wUe(t));
class SUe extends v$e {
  constructor(t) {
    super(t), this.name = mUe, this.events = new Wk, this.initialized = !1, this.ignoredPayloadTypes = [Nje], this.requestQueue = {
      state: zl.idle,
      queue: []
    }, this.sessionRequestQueue = {
      state: zl.idle,
      queue: []
    }, this.requestQueueDelay = it.ONE_SECOND, this.recentlyDeletedMap = new Map, this.recentlyDeletedLimit = 200, this.init = async () => {
      this.initialized || (await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.registerPairingEvents(), this.client.core.pairing.register({
        methods: Object.keys(Ul)
      }), this.initialized = !0, setTimeout(() => {
        this.sessionRequestQueue.queue = this.getPendingSessionRequests(), this.processSessionRequestQueue()
      }, it.toMiliseconds(this.requestQueueDelay)))
    }, this.connect = async n => {
      await this.isInitialized();
      const r = v0(ws({}, n), {
        requiredNamespaces: n.requiredNamespaces || {},
        optionalNamespaces: n.optionalNamespaces || {}
      });
      await this.isValidConnect(r);
      const {
        pairingTopic: i,
        requiredNamespaces: s,
        optionalNamespaces: o,
        sessionProperties: a,
        relays: c
      } = r;
      let l = i,
        u, f = !1;
      try {
        l && (f = this.client.core.pairing.pairings.get(l).active)
      } catch (S) {
        throw this.client.logger.error(`connect() -> pairing.get(${l}) failed`), S
      }
      if (!l || !f) {
        const {
          topic: S,
          uri: I
        } = await this.client.core.pairing.create();
        l = S, u = I
      }
      if (!l) {
        const {
          message: S
        } = Mt("NO_MATCHING_KEY", `connect() pairing topic: ${l}`);
        throw new Error(S)
      }
      const h = await this.client.core.crypto.generateKeyPair(),
        g = Ul.wc_sessionPropose.req.ttl || it.FIVE_MINUTES,
        y = jl(g),
        x = ws({
          requiredNamespaces: s,
          optionalNamespaces: o,
          relays: c ?? [{
            protocol: nJ
          }],
          proposer: {
            publicKey: h,
            metadata: this.client.metadata
          },
          expiryTimestamp: y
        }, a && {
          sessionProperties: a
        }),
        {
          reject: k,
          resolve: _,
          done: p
        } = Wg(g, fJ);
      this.events.once(pr("session_connect"), async ({
        error: S,
        session: I
      }) => {
        if (S) k(S);
        else if (I) {
          I.self.publicKey = h;
          const A = v0(ws({}, I), {
            requiredNamespaces: x.requiredNamespaces,
            optionalNamespaces: x.optionalNamespaces
          });
          await this.client.session.set(I.topic, A), await this.setExpiry(I.topic, I.expiry), l && await this.client.core.pairing.updateMetadata({
            topic: l,
            metadata: I.peer.metadata
          }), _(A)
        }
      });
      const v = await this.sendRequest({
        topic: l,
        method: "wc_sessionPropose",
        params: x,
        throwOnFailedPublish: !0
      });
      return await this.setProposal(v, ws({
        id: v
      }, x)), {
        uri: u,
        approval: p
      }
    }, this.pair = async n => {
      await this.isInitialized();
      try {
        return await this.client.core.pairing.pair(n)
      } catch (r) {
        throw this.client.logger.error("pair() failed"), r
      }
    }, this.approve = async n => {
      await this.isInitialized();
      try {
        await this.isValidApprove(n)
      } catch (_) {
        throw this.client.logger.error("approve() -> isValidApprove() failed"), _
      }
      const {
        id: r,
        relayProtocol: i,
        namespaces: s,
        sessionProperties: o
      } = n;
      let a;
      try {
        a = this.client.proposal.get(r)
      } catch (_) {
        throw this.client.logger.error(`approve() -> proposal.get(${r}) failed`), _
      }
      let {
        pairingTopic: c,
        proposer: l,
        requiredNamespaces: u,
        optionalNamespaces: f
      } = a;
      c = c || "";
      const h = await this.client.core.crypto.generateKeyPair(),
        g = l.publicKey,
        y = await this.client.core.crypto.generateSharedKey(h, g),
        x = ws({
          relay: {
            protocol: i ?? "irn"
          },
          namespaces: s,
          pairingTopic: c,
          controller: {
            publicKey: h,
            metadata: this.client.metadata
          },
          expiry: jl(Fb)
        }, o && {
          sessionProperties: o
        });
      await this.client.core.relayer.subscribe(y);
      const k = v0(ws({}, x), {
        topic: y,
        requiredNamespaces: u,
        optionalNamespaces: f,
        pairingTopic: c,
        acknowledged: !1,
        self: x.controller,
        peer: {
          publicKey: l.publicKey,
          metadata: l.metadata
        },
        controller: h
      });
      await this.client.session.set(y, k);
      try {
        await this.sendResult({
          id: r,
          topic: c,
          result: {
            relay: {
              protocol: i ?? "irn"
            },
            responderPublicKey: h
          },
          throwOnFailedPublish: !0
        }), await this.sendRequest({
          topic: y,
          method: "wc_sessionSettle",
          params: x,
          throwOnFailedPublish: !0
        })
      } catch (_) {
        throw this.client.logger.error(_), this.client.session.delete(y, $i("USER_DISCONNECTED")), await this.client.core.relayer.unsubscribe(y), _
      }
      return await this.client.core.pairing.updateMetadata({
        topic: c,
        metadata: l.metadata
      }), await this.client.proposal.delete(r, $i("USER_DISCONNECTED")), await this.client.core.pairing.activate({
        topic: c
      }), await this.setExpiry(y, jl(Fb)), {
        topic: y,
        acknowledged: () => new Promise(_ => setTimeout(() => _(this.client.session.get(y)), 500))
      }
    }, this.reject = async n => {
      await this.isInitialized();
      try {
        await this.isValidReject(n)
      } catch (o) {
        throw this.client.logger.error("reject() -> isValidReject() failed"), o
      }
      const {
        id: r,
        reason: i
      } = n;
      let s;
      try {
        s = this.client.proposal.get(r).pairingTopic
      } catch (o) {
        throw this.client.logger.error(`reject() -> proposal.get(${r}) failed`), o
      }
      s && (await this.sendError(r, s, i), await this.client.proposal.delete(r, $i("USER_DISCONNECTED")))
    }, this.update = async n => {
      await this.isInitialized();
      try {
        await this.isValidUpdate(n)
      } catch (f) {
        throw this.client.logger.error("update() -> isValidUpdate() failed"), f
      }
      const {
        topic: r,
        namespaces: i
      } = n, {
        done: s,
        resolve: o,
        reject: a
      } = Wg(), c = X0(), l = Bf().toString(), u = this.client.session.get(r).namespaces;
      return this.events.once(pr("session_update", c), async ({
        error: f
      }) => {
        f ? a(f) : (await this.client.session.update(r, {
          namespaces: i
        }), o())
      }), this.sendRequest({
        topic: r,
        method: "wc_sessionUpdate",
        params: {
          namespaces: i
        },
        throwOnFailedPublish: !0,
        clientRpcId: c,
        relayRpcId: l
      }).catch(f => {
        this.client.logger.error(f), this.client.session.update(r, {
          namespaces: u
        }), a(f)
      }), {
        acknowledged: s
      }
    }, this.extend = async n => {
      await this.isInitialized();
      try {
        await this.isValidExtend(n)
      } catch (c) {
        throw this.client.logger.error("extend() -> isValidExtend() failed"), c
      }
      const {
        topic: r
      } = n, i = X0(), {
        done: s,
        resolve: o,
        reject: a
      } = Wg();
      return this.events.once(pr("session_extend", i), ({
        error: c
      }) => {
        c ? a(c) : o()
      }), await this.setExpiry(r, jl(Fb)), this.sendRequest({
        topic: r,
        method: "wc_sessionExtend",
        params: {},
        clientRpcId: i,
        throwOnFailedPublish: !0
      }).catch(c => {
        a(c)
      }), {
        acknowledged: s
      }
    }, this.request = async n => {
      await this.isInitialized();
      try {
        await this.isValidRequest(n)
      } catch (h) {
        throw this.client.logger.error("request() -> isValidRequest() failed"), h
      }
      const {
        chainId: r,
        request: i,
        topic: s,
        expiry: o = Ul.wc_sessionRequest.req.ttl
      } = n, a = X0(), c = Bf().toString(), {
        done: l,
        resolve: u,
        reject: f
      } = Wg(o, "Request expired. Please try again.");
      return this.events.once(pr("session_request", a), ({
        error: h,
        result: g
      }) => {
        h ? f(h) : u(g)
      }), await Promise.all([new Promise(async h => {
        await this.sendRequest({
          clientRpcId: a,
          relayRpcId: c,
          topic: s,
          method: "wc_sessionRequest",
          params: {
            request: v0(ws({}, i), {
              expiryTimestamp: jl(o)
            }),
            chainId: r
          },
          expiry: o,
          throwOnFailedPublish: !0
        }).catch(g => f(g)), this.client.events.emit("session_request_sent", {
          topic: s,
          request: i,
          chainId: r,
          id: a
        }), h()
      }), new Promise(async h => {
        const g = await Uje(this.client.core.storage, sB);
        jje({
          id: a,
          topic: s,
          wcDeepLink: g
        }), h()
      }), l()]).then(h => h[2])
    }, this.respond = async n => {
      await this.isInitialized(), await this.isValidRespond(n);
      const {
        topic: r,
        response: i
      } = n, {
        id: s
      } = i;
      Kl(i) ? await this.sendResult({
        id: s,
        topic: r,
        result: i.result,
        throwOnFailedPublish: !0
      }) : oc(i) && await this.sendError(s, r, i.error), this.cleanupAfterResponse(n)
    }, this.ping = async n => {
      await this.isInitialized();
      try {
        await this.isValidPing(n)
      } catch (i) {
        throw this.client.logger.error("ping() -> isValidPing() failed"), i
      }
      const {
        topic: r
      } = n;
      if (this.client.session.keys.includes(r)) {
        const i = X0(),
          s = Bf().toString(),
          {
            done: o,
            resolve: a,
            reject: c
          } = Wg();
        this.events.once(pr("session_ping", i), ({
          error: l
        }) => {
          l ? c(l) : a()
        }), await Promise.all([this.sendRequest({
          topic: r,
          method: "wc_sessionPing",
          params: {},
          throwOnFailedPublish: !0,
          clientRpcId: i,
          relayRpcId: s
        }), o()])
      } else this.client.core.pairing.pairings.keys.includes(r) && await this.client.core.pairing.ping({
        topic: r
      })
    }, this.emit = async n => {
      await this.isInitialized(), await this.isValidEmit(n);
      const {
        topic: r,
        event: i,
        chainId: s
      } = n, o = Bf().toString();
      await this.sendRequest({
        topic: r,
        method: "wc_sessionEvent",
        params: {
          event: i,
          chainId: s
        },
        throwOnFailedPublish: !0,
        relayRpcId: o
      })
    }, this.disconnect = async n => {
      await this.isInitialized(), await this.isValidDisconnect(n);
      const {
        topic: r
      } = n;
      if (this.client.session.keys.includes(r)) await this.sendRequest({
        topic: r,
        method: "wc_sessionDelete",
        params: $i("USER_DISCONNECTED"),
        throwOnFailedPublish: !0
      }), await this.deleteSession({
        topic: r,
        emitEvent: !1
      });
      else if (this.client.core.pairing.pairings.keys.includes(r)) await this.client.core.pairing.disconnect({
        topic: r
      });
      else {
        const {
          message: i
        } = Mt("MISMATCHED_TOPIC", `Session or pairing topic not found: ${r}`);
        throw new Error(i)
      }
    }, this.find = n => (this.isInitialized(), this.client.session.getAll().filter(r => Gje(r, n))), this.getPendingSessionRequests = () => this.client.pendingRequest.getAll(), this.cleanupDuplicatePairings = async n => {
      if (n.pairingTopic) try {
        const r = this.client.core.pairing.pairings.get(n.pairingTopic),
          i = this.client.core.pairing.pairings.getAll().filter(s => {
            var o, a;
            return ((o = s.peerMetadata) == null ? void 0 : o.url) && ((a = s.peerMetadata) == null ? void 0 : a.url) === n.peer.metadata.url && s.topic && s.topic !== r.topic
          });
        if (i.length === 0) return;
        this.client.logger.info(`Cleaning up ${i.length} duplicate pairing(s)`), await Promise.all(i.map(s => this.client.core.pairing.disconnect({
          topic: s.topic
        }))), this.client.logger.info("Duplicate pairings clean up finished")
      } catch (r) {
        this.client.logger.error(r)
      }
    }, this.deleteSession = async n => {
      const {
        topic: r,
        expirerHasDeleted: i = !1,
        emitEvent: s = !0,
        id: o = 0
      } = n, {
        self: a
      } = this.client.session.get(r);
      await this.client.core.relayer.unsubscribe(r), await this.client.session.delete(r, $i("USER_DISCONNECTED")), this.addToRecentlyDeleted(r, "session"), this.client.core.crypto.keychain.has(a.publicKey) && await this.client.core.crypto.deleteKeyPair(a.publicKey), this.client.core.crypto.keychain.has(r) && await this.client.core.crypto.deleteSymKey(r), i || this.client.core.expirer.del(r), this.client.core.storage.removeItem(sB).catch(c => this.client.logger.warn(c)), this.getPendingSessionRequests().forEach(c => {
        c.topic === r && this.deletePendingSessionRequest(c.id, $i("USER_DISCONNECTED"))
      }), s && this.client.events.emit("session_delete", {
        id: o,
        topic: r
      })
    }, this.deleteProposal = async (n, r) => {
      await Promise.all([this.client.proposal.delete(n, $i("USER_DISCONNECTED")), r ? Promise.resolve() : this.client.core.expirer.del(n)]), this.addToRecentlyDeleted(n, "proposal")
    }, this.deletePendingSessionRequest = async (n, r, i = !1) => {
      await Promise.all([this.client.pendingRequest.delete(n, r), i ? Promise.resolve() : this.client.core.expirer.del(n)]), this.addToRecentlyDeleted(n, "request"), this.sessionRequestQueue.queue = this.sessionRequestQueue.queue.filter(s => s.id !== n), i && (this.sessionRequestQueue.state = zl.idle, this.client.events.emit("session_request_expire", {
        id: n
      }))
    }, this.setExpiry = async (n, r) => {
      this.client.session.keys.includes(n) && await this.client.session.update(n, {
        expiry: r
      }), this.client.core.expirer.set(n, r)
    }, this.setProposal = async (n, r) => {
      await this.client.proposal.set(n, r), this.client.core.expirer.set(n, jl(Ul.wc_sessionPropose.req.ttl))
    }, this.setPendingSessionRequest = async n => {
      const {
        id: r,
        topic: i,
        params: s,
        verifyContext: o
      } = n, a = s.request.expiryTimestamp || jl(Ul.wc_sessionRequest.req.ttl);
      await this.client.pendingRequest.set(r, {
        id: r,
        topic: i,
        params: s,
        verifyContext: o
      }), a && this.client.core.expirer.set(r, a)
    }, this.sendRequest = async n => {
      const {
        topic: r,
        method: i,
        params: s,
        expiry: o,
        relayRpcId: a,
        clientRpcId: c,
        throwOnFailedPublish: l
      } = n, u = vp(i, s, c);
      if (E_() && yUe.includes(i)) {
        const g = T8(JSON.stringify(u));
        this.client.core.verify.register({
          attestationId: g
        })
      }
      let f;
      try {
        f = await this.client.core.crypto.encode(r, u)
      } catch (g) {
        throw await this.cleanup(), this.client.logger.error(`sendRequest() -> core.crypto.encode() for topic ${r} failed`), g
      }
      const h = Ul[i].req;
      return o && (h.ttl = o), a && (h.id = a), this.client.core.history.set(r, u), l ? (h.internal = v0(ws({}, h.internal), {
        throwOnFailedPublish: !0
      }), await this.client.core.relayer.publish(r, f, h)) : this.client.core.relayer.publish(r, f, h).catch(g => this.client.logger.error(g)), u.id
    }, this.sendResult = async n => {
      const {
        id: r,
        topic: i,
        result: s,
        throwOnFailedPublish: o
      } = n, a = aE(r, s);
      let c;
      try {
        c = await this.client.core.crypto.encode(i, a)
      } catch (f) {
        throw await this.cleanup(), this.client.logger.error(`sendResult() -> core.crypto.encode() for topic ${i} failed`), f
      }
      let l;
      try {
        l = await this.client.core.history.get(i, r)
      } catch (f) {
        throw this.client.logger.error(`sendResult() -> history.get(${i}, ${r}) failed`), f
      }
      const u = Ul[l.request.method].res;
      o ? (u.internal = v0(ws({}, u.internal), {
        throwOnFailedPublish: !0
      }), await this.client.core.relayer.publish(i, c, u)) : this.client.core.relayer.publish(i, c, u).catch(f => this.client.logger.error(f)), await this.client.core.history.resolve(a)
    }, this.sendError = async (n, r, i) => {
      const s = cE(n, i);
      let o;
      try {
        o = await this.client.core.crypto.encode(r, s)
      } catch (l) {
        throw await this.cleanup(), this.client.logger.error(`sendError() -> core.crypto.encode() for topic ${r} failed`), l
      }
      let a;
      try {
        a = await this.client.core.history.get(r, n)
      } catch (l) {
        throw this.client.logger.error(`sendError() -> history.get(${r}, ${n}) failed`), l
      }
      const c = Ul[a.request.method].res;
      this.client.core.relayer.publish(r, o, c), await this.client.core.history.resolve(s)
    }, this.cleanup = async () => {
      const n = [],
        r = [];
      this.client.session.getAll().forEach(i => {
        let s = !1;
        y0(i.expiry) && (s = !0), this.client.core.crypto.keychain.has(i.topic) || (s = !0), s && n.push(i.topic)
      }), this.client.proposal.getAll().forEach(i => {
        y0(i.expiryTimestamp) && r.push(i.id)
      }), await Promise.all([...n.map(i => this.deleteSession({
        topic: i
      })), ...r.map(i => this.deleteProposal(i))])
    }, this.onRelayEventRequest = async n => {
      this.requestQueue.queue.push(n), await this.processRequestsQueue()
    }, this.processRequestsQueue = async () => {
      if (this.requestQueue.state === zl.active) {
        this.client.logger.info("Request queue already active, skipping...");
        return
      }
      for (this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`); this.requestQueue.queue.length > 0;) {
        this.requestQueue.state = zl.active;
        const n = this.requestQueue.queue.shift();
        if (n) try {
          this.processRequest(n), await new Promise(r => setTimeout(r, 300))
        } catch (r) {
          this.client.logger.warn(r)
        }
      }
      this.requestQueue.state = zl.idle
    }, this.processRequest = n => {
      const {
        topic: r,
        payload: i
      } = n, s = i.method;
      switch (s) {
        case "wc_sessionPropose":
          return this.onSessionProposeRequest(r, i);
        case "wc_sessionSettle":
          return this.onSessionSettleRequest(r, i);
        case "wc_sessionUpdate":
          return this.onSessionUpdateRequest(r, i);
        case "wc_sessionExtend":
          return this.onSessionExtendRequest(r, i);
        case "wc_sessionPing":
          return this.onSessionPingRequest(r, i);
        case "wc_sessionDelete":
          return this.onSessionDeleteRequest(r, i);
        case "wc_sessionRequest":
          return this.onSessionRequest(r, i);
        case "wc_sessionEvent":
          return this.onSessionEventRequest(r, i);
        default:
          return this.client.logger.info(`Unsupported request method ${s}`)
      }
    }, this.onRelayEventResponse = async n => {
      const {
        topic: r,
        payload: i
      } = n, s = (await this.client.core.history.get(r, i.id)).request.method;
      switch (s) {
        case "wc_sessionPropose":
          return this.onSessionProposeResponse(r, i);
        case "wc_sessionSettle":
          return this.onSessionSettleResponse(r, i);
        case "wc_sessionUpdate":
          return this.onSessionUpdateResponse(r, i);
        case "wc_sessionExtend":
          return this.onSessionExtendResponse(r, i);
        case "wc_sessionPing":
          return this.onSessionPingResponse(r, i);
        case "wc_sessionRequest":
          return this.onSessionRequestResponse(r, i);
        default:
          return this.client.logger.info(`Unsupported response method ${s}`)
      }
    }, this.onRelayEventUnknownPayload = n => {
      const {
        topic: r
      } = n, {
        message: i
      } = Mt("MISSING_OR_INVALID", `Decoded payload on topic ${r} is not identifiable as a JSON-RPC request or a response.`);
      throw new Error(i)
    }, this.onSessionProposeRequest = async (n, r) => {
      const {
        params: i,
        id: s
      } = r;
      try {
        this.isValidConnect(ws({}, r.params));
        const o = i.expiryTimestamp || jl(Ul.wc_sessionPropose.req.ttl),
          a = ws({
            id: s,
            pairingTopic: n,
            expiryTimestamp: o
          }, i);
        await this.setProposal(s, a);
        const c = T8(JSON.stringify(r)),
          l = await this.getVerifyContext(c, a.proposer.metadata);
        this.client.events.emit("session_proposal", {
          id: s,
          params: a,
          verifyContext: l
        })
      } catch (o) {
        await this.sendError(s, n, o), this.client.logger.error(o)
      }
    }, this.onSessionProposeResponse = async (n, r) => {
      const {
        id: i
      } = r;
      if (Kl(r)) {
        const {
          result: s
        } = r;
        this.client.logger.trace({
          type: "method",
          method: "onSessionProposeResponse",
          result: s
        });
        const o = this.client.proposal.get(i);
        this.client.logger.trace({
          type: "method",
          method: "onSessionProposeResponse",
          proposal: o
        });
        const a = o.proposer.publicKey;
        this.client.logger.trace({
          type: "method",
          method: "onSessionProposeResponse",
          selfPublicKey: a
        });
        const c = s.responderPublicKey;
        this.client.logger.trace({
          type: "method",
          method: "onSessionProposeResponse",
          peerPublicKey: c
        });
        const l = await this.client.core.crypto.generateSharedKey(a, c);
        this.client.logger.trace({
          type: "method",
          method: "onSessionProposeResponse",
          sessionTopic: l
        });
        const u = await this.client.core.relayer.subscribe(l);
        this.client.logger.trace({
          type: "method",
          method: "onSessionProposeResponse",
          subscriptionId: u
        }), await this.client.core.pairing.activate({
          topic: n
        })
      } else if (oc(r)) {
        await this.client.proposal.delete(i, $i("USER_DISCONNECTED"));
        const s = pr("session_connect");
        if (this.events.listenerCount(s) === 0) throw new Error(`emitting ${s} without any listeners, 954`);
        this.events.emit(pr("session_connect"), {
          error: r.error
        })
      }
    }, this.onSessionSettleRequest = async (n, r) => {
      const {
        id: i,
        params: s
      } = r;
      try {
        this.isValidSessionSettleRequest(s);
        const {
          relay: o,
          controller: a,
          expiry: c,
          namespaces: l,
          sessionProperties: u,
          pairingTopic: f
        } = r.params, h = ws({
          topic: n,
          relay: o,
          expiry: c,
          namespaces: l,
          acknowledged: !0,
          pairingTopic: f,
          requiredNamespaces: {},
          optionalNamespaces: {},
          controller: a.publicKey,
          self: {
            publicKey: "",
            metadata: this.client.metadata
          },
          peer: {
            publicKey: a.publicKey,
            metadata: a.metadata
          }
        }, u && {
          sessionProperties: u
        });
        await this.sendResult({
          id: r.id,
          topic: n,
          result: !0,
          throwOnFailedPublish: !0
        });
        const g = pr("session_connect");
        if (this.events.listenerCount(g) === 0) throw new Error(`emitting ${g} without any listeners 997`);
        this.events.emit(pr("session_connect"), {
          session: h
        }), this.cleanupDuplicatePairings(h)
      } catch (o) {
        await this.sendError(i, n, o), this.client.logger.error(o)
      }
    }, this.onSessionSettleResponse = async (n, r) => {
      const {
        id: i
      } = r;
      Kl(r) ? (await this.client.session.update(n, {
        acknowledged: !0
      }), this.events.emit(pr("session_approve", i), {})) : oc(r) && (await this.client.session.delete(n, $i("USER_DISCONNECTED")), this.events.emit(pr("session_approve", i), {
        error: r.error
      }))
    }, this.onSessionUpdateRequest = async (n, r) => {
      const {
        params: i,
        id: s
      } = r;
      try {
        const o = `${n}_session_update`,
          a = qg.get(o);
        if (a && this.isRequestOutOfSync(a, s)) {
          this.client.logger.info(`Discarding out of sync request - ${s}`), this.sendError(s, n, $i("INVALID_UPDATE_REQUEST"));
          return
        }
        this.isValidUpdate(ws({
          topic: n
        }, i));
        try {
          qg.set(o, s), await this.client.session.update(n, {
            namespaces: i.namespaces
          }), await this.sendResult({
            id: s,
            topic: n,
            result: !0,
            throwOnFailedPublish: !0
          })
        } catch (c) {
          throw qg.delete(o), c
        }
        this.client.events.emit("session_update", {
          id: s,
          topic: n,
          params: i
        })
      } catch (o) {
        await this.sendError(s, n, o), this.client.logger.error(o)
      }
    }, this.isRequestOutOfSync = (n, r) => parseInt(r.toString().slice(0, -3)) <= parseInt(n.toString().slice(0, -3)), this.onSessionUpdateResponse = (n, r) => {
      const {
        id: i
      } = r, s = pr("session_update", i);
      if (this.events.listenerCount(s) === 0) throw new Error(`emitting ${s} without any listeners`);
      Kl(r) ? this.events.emit(pr("session_update", i), {}) : oc(r) && this.events.emit(pr("session_update", i), {
        error: r.error
      })
    }, this.onSessionExtendRequest = async (n, r) => {
      const {
        id: i
      } = r;
      try {
        this.isValidExtend({
          topic: n
        }), await this.setExpiry(n, jl(Fb)), await this.sendResult({
          id: i,
          topic: n,
          result: !0,
          throwOnFailedPublish: !0
        }), this.client.events.emit("session_extend", {
          id: i,
          topic: n
        })
      } catch (s) {
        await this.sendError(i, n, s), this.client.logger.error(s)
      }
    }, this.onSessionExtendResponse = (n, r) => {
      const {
        id: i
      } = r, s = pr("session_extend", i);
      if (this.events.listenerCount(s) === 0) throw new Error(`emitting ${s} without any listeners`);
      Kl(r) ? this.events.emit(pr("session_extend", i), {}) : oc(r) && this.events.emit(pr("session_extend", i), {
        error: r.error
      })
    }, this.onSessionPingRequest = async (n, r) => {
      const {
        id: i
      } = r;
      try {
        this.isValidPing({
          topic: n
        }), await this.sendResult({
          id: i,
          topic: n,
          result: !0,
          throwOnFailedPublish: !0
        }), this.client.events.emit("session_ping", {
          id: i,
          topic: n
        })
      } catch (s) {
        await this.sendError(i, n, s), this.client.logger.error(s)
      }
    }, this.onSessionPingResponse = (n, r) => {
      const {
        id: i
      } = r, s = pr("session_ping", i);
      if (this.events.listenerCount(s) === 0) throw new Error(`emitting ${s} without any listeners`);
      setTimeout(() => {
        Kl(r) ? this.events.emit(pr("session_ping", i), {}) : oc(r) && this.events.emit(pr("session_ping", i), {
          error: r.error
        })
      }, 500)
    }, this.onSessionDeleteRequest = async (n, r) => {
      const {
        id: i
      } = r;
      try {
        this.isValidDisconnect({
          topic: n,
          reason: r.params
        }), await Promise.all([new Promise(s => {
          this.client.core.relayer.once($o.publish, async () => {
            s(await this.deleteSession({
              topic: n,
              id: i
            }))
          })
        }), this.sendResult({
          id: i,
          topic: n,
          result: !0,
          throwOnFailedPublish: !0
        }), this.cleanupPendingSentRequestsForTopic({
          topic: n,
          error: $i("USER_DISCONNECTED")
        })])
      } catch (s) {
        this.client.logger.error(s)
      }
    }, this.onSessionRequest = async (n, r) => {
      const {
        id: i,
        params: s
      } = r;
      try {
        this.isValidRequest(ws({
          topic: n
        }, s));
        const o = T8(JSON.stringify(vp("wc_sessionRequest", s, i))),
          a = this.client.session.get(n),
          c = await this.getVerifyContext(o, a.peer.metadata),
          l = {
            id: i,
            topic: n,
            params: s,
            verifyContext: c
          };
        await this.setPendingSessionRequest(l), this.addSessionRequestToSessionRequestQueue(l), this.processSessionRequestQueue()
      } catch (o) {
        await this.sendError(i, n, o), this.client.logger.error(o)
      }
    }, this.onSessionRequestResponse = (n, r) => {
      const {
        id: i
      } = r, s = pr("session_request", i);
      if (this.events.listenerCount(s) === 0) throw new Error(`emitting ${s} without any listeners`);
      Kl(r) ? this.events.emit(pr("session_request", i), {
        result: r.result
      }) : oc(r) && this.events.emit(pr("session_request", i), {
        error: r.error
      })
    }, this.onSessionEventRequest = async (n, r) => {
      const {
        id: i,
        params: s
      } = r;
      try {
        const o = `${n}_session_event_${s.event.name}`,
          a = qg.get(o);
        if (a && this.isRequestOutOfSync(a, i)) {
          this.client.logger.info(`Discarding out of sync request - ${i}`);
          return
        }
        this.isValidEmit(ws({
          topic: n
        }, s)), this.client.events.emit("session_event", {
          id: i,
          topic: n,
          params: s
        }), qg.set(o, i)
      } catch (o) {
        await this.sendError(i, n, o), this.client.logger.error(o)
      }
    }, this.addSessionRequestToSessionRequestQueue = n => {
      this.sessionRequestQueue.queue.push(n)
    }, this.cleanupAfterResponse = n => {
      this.deletePendingSessionRequest(n.response.id, {
        message: "fulfilled",
        code: 0
      }), setTimeout(() => {
        this.sessionRequestQueue.state = zl.idle, this.processSessionRequestQueue()
      }, it.toMiliseconds(this.requestQueueDelay))
    }, this.cleanupPendingSentRequestsForTopic = ({
      topic: n,
      error: r
    }) => {
      const i = this.client.core.history.pending;
      i.length > 0 && i.filter(s => s.topic === n && s.request.method === "wc_sessionRequest").forEach(s => {
        const o = s.request.id,
          a = pr("session_request", o);
        if (this.events.listenerCount(a) === 0) throw new Error(`emitting ${a} without any listeners`);
        this.events.emit(pr("session_request", s.request.id), {
          error: r
        })
      })
    }, this.processSessionRequestQueue = () => {
      if (this.sessionRequestQueue.state === zl.active) {
        this.client.logger.info("session request queue is already active.");
        return
      }
      const n = this.sessionRequestQueue.queue[0];
      if (!n) {
        this.client.logger.info("session request queue is empty.");
        return
      }
      try {
        this.sessionRequestQueue.state = zl.active, this.client.events.emit("session_request", n)
      } catch (r) {
        this.client.logger.error(r)
      }
    }, this.onPairingCreated = n => {
      if (n.active) return;
      const r = this.client.proposal.getAll().find(i => i.pairingTopic === n.topic);
      r && this.onSessionProposeRequest(n.topic, vp("wc_sessionPropose", {
        requiredNamespaces: r.requiredNamespaces,
        optionalNamespaces: r.optionalNamespaces,
        relays: r.relays,
        proposer: r.proposer,
        sessionProperties: r.sessionProperties
      }, r.id))
    }, this.isValidConnect = async n => {
      if (!Za(n)) {
        const {
          message: c
        } = Mt("MISSING_OR_INVALID", `connect() params: ${JSON.stringify(n)}`);
        throw new Error(c)
      }
      const {
        pairingTopic: r,
        requiredNamespaces: i,
        optionalNamespaces: s,
        sessionProperties: o,
        relays: a
      } = n;
      if (wa(r) || await this.isValidPairingTopic(r), !nUe(a, !0)) {
        const {
          message: c
        } = Mt("MISSING_OR_INVALID", `connect() relays: ${a}`);
        throw new Error(c)
      }!wa(i) && gx(i) !== 0 && this.validateNamespaces(i, "requiredNamespaces"), !wa(s) && gx(s) !== 0 && this.validateNamespaces(s, "optionalNamespaces"), wa(o) || this.validateSessionProps(o, "sessionProperties")
    }, this.validateNamespaces = (n, r) => {
      const i = tUe(n, "connect()", r);
      if (i) throw new Error(i.message)
    }, this.isValidApprove = async n => {
      if (!Za(n)) throw new Error(Mt("MISSING_OR_INVALID", `approve() params: ${n}`).message);
      const {
        id: r,
        namespaces: i,
        relayProtocol: s,
        sessionProperties: o
      } = n;
      this.checkRecentlyDeleted(r), await this.isValidProposalId(r);
      const a = this.client.proposal.get(r),
        c = k8(i, "approve()");
      if (c) throw new Error(c.message);
      const l = rB(a.requiredNamespaces, i, "approve()");
      if (l) throw new Error(l.message);
      if (!os(s, !0)) {
        const {
          message: u
        } = Mt("MISSING_OR_INVALID", `approve() relayProtocol: ${s}`);
        throw new Error(u)
      }
      wa(o) || this.validateSessionProps(o, "sessionProperties")
    }, this.isValidReject = async n => {
      if (!Za(n)) {
        const {
          message: s
        } = Mt("MISSING_OR_INVALID", `reject() params: ${n}`);
        throw new Error(s)
      }
      const {
        id: r,
        reason: i
      } = n;
      if (this.checkRecentlyDeleted(r), await this.isValidProposalId(r), !iUe(i)) {
        const {
          message: s
        } = Mt("MISSING_OR_INVALID", `reject() reason: ${JSON.stringify(i)}`);
        throw new Error(s)
      }
    }, this.isValidSessionSettleRequest = n => {
      if (!Za(n)) {
        const {
          message: l
        } = Mt("MISSING_OR_INVALID", `onSessionSettleRequest() params: ${n}`);
        throw new Error(l)
      }
      const {
        relay: r,
        controller: i,
        namespaces: s,
        expiry: o
      } = n;
      if (!cJ(r)) {
        const {
          message: l
        } = Mt("MISSING_OR_INVALID", "onSessionSettleRequest() relay protocol should be a string");
        throw new Error(l)
      }
      const a = Qje(i, "onSessionSettleRequest()");
      if (a) throw new Error(a.message);
      const c = k8(s, "onSessionSettleRequest()");
      if (c) throw new Error(c.message);
      if (y0(o)) {
        const {
          message: l
        } = Mt("EXPIRED", "onSessionSettleRequest()");
        throw new Error(l)
      }
    }, this.isValidUpdate = async n => {
      if (!Za(n)) {
        const {
          message: c
        } = Mt("MISSING_OR_INVALID", `update() params: ${n}`);
        throw new Error(c)
      }
      const {
        topic: r,
        namespaces: i
      } = n;
      this.checkRecentlyDeleted(r), await this.isValidSessionTopic(r);
      const s = this.client.session.get(r),
        o = k8(i, "update()");
      if (o) throw new Error(o.message);
      const a = rB(s.requiredNamespaces, i, "update()");
      if (a) throw new Error(a.message)
    }, this.isValidExtend = async n => {
      if (!Za(n)) {
        const {
          message: i
        } = Mt("MISSING_OR_INVALID", `extend() params: ${n}`);
        throw new Error(i)
      }
      const {
        topic: r
      } = n;
      this.checkRecentlyDeleted(r), await this.isValidSessionTopic(r)
    }, this.isValidRequest = async n => {
      if (!Za(n)) {
        const {
          message: c
        } = Mt("MISSING_OR_INVALID", `request() params: ${n}`);
        throw new Error(c)
      }
      const {
        topic: r,
        request: i,
        chainId: s,
        expiry: o
      } = n;
      this.checkRecentlyDeleted(r), await this.isValidSessionTopic(r);
      const {
        namespaces: a
      } = this.client.session.get(r);
      if (!nB(a, s)) {
        const {
          message: c
        } = Mt("MISSING_OR_INVALID", `request() chainId: ${s}`);
        throw new Error(c)
      }
      if (!sUe(i)) {
        const {
          message: c
        } = Mt("MISSING_OR_INVALID", `request() ${JSON.stringify(i)}`);
        throw new Error(c)
      }
      if (!cUe(a, s, i.method)) {
        const {
          message: c
        } = Mt("MISSING_OR_INVALID", `request() method: ${i.method}`);
        throw new Error(c)
      }
      if (o && !fUe(o, P8)) {
        const {
          message: c
        } = Mt("MISSING_OR_INVALID", `request() expiry: ${o}. Expiry must be a number (in seconds) between ${P8.min} and ${P8.max}`);
        throw new Error(c)
      }
    }, this.isValidRespond = async n => {
      var r;
      if (!Za(n)) {
        const {
          message: o
        } = Mt("MISSING_OR_INVALID", `respond() params: ${n}`);
        throw new Error(o)
      }
      const {
        topic: i,
        response: s
      } = n;
      try {
        await this.isValidSessionTopic(i)
      } catch (o) {
        throw (r = n == null ? void 0 : n.response) != null && r.id && this.cleanupAfterResponse(n), o
      }
      if (!oUe(s)) {
        const {
          message: o
        } = Mt("MISSING_OR_INVALID", `respond() response: ${JSON.stringify(s)}`);
        throw new Error(o)
      }
    }, this.isValidPing = async n => {
      if (!Za(n)) {
        const {
          message: i
        } = Mt("MISSING_OR_INVALID", `ping() params: ${n}`);
        throw new Error(i)
      }
      const {
        topic: r
      } = n;
      await this.isValidSessionOrPairingTopic(r)
    }, this.isValidEmit = async n => {
      if (!Za(n)) {
        const {
          message: a
        } = Mt("MISSING_OR_INVALID", `emit() params: ${n}`);
        throw new Error(a)
      }
      const {
        topic: r,
        event: i,
        chainId: s
      } = n;
      await this.isValidSessionTopic(r);
      const {
        namespaces: o
      } = this.client.session.get(r);
      if (!nB(o, s)) {
        const {
          message: a
        } = Mt("MISSING_OR_INVALID", `emit() chainId: ${s}`);
        throw new Error(a)
      }
      if (!aUe(i)) {
        const {
          message: a
        } = Mt("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(i)}`);
        throw new Error(a)
      }
      if (!lUe(o, s, i.name)) {
        const {
          message: a
        } = Mt("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(i)}`);
        throw new Error(a)
      }
    }, this.isValidDisconnect = async n => {
      if (!Za(n)) {
        const {
          message: i
        } = Mt("MISSING_OR_INVALID", `disconnect() params: ${n}`);
        throw new Error(i)
      }
      const {
        topic: r
      } = n;
      await this.isValidSessionOrPairingTopic(r)
    }, this.getVerifyContext = async (n, r) => {
      const i = {
        verified: {
          verifyUrl: r.verifyUrl || ep,
          validation: "UNKNOWN",
          origin: r.url || ""
        }
      };
      try {
        const s = await this.client.core.verify.resolve({
          attestationId: n,
          verifyUrl: r.verifyUrl
        });
        s && (i.verified.origin = s.origin, i.verified.isScam = s.isScam, i.verified.validation = s.origin === new URL(r.url).origin ? "VALID" : "INVALID")
      } catch (s) {
        this.client.logger.info(s)
      }
      return this.client.logger.info(`Verify context: ${JSON.stringify(i)}`), i
    }, this.validateSessionProps = (n, r) => {
      Object.values(n).forEach(i => {
        if (!os(i, !1)) {
          const {
            message: s
          } = Mt("MISSING_OR_INVALID", `${r} must be in Record<string, string> format. Received: ${JSON.stringify(i)}`);
          throw new Error(s)
        }
      })
    }, this.addToRecentlyDeleted = (n, r) => {
      if (this.recentlyDeletedMap.set(n, r), this.recentlyDeletedMap.size >= this.recentlyDeletedLimit) {
        let i = 0;
        const s = this.recentlyDeletedLimit / 2;
        for (const o of this.recentlyDeletedMap.keys()) {
          if (i++ >= s) break;
          this.recentlyDeletedMap.delete(o)
        }
      }
    }, this.checkRecentlyDeleted = n => {
      const r = this.recentlyDeletedMap.get(n);
      if (r) {
        const {
          message: i
        } = Mt("MISSING_OR_INVALID", `Record was recently deleted - ${r}: ${n}`);
        throw new Error(i)
      }
    }
  }
  async isInitialized() {
    if (!this.initialized) {
      const {
        message: t
      } = Mt("NOT_INITIALIZED", this.name);
      throw new Error(t)
    }
    await this.client.core.relayer.confirmOnlineStateOrThrow()
  }
  registerRelayerEvents() {
    this.client.core.relayer.on($o.message, async t => {
      const {
        topic: n,
        message: r
      } = t;
      if (this.ignoredPayloadTypes.includes(this.client.core.crypto.getPayloadType(r))) return;
      const i = await this.client.core.crypto.decode(n, r);
      try {
        w_(i) ? (this.client.core.history.set(n, i), this.onRelayEventRequest({
          topic: n,
          payload: i
        })) : lE(i) ? (await this.client.core.history.resolve(i), await this.onRelayEventResponse({
          topic: n,
          payload: i
        }), this.client.core.history.delete(n, i.id)) : this.onRelayEventUnknownPayload({
          topic: n,
          payload: i
        })
      } catch (s) {
        this.client.logger.error(s)
      }
    })
  }
  registerExpirerEvents() {
    this.client.core.expirer.on(fa.expired, async t => {
      const {
        topic: n,
        id: r
      } = Fje(t.target);
      if (r && this.client.pendingRequest.keys.includes(r)) return await this.deletePendingSessionRequest(r, Mt("EXPIRED"), !0);
      n ? this.client.session.keys.includes(n) && (await this.deleteSession({
        topic: n,
        expirerHasDeleted: !0
      }), this.client.events.emit("session_expire", {
        topic: n
      })) : r && (await this.deleteProposal(r, !0), this.client.events.emit("proposal_expire", {
        id: r
      }))
    })
  }
  registerPairingEvents() {
    this.client.core.pairing.events.on(Z0.create, t => this.onPairingCreated(t)), this.client.core.pairing.events.on(Z0.delete, t => {
      this.addToRecentlyDeleted(t.topic, "pairing")
    })
  }
  isValidPairingTopic(t) {
    if (!os(t, !1)) {
      const {
        message: n
      } = Mt("MISSING_OR_INVALID", `pairing topic should be a string: ${t}`);
      throw new Error(n)
    }
    if (!this.client.core.pairing.pairings.keys.includes(t)) {
      const {
        message: n
      } = Mt("NO_MATCHING_KEY", `pairing topic doesn't exist: ${t}`);
      throw new Error(n)
    }
    if (y0(this.client.core.pairing.pairings.get(t).expiry)) {
      const {
        message: n
      } = Mt("EXPIRED", `pairing topic: ${t}`);
      throw new Error(n)
    }
  }
  async isValidSessionTopic(t) {
    if (!os(t, !1)) {
      const {
        message: n
      } = Mt("MISSING_OR_INVALID", `session topic should be a string: ${t}`);
      throw new Error(n)
    }
    if (this.checkRecentlyDeleted(t), !this.client.session.keys.includes(t)) {
      const {
        message: n
      } = Mt("NO_MATCHING_KEY", `session topic doesn't exist: ${t}`);
      throw new Error(n)
    }
    if (y0(this.client.session.get(t).expiry)) {
      await this.deleteSession({
        topic: t
      });
      const {
        message: n
      } = Mt("EXPIRED", `session topic: ${t}`);
      throw new Error(n)
    }
    if (!this.client.core.crypto.keychain.has(t)) {
      const {
        message: n
      } = Mt("MISSING_OR_INVALID", `session topic does not exist in keychain: ${t}`);
      throw await this.deleteSession({
        topic: t
      }), new Error(n)
    }
  }
  async isValidSessionOrPairingTopic(t) {
    if (this.checkRecentlyDeleted(t), this.client.session.keys.includes(t)) await this.isValidSessionTopic(t);
    else if (this.client.core.pairing.pairings.keys.includes(t)) this.isValidPairingTopic(t);
    else if (os(t, !1)) {
      const {
        message: n
      } = Mt("NO_MATCHING_KEY", `session or pairing topic doesn't exist: ${t}`);
      throw new Error(n)
    } else {
      const {
        message: n
      } = Mt("MISSING_OR_INVALID", `session or pairing topic should be a string: ${t}`);
      throw new Error(n)
    }
  }
  async isValidProposalId(t) {
    if (!rUe(t)) {
      const {
        message: n
      } = Mt("MISSING_OR_INVALID", `proposal id should be a number: ${t}`);
      throw new Error(n)
    }
    if (!this.client.proposal.keys.includes(t)) {
      const {
        message: n
      } = Mt("NO_MATCHING_KEY", `proposal id doesn't exist: ${t}`);
      throw new Error(n)
    }
    if (y0(this.client.proposal.get(t).expiryTimestamp)) {
      await this.deleteProposal(t);
      const {
        message: n
      } = Mt("EXPIRED", `proposal id: ${t}`);
      throw new Error(n)
    }
  }
}
class CUe extends dE {
  constructor(t, n) {
    super(t, n, hUe, C_), this.core = t, this.logger = n
  }
}
class AUe extends dE {
  constructor(t, n) {
    super(t, n, pUe, C_), this.core = t, this.logger = n
  }
}
class TUe extends dE {
  constructor(t, n) {
    super(t, n, gUe, C_, r => r.id), this.core = t, this.logger = n
  }
}
let kUe = class hJ extends y$e {
  constructor(t) {
    super(t), this.protocol = lJ, this.version = uJ, this.name = I8.name, this.events = new si.EventEmitter, this.on = (r, i) => this.events.on(r, i), this.once = (r, i) => this.events.once(r, i), this.off = (r, i) => this.events.off(r, i), this.removeListener = (r, i) => this.events.removeListener(r, i), this.removeAllListeners = r => this.events.removeAllListeners(r), this.connect = async r => {
      try {
        return await this.engine.connect(r)
      } catch (i) {
        throw this.logger.error(i.message), i
      }
    }, this.pair = async r => {
      try {
        return await this.engine.pair(r)
      } catch (i) {
        throw this.logger.error(i.message), i
      }
    }, this.approve = async r => {
      try {
        return await this.engine.approve(r)
      } catch (i) {
        throw this.logger.error(i.message), i
      }
    }, this.reject = async r => {
      try {
        return await this.engine.reject(r)
      } catch (i) {
        throw this.logger.error(i.message), i
      }
    }, this.update = async r => {
      try {
        return await this.engine.update(r)
      } catch (i) {
        throw this.logger.error(i.message), i
      }
    }, this.extend = async r => {
      try {
        return await this.engine.extend(r)
      } catch (i) {
        throw this.logger.error(i.message), i
      }
    }, this.request = async r => {
      try {
        return await this.engine.request(r)
      } catch (i) {
        throw this.logger.error(i.message), i
      }
    }, this.respond = async r => {
      try {
        return await this.engine.respond(r)
      } catch (i) {
        throw this.logger.error(i.message), i
      }
    }, this.ping = async r => {
      try {
        return await this.engine.ping(r)
      } catch (i) {
        throw this.logger.error(i.message), i
      }
    }, this.emit = async r => {
      try {
        return await this.engine.emit(r)
      } catch (i) {
        throw this.logger.error(i.message), i
      }
    }, this.disconnect = async r => {
      try {
        return await this.engine.disconnect(r)
      } catch (i) {
        throw this.logger.error(i.message), i
      }
    }, this.find = r => {
      try {
        return this.engine.find(r)
      } catch (i) {
        throw this.logger.error(i.message), i
      }
    }, this.getPendingSessionRequests = () => {
      try {
        return this.engine.getPendingSessionRequests()
      } catch (r) {
        throw this.logger.error(r.message), r
      }
    }, this.name = (t == null ? void 0 : t.name) || I8.name, this.metadata = (t == null ? void 0 : t.metadata) || Bje();
    const n = typeof (t == null ? void 0 : t.logger) < "u" && typeof (t == null ? void 0 : t.logger) != "string" ? t.logger : vn.pino(vn.getDefaultLoggerOptions({
      level: (t == null ? void 0 : t.logger) || I8.logger
    }));
    this.core = (t == null ? void 0 : t.core) || new Pje(t), this.logger = vn.generateChildLogger(n, this.name), this.session = new AUe(this.core, this.logger), this.proposal = new CUe(this.core, this.logger), this.pendingRequest = new TUe(this.core, this.logger), this.engine = new SUe(this)
  }
  static async init(t) {
    const n = new hJ(t);
    return await n.initialize(), n
  }
  get context() {
    return vn.getLoggerContext(this.logger)
  }
  get pairing() {
    return this.core.pairing.pairings
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.core.start(), await this.session.init(), await this.proposal.init(), await this.pendingRequest.init(), await this.engine.init(), this.core.verify.init({
        verifyUrl: this.metadata.verifyUrl
      }), this.logger.info("SignClient Initialization Success")
    } catch (t) {
      throw this.logger.info("SignClient Initialization Failure"), this.logger.error(t.message), t
    }
  }
};
var _Ue = {};
(function (e) {
  const t = tE,
    n = nE,
    r = rE,
    i = iE,
    s = p => p == null,
    o = Symbol("encodeFragmentIdentifier");

  function a(p) {
    switch (p.arrayFormat) {
      case "index":
        return v => (S, I) => {
          const A = S.length;
          return I === void 0 || p.skipNull && I === null || p.skipEmptyString && I === "" ? S : I === null ? [...S, [u(v, p), "[", A, "]"].join("")] : [...S, [u(v, p), "[", u(A, p), "]=", u(I, p)].join("")]
        };
      case "bracket":
        return v => (S, I) => I === void 0 || p.skipNull && I === null || p.skipEmptyString && I === "" ? S : I === null ? [...S, [u(v, p), "[]"].join("")] : [...S, [u(v, p), "[]=", u(I, p)].join("")];
      case "colon-list-separator":
        return v => (S, I) => I === void 0 || p.skipNull && I === null || p.skipEmptyString && I === "" ? S : I === null ? [...S, [u(v, p), ":list="].join("")] : [...S, [u(v, p), ":list=", u(I, p)].join("")];
      case "comma":
      case "separator":
      case "bracket-separator": {
        const v = p.arrayFormat === "bracket-separator" ? "[]=" : "=";
        return S => (I, A) => A === void 0 || p.skipNull && A === null || p.skipEmptyString && A === "" ? I : (A = A === null ? "" : A, I.length === 0 ? [
          [u(S, p), v, u(A, p)].join("")
        ] : [
          [I, u(A, p)].join(p.arrayFormatSeparator)
        ])
      }
      default:
        return v => (S, I) => I === void 0 || p.skipNull && I === null || p.skipEmptyString && I === "" ? S : I === null ? [...S, u(v, p)] : [...S, [u(v, p), "=", u(I, p)].join("")]
    }
  }

  function c(p) {
    let v;
    switch (p.arrayFormat) {
      case "index":
        return (S, I, A) => {
          if (v = /\[(\d*)\]$/.exec(S), S = S.replace(/\[\d*\]$/, ""), !v) {
            A[S] = I;
            return
          }
          A[S] === void 0 && (A[S] = {}), A[S][v[1]] = I
        };
      case "bracket":
        return (S, I, A) => {
          if (v = /(\[\])$/.exec(S), S = S.replace(/\[\]$/, ""), !v) {
            A[S] = I;
            return
          }
          if (A[S] === void 0) {
            A[S] = [I];
            return
          }
          A[S] = [].concat(A[S], I)
        };
      case "colon-list-separator":
        return (S, I, A) => {
          if (v = /(:list)$/.exec(S), S = S.replace(/:list$/, ""), !v) {
            A[S] = I;
            return
          }
          if (A[S] === void 0) {
            A[S] = [I];
            return
          }
          A[S] = [].concat(A[S], I)
        };
      case "comma":
      case "separator":
        return (S, I, A) => {
          const w = typeof I == "string" && I.includes(p.arrayFormatSeparator),
            E = typeof I == "string" && !w && f(I, p).includes(p.arrayFormatSeparator);
          I = E ? f(I, p) : I;
          const D = w || E ? I.split(p.arrayFormatSeparator).map($ => f($, p)) : I === null ? I : f(I, p);
          A[S] = D
        };
      case "bracket-separator":
        return (S, I, A) => {
          const w = /(\[\])$/.test(S);
          if (S = S.replace(/\[\]$/, ""), !w) {
            A[S] = I && f(I, p);
            return
          }
          const E = I === null ? [] : I.split(p.arrayFormatSeparator).map(D => f(D, p));
          if (A[S] === void 0) {
            A[S] = E;
            return
          }
          A[S] = [].concat(A[S], E)
        };
      default:
        return (S, I, A) => {
          if (A[S] === void 0) {
            A[S] = I;
            return
          }
          A[S] = [].concat(A[S], I)
        }
    }
  }

  function l(p) {
    if (typeof p != "string" || p.length !== 1) throw new TypeError("arrayFormatSeparator must be single character string")
  }

  function u(p, v) {
    return v.encode ? v.strict ? t(p) : encodeURIComponent(p) : p
  }

  function f(p, v) {
    return v.decode ? n(p) : p
  }

  function h(p) {
    return Array.isArray(p) ? p.sort() : typeof p == "object" ? h(Object.keys(p)).sort((v, S) => Number(v) - Number(S)).map(v => p[v]) : p
  }

  function g(p) {
    const v = p.indexOf("#");
    return v !== -1 && (p = p.slice(0, v)), p
  }

  function y(p) {
    let v = "";
    const S = p.indexOf("#");
    return S !== -1 && (v = p.slice(S)), v
  }

  function x(p) {
    p = g(p);
    const v = p.indexOf("?");
    return v === -1 ? "" : p.slice(v + 1)
  }

  function k(p, v) {
    return v.parseNumbers && !Number.isNaN(Number(p)) && typeof p == "string" && p.trim() !== "" ? p = Number(p) : v.parseBooleans && p !== null && (p.toLowerCase() === "true" || p.toLowerCase() === "false") && (p = p.toLowerCase() === "true"), p
  }

  function _(p, v) {
    v = Object.assign({
      decode: !0,
      sort: !0,
      arrayFormat: "none",
      arrayFormatSeparator: ",",
      parseNumbers: !1,
      parseBooleans: !1
    }, v), l(v.arrayFormatSeparator);
    const S = c(v),
      I = Object.create(null);
    if (typeof p != "string" || (p = p.trim().replace(/^[?#&]/, ""), !p)) return I;
    for (const A of p.split("&")) {
      if (A === "") continue;
      let [w, E] = r(v.decode ? A.replace(/\+/g, " ") : A, "=");
      E = E === void 0 ? null : ["comma", "separator", "bracket-separator"].includes(v.arrayFormat) ? E : f(E, v), S(f(w, v), E, I)
    }
    for (const A of Object.keys(I)) {
      const w = I[A];
      if (typeof w == "object" && w !== null)
        for (const E of Object.keys(w)) w[E] = k(w[E], v);
      else I[A] = k(w, v)
    }
    return v.sort === !1 ? I : (v.sort === !0 ? Object.keys(I).sort() : Object.keys(I).sort(v.sort)).reduce((A, w) => {
      const E = I[w];
      return E && typeof E == "object" && !Array.isArray(E) ? A[w] = h(E) : A[w] = E, A
    }, Object.create(null))
  }
  e.extract = x, e.parse = _, e.stringify = (p, v) => {
    if (!p) return "";
    v = Object.assign({
      encode: !0,
      strict: !0,
      arrayFormat: "none",
      arrayFormatSeparator: ","
    }, v), l(v.arrayFormatSeparator);
    const S = E => v.skipNull && s(p[E]) || v.skipEmptyString && p[E] === "",
      I = a(v),
      A = {};
    for (const E of Object.keys(p)) S(E) || (A[E] = p[E]);
    const w = Object.keys(A);
    return v.sort !== !1 && w.sort(v.sort), w.map(E => {
      const D = p[E];
      return D === void 0 ? "" : D === null ? u(E, v) : Array.isArray(D) ? D.length === 0 && v.arrayFormat === "bracket-separator" ? u(E, v) + "[]" : D.reduce(I(E), []).join("&") : u(E, v) + "=" + u(D, v)
    }).filter(E => E.length > 0).join("&")
  }, e.parseUrl = (p, v) => {
    v = Object.assign({
      decode: !0
    }, v);
    const [S, I] = r(p, "#");
    return Object.assign({
      url: S.split("?")[0] || "",
      query: _(x(p), v)
    }, v && v.parseFragmentIdentifier && I ? {
      fragmentIdentifier: f(I, v)
    } : {})
  }, e.stringifyUrl = (p, v) => {
    v = Object.assign({
      encode: !0,
      strict: !0,
      [o]: !0
    }, v);
    const S = g(p.url).split("?")[0] || "",
      I = e.extract(p.url),
      A = e.parse(I, {
        sort: !1
      }),
      w = Object.assign(A, p.query);
    let E = e.stringify(w, v);
    E && (E = `?${E}`);
    let D = y(p.url);
    return p.fragmentIdentifier && (D = `#${v[o]?u(p.fragmentIdentifier,v):p.fragmentIdentifier}`), `${S}${E}${D}`
  }, e.pick = (p, v, S) => {
    S = Object.assign({
      parseFragmentIdentifier: !0,
      [o]: !1
    }, S);
    const {
      url: I,
      query: A,
      fragmentIdentifier: w
    } = e.parseUrl(p, S);
    return e.stringifyUrl({
      url: I,
      query: i(A, v),
      fragmentIdentifier: w
    }, S)
  }, e.exclude = (p, v, S) => {
    const I = Array.isArray(v) ? A => !v.includes(A) : (A, w) => !v(A, w);
    return e.pick(p, I, S)
  }
})(_Ue);
const IUe = ":";

function PUe(e) {
  const [t, n] = e.split(IUe);
  return {
    namespace: t,
    reference: n
  }
}

function R8(e = [], t = []) {
  return [...new Set([...e, ...t])]
}

function A_(e) {
  return e.includes(":")
}

function s1(e) {
  return A_(e) ? e.split(":")[0] : e
}
const RUe = {
  INVALID_METHOD: {
    message: "Invalid method.",
    code: 1001
  },
  INVALID_EVENT: {
    message: "Invalid event.",
    code: 1002
  },
  INVALID_UPDATE_REQUEST: {
    message: "Invalid update request.",
    code: 1003
  },
  INVALID_EXTEND_REQUEST: {
    message: "Invalid extend request.",
    code: 1004
  },
  INVALID_SESSION_SETTLE_REQUEST: {
    message: "Invalid session settle request.",
    code: 1005
  },
  UNAUTHORIZED_METHOD: {
    message: "Unauthorized method.",
    code: 3001
  },
  UNAUTHORIZED_EVENT: {
    message: "Unauthorized event.",
    code: 3002
  },
  UNAUTHORIZED_UPDATE_REQUEST: {
    message: "Unauthorized update request.",
    code: 3003
  },
  UNAUTHORIZED_EXTEND_REQUEST: {
    message: "Unauthorized extend request.",
    code: 3004
  },
  USER_REJECTED: {
    message: "User rejected.",
    code: 5e3
  },
  USER_REJECTED_CHAINS: {
    message: "User rejected chains.",
    code: 5001
  },
  USER_REJECTED_METHODS: {
    message: "User rejected methods.",
    code: 5002
  },
  USER_REJECTED_EVENTS: {
    message: "User rejected events.",
    code: 5003
  },
  UNSUPPORTED_CHAINS: {
    message: "Unsupported chains.",
    code: 5100
  },
  UNSUPPORTED_METHODS: {
    message: "Unsupported methods.",
    code: 5101
  },
  UNSUPPORTED_EVENTS: {
    message: "Unsupported events.",
    code: 5102
  },
  UNSUPPORTED_ACCOUNTS: {
    message: "Unsupported accounts.",
    code: 5103
  },
  UNSUPPORTED_NAMESPACE_KEY: {
    message: "Unsupported namespace key.",
    code: 5104
  },
  USER_DISCONNECTED: {
    message: "User disconnected.",
    code: 6e3
  },
  SESSION_SETTLEMENT_FAILED: {
    message: "Session settlement failed.",
    code: 7e3
  },
  WC_METHOD_UNSUPPORTED: {
    message: "Unsupported wc_ method.",
    code: 10001
  }
};

function cB(e, t) {
  const {
    message: n,
    code: r
  } = RUe[e];
  return {
    message: t ? `${n} ${t}` : n,
    code: r
  }
}

function lB(e, t) {
  return Array.isArray(e) ? typeof t < "u" && e.length ? e.every(t) : !0 : !1
}

function OUe(e) {
  return Object.getPrototypeOf(e) === Object.prototype && Object.keys(e).length
}
var a9 = {
  exports: {}
};
(function (e, t) {
  var n = typeof self < "u" ? self : rn,
    r = function () {
      function s() {
        this.fetch = !1, this.DOMException = n.DOMException
      }
      return s.prototype = n, new s
    }();
  (function (s) {
    (function (o) {
      var a = {
        searchParams: "URLSearchParams" in s,
        iterable: "Symbol" in s && "iterator" in Symbol,
        blob: "FileReader" in s && "Blob" in s && function () {
          try {
            return new Blob, !0
          } catch {
            return !1
          }
        }(),
        formData: "FormData" in s,
        arrayBuffer: "ArrayBuffer" in s
      };

      function c(b) {
        return b && DataView.prototype.isPrototypeOf(b)
      }
      if (a.arrayBuffer) var l = ["[object Int8Array]", "[object Uint8Array]", "[object Uint8ClampedArray]", "[object Int16Array]", "[object Uint16Array]", "[object Int32Array]", "[object Uint32Array]", "[object Float32Array]", "[object Float64Array]"],
        u = ArrayBuffer.isView || function (b) {
          return b && l.indexOf(Object.prototype.toString.call(b)) > -1
        };

      function f(b) {
        if (typeof b != "string" && (b = String(b)), /[^a-z0-9\-#$%&'*+.^_`|~]/i.test(b)) throw new TypeError("Invalid character in header field name");
        return b.toLowerCase()
      }

      function h(b) {
        return typeof b != "string" && (b = String(b)), b
      }

      function g(b) {
        var T = {
          next: function () {
            var R = b.shift();
            return {
              done: R === void 0,
              value: R
            }
          }
        };
        return a.iterable && (T[Symbol.iterator] = function () {
          return T
        }), T
      }

      function y(b) {
        this.map = {}, b instanceof y ? b.forEach(function (T, R) {
          this.append(R, T)
        }, this) : Array.isArray(b) ? b.forEach(function (T) {
          this.append(T[0], T[1])
        }, this) : b && Object.getOwnPropertyNames(b).forEach(function (T) {
          this.append(T, b[T])
        }, this)
      }
      y.prototype.append = function (b, T) {
        b = f(b), T = h(T);
        var R = this.map[b];
        this.map[b] = R ? R + ", " + T : T
      }, y.prototype.delete = function (b) {
        delete this.map[f(b)]
      }, y.prototype.get = function (b) {
        return b = f(b), this.has(b) ? this.map[b] : null
      }, y.prototype.has = function (b) {
        return this.map.hasOwnProperty(f(b))
      }, y.prototype.set = function (b, T) {
        this.map[f(b)] = h(T)
      }, y.prototype.forEach = function (b, T) {
        for (var R in this.map) this.map.hasOwnProperty(R) && b.call(T, this.map[R], R, this)
      }, y.prototype.keys = function () {
        var b = [];
        return this.forEach(function (T, R) {
          b.push(R)
        }), g(b)
      }, y.prototype.values = function () {
        var b = [];
        return this.forEach(function (T) {
          b.push(T)
        }), g(b)
      }, y.prototype.entries = function () {
        var b = [];
        return this.forEach(function (T, R) {
          b.push([R, T])
        }), g(b)
      }, a.iterable && (y.prototype[Symbol.iterator] = y.prototype.entries);

      function x(b) {
        if (b.bodyUsed) return Promise.reject(new TypeError("Already read"));
        b.bodyUsed = !0
      }

      function k(b) {
        return new Promise(function (T, R) {
          b.onload = function () {
            T(b.result)
          }, b.onerror = function () {
            R(b.error)
          }
        })
      }

      function _(b) {
        var T = new FileReader,
          R = k(T);
        return T.readAsArrayBuffer(b), R
      }

      function p(b) {
        var T = new FileReader,
          R = k(T);
        return T.readAsText(b), R
      }

      function v(b) {
        for (var T = new Uint8Array(b), R = new Array(T.length), N = 0; N < T.length; N++) R[N] = String.fromCharCode(T[N]);
        return R.join("")
      }

      function S(b) {
        if (b.slice) return b.slice(0);
        var T = new Uint8Array(b.byteLength);
        return T.set(new Uint8Array(b)), T.buffer
      }

      function I() {
        return this.bodyUsed = !1, this._initBody = function (b) {
          this._bodyInit = b, b ? typeof b == "string" ? this._bodyText = b : a.blob && Blob.prototype.isPrototypeOf(b) ? this._bodyBlob = b : a.formData && FormData.prototype.isPrototypeOf(b) ? this._bodyFormData = b : a.searchParams && URLSearchParams.prototype.isPrototypeOf(b) ? this._bodyText = b.toString() : a.arrayBuffer && a.blob && c(b) ? (this._bodyArrayBuffer = S(b.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer])) : a.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(b) || u(b)) ? this._bodyArrayBuffer = S(b) : this._bodyText = b = Object.prototype.toString.call(b) : this._bodyText = "", this.headers.get("content-type") || (typeof b == "string" ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : a.searchParams && URLSearchParams.prototype.isPrototypeOf(b) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"))
        }, a.blob && (this.blob = function () {
          var b = x(this);
          if (b) return b;
          if (this._bodyBlob) return Promise.resolve(this._bodyBlob);
          if (this._bodyArrayBuffer) return Promise.resolve(new Blob([this._bodyArrayBuffer]));
          if (this._bodyFormData) throw new Error("could not read FormData body as blob");
          return Promise.resolve(new Blob([this._bodyText]))
        }, this.arrayBuffer = function () {
          return this._bodyArrayBuffer ? x(this) || Promise.resolve(this._bodyArrayBuffer) : this.blob().then(_)
        }), this.text = function () {
          var b = x(this);
          if (b) return b;
          if (this._bodyBlob) return p(this._bodyBlob);
          if (this._bodyArrayBuffer) return Promise.resolve(v(this._bodyArrayBuffer));
          if (this._bodyFormData) throw new Error("could not read FormData body as text");
          return Promise.resolve(this._bodyText)
        }, a.formData && (this.formData = function () {
          return this.text().then(D)
        }), this.json = function () {
          return this.text().then(JSON.parse)
        }, this
      }
      var A = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];

      function w(b) {
        var T = b.toUpperCase();
        return A.indexOf(T) > -1 ? T : b
      }

      function E(b, T) {
        T = T || {};
        var R = T.body;
        if (b instanceof E) {
          if (b.bodyUsed) throw new TypeError("Already read");
          this.url = b.url, this.credentials = b.credentials, T.headers || (this.headers = new y(b.headers)), this.method = b.method, this.mode = b.mode, this.signal = b.signal, !R && b._bodyInit != null && (R = b._bodyInit, b.bodyUsed = !0)
        } else this.url = String(b);
        if (this.credentials = T.credentials || this.credentials || "same-origin", (T.headers || !this.headers) && (this.headers = new y(T.headers)), this.method = w(T.method || this.method || "GET"), this.mode = T.mode || this.mode || null, this.signal = T.signal || this.signal, this.referrer = null, (this.method === "GET" || this.method === "HEAD") && R) throw new TypeError("Body not allowed for GET or HEAD requests");
        this._initBody(R)
      }
      E.prototype.clone = function () {
        return new E(this, {
          body: this._bodyInit
        })
      };

      function D(b) {
        var T = new FormData;
        return b.trim().split("&").forEach(function (R) {
          if (R) {
            var N = R.split("="),
              O = N.shift().replace(/\+/g, " "),
              U = N.join("=").replace(/\+/g, " ");
            T.append(decodeURIComponent(O), decodeURIComponent(U))
          }
        }), T
      }

      function $(b) {
        var T = new y,
          R = b.replace(/\r?\n[\t ]+/g, " ");
        return R.split(/\r?\n/).forEach(function (N) {
          var O = N.split(":"),
            U = O.shift().trim();
          if (U) {
            var q = O.join(":").trim();
            T.append(U, q)
          }
        }), T
      }
      I.call(E.prototype);

      function V(b, T) {
        T || (T = {}), this.type = "default", this.status = T.status === void 0 ? 200 : T.status, this.ok = this.status >= 200 && this.status < 300, this.statusText = "statusText" in T ? T.statusText : "OK", this.headers = new y(T.headers), this.url = T.url || "", this._initBody(b)
      }
      I.call(V.prototype), V.prototype.clone = function () {
        return new V(this._bodyInit, {
          status: this.status,
          statusText: this.statusText,
          headers: new y(this.headers),
          url: this.url
        })
      }, V.error = function () {
        var b = new V(null, {
          status: 0,
          statusText: ""
        });
        return b.type = "error", b
      };
      var G = [301, 302, 303, 307, 308];
      V.redirect = function (b, T) {
        if (G.indexOf(T) === -1) throw new RangeError("Invalid status code");
        return new V(null, {
          status: T,
          headers: {
            location: b
          }
        })
      }, o.DOMException = s.DOMException;
      try {
        new o.DOMException
      } catch {
        o.DOMException = function (T, R) {
          this.message = T, this.name = R;
          var N = Error(T);
          this.stack = N.stack
        }, o.DOMException.prototype = Object.create(Error.prototype), o.DOMException.prototype.constructor = o.DOMException
      }

      function L(b, T) {
        return new Promise(function (R, N) {
          var O = new E(b, T);
          if (O.signal && O.signal.aborted) return N(new o.DOMException("Aborted", "AbortError"));
          var U = new XMLHttpRequest;

          function q() {
            U.abort()
          }
          U.onload = function () {
            var W = {
              status: U.status,
              statusText: U.statusText,
              headers: $(U.getAllResponseHeaders() || "")
            };
            W.url = "responseURL" in U ? U.responseURL : W.headers.get("X-Request-URL");
            var M = "response" in U ? U.response : U.responseText;
            R(new V(M, W))
          }, U.onerror = function () {
            N(new TypeError("Network request failed"))
          }, U.ontimeout = function () {
            N(new TypeError("Network request failed"))
          }, U.onabort = function () {
            N(new o.DOMException("Aborted", "AbortError"))
          }, U.open(O.method, O.url, !0), O.credentials === "include" ? U.withCredentials = !0 : O.credentials === "omit" && (U.withCredentials = !1), "responseType" in U && a.blob && (U.responseType = "blob"), O.headers.forEach(function (W, M) {
            U.setRequestHeader(M, W)
          }), O.signal && (O.signal.addEventListener("abort", q), U.onreadystatechange = function () {
            U.readyState === 4 && O.signal.removeEventListener("abort", q)
          }), U.send(typeof O._bodyInit > "u" ? null : O._bodyInit)
        })
      }
      return L.polyfill = !0, s.fetch || (s.fetch = L, s.Headers = y, s.Request = E, s.Response = V), o.Headers = y, o.Request = E, o.Response = V, o.fetch = L, Object.defineProperty(o, "__esModule", {
        value: !0
      }), o
    })({})
  })(r), r.fetch.ponyfill = !0, delete r.fetch.polyfill;
  var i = r;
  t = i.fetch, t.default = i.fetch, t.fetch = i.fetch, t.Headers = i.Headers, t.Request = i.Request, t.Response = i.Response, e.exports = t
})(a9, a9.exports);
var DUe = a9.exports;
const uB = Vo(DUe),
  NUe = {
    Accept: "application/json",
    "Content-Type": "application/json"
  },
  MUe = "POST",
  dB = {
    headers: NUe,
    method: MUe
  },
  fB = 10;
class Wd {
  constructor(t, n = !1) {
    if (this.url = t, this.disableProviderPing = n, this.events = new si.EventEmitter, this.isAvailable = !1, this.registering = !1, !OL(t)) throw new Error(`Provided URL is not compatible with HTTP connection: ${t}`);
    this.url = t, this.disableProviderPing = n
  }
  get connected() {
    return this.isAvailable
  }
  get connecting() {
    return this.registering
  }
  on(t, n) {
    this.events.on(t, n)
  }
  once(t, n) {
    this.events.once(t, n)
  }
  off(t, n) {
    this.events.off(t, n)
  }
  removeListener(t, n) {
    this.events.removeListener(t, n)
  }
  async open(t = this.url) {
    await this.register(t)
  }
  async close() {
    if (!this.isAvailable) throw new Error("Connection already closed");
    this.onClose()
  }
  async send(t, n) {
    this.isAvailable || await this.register();
    try {
      const r = bh(t),
        s = await (await uB(this.url, Object.assign(Object.assign({}, dB), {
          body: r
        }))).json();
      this.onPayload({
        data: s
      })
    } catch (r) {
      this.onError(t.id, r)
    }
  }
  async register(t = this.url) {
    if (!OL(t)) throw new Error(`Provided URL is not compatible with HTTP connection: ${t}`);
    if (this.registering) {
      const n = this.events.getMaxListeners();
      return (this.events.listenerCount("register_error") >= n || this.events.listenerCount("open") >= n) && this.events.setMaxListeners(n + 1), new Promise((r, i) => {
        this.events.once("register_error", s => {
          this.resetMaxListeners(), i(s)
        }), this.events.once("open", () => {
          if (this.resetMaxListeners(), typeof this.isAvailable > "u") return i(new Error("HTTP connection is missing or invalid"));
          r()
        })
      })
    }
    this.url = t, this.registering = !0;
    try {
      if (!this.disableProviderPing) {
        const n = bh({
          id: 1,
          jsonrpc: "2.0",
          method: "test",
          params: []
        });
        await uB(t, Object.assign(Object.assign({}, dB), {
          body: n
        }))
      }
      this.onOpen()
    } catch (n) {
      const r = this.parseError(n);
      throw this.events.emit("register_error", r), this.onClose(), r
    }
  }
  onOpen() {
    this.isAvailable = !0, this.registering = !1, this.events.emit("open")
  }
  onClose() {
    this.isAvailable = !1, this.registering = !1, this.events.emit("close")
  }
  onPayload(t) {
    if (typeof t.data > "u") return;
    const n = typeof t.data == "string" ? Py(t.data) : t.data;
    this.events.emit("payload", n)
  }
  onError(t, n) {
    const r = this.parseError(n),
      i = r.message || r.toString(),
      s = cE(t, i);
    this.events.emit("payload", s)
  }
  parseError(t, n = this.url) {
    return jY(t, n, "HTTP")
  }
  resetMaxListeners() {
    this.events.getMaxListeners() > fB && this.events.setMaxListeners(fB)
  }
}
const hB = "error",
  $Ue = "wss://relay.walletconnect.com",
  LUe = "wc",
  BUe = "universal_provider",
  pB = `${LUe}@2:${BUe}:`,
  FUe = "https://rpc.walletconnect.com/v1/",
  Tu = {
    DEFAULT_CHAIN_CHANGED: "default_chain_changed"
  };
var Gg = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {},
  c9 = {
    exports: {}
  };
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
(function (e, t) {
  (function () {
    var n, r = "4.17.21",
      i = 200,
      s = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.",
      o = "Expected a function",
      a = "Invalid `variable` option passed into `_.template`",
      c = "__lodash_hash_undefined__",
      l = 500,
      u = "__lodash_placeholder__",
      f = 1,
      h = 2,
      g = 4,
      y = 1,
      x = 2,
      k = 1,
      _ = 2,
      p = 4,
      v = 8,
      S = 16,
      I = 32,
      A = 64,
      w = 128,
      E = 256,
      D = 512,
      $ = 30,
      V = "...",
      G = 800,
      L = 16,
      b = 1,
      T = 2,
      R = 3,
      N = 1 / 0,
      O = 9007199254740991,
      U = 17976931348623157e292,
      q = NaN,
      W = 4294967295,
      M = W - 1,
      Q = W >>> 1,
      he = [
        ["ary", w],
        ["bind", k],
        ["bindKey", _],
        ["curry", v],
        ["curryRight", S],
        ["flip", D],
        ["partial", I],
        ["partialRight", A],
        ["rearg", E]
      ],
      H = "[object Arguments]",
      ne = "[object Array]",
      X = "[object AsyncFunction]",
      Z = "[object Boolean]",
      te = "[object Date]",
      F = "[object DOMException]",
      J = "[object Error]",
      ie = "[object Function]",
      ce = "[object GeneratorFunction]",
      ue = "[object Map]",
      ge = "[object Number]",
      et = "[object Null]",
      He = "[object Object]",
      se = "[object Promise]",
      pe = "[object Proxy]",
      de = "[object RegExp]",
      we = "[object Set]",
      Ce = "[object String]",
      be = "[object Symbol]",
      Se = "[object Undefined]",
      Fe = "[object WeakMap]",
      Ne = "[object WeakSet]",
      Me = "[object ArrayBuffer]",
      We = "[object DataView]",
      ke = "[object Float32Array]",
      ze = "[object Float64Array]",
      ct = "[object Int8Array]",
      Xe = "[object Int16Array]",
      _e = "[object Int32Array]",
      Ze = "[object Uint8Array]",
      Ee = "[object Uint8ClampedArray]",
      Oe = "[object Uint16Array]",
      yt = "[object Uint32Array]",
      tt = /\b__p \+= '';/g,
      dt = /\b(__p \+=) '' \+/g,
      xn = /(__e\(.*?\)|\b__t\)) \+\n'';/g,
      Ht = /&(?:amp|lt|gt|quot|#39);/g,
      en = /[&<>"']/g,
      tn = RegExp(Ht.source),
      Et = RegExp(en.source),
      Ot = /<%-([\s\S]+?)%>/g,
      kn = /<%([\s\S]+?)%>/g,
      Dt = /<%=([\s\S]+?)%>/g,
      Pt = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
      _n = /^\w*$/,
      zt = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
      kt = /[\\^$.*+?()[\]{}|]/g,
      In = RegExp(kt.source),
      vt = /^\s+/,
      _t = /\s/,
      Pn = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
      wt = /\{\n\/\* \[wrapped with (.+)\] \*/,
      $t = /,? & /,
      Mn = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g,
      Rn = /[()=,{}\[\]\/\s]/,
      On = /\\(\\)?/g,
      js = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g,
      cn = /\w*$/,
      $n = /^[-+]0x[0-9a-f]+$/i,
      Us = /^0b[01]+$/i,
      zs = /^\[object .+?Constructor\]$/,
      Ut = /^0o[0-7]+$/i,
      or = /^(?:0|[1-9]\d*)$/,
      pi = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g,
      _c = /($^)/,
      qd = /['\n\r\u2028\u2029\\]/g,
      Ic = "\\ud800-\\udfff",
      Gd = "\\u0300-\\u036f",
      Kd = "\\ufe20-\\ufe2f",
      Pc = "\\u20d0-\\u20ff",
      _u = Gd + Kd + Pc,
      Iu = "\\u2700-\\u27bf",
      ps = "a-z\\xdf-\\xf6\\xf8-\\xff",
      Qd = "\\xac\\xb1\\xd7\\xf7",
      Yd = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf",
      Jd = "\\u2000-\\u206f",
      Xd = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000",
      Pu = "A-Z\\xc0-\\xd6\\xd8-\\xde",
      By = "\\ufe0e\\ufe0f",
      Zd = Qd + Yd + Jd + Xd,
      Km = "['’]",
      ef = "[" + Ic + "]",
      Qm = "[" + Zd + "]",
      tf = "[" + _u + "]",
      Fy = "\\d+",
      xE = "[" + Iu + "]",
      jy = "[" + ps + "]",
      Uy = "[^" + Ic + Zd + Fy + Iu + ps + Pu + "]",
      Hh = "\\ud83c[\\udffb-\\udfff]",
      EE = "(?:" + tf + "|" + Hh + ")",
      zy = "[^" + Ic + "]",
      Vh = "(?:\\ud83c[\\udde6-\\uddff]){2}",
      Ru = "[\\ud800-\\udbff][\\udc00-\\udfff]",
      bo = "[" + Pu + "]",
      Hy = "\\u200d",
      Vy = "(?:" + jy + "|" + Uy + ")",
      Rc = "(?:" + bo + "|" + Uy + ")",
      Wy = "(?:" + Km + "(?:d|ll|m|re|s|t|ve))?",
      qy = "(?:" + Km + "(?:D|LL|M|RE|S|T|VE))?",
      Gy = EE + "?",
      Ky = "[" + By + "]?",
      SE = "(?:" + Hy + "(?:" + [zy, Vh, Ru].join("|") + ")" + Ky + Gy + ")*",
      Cl = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])",
      Qy = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])",
      Yy = Ky + Gy + SE,
      Wh = "(?:" + [xE, Vh, Ru].join("|") + ")" + Yy,
      CE = "(?:" + [zy + tf + "?", tf, Vh, Ru, ef].join("|") + ")",
      Ym = RegExp(Km, "g"),
      AE = RegExp(tf, "g"),
      qh = RegExp(Hh + "(?=" + Hh + ")|" + CE + Yy, "g"),
      Jy = RegExp([bo + "?" + jy + "+" + Wy + "(?=" + [Qm, bo, "$"].join("|") + ")", Rc + "+" + qy + "(?=" + [Qm, bo + Vy, "$"].join("|") + ")", bo + "?" + Vy + "+" + Wy, bo + "+" + qy, Qy, Cl, Fy, Wh].join("|"), "g"),
      Xy = RegExp("[" + Hy + Ic + _u + By + "]"),
      nf = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/,
      Zy = ["Array", "Buffer", "DataView", "Date", "Error", "Float32Array", "Float64Array", "Function", "Int8Array", "Int16Array", "Int32Array", "Map", "Math", "Object", "Promise", "RegExp", "Set", "String", "Symbol", "TypeError", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "WeakMap", "_", "clearTimeout", "isFinite", "parseInt", "setTimeout"],
      TE = -1,
      er = {};
    er[ke] = er[ze] = er[ct] = er[Xe] = er[_e] = er[Ze] = er[Ee] = er[Oe] = er[yt] = !0, er[H] = er[ne] = er[Me] = er[Z] = er[We] = er[te] = er[J] = er[ie] = er[ue] = er[ge] = er[He] = er[de] = er[we] = er[Ce] = er[Fe] = !1;
    var Yn = {};
    Yn[H] = Yn[ne] = Yn[Me] = Yn[We] = Yn[Z] = Yn[te] = Yn[ke] = Yn[ze] = Yn[ct] = Yn[Xe] = Yn[_e] = Yn[ue] = Yn[ge] = Yn[He] = Yn[de] = Yn[we] = Yn[Ce] = Yn[be] = Yn[Ze] = Yn[Ee] = Yn[Oe] = Yn[yt] = !0, Yn[J] = Yn[ie] = Yn[Fe] = !1;
    var oe = {
        À: "A",
        Á: "A",
        Â: "A",
        Ã: "A",
        Ä: "A",
        Å: "A",
        à: "a",
        á: "a",
        â: "a",
        ã: "a",
        ä: "a",
        å: "a",
        Ç: "C",
        ç: "c",
        Ð: "D",
        ð: "d",
        È: "E",
        É: "E",
        Ê: "E",
        Ë: "E",
        è: "e",
        é: "e",
        ê: "e",
        ë: "e",
        Ì: "I",
        Í: "I",
        Î: "I",
        Ï: "I",
        ì: "i",
        í: "i",
        î: "i",
        ï: "i",
        Ñ: "N",
        ñ: "n",
        Ò: "O",
        Ó: "O",
        Ô: "O",
        Õ: "O",
        Ö: "O",
        Ø: "O",
        ò: "o",
        ó: "o",
        ô: "o",
        õ: "o",
        ö: "o",
        ø: "o",
        Ù: "U",
        Ú: "U",
        Û: "U",
        Ü: "U",
        ù: "u",
        ú: "u",
        û: "u",
        ü: "u",
        Ý: "Y",
        ý: "y",
        ÿ: "y",
        Æ: "Ae",
        æ: "ae",
        Þ: "Th",
        þ: "th",
        ß: "ss",
        Ā: "A",
        Ă: "A",
        Ą: "A",
        ā: "a",
        ă: "a",
        ą: "a",
        Ć: "C",
        Ĉ: "C",
        Ċ: "C",
        Č: "C",
        ć: "c",
        ĉ: "c",
        ċ: "c",
        č: "c",
        Ď: "D",
        Đ: "D",
        ď: "d",
        đ: "d",
        Ē: "E",
        Ĕ: "E",
        Ė: "E",
        Ę: "E",
        Ě: "E",
        ē: "e",
        ĕ: "e",
        ė: "e",
        ę: "e",
        ě: "e",
        Ĝ: "G",
        Ğ: "G",
        Ġ: "G",
        Ģ: "G",
        ĝ: "g",
        ğ: "g",
        ġ: "g",
        ģ: "g",
        Ĥ: "H",
        Ħ: "H",
        ĥ: "h",
        ħ: "h",
        Ĩ: "I",
        Ī: "I",
        Ĭ: "I",
        Į: "I",
        İ: "I",
        ĩ: "i",
        ī: "i",
        ĭ: "i",
        į: "i",
        ı: "i",
        Ĵ: "J",
        ĵ: "j",
        Ķ: "K",
        ķ: "k",
        ĸ: "k",
        Ĺ: "L",
        Ļ: "L",
        Ľ: "L",
        Ŀ: "L",
        Ł: "L",
        ĺ: "l",
        ļ: "l",
        ľ: "l",
        ŀ: "l",
        ł: "l",
        Ń: "N",
        Ņ: "N",
        Ň: "N",
        Ŋ: "N",
        ń: "n",
        ņ: "n",
        ň: "n",
        ŋ: "n",
        Ō: "O",
        Ŏ: "O",
        Ő: "O",
        ō: "o",
        ŏ: "o",
        ő: "o",
        Ŕ: "R",
        Ŗ: "R",
        Ř: "R",
        ŕ: "r",
        ŗ: "r",
        ř: "r",
        Ś: "S",
        Ŝ: "S",
        Ş: "S",
        Š: "S",
        ś: "s",
        ŝ: "s",
        ş: "s",
        š: "s",
        Ţ: "T",
        Ť: "T",
        Ŧ: "T",
        ţ: "t",
        ť: "t",
        ŧ: "t",
        Ũ: "U",
        Ū: "U",
        Ŭ: "U",
        Ů: "U",
        Ű: "U",
        Ų: "U",
        ũ: "u",
        ū: "u",
        ŭ: "u",
        ů: "u",
        ű: "u",
        ų: "u",
        Ŵ: "W",
        ŵ: "w",
        Ŷ: "Y",
        ŷ: "y",
        Ÿ: "Y",
        Ź: "Z",
        Ż: "Z",
        Ž: "Z",
        ź: "z",
        ż: "z",
        ž: "z",
        Ĳ: "IJ",
        ĳ: "ij",
        Œ: "Oe",
        œ: "oe",
        ŉ: "'n",
        ſ: "s"
      },
      ye = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      },
      Le = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'"
      },
      at = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029"
      },
      tr = parseFloat,
      Kt = parseInt,
      fr = typeof Gg == "object" && Gg && Gg.Object === Object && Gg,
      Xr = typeof self == "object" && self && self.Object === Object && self,
      En = fr || Xr || Function("return this")(),
      nr = t && !t.nodeType && t,
      Hr = nr && !0 && e && !e.nodeType && e,
      Hs = Hr && Hr.exports === nr,
      Zr = Hs && fr.process,
      hr = function () {
        try {
          var ve = Hr && Hr.require && Hr.require("util").types;
          return ve || Zr && Zr.binding && Zr.binding("util")
        } catch {}
      }(),
      ms = hr && hr.isArrayBuffer,
      Va = hr && hr.isDate,
      Yo = hr && hr.isMap,
      Oc = hr && hr.isRegExp,
      Jm = hr && hr.isSet,
      rf = hr && hr.isTypedArray;

    function mi(ve, Ie, Te) {
      switch (Te.length) {
        case 0:
          return ve.call(Ie);
        case 1:
          return ve.call(Ie, Te[0]);
        case 2:
          return ve.call(Ie, Te[0], Te[1]);
        case 3:
          return ve.call(Ie, Te[0], Te[1], Te[2])
      }
      return ve.apply(Ie, Te)
    }

    function kX(ve, Ie, Te, lt) {
      for (var qt = -1, Ln = ve == null ? 0 : ve.length; ++qt < Ln;) {
        var oi = ve[qt];
        Ie(lt, oi, Te(oi), ve)
      }
      return lt
    }

    function Jo(ve, Ie) {
      for (var Te = -1, lt = ve == null ? 0 : ve.length; ++Te < lt && Ie(ve[Te], Te, ve) !== !1;);
      return ve
    }

    function _X(ve, Ie) {
      for (var Te = ve == null ? 0 : ve.length; Te-- && Ie(ve[Te], Te, ve) !== !1;);
      return ve
    }

    function MI(ve, Ie) {
      for (var Te = -1, lt = ve == null ? 0 : ve.length; ++Te < lt;)
        if (!Ie(ve[Te], Te, ve)) return !1;
      return !0
    }

    function Ou(ve, Ie) {
      for (var Te = -1, lt = ve == null ? 0 : ve.length, qt = 0, Ln = []; ++Te < lt;) {
        var oi = ve[Te];
        Ie(oi, Te, ve) && (Ln[qt++] = oi)
      }
      return Ln
    }

    function ev(ve, Ie) {
      var Te = ve == null ? 0 : ve.length;
      return !!Te && Gh(ve, Ie, 0) > -1
    }

    function kE(ve, Ie, Te) {
      for (var lt = -1, qt = ve == null ? 0 : ve.length; ++lt < qt;)
        if (Te(Ie, ve[lt])) return !0;
      return !1
    }

    function br(ve, Ie) {
      for (var Te = -1, lt = ve == null ? 0 : ve.length, qt = Array(lt); ++Te < lt;) qt[Te] = Ie(ve[Te], Te, ve);
      return qt
    }

    function Du(ve, Ie) {
      for (var Te = -1, lt = Ie.length, qt = ve.length; ++Te < lt;) ve[qt + Te] = Ie[Te];
      return ve
    }

    function _E(ve, Ie, Te, lt) {
      var qt = -1,
        Ln = ve == null ? 0 : ve.length;
      for (lt && Ln && (Te = ve[++qt]); ++qt < Ln;) Te = Ie(Te, ve[qt], qt, ve);
      return Te
    }

    function IX(ve, Ie, Te, lt) {
      var qt = ve == null ? 0 : ve.length;
      for (lt && qt && (Te = ve[--qt]); qt--;) Te = Ie(Te, ve[qt], qt, ve);
      return Te
    }

    function IE(ve, Ie) {
      for (var Te = -1, lt = ve == null ? 0 : ve.length; ++Te < lt;)
        if (Ie(ve[Te], Te, ve)) return !0;
      return !1
    }
    var PX = PE("length");

    function RX(ve) {
      return ve.split("")
    }

    function OX(ve) {
      return ve.match(Mn) || []
    }

    function $I(ve, Ie, Te) {
      var lt;
      return Te(ve, function (qt, Ln, oi) {
        if (Ie(qt, Ln, oi)) return lt = Ln, !1
      }), lt
    }

    function tv(ve, Ie, Te, lt) {
      for (var qt = ve.length, Ln = Te + (lt ? 1 : -1); lt ? Ln-- : ++Ln < qt;)
        if (Ie(ve[Ln], Ln, ve)) return Ln;
      return -1
    }

    function Gh(ve, Ie, Te) {
      return Ie === Ie ? VX(ve, Ie, Te) : tv(ve, LI, Te)
    }

    function DX(ve, Ie, Te, lt) {
      for (var qt = Te - 1, Ln = ve.length; ++qt < Ln;)
        if (lt(ve[qt], Ie)) return qt;
      return -1
    }

    function LI(ve) {
      return ve !== ve
    }

    function BI(ve, Ie) {
      var Te = ve == null ? 0 : ve.length;
      return Te ? OE(ve, Ie) / Te : q
    }

    function PE(ve) {
      return function (Ie) {
        return Ie == null ? n : Ie[ve]
      }
    }

    function RE(ve) {
      return function (Ie) {
        return ve == null ? n : ve[Ie]
      }
    }

    function FI(ve, Ie, Te, lt, qt) {
      return qt(ve, function (Ln, oi, rr) {
        Te = lt ? (lt = !1, Ln) : Ie(Te, Ln, oi, rr)
      }), Te
    }

    function NX(ve, Ie) {
      var Te = ve.length;
      for (ve.sort(Ie); Te--;) ve[Te] = ve[Te].value;
      return ve
    }

    function OE(ve, Ie) {
      for (var Te, lt = -1, qt = ve.length; ++lt < qt;) {
        var Ln = Ie(ve[lt]);
        Ln !== n && (Te = Te === n ? Ln : Te + Ln)
      }
      return Te
    }

    function DE(ve, Ie) {
      for (var Te = -1, lt = Array(ve); ++Te < ve;) lt[Te] = Ie(Te);
      return lt
    }

    function MX(ve, Ie) {
      return br(Ie, function (Te) {
        return [Te, ve[Te]]
      })
    }

    function jI(ve) {
      return ve && ve.slice(0, VI(ve) + 1).replace(vt, "")
    }

    function wo(ve) {
      return function (Ie) {
        return ve(Ie)
      }
    }

    function NE(ve, Ie) {
      return br(Ie, function (Te) {
        return ve[Te]
      })
    }

    function Xm(ve, Ie) {
      return ve.has(Ie)
    }

    function UI(ve, Ie) {
      for (var Te = -1, lt = ve.length; ++Te < lt && Gh(Ie, ve[Te], 0) > -1;);
      return Te
    }

    function zI(ve, Ie) {
      for (var Te = ve.length; Te-- && Gh(Ie, ve[Te], 0) > -1;);
      return Te
    }

    function $X(ve, Ie) {
      for (var Te = ve.length, lt = 0; Te--;) ve[Te] === Ie && ++lt;
      return lt
    }
    var LX = RE(oe),
      BX = RE(ye);

    function FX(ve) {
      return "\\" + at[ve]
    }

    function jX(ve, Ie) {
      return ve == null ? n : ve[Ie]
    }

    function Kh(ve) {
      return Xy.test(ve)
    }

    function UX(ve) {
      return nf.test(ve)
    }

    function zX(ve) {
      for (var Ie, Te = []; !(Ie = ve.next()).done;) Te.push(Ie.value);
      return Te
    }

    function ME(ve) {
      var Ie = -1,
        Te = Array(ve.size);
      return ve.forEach(function (lt, qt) {
        Te[++Ie] = [qt, lt]
      }), Te
    }

    function HI(ve, Ie) {
      return function (Te) {
        return ve(Ie(Te))
      }
    }

    function Nu(ve, Ie) {
      for (var Te = -1, lt = ve.length, qt = 0, Ln = []; ++Te < lt;) {
        var oi = ve[Te];
        (oi === Ie || oi === u) && (ve[Te] = u, Ln[qt++] = Te)
      }
      return Ln
    }

    function nv(ve) {
      var Ie = -1,
        Te = Array(ve.size);
      return ve.forEach(function (lt) {
        Te[++Ie] = lt
      }), Te
    }

    function HX(ve) {
      var Ie = -1,
        Te = Array(ve.size);
      return ve.forEach(function (lt) {
        Te[++Ie] = [lt, lt]
      }), Te
    }

    function VX(ve, Ie, Te) {
      for (var lt = Te - 1, qt = ve.length; ++lt < qt;)
        if (ve[lt] === Ie) return lt;
      return -1
    }

    function WX(ve, Ie, Te) {
      for (var lt = Te + 1; lt--;)
        if (ve[lt] === Ie) return lt;
      return lt
    }

    function Qh(ve) {
      return Kh(ve) ? GX(ve) : PX(ve)
    }

    function Wa(ve) {
      return Kh(ve) ? KX(ve) : RX(ve)
    }

    function VI(ve) {
      for (var Ie = ve.length; Ie-- && _t.test(ve.charAt(Ie)););
      return Ie
    }
    var qX = RE(Le);

    function GX(ve) {
      for (var Ie = qh.lastIndex = 0; qh.test(ve);) ++Ie;
      return Ie
    }

    function KX(ve) {
      return ve.match(qh) || []
    }

    function QX(ve) {
      return ve.match(Jy) || []
    }
    var YX = function ve(Ie) {
        Ie = Ie == null ? En : Yh.defaults(En.Object(), Ie, Yh.pick(En, Zy));
        var Te = Ie.Array,
          lt = Ie.Date,
          qt = Ie.Error,
          Ln = Ie.Function,
          oi = Ie.Math,
          rr = Ie.Object,
          $E = Ie.RegExp,
          JX = Ie.String,
          Xo = Ie.TypeError,
          rv = Te.prototype,
          XX = Ln.prototype,
          Jh = rr.prototype,
          iv = Ie["__core-js_shared__"],
          sv = XX.toString,
          Wn = Jh.hasOwnProperty,
          ZX = 0,
          WI = function () {
            var d = /[^.]+$/.exec(iv && iv.keys && iv.keys.IE_PROTO || "");
            return d ? "Symbol(src)_1." + d : ""
          }(),
          ov = Jh.toString,
          eZ = sv.call(rr),
          tZ = En._,
          nZ = $E("^" + sv.call(Wn).replace(kt, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"),
          av = Hs ? Ie.Buffer : n,
          Mu = Ie.Symbol,
          cv = Ie.Uint8Array,
          qI = av ? av.allocUnsafe : n,
          lv = HI(rr.getPrototypeOf, rr),
          GI = rr.create,
          KI = Jh.propertyIsEnumerable,
          uv = rv.splice,
          QI = Mu ? Mu.isConcatSpreadable : n,
          Zm = Mu ? Mu.iterator : n,
          sf = Mu ? Mu.toStringTag : n,
          dv = function () {
            try {
              var d = uf(rr, "defineProperty");
              return d({}, "", {}), d
            } catch {}
          }(),
          rZ = Ie.clearTimeout !== En.clearTimeout && Ie.clearTimeout,
          iZ = lt && lt.now !== En.Date.now && lt.now,
          sZ = Ie.setTimeout !== En.setTimeout && Ie.setTimeout,
          fv = oi.ceil,
          hv = oi.floor,
          LE = rr.getOwnPropertySymbols,
          oZ = av ? av.isBuffer : n,
          YI = Ie.isFinite,
          aZ = rv.join,
          cZ = HI(rr.keys, rr),
          ai = oi.max,
          Ki = oi.min,
          lZ = lt.now,
          uZ = Ie.parseInt,
          JI = oi.random,
          dZ = rv.reverse,
          BE = uf(Ie, "DataView"),
          eg = uf(Ie, "Map"),
          FE = uf(Ie, "Promise"),
          Xh = uf(Ie, "Set"),
          tg = uf(Ie, "WeakMap"),
          ng = uf(rr, "create"),
          pv = tg && new tg,
          Zh = {},
          fZ = df(BE),
          hZ = df(eg),
          pZ = df(FE),
          mZ = df(Xh),
          gZ = df(tg),
          mv = Mu ? Mu.prototype : n,
          rg = mv ? mv.valueOf : n,
          XI = mv ? mv.toString : n;

        function ee(d) {
          if (Nr(d) && !Qt(d) && !(d instanceof mn)) {
            if (d instanceof Zo) return d;
            if (Wn.call(d, "__wrapped__")) return ZP(d)
          }
          return new Zo(d)
        }
        var e0 = function () {
          function d() {}
          return function (m) {
            if (!Tr(m)) return {};
            if (GI) return GI(m);
            d.prototype = m;
            var P = new d;
            return d.prototype = n, P
          }
        }();

        function gv() {}

        function Zo(d, m) {
          this.__wrapped__ = d, this.__actions__ = [], this.__chain__ = !!m, this.__index__ = 0, this.__values__ = n
        }
        ee.templateSettings = {
          escape: Ot,
          evaluate: kn,
          interpolate: Dt,
          variable: "",
          imports: {
            _: ee
          }
        }, ee.prototype = gv.prototype, ee.prototype.constructor = ee, Zo.prototype = e0(gv.prototype), Zo.prototype.constructor = Zo;

        function mn(d) {
          this.__wrapped__ = d, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = !1, this.__iteratees__ = [], this.__takeCount__ = W, this.__views__ = []
        }

        function yZ() {
          var d = new mn(this.__wrapped__);
          return d.__actions__ = Vs(this.__actions__), d.__dir__ = this.__dir__, d.__filtered__ = this.__filtered__, d.__iteratees__ = Vs(this.__iteratees__), d.__takeCount__ = this.__takeCount__, d.__views__ = Vs(this.__views__), d
        }

        function vZ() {
          if (this.__filtered__) {
            var d = new mn(this);
            d.__dir__ = -1, d.__filtered__ = !0
          } else d = this.clone(), d.__dir__ *= -1;
          return d
        }

        function bZ() {
          var d = this.__wrapped__.value(),
            m = this.__dir__,
            P = Qt(d),
            z = m < 0,
            Y = P ? d.length : 0,
            re = Ree(0, Y, this.__views__),
            le = re.start,
            fe = re.end,
            xe = fe - le,
            Re = z ? fe : le - 1,
            De = this.__iteratees__,
            je = De.length,
            rt = 0,
            bt = Ki(xe, this.__takeCount__);
          if (!P || !z && Y == xe && bt == xe) return EP(d, this.__actions__);
          var Lt = [];
          e: for (; xe-- && rt < bt;) {
            Re += m;
            for (var ln = -1, Bt = d[Re]; ++ln < je;) {
              var fn = De[ln],
                Sn = fn.iteratee,
                So = fn.type,
                vs = Sn(Bt);
              if (So == T) Bt = vs;
              else if (!vs) {
                if (So == b) continue e;
                break e
              }
            }
            Lt[rt++] = Bt
          }
          return Lt
        }
        mn.prototype = e0(gv.prototype), mn.prototype.constructor = mn;

        function of (d) {
          var m = -1,
            P = d == null ? 0 : d.length;
          for (this.clear(); ++m < P;) {
            var z = d[m];
            this.set(z[0], z[1])
          }
        }

        function wZ() {
          this.__data__ = ng ? ng(null) : {}, this.size = 0
        }

        function xZ(d) {
          var m = this.has(d) && delete this.__data__[d];
          return this.size -= m ? 1 : 0, m
        }

        function EZ(d) {
          var m = this.__data__;
          if (ng) {
            var P = m[d];
            return P === c ? n : P
          }
          return Wn.call(m, d) ? m[d] : n
        }

        function SZ(d) {
          var m = this.__data__;
          return ng ? m[d] !== n : Wn.call(m, d)
        }

        function CZ(d, m) {
          var P = this.__data__;
          return this.size += this.has(d) ? 0 : 1, P[d] = ng && m === n ? c : m, this
        } of .prototype.clear = wZ, of .prototype.delete = xZ, of .prototype.get = EZ, of .prototype.has = SZ, of .prototype.set = CZ;

        function Al(d) {
          var m = -1,
            P = d == null ? 0 : d.length;
          for (this.clear(); ++m < P;) {
            var z = d[m];
            this.set(z[0], z[1])
          }
        }

        function AZ() {
          this.__data__ = [], this.size = 0
        }

        function TZ(d) {
          var m = this.__data__,
            P = yv(m, d);
          if (P < 0) return !1;
          var z = m.length - 1;
          return P == z ? m.pop() : uv.call(m, P, 1), --this.size, !0
        }

        function kZ(d) {
          var m = this.__data__,
            P = yv(m, d);
          return P < 0 ? n : m[P][1]
        }

        function _Z(d) {
          return yv(this.__data__, d) > -1
        }

        function IZ(d, m) {
          var P = this.__data__,
            z = yv(P, d);
          return z < 0 ? (++this.size, P.push([d, m])) : P[z][1] = m, this
        }
        Al.prototype.clear = AZ, Al.prototype.delete = TZ, Al.prototype.get = kZ, Al.prototype.has = _Z, Al.prototype.set = IZ;

        function Tl(d) {
          var m = -1,
            P = d == null ? 0 : d.length;
          for (this.clear(); ++m < P;) {
            var z = d[m];
            this.set(z[0], z[1])
          }
        }

        function PZ() {
          this.size = 0, this.__data__ = {
            hash: new of ,
            map: new(eg || Al),
            string: new of
          }
        }

        function RZ(d) {
          var m = Iv(this, d).delete(d);
          return this.size -= m ? 1 : 0, m
        }

        function OZ(d) {
          return Iv(this, d).get(d)
        }

        function DZ(d) {
          return Iv(this, d).has(d)
        }

        function NZ(d, m) {
          var P = Iv(this, d),
            z = P.size;
          return P.set(d, m), this.size += P.size == z ? 0 : 1, this
        }
        Tl.prototype.clear = PZ, Tl.prototype.delete = RZ, Tl.prototype.get = OZ, Tl.prototype.has = DZ, Tl.prototype.set = NZ;

        function af(d) {
          var m = -1,
            P = d == null ? 0 : d.length;
          for (this.__data__ = new Tl; ++m < P;) this.add(d[m])
        }

        function MZ(d) {
          return this.__data__.set(d, c), this
        }

        function $Z(d) {
          return this.__data__.has(d)
        }
        af.prototype.add = af.prototype.push = MZ, af.prototype.has = $Z;

        function qa(d) {
          var m = this.__data__ = new Al(d);
          this.size = m.size
        }

        function LZ() {
          this.__data__ = new Al, this.size = 0
        }

        function BZ(d) {
          var m = this.__data__,
            P = m.delete(d);
          return this.size = m.size, P
        }

        function FZ(d) {
          return this.__data__.get(d)
        }

        function jZ(d) {
          return this.__data__.has(d)
        }

        function UZ(d, m) {
          var P = this.__data__;
          if (P instanceof Al) {
            var z = P.__data__;
            if (!eg || z.length < i - 1) return z.push([d, m]), this.size = ++P.size, this;
            P = this.__data__ = new Tl(z)
          }
          return P.set(d, m), this.size = P.size, this
        }
        qa.prototype.clear = LZ, qa.prototype.delete = BZ, qa.prototype.get = FZ, qa.prototype.has = jZ, qa.prototype.set = UZ;

        function ZI(d, m) {
          var P = Qt(d),
            z = !P && ff(d),
            Y = !P && !z && ju(d),
            re = !P && !z && !Y && i0(d),
            le = P || z || Y || re,
            fe = le ? DE(d.length, JX) : [],
            xe = fe.length;
          for (var Re in d)(m || Wn.call(d, Re)) && !(le && (Re == "length" || Y && (Re == "offset" || Re == "parent") || re && (Re == "buffer" || Re == "byteLength" || Re == "byteOffset") || Pl(Re, xe))) && fe.push(Re);
          return fe
        }

        function eP(d) {
          var m = d.length;
          return m ? d[YE(0, m - 1)] : n
        }

        function zZ(d, m) {
          return Pv(Vs(d), cf(m, 0, d.length))
        }

        function HZ(d) {
          return Pv(Vs(d))
        }

        function jE(d, m, P) {
          (P !== n && !Ga(d[m], P) || P === n && !(m in d)) && kl(d, m, P)
        }

        function ig(d, m, P) {
          var z = d[m];
          (!(Wn.call(d, m) && Ga(z, P)) || P === n && !(m in d)) && kl(d, m, P)
        }

        function yv(d, m) {
          for (var P = d.length; P--;)
            if (Ga(d[P][0], m)) return P;
          return -1
        }

        function VZ(d, m, P, z) {
          return $u(d, function (Y, re, le) {
            m(z, Y, P(Y), le)
          }), z
        }

        function tP(d, m) {
          return d && Nc(m, gi(m), d)
        }

        function WZ(d, m) {
          return d && Nc(m, qs(m), d)
        }

        function kl(d, m, P) {
          m == "__proto__" && dv ? dv(d, m, {
            configurable: !0,
            enumerable: !0,
            value: P,
            writable: !0
          }) : d[m] = P
        }

        function UE(d, m) {
          for (var P = -1, z = m.length, Y = Te(z), re = d == null; ++P < z;) Y[P] = re ? n : x4(d, m[P]);
          return Y
        }

        function cf(d, m, P) {
          return d === d && (P !== n && (d = d <= P ? d : P), m !== n && (d = d >= m ? d : m)), d
        }

        function ea(d, m, P, z, Y, re) {
          var le, fe = m & f,
            xe = m & h,
            Re = m & g;
          if (P && (le = Y ? P(d, z, Y, re) : P(d)), le !== n) return le;
          if (!Tr(d)) return d;
          var De = Qt(d);
          if (De) {
            if (le = Dee(d), !fe) return Vs(d, le)
          } else {
            var je = Qi(d),
              rt = je == ie || je == ce;
            if (ju(d)) return AP(d, fe);
            if (je == He || je == H || rt && !Y) {
              if (le = xe || rt ? {} : VP(d), !fe) return xe ? Eee(d, WZ(le, d)) : xee(d, tP(le, d))
            } else {
              if (!Yn[je]) return Y ? d : {};
              le = Nee(d, je, fe)
            }
          }
          re || (re = new qa);
          var bt = re.get(d);
          if (bt) return bt;
          re.set(d, le), bR(d) ? d.forEach(function (Bt) {
            le.add(ea(Bt, m, P, Bt, d, re))
          }) : yR(d) && d.forEach(function (Bt, fn) {
            le.set(fn, ea(Bt, m, P, fn, d, re))
          });
          var Lt = Re ? xe ? a4 : o4 : xe ? qs : gi,
            ln = De ? n : Lt(d);
          return Jo(ln || d, function (Bt, fn) {
            ln && (fn = Bt, Bt = d[fn]), ig(le, fn, ea(Bt, m, P, fn, d, re))
          }), le
        }

        function qZ(d) {
          var m = gi(d);
          return function (P) {
            return nP(P, d, m)
          }
        }

        function nP(d, m, P) {
          var z = P.length;
          if (d == null) return !z;
          for (d = rr(d); z--;) {
            var Y = P[z],
              re = m[Y],
              le = d[Y];
            if (le === n && !(Y in d) || !re(le)) return !1
          }
          return !0
        }

        function rP(d, m, P) {
          if (typeof d != "function") throw new Xo(o);
          return dg(function () {
            d.apply(n, P)
          }, m)
        }

        function sg(d, m, P, z) {
          var Y = -1,
            re = ev,
            le = !0,
            fe = d.length,
            xe = [],
            Re = m.length;
          if (!fe) return xe;
          P && (m = br(m, wo(P))), z ? (re = kE, le = !1) : m.length >= i && (re = Xm, le = !1, m = new af(m));
          e: for (; ++Y < fe;) {
            var De = d[Y],
              je = P == null ? De : P(De);
            if (De = z || De !== 0 ? De : 0, le && je === je) {
              for (var rt = Re; rt--;)
                if (m[rt] === je) continue e;
              xe.push(De)
            } else re(m, je, z) || xe.push(De)
          }
          return xe
        }
        var $u = PP(Dc),
          iP = PP(HE, !0);

        function GZ(d, m) {
          var P = !0;
          return $u(d, function (z, Y, re) {
            return P = !!m(z, Y, re), P
          }), P
        }

        function vv(d, m, P) {
          for (var z = -1, Y = d.length; ++z < Y;) {
            var re = d[z],
              le = m(re);
            if (le != null && (fe === n ? le === le && !Eo(le) : P(le, fe))) var fe = le,
              xe = re
          }
          return xe
        }

        function KZ(d, m, P, z) {
          var Y = d.length;
          for (P = on(P), P < 0 && (P = -P > Y ? 0 : Y + P), z = z === n || z > Y ? Y : on(z), z < 0 && (z += Y), z = P > z ? 0 : xR(z); P < z;) d[P++] = m;
          return d
        }

        function sP(d, m) {
          var P = [];
          return $u(d, function (z, Y, re) {
            m(z, Y, re) && P.push(z)
          }), P
        }

        function Di(d, m, P, z, Y) {
          var re = -1,
            le = d.length;
          for (P || (P = $ee), Y || (Y = []); ++re < le;) {
            var fe = d[re];
            m > 0 && P(fe) ? m > 1 ? Di(fe, m - 1, P, z, Y) : Du(Y, fe) : z || (Y[Y.length] = fe)
          }
          return Y
        }
        var zE = RP(),
          oP = RP(!0);

        function Dc(d, m) {
          return d && zE(d, m, gi)
        }

        function HE(d, m) {
          return d && oP(d, m, gi)
        }

        function bv(d, m) {
          return Ou(m, function (P) {
            return Rl(d[P])
          })
        }

        function lf(d, m) {
          m = Bu(m, d);
          for (var P = 0, z = m.length; d != null && P < z;) d = d[Mc(m[P++])];
          return P && P == z ? d : n
        }

        function aP(d, m, P) {
          var z = m(d);
          return Qt(d) ? z : Du(z, P(d))
        }

        function gs(d) {
          return d == null ? d === n ? Se : et : sf && sf in rr(d) ? Pee(d) : Hee(d)
        }

        function VE(d, m) {
          return d > m
        }

        function QZ(d, m) {
          return d != null && Wn.call(d, m)
        }

        function YZ(d, m) {
          return d != null && m in rr(d)
        }

        function JZ(d, m, P) {
          return d >= Ki(m, P) && d < ai(m, P)
        }

        function WE(d, m, P) {
          for (var z = P ? kE : ev, Y = d[0].length, re = d.length, le = re, fe = Te(re), xe = 1 / 0, Re = []; le--;) {
            var De = d[le];
            le && m && (De = br(De, wo(m))), xe = Ki(De.length, xe), fe[le] = !P && (m || Y >= 120 && De.length >= 120) ? new af(le && De) : n
          }
          De = d[0];
          var je = -1,
            rt = fe[0];
          e: for (; ++je < Y && Re.length < xe;) {
            var bt = De[je],
              Lt = m ? m(bt) : bt;
            if (bt = P || bt !== 0 ? bt : 0, !(rt ? Xm(rt, Lt) : z(Re, Lt, P))) {
              for (le = re; --le;) {
                var ln = fe[le];
                if (!(ln ? Xm(ln, Lt) : z(d[le], Lt, P))) continue e
              }
              rt && rt.push(Lt), Re.push(bt)
            }
          }
          return Re
        }

        function XZ(d, m, P, z) {
          return Dc(d, function (Y, re, le) {
            m(z, P(Y), re, le)
          }), z
        }

        function og(d, m, P) {
          m = Bu(m, d), d = KP(d, m);
          var z = d == null ? d : d[Mc(na(m))];
          return z == null ? n : mi(z, d, P)
        }

        function cP(d) {
          return Nr(d) && gs(d) == H
        }

        function ZZ(d) {
          return Nr(d) && gs(d) == Me
        }

        function eee(d) {
          return Nr(d) && gs(d) == te
        }

        function ag(d, m, P, z, Y) {
          return d === m ? !0 : d == null || m == null || !Nr(d) && !Nr(m) ? d !== d && m !== m : tee(d, m, P, z, ag, Y)
        }

        function tee(d, m, P, z, Y, re) {
          var le = Qt(d),
            fe = Qt(m),
            xe = le ? ne : Qi(d),
            Re = fe ? ne : Qi(m);
          xe = xe == H ? He : xe, Re = Re == H ? He : Re;
          var De = xe == He,
            je = Re == He,
            rt = xe == Re;
          if (rt && ju(d)) {
            if (!ju(m)) return !1;
            le = !0, De = !1
          }
          if (rt && !De) return re || (re = new qa), le || i0(d) ? UP(d, m, P, z, Y, re) : _ee(d, m, xe, P, z, Y, re);
          if (!(P & y)) {
            var bt = De && Wn.call(d, "__wrapped__"),
              Lt = je && Wn.call(m, "__wrapped__");
            if (bt || Lt) {
              var ln = bt ? d.value() : d,
                Bt = Lt ? m.value() : m;
              return re || (re = new qa), Y(ln, Bt, P, z, re)
            }
          }
          return rt ? (re || (re = new qa), Iee(d, m, P, z, Y, re)) : !1
        }

        function nee(d) {
          return Nr(d) && Qi(d) == ue
        }

        function qE(d, m, P, z) {
          var Y = P.length,
            re = Y,
            le = !z;
          if (d == null) return !re;
          for (d = rr(d); Y--;) {
            var fe = P[Y];
            if (le && fe[2] ? fe[1] !== d[fe[0]] : !(fe[0] in d)) return !1
          }
          for (; ++Y < re;) {
            fe = P[Y];
            var xe = fe[0],
              Re = d[xe],
              De = fe[1];
            if (le && fe[2]) {
              if (Re === n && !(xe in d)) return !1
            } else {
              var je = new qa;
              if (z) var rt = z(Re, De, xe, d, m, je);
              if (!(rt === n ? ag(De, Re, y | x, z, je) : rt)) return !1
            }
          }
          return !0
        }

        function lP(d) {
          if (!Tr(d) || Bee(d)) return !1;
          var m = Rl(d) ? nZ : zs;
          return m.test(df(d))
        }

        function ree(d) {
          return Nr(d) && gs(d) == de
        }

        function iee(d) {
          return Nr(d) && Qi(d) == we
        }

        function see(d) {
          return Nr(d) && $v(d.length) && !!er[gs(d)]
        }

        function uP(d) {
          return typeof d == "function" ? d : d == null ? Gs : typeof d == "object" ? Qt(d) ? hP(d[0], d[1]) : fP(d) : OR(d)
        }

        function GE(d) {
          if (!ug(d)) return cZ(d);
          var m = [];
          for (var P in rr(d)) Wn.call(d, P) && P != "constructor" && m.push(P);
          return m
        }

        function oee(d) {
          if (!Tr(d)) return zee(d);
          var m = ug(d),
            P = [];
          for (var z in d) z == "constructor" && (m || !Wn.call(d, z)) || P.push(z);
          return P
        }

        function KE(d, m) {
          return d < m
        }

        function dP(d, m) {
          var P = -1,
            z = Ws(d) ? Te(d.length) : [];
          return $u(d, function (Y, re, le) {
            z[++P] = m(Y, re, le)
          }), z
        }

        function fP(d) {
          var m = l4(d);
          return m.length == 1 && m[0][2] ? qP(m[0][0], m[0][1]) : function (P) {
            return P === d || qE(P, d, m)
          }
        }

        function hP(d, m) {
          return d4(d) && WP(m) ? qP(Mc(d), m) : function (P) {
            var z = x4(P, d);
            return z === n && z === m ? E4(P, d) : ag(m, z, y | x)
          }
        }

        function wv(d, m, P, z, Y) {
          d !== m && zE(m, function (re, le) {
            if (Y || (Y = new qa), Tr(re)) aee(d, m, le, P, wv, z, Y);
            else {
              var fe = z ? z(h4(d, le), re, le + "", d, m, Y) : n;
              fe === n && (fe = re), jE(d, le, fe)
            }
          }, qs)
        }

        function aee(d, m, P, z, Y, re, le) {
          var fe = h4(d, P),
            xe = h4(m, P),
            Re = le.get(xe);
          if (Re) {
            jE(d, P, Re);
            return
          }
          var De = re ? re(fe, xe, P + "", d, m, le) : n,
            je = De === n;
          if (je) {
            var rt = Qt(xe),
              bt = !rt && ju(xe),
              Lt = !rt && !bt && i0(xe);
            De = xe, rt || bt || Lt ? Qt(fe) ? De = fe : Vr(fe) ? De = Vs(fe) : bt ? (je = !1, De = AP(xe, !0)) : Lt ? (je = !1, De = TP(xe, !0)) : De = [] : fg(xe) || ff(xe) ? (De = fe, ff(fe) ? De = ER(fe) : (!Tr(fe) || Rl(fe)) && (De = VP(xe))) : je = !1
          }
          je && (le.set(xe, De), Y(De, xe, z, re, le), le.delete(xe)), jE(d, P, De)
        }

        function pP(d, m) {
          var P = d.length;
          if (P) return m += m < 0 ? P : 0, Pl(m, P) ? d[m] : n
        }

        function mP(d, m, P) {
          m.length ? m = br(m, function (re) {
            return Qt(re) ? function (le) {
              return lf(le, re.length === 1 ? re[0] : re)
            } : re
          }) : m = [Gs];
          var z = -1;
          m = br(m, wo(Nt()));
          var Y = dP(d, function (re, le, fe) {
            var xe = br(m, function (Re) {
              return Re(re)
            });
            return {
              criteria: xe,
              index: ++z,
              value: re
            }
          });
          return NX(Y, function (re, le) {
            return wee(re, le, P)
          })
        }

        function cee(d, m) {
          return gP(d, m, function (P, z) {
            return E4(d, z)
          })
        }

        function gP(d, m, P) {
          for (var z = -1, Y = m.length, re = {}; ++z < Y;) {
            var le = m[z],
              fe = lf(d, le);
            P(fe, le) && cg(re, Bu(le, d), fe)
          }
          return re
        }

        function lee(d) {
          return function (m) {
            return lf(m, d)
          }
        }

        function QE(d, m, P, z) {
          var Y = z ? DX : Gh,
            re = -1,
            le = m.length,
            fe = d;
          for (d === m && (m = Vs(m)), P && (fe = br(d, wo(P))); ++re < le;)
            for (var xe = 0, Re = m[re], De = P ? P(Re) : Re;
              (xe = Y(fe, De, xe, z)) > -1;) fe !== d && uv.call(fe, xe, 1), uv.call(d, xe, 1);
          return d
        }

        function yP(d, m) {
          for (var P = d ? m.length : 0, z = P - 1; P--;) {
            var Y = m[P];
            if (P == z || Y !== re) {
              var re = Y;
              Pl(Y) ? uv.call(d, Y, 1) : ZE(d, Y)
            }
          }
          return d
        }

        function YE(d, m) {
          return d + hv(JI() * (m - d + 1))
        }

        function uee(d, m, P, z) {
          for (var Y = -1, re = ai(fv((m - d) / (P || 1)), 0), le = Te(re); re--;) le[z ? re : ++Y] = d, d += P;
          return le
        }

        function JE(d, m) {
          var P = "";
          if (!d || m < 1 || m > O) return P;
          do m % 2 && (P += d), m = hv(m / 2), m && (d += d); while (m);
          return P
        }

        function un(d, m) {
          return p4(GP(d, m, Gs), d + "")
        }

        function dee(d) {
          return eP(s0(d))
        }

        function fee(d, m) {
          var P = s0(d);
          return Pv(P, cf(m, 0, P.length))
        }

        function cg(d, m, P, z) {
          if (!Tr(d)) return d;
          m = Bu(m, d);
          for (var Y = -1, re = m.length, le = re - 1, fe = d; fe != null && ++Y < re;) {
            var xe = Mc(m[Y]),
              Re = P;
            if (xe === "__proto__" || xe === "constructor" || xe === "prototype") return d;
            if (Y != le) {
              var De = fe[xe];
              Re = z ? z(De, xe, fe) : n, Re === n && (Re = Tr(De) ? De : Pl(m[Y + 1]) ? [] : {})
            }
            ig(fe, xe, Re), fe = fe[xe]
          }
          return d
        }
        var vP = pv ? function (d, m) {
            return pv.set(d, m), d
          } : Gs,
          hee = dv ? function (d, m) {
            return dv(d, "toString", {
              configurable: !0,
              enumerable: !1,
              value: C4(m),
              writable: !0
            })
          } : Gs;

        function pee(d) {
          return Pv(s0(d))
        }

        function ta(d, m, P) {
          var z = -1,
            Y = d.length;
          m < 0 && (m = -m > Y ? 0 : Y + m), P = P > Y ? Y : P, P < 0 && (P += Y), Y = m > P ? 0 : P - m >>> 0, m >>>= 0;
          for (var re = Te(Y); ++z < Y;) re[z] = d[z + m];
          return re
        }

        function mee(d, m) {
          var P;
          return $u(d, function (z, Y, re) {
            return P = m(z, Y, re), !P
          }), !!P
        }

        function xv(d, m, P) {
          var z = 0,
            Y = d == null ? z : d.length;
          if (typeof m == "number" && m === m && Y <= Q) {
            for (; z < Y;) {
              var re = z + Y >>> 1,
                le = d[re];
              le !== null && !Eo(le) && (P ? le <= m : le < m) ? z = re + 1 : Y = re
            }
            return Y
          }
          return XE(d, m, Gs, P)
        }

        function XE(d, m, P, z) {
          var Y = 0,
            re = d == null ? 0 : d.length;
          if (re === 0) return 0;
          m = P(m);
          for (var le = m !== m, fe = m === null, xe = Eo(m), Re = m === n; Y < re;) {
            var De = hv((Y + re) / 2),
              je = P(d[De]),
              rt = je !== n,
              bt = je === null,
              Lt = je === je,
              ln = Eo(je);
            if (le) var Bt = z || Lt;
            else Re ? Bt = Lt && (z || rt) : fe ? Bt = Lt && rt && (z || !bt) : xe ? Bt = Lt && rt && !bt && (z || !ln) : bt || ln ? Bt = !1 : Bt = z ? je <= m : je < m;
            Bt ? Y = De + 1 : re = De
          }
          return Ki(re, M)
        }

        function bP(d, m) {
          for (var P = -1, z = d.length, Y = 0, re = []; ++P < z;) {
            var le = d[P],
              fe = m ? m(le) : le;
            if (!P || !Ga(fe, xe)) {
              var xe = fe;
              re[Y++] = le === 0 ? 0 : le
            }
          }
          return re
        }

        function wP(d) {
          return typeof d == "number" ? d : Eo(d) ? q : +d
        }

        function xo(d) {
          if (typeof d == "string") return d;
          if (Qt(d)) return br(d, xo) + "";
          if (Eo(d)) return XI ? XI.call(d) : "";
          var m = d + "";
          return m == "0" && 1 / d == -N ? "-0" : m
        }

        function Lu(d, m, P) {
          var z = -1,
            Y = ev,
            re = d.length,
            le = !0,
            fe = [],
            xe = fe;
          if (P) le = !1, Y = kE;
          else if (re >= i) {
            var Re = m ? null : Tee(d);
            if (Re) return nv(Re);
            le = !1, Y = Xm, xe = new af
          } else xe = m ? [] : fe;
          e: for (; ++z < re;) {
            var De = d[z],
              je = m ? m(De) : De;
            if (De = P || De !== 0 ? De : 0, le && je === je) {
              for (var rt = xe.length; rt--;)
                if (xe[rt] === je) continue e;
              m && xe.push(je), fe.push(De)
            } else Y(xe, je, P) || (xe !== fe && xe.push(je), fe.push(De))
          }
          return fe
        }

        function ZE(d, m) {
          return m = Bu(m, d), d = KP(d, m), d == null || delete d[Mc(na(m))]
        }

        function xP(d, m, P, z) {
          return cg(d, m, P(lf(d, m)), z)
        }

        function Ev(d, m, P, z) {
          for (var Y = d.length, re = z ? Y : -1;
            (z ? re-- : ++re < Y) && m(d[re], re, d););
          return P ? ta(d, z ? 0 : re, z ? re + 1 : Y) : ta(d, z ? re + 1 : 0, z ? Y : re)
        }

        function EP(d, m) {
          var P = d;
          return P instanceof mn && (P = P.value()), _E(m, function (z, Y) {
            return Y.func.apply(Y.thisArg, Du([z], Y.args))
          }, P)
        }

        function e4(d, m, P) {
          var z = d.length;
          if (z < 2) return z ? Lu(d[0]) : [];
          for (var Y = -1, re = Te(z); ++Y < z;)
            for (var le = d[Y], fe = -1; ++fe < z;) fe != Y && (re[Y] = sg(re[Y] || le, d[fe], m, P));
          return Lu(Di(re, 1), m, P)
        }

        function SP(d, m, P) {
          for (var z = -1, Y = d.length, re = m.length, le = {}; ++z < Y;) {
            var fe = z < re ? m[z] : n;
            P(le, d[z], fe)
          }
          return le
        }

        function t4(d) {
          return Vr(d) ? d : []
        }

        function n4(d) {
          return typeof d == "function" ? d : Gs
        }

        function Bu(d, m) {
          return Qt(d) ? d : d4(d, m) ? [d] : XP(Un(d))
        }
        var gee = un;

        function Fu(d, m, P) {
          var z = d.length;
          return P = P === n ? z : P, !m && P >= z ? d : ta(d, m, P)
        }
        var CP = rZ || function (d) {
          return En.clearTimeout(d)
        };

        function AP(d, m) {
          if (m) return d.slice();
          var P = d.length,
            z = qI ? qI(P) : new d.constructor(P);
          return d.copy(z), z
        }

        function r4(d) {
          var m = new d.constructor(d.byteLength);
          return new cv(m).set(new cv(d)), m
        }

        function yee(d, m) {
          var P = m ? r4(d.buffer) : d.buffer;
          return new d.constructor(P, d.byteOffset, d.byteLength)
        }

        function vee(d) {
          var m = new d.constructor(d.source, cn.exec(d));
          return m.lastIndex = d.lastIndex, m
        }

        function bee(d) {
          return rg ? rr(rg.call(d)) : {}
        }

        function TP(d, m) {
          var P = m ? r4(d.buffer) : d.buffer;
          return new d.constructor(P, d.byteOffset, d.length)
        }

        function kP(d, m) {
          if (d !== m) {
            var P = d !== n,
              z = d === null,
              Y = d === d,
              re = Eo(d),
              le = m !== n,
              fe = m === null,
              xe = m === m,
              Re = Eo(m);
            if (!fe && !Re && !re && d > m || re && le && xe && !fe && !Re || z && le && xe || !P && xe || !Y) return 1;
            if (!z && !re && !Re && d < m || Re && P && Y && !z && !re || fe && P && Y || !le && Y || !xe) return -1
          }
          return 0
        }

        function wee(d, m, P) {
          for (var z = -1, Y = d.criteria, re = m.criteria, le = Y.length, fe = P.length; ++z < le;) {
            var xe = kP(Y[z], re[z]);
            if (xe) {
              if (z >= fe) return xe;
              var Re = P[z];
              return xe * (Re == "desc" ? -1 : 1)
            }
          }
          return d.index - m.index
        }

        function _P(d, m, P, z) {
          for (var Y = -1, re = d.length, le = P.length, fe = -1, xe = m.length, Re = ai(re - le, 0), De = Te(xe + Re), je = !z; ++fe < xe;) De[fe] = m[fe];
          for (; ++Y < le;)(je || Y < re) && (De[P[Y]] = d[Y]);
          for (; Re--;) De[fe++] = d[Y++];
          return De
        }

        function IP(d, m, P, z) {
          for (var Y = -1, re = d.length, le = -1, fe = P.length, xe = -1, Re = m.length, De = ai(re - fe, 0), je = Te(De + Re), rt = !z; ++Y < De;) je[Y] = d[Y];
          for (var bt = Y; ++xe < Re;) je[bt + xe] = m[xe];
          for (; ++le < fe;)(rt || Y < re) && (je[bt + P[le]] = d[Y++]);
          return je
        }

        function Vs(d, m) {
          var P = -1,
            z = d.length;
          for (m || (m = Te(z)); ++P < z;) m[P] = d[P];
          return m
        }

        function Nc(d, m, P, z) {
          var Y = !P;
          P || (P = {});
          for (var re = -1, le = m.length; ++re < le;) {
            var fe = m[re],
              xe = z ? z(P[fe], d[fe], fe, P, d) : n;
            xe === n && (xe = d[fe]), Y ? kl(P, fe, xe) : ig(P, fe, xe)
          }
          return P
        }

        function xee(d, m) {
          return Nc(d, u4(d), m)
        }

        function Eee(d, m) {
          return Nc(d, zP(d), m)
        }

        function Sv(d, m) {
          return function (P, z) {
            var Y = Qt(P) ? kX : VZ,
              re = m ? m() : {};
            return Y(P, d, Nt(z, 2), re)
          }
        }

        function t0(d) {
          return un(function (m, P) {
            var z = -1,
              Y = P.length,
              re = Y > 1 ? P[Y - 1] : n,
              le = Y > 2 ? P[2] : n;
            for (re = d.length > 3 && typeof re == "function" ? (Y--, re) : n, le && ys(P[0], P[1], le) && (re = Y < 3 ? n : re, Y = 1), m = rr(m); ++z < Y;) {
              var fe = P[z];
              fe && d(m, fe, z, re)
            }
            return m
          })
        }

        function PP(d, m) {
          return function (P, z) {
            if (P == null) return P;
            if (!Ws(P)) return d(P, z);
            for (var Y = P.length, re = m ? Y : -1, le = rr(P);
              (m ? re-- : ++re < Y) && z(le[re], re, le) !== !1;);
            return P
          }
        }

        function RP(d) {
          return function (m, P, z) {
            for (var Y = -1, re = rr(m), le = z(m), fe = le.length; fe--;) {
              var xe = le[d ? fe : ++Y];
              if (P(re[xe], xe, re) === !1) break
            }
            return m
          }
        }

        function See(d, m, P) {
          var z = m & k,
            Y = lg(d);

          function re() {
            var le = this && this !== En && this instanceof re ? Y : d;
            return le.apply(z ? P : this, arguments)
          }
          return re
        }

        function OP(d) {
          return function (m) {
            m = Un(m);
            var P = Kh(m) ? Wa(m) : n,
              z = P ? P[0] : m.charAt(0),
              Y = P ? Fu(P, 1).join("") : m.slice(1);
            return z[d]() + Y
          }
        }

        function n0(d) {
          return function (m) {
            return _E(PR(IR(m).replace(Ym, "")), d, "")
          }
        }

        function lg(d) {
          return function () {
            var m = arguments;
            switch (m.length) {
              case 0:
                return new d;
              case 1:
                return new d(m[0]);
              case 2:
                return new d(m[0], m[1]);
              case 3:
                return new d(m[0], m[1], m[2]);
              case 4:
                return new d(m[0], m[1], m[2], m[3]);
              case 5:
                return new d(m[0], m[1], m[2], m[3], m[4]);
              case 6:
                return new d(m[0], m[1], m[2], m[3], m[4], m[5]);
              case 7:
                return new d(m[0], m[1], m[2], m[3], m[4], m[5], m[6])
            }
            var P = e0(d.prototype),
              z = d.apply(P, m);
            return Tr(z) ? z : P
          }
        }

        function Cee(d, m, P) {
          var z = lg(d);

          function Y() {
            for (var re = arguments.length, le = Te(re), fe = re, xe = r0(Y); fe--;) le[fe] = arguments[fe];
            var Re = re < 3 && le[0] !== xe && le[re - 1] !== xe ? [] : Nu(le, xe);
            if (re -= Re.length, re < P) return LP(d, m, Cv, Y.placeholder, n, le, Re, n, n, P - re);
            var De = this && this !== En && this instanceof Y ? z : d;
            return mi(De, this, le)
          }
          return Y
        }

        function DP(d) {
          return function (m, P, z) {
            var Y = rr(m);
            if (!Ws(m)) {
              var re = Nt(P, 3);
              m = gi(m), P = function (fe) {
                return re(Y[fe], fe, Y)
              }
            }
            var le = d(m, P, z);
            return le > -1 ? Y[re ? m[le] : le] : n
          }
        }

        function NP(d) {
          return Il(function (m) {
            var P = m.length,
              z = P,
              Y = Zo.prototype.thru;
            for (d && m.reverse(); z--;) {
              var re = m[z];
              if (typeof re != "function") throw new Xo(o);
              if (Y && !le && _v(re) == "wrapper") var le = new Zo([], !0)
            }
            for (z = le ? z : P; ++z < P;) {
              re = m[z];
              var fe = _v(re),
                xe = fe == "wrapper" ? c4(re) : n;
              xe && f4(xe[0]) && xe[1] == (w | v | I | E) && !xe[4].length && xe[9] == 1 ? le = le[_v(xe[0])].apply(le, xe[3]) : le = re.length == 1 && f4(re) ? le[fe]() : le.thru(re)
            }
            return function () {
              var Re = arguments,
                De = Re[0];
              if (le && Re.length == 1 && Qt(De)) return le.plant(De).value();
              for (var je = 0, rt = P ? m[je].apply(this, Re) : De; ++je < P;) rt = m[je].call(this, rt);
              return rt
            }
          })
        }

        function Cv(d, m, P, z, Y, re, le, fe, xe, Re) {
          var De = m & w,
            je = m & k,
            rt = m & _,
            bt = m & (v | S),
            Lt = m & D,
            ln = rt ? n : lg(d);

          function Bt() {
            for (var fn = arguments.length, Sn = Te(fn), So = fn; So--;) Sn[So] = arguments[So];
            if (bt) var vs = r0(Bt),
              Co = $X(Sn, vs);
            if (z && (Sn = _P(Sn, z, Y, bt)), re && (Sn = IP(Sn, re, le, bt)), fn -= Co, bt && fn < Re) {
              var Wr = Nu(Sn, vs);
              return LP(d, m, Cv, Bt.placeholder, P, Sn, Wr, fe, xe, Re - fn)
            }
            var Ka = je ? P : this,
              Dl = rt ? Ka[d] : d;
            return fn = Sn.length, fe ? Sn = Vee(Sn, fe) : Lt && fn > 1 && Sn.reverse(), De && xe < fn && (Sn.length = xe), this && this !== En && this instanceof Bt && (Dl = ln || lg(Dl)), Dl.apply(Ka, Sn)
          }
          return Bt
        }

        function MP(d, m) {
          return function (P, z) {
            return XZ(P, d, m(z), {})
          }
        }

        function Av(d, m) {
          return function (P, z) {
            var Y;
            if (P === n && z === n) return m;
            if (P !== n && (Y = P), z !== n) {
              if (Y === n) return z;
              typeof P == "string" || typeof z == "string" ? (P = xo(P), z = xo(z)) : (P = wP(P), z = wP(z)), Y = d(P, z)
            }
            return Y
          }
        }

        function i4(d) {
          return Il(function (m) {
            return m = br(m, wo(Nt())), un(function (P) {
              var z = this;
              return d(m, function (Y) {
                return mi(Y, z, P)
              })
            })
          })
        }

        function Tv(d, m) {
          m = m === n ? " " : xo(m);
          var P = m.length;
          if (P < 2) return P ? JE(m, d) : m;
          var z = JE(m, fv(d / Qh(m)));
          return Kh(m) ? Fu(Wa(z), 0, d).join("") : z.slice(0, d)
        }

        function Aee(d, m, P, z) {
          var Y = m & k,
            re = lg(d);

          function le() {
            for (var fe = -1, xe = arguments.length, Re = -1, De = z.length, je = Te(De + xe), rt = this && this !== En && this instanceof le ? re : d; ++Re < De;) je[Re] = z[Re];
            for (; xe--;) je[Re++] = arguments[++fe];
            return mi(rt, Y ? P : this, je)
          }
          return le
        }

        function $P(d) {
          return function (m, P, z) {
            return z && typeof z != "number" && ys(m, P, z) && (P = z = n), m = Ol(m), P === n ? (P = m, m = 0) : P = Ol(P), z = z === n ? m < P ? 1 : -1 : Ol(z), uee(m, P, z, d)
          }
        }

        function kv(d) {
          return function (m, P) {
            return typeof m == "string" && typeof P == "string" || (m = ra(m), P = ra(P)), d(m, P)
          }
        }

        function LP(d, m, P, z, Y, re, le, fe, xe, Re) {
          var De = m & v,
            je = De ? le : n,
            rt = De ? n : le,
            bt = De ? re : n,
            Lt = De ? n : re;
          m |= De ? I : A, m &= ~(De ? A : I), m & p || (m &= ~(k | _));
          var ln = [d, m, Y, bt, je, Lt, rt, fe, xe, Re],
            Bt = P.apply(n, ln);
          return f4(d) && QP(Bt, ln), Bt.placeholder = z, YP(Bt, d, m)
        }

        function s4(d) {
          var m = oi[d];
          return function (P, z) {
            if (P = ra(P), z = z == null ? 0 : Ki(on(z), 292), z && YI(P)) {
              var Y = (Un(P) + "e").split("e"),
                re = m(Y[0] + "e" + (+Y[1] + z));
              return Y = (Un(re) + "e").split("e"), +(Y[0] + "e" + (+Y[1] - z))
            }
            return m(P)
          }
        }
        var Tee = Xh && 1 / nv(new Xh([, -0]))[1] == N ? function (d) {
          return new Xh(d)
        } : k4;

        function BP(d) {
          return function (m) {
            var P = Qi(m);
            return P == ue ? ME(m) : P == we ? HX(m) : MX(m, d(m))
          }
        }

        function _l(d, m, P, z, Y, re, le, fe) {
          var xe = m & _;
          if (!xe && typeof d != "function") throw new Xo(o);
          var Re = z ? z.length : 0;
          if (Re || (m &= ~(I | A), z = Y = n), le = le === n ? le : ai(on(le), 0), fe = fe === n ? fe : on(fe), Re -= Y ? Y.length : 0, m & A) {
            var De = z,
              je = Y;
            z = Y = n
          }
          var rt = xe ? n : c4(d),
            bt = [d, m, P, z, Y, De, je, re, le, fe];
          if (rt && Uee(bt, rt), d = bt[0], m = bt[1], P = bt[2], z = bt[3], Y = bt[4], fe = bt[9] = bt[9] === n ? xe ? 0 : d.length : ai(bt[9] - Re, 0), !fe && m & (v | S) && (m &= ~(v | S)), !m || m == k) var Lt = See(d, m, P);
          else m == v || m == S ? Lt = Cee(d, m, fe) : (m == I || m == (k | I)) && !Y.length ? Lt = Aee(d, m, P, z) : Lt = Cv.apply(n, bt);
          var ln = rt ? vP : QP;
          return YP(ln(Lt, bt), d, m)
        }

        function FP(d, m, P, z) {
          return d === n || Ga(d, Jh[P]) && !Wn.call(z, P) ? m : d
        }

        function jP(d, m, P, z, Y, re) {
          return Tr(d) && Tr(m) && (re.set(m, d), wv(d, m, n, jP, re), re.delete(m)), d
        }

        function kee(d) {
          return fg(d) ? n : d
        }

        function UP(d, m, P, z, Y, re) {
          var le = P & y,
            fe = d.length,
            xe = m.length;
          if (fe != xe && !(le && xe > fe)) return !1;
          var Re = re.get(d),
            De = re.get(m);
          if (Re && De) return Re == m && De == d;
          var je = -1,
            rt = !0,
            bt = P & x ? new af : n;
          for (re.set(d, m), re.set(m, d); ++je < fe;) {
            var Lt = d[je],
              ln = m[je];
            if (z) var Bt = le ? z(ln, Lt, je, m, d, re) : z(Lt, ln, je, d, m, re);
            if (Bt !== n) {
              if (Bt) continue;
              rt = !1;
              break
            }
            if (bt) {
              if (!IE(m, function (fn, Sn) {
                  if (!Xm(bt, Sn) && (Lt === fn || Y(Lt, fn, P, z, re))) return bt.push(Sn)
                })) {
                rt = !1;
                break
              }
            } else if (!(Lt === ln || Y(Lt, ln, P, z, re))) {
              rt = !1;
              break
            }
          }
          return re.delete(d), re.delete(m), rt
        }

        function _ee(d, m, P, z, Y, re, le) {
          switch (P) {
            case We:
              if (d.byteLength != m.byteLength || d.byteOffset != m.byteOffset) return !1;
              d = d.buffer, m = m.buffer;
            case Me:
              return !(d.byteLength != m.byteLength || !re(new cv(d), new cv(m)));
            case Z:
            case te:
            case ge:
              return Ga(+d, +m);
            case J:
              return d.name == m.name && d.message == m.message;
            case de:
            case Ce:
              return d == m + "";
            case ue:
              var fe = ME;
            case we:
              var xe = z & y;
              if (fe || (fe = nv), d.size != m.size && !xe) return !1;
              var Re = le.get(d);
              if (Re) return Re == m;
              z |= x, le.set(d, m);
              var De = UP(fe(d), fe(m), z, Y, re, le);
              return le.delete(d), De;
            case be:
              if (rg) return rg.call(d) == rg.call(m)
          }
          return !1
        }

        function Iee(d, m, P, z, Y, re) {
          var le = P & y,
            fe = o4(d),
            xe = fe.length,
            Re = o4(m),
            De = Re.length;
          if (xe != De && !le) return !1;
          for (var je = xe; je--;) {
            var rt = fe[je];
            if (!(le ? rt in m : Wn.call(m, rt))) return !1
          }
          var bt = re.get(d),
            Lt = re.get(m);
          if (bt && Lt) return bt == m && Lt == d;
          var ln = !0;
          re.set(d, m), re.set(m, d);
          for (var Bt = le; ++je < xe;) {
            rt = fe[je];
            var fn = d[rt],
              Sn = m[rt];
            if (z) var So = le ? z(Sn, fn, rt, m, d, re) : z(fn, Sn, rt, d, m, re);
            if (!(So === n ? fn === Sn || Y(fn, Sn, P, z, re) : So)) {
              ln = !1;
              break
            }
            Bt || (Bt = rt == "constructor")
          }
          if (ln && !Bt) {
            var vs = d.constructor,
              Co = m.constructor;
            vs != Co && "constructor" in d && "constructor" in m && !(typeof vs == "function" && vs instanceof vs && typeof Co == "function" && Co instanceof Co) && (ln = !1)
          }
          return re.delete(d), re.delete(m), ln
        }

        function Il(d) {
          return p4(GP(d, n, nR), d + "")
        }

        function o4(d) {
          return aP(d, gi, u4)
        }

        function a4(d) {
          return aP(d, qs, zP)
        }
        var c4 = pv ? function (d) {
          return pv.get(d)
        } : k4;

        function _v(d) {
          for (var m = d.name + "", P = Zh[m], z = Wn.call(Zh, m) ? P.length : 0; z--;) {
            var Y = P[z],
              re = Y.func;
            if (re == null || re == d) return Y.name
          }
          return m
        }

        function r0(d) {
          var m = Wn.call(ee, "placeholder") ? ee : d;
          return m.placeholder
        }

        function Nt() {
          var d = ee.iteratee || A4;
          return d = d === A4 ? uP : d, arguments.length ? d(arguments[0], arguments[1]) : d
        }

        function Iv(d, m) {
          var P = d.__data__;
          return Lee(m) ? P[typeof m == "string" ? "string" : "hash"] : P.map
        }

        function l4(d) {
          for (var m = gi(d), P = m.length; P--;) {
            var z = m[P],
              Y = d[z];
            m[P] = [z, Y, WP(Y)]
          }
          return m
        }

        function uf(d, m) {
          var P = jX(d, m);
          return lP(P) ? P : n
        }

        function Pee(d) {
          var m = Wn.call(d, sf),
            P = d[sf];
          try {
            d[sf] = n;
            var z = !0
          } catch {}
          var Y = ov.call(d);
          return z && (m ? d[sf] = P : delete d[sf]), Y
        }
        var u4 = LE ? function (d) {
            return d == null ? [] : (d = rr(d), Ou(LE(d), function (m) {
              return KI.call(d, m)
            }))
          } : _4,
          zP = LE ? function (d) {
            for (var m = []; d;) Du(m, u4(d)), d = lv(d);
            return m
          } : _4,
          Qi = gs;
        (BE && Qi(new BE(new ArrayBuffer(1))) != We || eg && Qi(new eg) != ue || FE && Qi(FE.resolve()) != se || Xh && Qi(new Xh) != we || tg && Qi(new tg) != Fe) && (Qi = function (d) {
          var m = gs(d),
            P = m == He ? d.constructor : n,
            z = P ? df(P) : "";
          if (z) switch (z) {
            case fZ:
              return We;
            case hZ:
              return ue;
            case pZ:
              return se;
            case mZ:
              return we;
            case gZ:
              return Fe
          }
          return m
        });

        function Ree(d, m, P) {
          for (var z = -1, Y = P.length; ++z < Y;) {
            var re = P[z],
              le = re.size;
            switch (re.type) {
              case "drop":
                d += le;
                break;
              case "dropRight":
                m -= le;
                break;
              case "take":
                m = Ki(m, d + le);
                break;
              case "takeRight":
                d = ai(d, m - le);
                break
            }
          }
          return {
            start: d,
            end: m
          }
        }

        function Oee(d) {
          var m = d.match(wt);
          return m ? m[1].split($t) : []
        }

        function HP(d, m, P) {
          m = Bu(m, d);
          for (var z = -1, Y = m.length, re = !1; ++z < Y;) {
            var le = Mc(m[z]);
            if (!(re = d != null && P(d, le))) break;
            d = d[le]
          }
          return re || ++z != Y ? re : (Y = d == null ? 0 : d.length, !!Y && $v(Y) && Pl(le, Y) && (Qt(d) || ff(d)))
        }

        function Dee(d) {
          var m = d.length,
            P = new d.constructor(m);
          return m && typeof d[0] == "string" && Wn.call(d, "index") && (P.index = d.index, P.input = d.input), P
        }

        function VP(d) {
          return typeof d.constructor == "function" && !ug(d) ? e0(lv(d)) : {}
        }

        function Nee(d, m, P) {
          var z = d.constructor;
          switch (m) {
            case Me:
              return r4(d);
            case Z:
            case te:
              return new z(+d);
            case We:
              return yee(d, P);
            case ke:
            case ze:
            case ct:
            case Xe:
            case _e:
            case Ze:
            case Ee:
            case Oe:
            case yt:
              return TP(d, P);
            case ue:
              return new z;
            case ge:
            case Ce:
              return new z(d);
            case de:
              return vee(d);
            case we:
              return new z;
            case be:
              return bee(d)
          }
        }

        function Mee(d, m) {
          var P = m.length;
          if (!P) return d;
          var z = P - 1;
          return m[z] = (P > 1 ? "& " : "") + m[z], m = m.join(P > 2 ? ", " : " "), d.replace(Pn, `{
/* [wrapped with ` + m + `] */
`)
        }

        function $ee(d) {
          return Qt(d) || ff(d) || !!(QI && d && d[QI])
        }

        function Pl(d, m) {
          var P = typeof d;
          return m = m ?? O, !!m && (P == "number" || P != "symbol" && or.test(d)) && d > -1 && d % 1 == 0 && d < m
        }

        function ys(d, m, P) {
          if (!Tr(P)) return !1;
          var z = typeof m;
          return (z == "number" ? Ws(P) && Pl(m, P.length) : z == "string" && m in P) ? Ga(P[m], d) : !1
        }

        function d4(d, m) {
          if (Qt(d)) return !1;
          var P = typeof d;
          return P == "number" || P == "symbol" || P == "boolean" || d == null || Eo(d) ? !0 : _n.test(d) || !Pt.test(d) || m != null && d in rr(m)
        }

        function Lee(d) {
          var m = typeof d;
          return m == "string" || m == "number" || m == "symbol" || m == "boolean" ? d !== "__proto__" : d === null
        }

        function f4(d) {
          var m = _v(d),
            P = ee[m];
          if (typeof P != "function" || !(m in mn.prototype)) return !1;
          if (d === P) return !0;
          var z = c4(P);
          return !!z && d === z[0]
        }

        function Bee(d) {
          return !!WI && WI in d
        }
        var Fee = iv ? Rl : I4;

        function ug(d) {
          var m = d && d.constructor,
            P = typeof m == "function" && m.prototype || Jh;
          return d === P
        }

        function WP(d) {
          return d === d && !Tr(d)
        }

        function qP(d, m) {
          return function (P) {
            return P == null ? !1 : P[d] === m && (m !== n || d in rr(P))
          }
        }

        function jee(d) {
          var m = Nv(d, function (z) {
              return P.size === l && P.clear(), z
            }),
            P = m.cache;
          return m
        }

        function Uee(d, m) {
          var P = d[1],
            z = m[1],
            Y = P | z,
            re = Y < (k | _ | w),
            le = z == w && P == v || z == w && P == E && d[7].length <= m[8] || z == (w | E) && m[7].length <= m[8] && P == v;
          if (!(re || le)) return d;
          z & k && (d[2] = m[2], Y |= P & k ? 0 : p);
          var fe = m[3];
          if (fe) {
            var xe = d[3];
            d[3] = xe ? _P(xe, fe, m[4]) : fe, d[4] = xe ? Nu(d[3], u) : m[4]
          }
          return fe = m[5], fe && (xe = d[5], d[5] = xe ? IP(xe, fe, m[6]) : fe, d[6] = xe ? Nu(d[5], u) : m[6]), fe = m[7], fe && (d[7] = fe), z & w && (d[8] = d[8] == null ? m[8] : Ki(d[8], m[8])), d[9] == null && (d[9] = m[9]), d[0] = m[0], d[1] = Y, d
        }

        function zee(d) {
          var m = [];
          if (d != null)
            for (var P in rr(d)) m.push(P);
          return m
        }

        function Hee(d) {
          return ov.call(d)
        }

        function GP(d, m, P) {
          return m = ai(m === n ? d.length - 1 : m, 0),
            function () {
              for (var z = arguments, Y = -1, re = ai(z.length - m, 0), le = Te(re); ++Y < re;) le[Y] = z[m + Y];
              Y = -1;
              for (var fe = Te(m + 1); ++Y < m;) fe[Y] = z[Y];
              return fe[m] = P(le), mi(d, this, fe)
            }
        }

        function KP(d, m) {
          return m.length < 2 ? d : lf(d, ta(m, 0, -1))
        }

        function Vee(d, m) {
          for (var P = d.length, z = Ki(m.length, P), Y = Vs(d); z--;) {
            var re = m[z];
            d[z] = Pl(re, P) ? Y[re] : n
          }
          return d
        }

        function h4(d, m) {
          if (!(m === "constructor" && typeof d[m] == "function") && m != "__proto__") return d[m]
        }
        var QP = JP(vP),
          dg = sZ || function (d, m) {
            return En.setTimeout(d, m)
          },
          p4 = JP(hee);

        function YP(d, m, P) {
          var z = m + "";
          return p4(d, Mee(z, Wee(Oee(z), P)))
        }

        function JP(d) {
          var m = 0,
            P = 0;
          return function () {
            var z = lZ(),
              Y = L - (z - P);
            if (P = z, Y > 0) {
              if (++m >= G) return arguments[0]
            } else m = 0;
            return d.apply(n, arguments)
          }
        }

        function Pv(d, m) {
          var P = -1,
            z = d.length,
            Y = z - 1;
          for (m = m === n ? z : m; ++P < m;) {
            var re = YE(P, Y),
              le = d[re];
            d[re] = d[P], d[P] = le
          }
          return d.length = m, d
        }
        var XP = jee(function (d) {
          var m = [];
          return d.charCodeAt(0) === 46 && m.push(""), d.replace(zt, function (P, z, Y, re) {
            m.push(Y ? re.replace(On, "$1") : z || P)
          }), m
        });

        function Mc(d) {
          if (typeof d == "string" || Eo(d)) return d;
          var m = d + "";
          return m == "0" && 1 / d == -N ? "-0" : m
        }

        function df(d) {
          if (d != null) {
            try {
              return sv.call(d)
            } catch {}
            try {
              return d + ""
            } catch {}
          }
          return ""
        }

        function Wee(d, m) {
          return Jo(he, function (P) {
            var z = "_." + P[0];
            m & P[1] && !ev(d, z) && d.push(z)
          }), d.sort()
        }

        function ZP(d) {
          if (d instanceof mn) return d.clone();
          var m = new Zo(d.__wrapped__, d.__chain__);
          return m.__actions__ = Vs(d.__actions__), m.__index__ = d.__index__, m.__values__ = d.__values__, m
        }

        function qee(d, m, P) {
          (P ? ys(d, m, P) : m === n) ? m = 1: m = ai(on(m), 0);
          var z = d == null ? 0 : d.length;
          if (!z || m < 1) return [];
          for (var Y = 0, re = 0, le = Te(fv(z / m)); Y < z;) le[re++] = ta(d, Y, Y += m);
          return le
        }

        function Gee(d) {
          for (var m = -1, P = d == null ? 0 : d.length, z = 0, Y = []; ++m < P;) {
            var re = d[m];
            re && (Y[z++] = re)
          }
          return Y
        }

        function Kee() {
          var d = arguments.length;
          if (!d) return [];
          for (var m = Te(d - 1), P = arguments[0], z = d; z--;) m[z - 1] = arguments[z];
          return Du(Qt(P) ? Vs(P) : [P], Di(m, 1))
        }
        var Qee = un(function (d, m) {
            return Vr(d) ? sg(d, Di(m, 1, Vr, !0)) : []
          }),
          Yee = un(function (d, m) {
            var P = na(m);
            return Vr(P) && (P = n), Vr(d) ? sg(d, Di(m, 1, Vr, !0), Nt(P, 2)) : []
          }),
          Jee = un(function (d, m) {
            var P = na(m);
            return Vr(P) && (P = n), Vr(d) ? sg(d, Di(m, 1, Vr, !0), n, P) : []
          });

        function Xee(d, m, P) {
          var z = d == null ? 0 : d.length;
          return z ? (m = P || m === n ? 1 : on(m), ta(d, m < 0 ? 0 : m, z)) : []
        }

        function Zee(d, m, P) {
          var z = d == null ? 0 : d.length;
          return z ? (m = P || m === n ? 1 : on(m), m = z - m, ta(d, 0, m < 0 ? 0 : m)) : []
        }

        function ete(d, m) {
          return d && d.length ? Ev(d, Nt(m, 3), !0, !0) : []
        }

        function tte(d, m) {
          return d && d.length ? Ev(d, Nt(m, 3), !0) : []
        }

        function nte(d, m, P, z) {
          var Y = d == null ? 0 : d.length;
          return Y ? (P && typeof P != "number" && ys(d, m, P) && (P = 0, z = Y), KZ(d, m, P, z)) : []
        }

        function eR(d, m, P) {
          var z = d == null ? 0 : d.length;
          if (!z) return -1;
          var Y = P == null ? 0 : on(P);
          return Y < 0 && (Y = ai(z + Y, 0)), tv(d, Nt(m, 3), Y)
        }

        function tR(d, m, P) {
          var z = d == null ? 0 : d.length;
          if (!z) return -1;
          var Y = z - 1;
          return P !== n && (Y = on(P), Y = P < 0 ? ai(z + Y, 0) : Ki(Y, z - 1)), tv(d, Nt(m, 3), Y, !0)
        }

        function nR(d) {
          var m = d == null ? 0 : d.length;
          return m ? Di(d, 1) : []
        }

        function rte(d) {
          var m = d == null ? 0 : d.length;
          return m ? Di(d, N) : []
        }

        function ite(d, m) {
          var P = d == null ? 0 : d.length;
          return P ? (m = m === n ? 1 : on(m), Di(d, m)) : []
        }

        function ste(d) {
          for (var m = -1, P = d == null ? 0 : d.length, z = {}; ++m < P;) {
            var Y = d[m];
            z[Y[0]] = Y[1]
          }
          return z
        }

        function rR(d) {
          return d && d.length ? d[0] : n
        }

        function ote(d, m, P) {
          var z = d == null ? 0 : d.length;
          if (!z) return -1;
          var Y = P == null ? 0 : on(P);
          return Y < 0 && (Y = ai(z + Y, 0)), Gh(d, m, Y)
        }

        function ate(d) {
          var m = d == null ? 0 : d.length;
          return m ? ta(d, 0, -1) : []
        }
        var cte = un(function (d) {
            var m = br(d, t4);
            return m.length && m[0] === d[0] ? WE(m) : []
          }),
          lte = un(function (d) {
            var m = na(d),
              P = br(d, t4);
            return m === na(P) ? m = n : P.pop(), P.length && P[0] === d[0] ? WE(P, Nt(m, 2)) : []
          }),
          ute = un(function (d) {
            var m = na(d),
              P = br(d, t4);
            return m = typeof m == "function" ? m : n, m && P.pop(), P.length && P[0] === d[0] ? WE(P, n, m) : []
          });

        function dte(d, m) {
          return d == null ? "" : aZ.call(d, m)
        }

        function na(d) {
          var m = d == null ? 0 : d.length;
          return m ? d[m - 1] : n
        }

        function fte(d, m, P) {
          var z = d == null ? 0 : d.length;
          if (!z) return -1;
          var Y = z;
          return P !== n && (Y = on(P), Y = Y < 0 ? ai(z + Y, 0) : Ki(Y, z - 1)), m === m ? WX(d, m, Y) : tv(d, LI, Y, !0)
        }

        function hte(d, m) {
          return d && d.length ? pP(d, on(m)) : n
        }
        var pte = un(iR);

        function iR(d, m) {
          return d && d.length && m && m.length ? QE(d, m) : d
        }

        function mte(d, m, P) {
          return d && d.length && m && m.length ? QE(d, m, Nt(P, 2)) : d
        }

        function gte(d, m, P) {
          return d && d.length && m && m.length ? QE(d, m, n, P) : d
        }
        var yte = Il(function (d, m) {
          var P = d == null ? 0 : d.length,
            z = UE(d, m);
          return yP(d, br(m, function (Y) {
            return Pl(Y, P) ? +Y : Y
          }).sort(kP)), z
        });

        function vte(d, m) {
          var P = [];
          if (!(d && d.length)) return P;
          var z = -1,
            Y = [],
            re = d.length;
          for (m = Nt(m, 3); ++z < re;) {
            var le = d[z];
            m(le, z, d) && (P.push(le), Y.push(z))
          }
          return yP(d, Y), P
        }

        function m4(d) {
          return d == null ? d : dZ.call(d)
        }

        function bte(d, m, P) {
          var z = d == null ? 0 : d.length;
          return z ? (P && typeof P != "number" && ys(d, m, P) ? (m = 0, P = z) : (m = m == null ? 0 : on(m), P = P === n ? z : on(P)), ta(d, m, P)) : []
        }

        function wte(d, m) {
          return xv(d, m)
        }

        function xte(d, m, P) {
          return XE(d, m, Nt(P, 2))
        }

        function Ete(d, m) {
          var P = d == null ? 0 : d.length;
          if (P) {
            var z = xv(d, m);
            if (z < P && Ga(d[z], m)) return z
          }
          return -1
        }

        function Ste(d, m) {
          return xv(d, m, !0)
        }

        function Cte(d, m, P) {
          return XE(d, m, Nt(P, 2), !0)
        }

        function Ate(d, m) {
          var P = d == null ? 0 : d.length;
          if (P) {
            var z = xv(d, m, !0) - 1;
            if (Ga(d[z], m)) return z
          }
          return -1
        }

        function Tte(d) {
          return d && d.length ? bP(d) : []
        }

        function kte(d, m) {
          return d && d.length ? bP(d, Nt(m, 2)) : []
        }

        function _te(d) {
          var m = d == null ? 0 : d.length;
          return m ? ta(d, 1, m) : []
        }

        function Ite(d, m, P) {
          return d && d.length ? (m = P || m === n ? 1 : on(m), ta(d, 0, m < 0 ? 0 : m)) : []
        }

        function Pte(d, m, P) {
          var z = d == null ? 0 : d.length;
          return z ? (m = P || m === n ? 1 : on(m), m = z - m, ta(d, m < 0 ? 0 : m, z)) : []
        }

        function Rte(d, m) {
          return d && d.length ? Ev(d, Nt(m, 3), !1, !0) : []
        }

        function Ote(d, m) {
          return d && d.length ? Ev(d, Nt(m, 3)) : []
        }
        var Dte = un(function (d) {
            return Lu(Di(d, 1, Vr, !0))
          }),
          Nte = un(function (d) {
            var m = na(d);
            return Vr(m) && (m = n), Lu(Di(d, 1, Vr, !0), Nt(m, 2))
          }),
          Mte = un(function (d) {
            var m = na(d);
            return m = typeof m == "function" ? m : n, Lu(Di(d, 1, Vr, !0), n, m)
          });

        function $te(d) {
          return d && d.length ? Lu(d) : []
        }

        function Lte(d, m) {
          return d && d.length ? Lu(d, Nt(m, 2)) : []
        }

        function Bte(d, m) {
          return m = typeof m == "function" ? m : n, d && d.length ? Lu(d, n, m) : []
        }

        function g4(d) {
          if (!(d && d.length)) return [];
          var m = 0;
          return d = Ou(d, function (P) {
            if (Vr(P)) return m = ai(P.length, m), !0
          }), DE(m, function (P) {
            return br(d, PE(P))
          })
        }

        function sR(d, m) {
          if (!(d && d.length)) return [];
          var P = g4(d);
          return m == null ? P : br(P, function (z) {
            return mi(m, n, z)
          })
        }
        var Fte = un(function (d, m) {
            return Vr(d) ? sg(d, m) : []
          }),
          jte = un(function (d) {
            return e4(Ou(d, Vr))
          }),
          Ute = un(function (d) {
            var m = na(d);
            return Vr(m) && (m = n), e4(Ou(d, Vr), Nt(m, 2))
          }),
          zte = un(function (d) {
            var m = na(d);
            return m = typeof m == "function" ? m : n, e4(Ou(d, Vr), n, m)
          }),
          Hte = un(g4);

        function Vte(d, m) {
          return SP(d || [], m || [], ig)
        }

        function Wte(d, m) {
          return SP(d || [], m || [], cg)
        }
        var qte = un(function (d) {
          var m = d.length,
            P = m > 1 ? d[m - 1] : n;
          return P = typeof P == "function" ? (d.pop(), P) : n, sR(d, P)
        });

        function oR(d) {
          var m = ee(d);
          return m.__chain__ = !0, m
        }

        function Gte(d, m) {
          return m(d), d
        }

        function Rv(d, m) {
          return m(d)
        }
        var Kte = Il(function (d) {
          var m = d.length,
            P = m ? d[0] : 0,
            z = this.__wrapped__,
            Y = function (re) {
              return UE(re, d)
            };
          return m > 1 || this.__actions__.length || !(z instanceof mn) || !Pl(P) ? this.thru(Y) : (z = z.slice(P, +P + (m ? 1 : 0)), z.__actions__.push({
            func: Rv,
            args: [Y],
            thisArg: n
          }), new Zo(z, this.__chain__).thru(function (re) {
            return m && !re.length && re.push(n), re
          }))
        });

        function Qte() {
          return oR(this)
        }

        function Yte() {
          return new Zo(this.value(), this.__chain__)
        }

        function Jte() {
          this.__values__ === n && (this.__values__ = wR(this.value()));
          var d = this.__index__ >= this.__values__.length,
            m = d ? n : this.__values__[this.__index__++];
          return {
            done: d,
            value: m
          }
        }

        function Xte() {
          return this
        }

        function Zte(d) {
          for (var m, P = this; P instanceof gv;) {
            var z = ZP(P);
            z.__index__ = 0, z.__values__ = n, m ? Y.__wrapped__ = z : m = z;
            var Y = z;
            P = P.__wrapped__
          }
          return Y.__wrapped__ = d, m
        }

        function ene() {
          var d = this.__wrapped__;
          if (d instanceof mn) {
            var m = d;
            return this.__actions__.length && (m = new mn(this)), m = m.reverse(), m.__actions__.push({
              func: Rv,
              args: [m4],
              thisArg: n
            }), new Zo(m, this.__chain__)
          }
          return this.thru(m4)
        }

        function tne() {
          return EP(this.__wrapped__, this.__actions__)
        }
        var nne = Sv(function (d, m, P) {
          Wn.call(d, P) ? ++d[P] : kl(d, P, 1)
        });

        function rne(d, m, P) {
          var z = Qt(d) ? MI : GZ;
          return P && ys(d, m, P) && (m = n), z(d, Nt(m, 3))
        }

        function ine(d, m) {
          var P = Qt(d) ? Ou : sP;
          return P(d, Nt(m, 3))
        }
        var sne = DP(eR),
          one = DP(tR);

        function ane(d, m) {
          return Di(Ov(d, m), 1)
        }

        function cne(d, m) {
          return Di(Ov(d, m), N)
        }

        function lne(d, m, P) {
          return P = P === n ? 1 : on(P), Di(Ov(d, m), P)
        }

        function aR(d, m) {
          var P = Qt(d) ? Jo : $u;
          return P(d, Nt(m, 3))
        }

        function cR(d, m) {
          var P = Qt(d) ? _X : iP;
          return P(d, Nt(m, 3))
        }
        var une = Sv(function (d, m, P) {
          Wn.call(d, P) ? d[P].push(m) : kl(d, P, [m])
        });

        function dne(d, m, P, z) {
          d = Ws(d) ? d : s0(d), P = P && !z ? on(P) : 0;
          var Y = d.length;
          return P < 0 && (P = ai(Y + P, 0)), Lv(d) ? P <= Y && d.indexOf(m, P) > -1 : !!Y && Gh(d, m, P) > -1
        }
        var fne = un(function (d, m, P) {
            var z = -1,
              Y = typeof m == "function",
              re = Ws(d) ? Te(d.length) : [];
            return $u(d, function (le) {
              re[++z] = Y ? mi(m, le, P) : og(le, m, P)
            }), re
          }),
          hne = Sv(function (d, m, P) {
            kl(d, P, m)
          });

        function Ov(d, m) {
          var P = Qt(d) ? br : dP;
          return P(d, Nt(m, 3))
        }

        function pne(d, m, P, z) {
          return d == null ? [] : (Qt(m) || (m = m == null ? [] : [m]), P = z ? n : P, Qt(P) || (P = P == null ? [] : [P]), mP(d, m, P))
        }
        var mne = Sv(function (d, m, P) {
          d[P ? 0 : 1].push(m)
        }, function () {
          return [
            [],
            []
          ]
        });

        function gne(d, m, P) {
          var z = Qt(d) ? _E : FI,
            Y = arguments.length < 3;
          return z(d, Nt(m, 4), P, Y, $u)
        }

        function yne(d, m, P) {
          var z = Qt(d) ? IX : FI,
            Y = arguments.length < 3;
          return z(d, Nt(m, 4), P, Y, iP)
        }

        function vne(d, m) {
          var P = Qt(d) ? Ou : sP;
          return P(d, Mv(Nt(m, 3)))
        }

        function bne(d) {
          var m = Qt(d) ? eP : dee;
          return m(d)
        }

        function wne(d, m, P) {
          (P ? ys(d, m, P) : m === n) ? m = 1: m = on(m);
          var z = Qt(d) ? zZ : fee;
          return z(d, m)
        }

        function xne(d) {
          var m = Qt(d) ? HZ : pee;
          return m(d)
        }

        function Ene(d) {
          if (d == null) return 0;
          if (Ws(d)) return Lv(d) ? Qh(d) : d.length;
          var m = Qi(d);
          return m == ue || m == we ? d.size : GE(d).length
        }

        function Sne(d, m, P) {
          var z = Qt(d) ? IE : mee;
          return P && ys(d, m, P) && (m = n), z(d, Nt(m, 3))
        }
        var Cne = un(function (d, m) {
            if (d == null) return [];
            var P = m.length;
            return P > 1 && ys(d, m[0], m[1]) ? m = [] : P > 2 && ys(m[0], m[1], m[2]) && (m = [m[0]]), mP(d, Di(m, 1), [])
          }),
          Dv = iZ || function () {
            return En.Date.now()
          };

        function Ane(d, m) {
          if (typeof m != "function") throw new Xo(o);
          return d = on(d),
            function () {
              if (--d < 1) return m.apply(this, arguments)
            }
        }

        function lR(d, m, P) {
          return m = P ? n : m, m = d && m == null ? d.length : m, _l(d, w, n, n, n, n, m)
        }

        function uR(d, m) {
          var P;
          if (typeof m != "function") throw new Xo(o);
          return d = on(d),
            function () {
              return --d > 0 && (P = m.apply(this, arguments)), d <= 1 && (m = n), P
            }
        }
        var y4 = un(function (d, m, P) {
            var z = k;
            if (P.length) {
              var Y = Nu(P, r0(y4));
              z |= I
            }
            return _l(d, z, m, P, Y)
          }),
          dR = un(function (d, m, P) {
            var z = k | _;
            if (P.length) {
              var Y = Nu(P, r0(dR));
              z |= I
            }
            return _l(m, z, d, P, Y)
          });

        function fR(d, m, P) {
          m = P ? n : m;
          var z = _l(d, v, n, n, n, n, n, m);
          return z.placeholder = fR.placeholder, z
        }

        function hR(d, m, P) {
          m = P ? n : m;
          var z = _l(d, S, n, n, n, n, n, m);
          return z.placeholder = hR.placeholder, z
        }

        function pR(d, m, P) {
          var z, Y, re, le, fe, xe, Re = 0,
            De = !1,
            je = !1,
            rt = !0;
          if (typeof d != "function") throw new Xo(o);
          m = ra(m) || 0, Tr(P) && (De = !!P.leading, je = "maxWait" in P, re = je ? ai(ra(P.maxWait) || 0, m) : re, rt = "trailing" in P ? !!P.trailing : rt);

          function bt(Wr) {
            var Ka = z,
              Dl = Y;
            return z = Y = n, Re = Wr, le = d.apply(Dl, Ka), le
          }

          function Lt(Wr) {
            return Re = Wr, fe = dg(fn, m), De ? bt(Wr) : le
          }

          function ln(Wr) {
            var Ka = Wr - xe,
              Dl = Wr - Re,
              DR = m - Ka;
            return je ? Ki(DR, re - Dl) : DR
          }

          function Bt(Wr) {
            var Ka = Wr - xe,
              Dl = Wr - Re;
            return xe === n || Ka >= m || Ka < 0 || je && Dl >= re
          }

          function fn() {
            var Wr = Dv();
            if (Bt(Wr)) return Sn(Wr);
            fe = dg(fn, ln(Wr))
          }

          function Sn(Wr) {
            return fe = n, rt && z ? bt(Wr) : (z = Y = n, le)
          }

          function So() {
            fe !== n && CP(fe), Re = 0, z = xe = Y = fe = n
          }

          function vs() {
            return fe === n ? le : Sn(Dv())
          }

          function Co() {
            var Wr = Dv(),
              Ka = Bt(Wr);
            if (z = arguments, Y = this, xe = Wr, Ka) {
              if (fe === n) return Lt(xe);
              if (je) return CP(fe), fe = dg(fn, m), bt(xe)
            }
            return fe === n && (fe = dg(fn, m)), le
          }
          return Co.cancel = So, Co.flush = vs, Co
        }
        var Tne = un(function (d, m) {
            return rP(d, 1, m)
          }),
          kne = un(function (d, m, P) {
            return rP(d, ra(m) || 0, P)
          });

        function _ne(d) {
          return _l(d, D)
        }

        function Nv(d, m) {
          if (typeof d != "function" || m != null && typeof m != "function") throw new Xo(o);
          var P = function () {
            var z = arguments,
              Y = m ? m.apply(this, z) : z[0],
              re = P.cache;
            if (re.has(Y)) return re.get(Y);
            var le = d.apply(this, z);
            return P.cache = re.set(Y, le) || re, le
          };
          return P.cache = new(Nv.Cache || Tl), P
        }
        Nv.Cache = Tl;

        function Mv(d) {
          if (typeof d != "function") throw new Xo(o);
          return function () {
            var m = arguments;
            switch (m.length) {
              case 0:
                return !d.call(this);
              case 1:
                return !d.call(this, m[0]);
              case 2:
                return !d.call(this, m[0], m[1]);
              case 3:
                return !d.call(this, m[0], m[1], m[2])
            }
            return !d.apply(this, m)
          }
        }

        function Ine(d) {
          return uR(2, d)
        }
        var Pne = gee(function (d, m) {
            m = m.length == 1 && Qt(m[0]) ? br(m[0], wo(Nt())) : br(Di(m, 1), wo(Nt()));
            var P = m.length;
            return un(function (z) {
              for (var Y = -1, re = Ki(z.length, P); ++Y < re;) z[Y] = m[Y].call(this, z[Y]);
              return mi(d, this, z)
            })
          }),
          v4 = un(function (d, m) {
            var P = Nu(m, r0(v4));
            return _l(d, I, n, m, P)
          }),
          mR = un(function (d, m) {
            var P = Nu(m, r0(mR));
            return _l(d, A, n, m, P)
          }),
          Rne = Il(function (d, m) {
            return _l(d, E, n, n, n, m)
          });

        function One(d, m) {
          if (typeof d != "function") throw new Xo(o);
          return m = m === n ? m : on(m), un(d, m)
        }

        function Dne(d, m) {
          if (typeof d != "function") throw new Xo(o);
          return m = m == null ? 0 : ai(on(m), 0), un(function (P) {
            var z = P[m],
              Y = Fu(P, 0, m);
            return z && Du(Y, z), mi(d, this, Y)
          })
        }

        function Nne(d, m, P) {
          var z = !0,
            Y = !0;
          if (typeof d != "function") throw new Xo(o);
          return Tr(P) && (z = "leading" in P ? !!P.leading : z, Y = "trailing" in P ? !!P.trailing : Y), pR(d, m, {
            leading: z,
            maxWait: m,
            trailing: Y
          })
        }

        function Mne(d) {
          return lR(d, 1)
        }

        function $ne(d, m) {
          return v4(n4(m), d)
        }

        function Lne() {
          if (!arguments.length) return [];
          var d = arguments[0];
          return Qt(d) ? d : [d]
        }

        function Bne(d) {
          return ea(d, g)
        }

        function Fne(d, m) {
          return m = typeof m == "function" ? m : n, ea(d, g, m)
        }

        function jne(d) {
          return ea(d, f | g)
        }

        function Une(d, m) {
          return m = typeof m == "function" ? m : n, ea(d, f | g, m)
        }

        function zne(d, m) {
          return m == null || nP(d, m, gi(m))
        }

        function Ga(d, m) {
          return d === m || d !== d && m !== m
        }
        var Hne = kv(VE),
          Vne = kv(function (d, m) {
            return d >= m
          }),
          ff = cP(function () {
            return arguments
          }()) ? cP : function (d) {
            return Nr(d) && Wn.call(d, "callee") && !KI.call(d, "callee")
          },
          Qt = Te.isArray,
          Wne = ms ? wo(ms) : ZZ;

        function Ws(d) {
          return d != null && $v(d.length) && !Rl(d)
        }

        function Vr(d) {
          return Nr(d) && Ws(d)
        }

        function qne(d) {
          return d === !0 || d === !1 || Nr(d) && gs(d) == Z
        }
        var ju = oZ || I4,
          Gne = Va ? wo(Va) : eee;

        function Kne(d) {
          return Nr(d) && d.nodeType === 1 && !fg(d)
        }

        function Qne(d) {
          if (d == null) return !0;
          if (Ws(d) && (Qt(d) || typeof d == "string" || typeof d.splice == "function" || ju(d) || i0(d) || ff(d))) return !d.length;
          var m = Qi(d);
          if (m == ue || m == we) return !d.size;
          if (ug(d)) return !GE(d).length;
          for (var P in d)
            if (Wn.call(d, P)) return !1;
          return !0
        }

        function Yne(d, m) {
          return ag(d, m)
        }

        function Jne(d, m, P) {
          P = typeof P == "function" ? P : n;
          var z = P ? P(d, m) : n;
          return z === n ? ag(d, m, n, P) : !!z
        }

        function b4(d) {
          if (!Nr(d)) return !1;
          var m = gs(d);
          return m == J || m == F || typeof d.message == "string" && typeof d.name == "string" && !fg(d)
        }

        function Xne(d) {
          return typeof d == "number" && YI(d)
        }

        function Rl(d) {
          if (!Tr(d)) return !1;
          var m = gs(d);
          return m == ie || m == ce || m == X || m == pe
        }

        function gR(d) {
          return typeof d == "number" && d == on(d)
        }

        function $v(d) {
          return typeof d == "number" && d > -1 && d % 1 == 0 && d <= O
        }

        function Tr(d) {
          var m = typeof d;
          return d != null && (m == "object" || m == "function")
        }

        function Nr(d) {
          return d != null && typeof d == "object"
        }
        var yR = Yo ? wo(Yo) : nee;

        function Zne(d, m) {
          return d === m || qE(d, m, l4(m))
        }

        function ere(d, m, P) {
          return P = typeof P == "function" ? P : n, qE(d, m, l4(m), P)
        }

        function tre(d) {
          return vR(d) && d != +d
        }

        function nre(d) {
          if (Fee(d)) throw new qt(s);
          return lP(d)
        }

        function rre(d) {
          return d === null
        }

        function ire(d) {
          return d == null
        }

        function vR(d) {
          return typeof d == "number" || Nr(d) && gs(d) == ge
        }

        function fg(d) {
          if (!Nr(d) || gs(d) != He) return !1;
          var m = lv(d);
          if (m === null) return !0;
          var P = Wn.call(m, "constructor") && m.constructor;
          return typeof P == "function" && P instanceof P && sv.call(P) == eZ
        }
        var w4 = Oc ? wo(Oc) : ree;

        function sre(d) {
          return gR(d) && d >= -O && d <= O
        }
        var bR = Jm ? wo(Jm) : iee;

        function Lv(d) {
          return typeof d == "string" || !Qt(d) && Nr(d) && gs(d) == Ce
        }

        function Eo(d) {
          return typeof d == "symbol" || Nr(d) && gs(d) == be
        }
        var i0 = rf ? wo(rf) : see;

        function ore(d) {
          return d === n
        }

        function are(d) {
          return Nr(d) && Qi(d) == Fe
        }

        function cre(d) {
          return Nr(d) && gs(d) == Ne
        }
        var lre = kv(KE),
          ure = kv(function (d, m) {
            return d <= m
          });

        function wR(d) {
          if (!d) return [];
          if (Ws(d)) return Lv(d) ? Wa(d) : Vs(d);
          if (Zm && d[Zm]) return zX(d[Zm]());
          var m = Qi(d),
            P = m == ue ? ME : m == we ? nv : s0;
          return P(d)
        }

        function Ol(d) {
          if (!d) return d === 0 ? d : 0;
          if (d = ra(d), d === N || d === -N) {
            var m = d < 0 ? -1 : 1;
            return m * U
          }
          return d === d ? d : 0
        }

        function on(d) {
          var m = Ol(d),
            P = m % 1;
          return m === m ? P ? m - P : m : 0
        }

        function xR(d) {
          return d ? cf(on(d), 0, W) : 0
        }

        function ra(d) {
          if (typeof d == "number") return d;
          if (Eo(d)) return q;
          if (Tr(d)) {
            var m = typeof d.valueOf == "function" ? d.valueOf() : d;
            d = Tr(m) ? m + "" : m
          }
          if (typeof d != "string") return d === 0 ? d : +d;
          d = jI(d);
          var P = Us.test(d);
          return P || Ut.test(d) ? Kt(d.slice(2), P ? 2 : 8) : $n.test(d) ? q : +d
        }

        function ER(d) {
          return Nc(d, qs(d))
        }

        function dre(d) {
          return d ? cf(on(d), -O, O) : d === 0 ? d : 0
        }

        function Un(d) {
          return d == null ? "" : xo(d)
        }
        var fre = t0(function (d, m) {
            if (ug(m) || Ws(m)) {
              Nc(m, gi(m), d);
              return
            }
            for (var P in m) Wn.call(m, P) && ig(d, P, m[P])
          }),
          SR = t0(function (d, m) {
            Nc(m, qs(m), d)
          }),
          Bv = t0(function (d, m, P, z) {
            Nc(m, qs(m), d, z)
          }),
          hre = t0(function (d, m, P, z) {
            Nc(m, gi(m), d, z)
          }),
          pre = Il(UE);

        function mre(d, m) {
          var P = e0(d);
          return m == null ? P : tP(P, m)
        }
        var gre = un(function (d, m) {
            d = rr(d);
            var P = -1,
              z = m.length,
              Y = z > 2 ? m[2] : n;
            for (Y && ys(m[0], m[1], Y) && (z = 1); ++P < z;)
              for (var re = m[P], le = qs(re), fe = -1, xe = le.length; ++fe < xe;) {
                var Re = le[fe],
                  De = d[Re];
                (De === n || Ga(De, Jh[Re]) && !Wn.call(d, Re)) && (d[Re] = re[Re])
              }
            return d
          }),
          yre = un(function (d) {
            return d.push(n, jP), mi(CR, n, d)
          });

        function vre(d, m) {
          return $I(d, Nt(m, 3), Dc)
        }

        function bre(d, m) {
          return $I(d, Nt(m, 3), HE)
        }

        function wre(d, m) {
          return d == null ? d : zE(d, Nt(m, 3), qs)
        }

        function xre(d, m) {
          return d == null ? d : oP(d, Nt(m, 3), qs)
        }

        function Ere(d, m) {
          return d && Dc(d, Nt(m, 3))
        }

        function Sre(d, m) {
          return d && HE(d, Nt(m, 3))
        }

        function Cre(d) {
          return d == null ? [] : bv(d, gi(d))
        }

        function Are(d) {
          return d == null ? [] : bv(d, qs(d))
        }

        function x4(d, m, P) {
          var z = d == null ? n : lf(d, m);
          return z === n ? P : z
        }

        function Tre(d, m) {
          return d != null && HP(d, m, QZ)
        }

        function E4(d, m) {
          return d != null && HP(d, m, YZ)
        }
        var kre = MP(function (d, m, P) {
            m != null && typeof m.toString != "function" && (m = ov.call(m)), d[m] = P
          }, C4(Gs)),
          _re = MP(function (d, m, P) {
            m != null && typeof m.toString != "function" && (m = ov.call(m)), Wn.call(d, m) ? d[m].push(P) : d[m] = [P]
          }, Nt),
          Ire = un(og);

        function gi(d) {
          return Ws(d) ? ZI(d) : GE(d)
        }

        function qs(d) {
          return Ws(d) ? ZI(d, !0) : oee(d)
        }

        function Pre(d, m) {
          var P = {};
          return m = Nt(m, 3), Dc(d, function (z, Y, re) {
            kl(P, m(z, Y, re), z)
          }), P
        }

        function Rre(d, m) {
          var P = {};
          return m = Nt(m, 3), Dc(d, function (z, Y, re) {
            kl(P, Y, m(z, Y, re))
          }), P
        }
        var Ore = t0(function (d, m, P) {
            wv(d, m, P)
          }),
          CR = t0(function (d, m, P, z) {
            wv(d, m, P, z)
          }),
          Dre = Il(function (d, m) {
            var P = {};
            if (d == null) return P;
            var z = !1;
            m = br(m, function (re) {
              return re = Bu(re, d), z || (z = re.length > 1), re
            }), Nc(d, a4(d), P), z && (P = ea(P, f | h | g, kee));
            for (var Y = m.length; Y--;) ZE(P, m[Y]);
            return P
          });

        function Nre(d, m) {
          return AR(d, Mv(Nt(m)))
        }
        var Mre = Il(function (d, m) {
          return d == null ? {} : cee(d, m)
        });

        function AR(d, m) {
          if (d == null) return {};
          var P = br(a4(d), function (z) {
            return [z]
          });
          return m = Nt(m), gP(d, P, function (z, Y) {
            return m(z, Y[0])
          })
        }

        function $re(d, m, P) {
          m = Bu(m, d);
          var z = -1,
            Y = m.length;
          for (Y || (Y = 1, d = n); ++z < Y;) {
            var re = d == null ? n : d[Mc(m[z])];
            re === n && (z = Y, re = P), d = Rl(re) ? re.call(d) : re
          }
          return d
        }

        function Lre(d, m, P) {
          return d == null ? d : cg(d, m, P)
        }

        function Bre(d, m, P, z) {
          return z = typeof z == "function" ? z : n, d == null ? d : cg(d, m, P, z)
        }
        var TR = BP(gi),
          kR = BP(qs);

        function Fre(d, m, P) {
          var z = Qt(d),
            Y = z || ju(d) || i0(d);
          if (m = Nt(m, 4), P == null) {
            var re = d && d.constructor;
            Y ? P = z ? new re : [] : Tr(d) ? P = Rl(re) ? e0(lv(d)) : {} : P = {}
          }
          return (Y ? Jo : Dc)(d, function (le, fe, xe) {
            return m(P, le, fe, xe)
          }), P
        }

        function jre(d, m) {
          return d == null ? !0 : ZE(d, m)
        }

        function Ure(d, m, P) {
          return d == null ? d : xP(d, m, n4(P))
        }

        function zre(d, m, P, z) {
          return z = typeof z == "function" ? z : n, d == null ? d : xP(d, m, n4(P), z)
        }

        function s0(d) {
          return d == null ? [] : NE(d, gi(d))
        }

        function Hre(d) {
          return d == null ? [] : NE(d, qs(d))
        }

        function Vre(d, m, P) {
          return P === n && (P = m, m = n), P !== n && (P = ra(P), P = P === P ? P : 0), m !== n && (m = ra(m), m = m === m ? m : 0), cf(ra(d), m, P)
        }

        function Wre(d, m, P) {
          return m = Ol(m), P === n ? (P = m, m = 0) : P = Ol(P), d = ra(d), JZ(d, m, P)
        }

        function qre(d, m, P) {
          if (P && typeof P != "boolean" && ys(d, m, P) && (m = P = n), P === n && (typeof m == "boolean" ? (P = m, m = n) : typeof d == "boolean" && (P = d, d = n)), d === n && m === n ? (d = 0, m = 1) : (d = Ol(d), m === n ? (m = d, d = 0) : m = Ol(m)), d > m) {
            var z = d;
            d = m, m = z
          }
          if (P || d % 1 || m % 1) {
            var Y = JI();
            return Ki(d + Y * (m - d + tr("1e-" + ((Y + "").length - 1))), m)
          }
          return YE(d, m)
        }
        var Gre = n0(function (d, m, P) {
          return m = m.toLowerCase(), d + (P ? _R(m) : m)
        });

        function _R(d) {
          return S4(Un(d).toLowerCase())
        }

        function IR(d) {
          return d = Un(d), d && d.replace(pi, LX).replace(AE, "")
        }

        function Kre(d, m, P) {
          d = Un(d), m = xo(m);
          var z = d.length;
          P = P === n ? z : cf(on(P), 0, z);
          var Y = P;
          return P -= m.length, P >= 0 && d.slice(P, Y) == m
        }

        function Qre(d) {
          return d = Un(d), d && Et.test(d) ? d.replace(en, BX) : d
        }

        function Yre(d) {
          return d = Un(d), d && In.test(d) ? d.replace(kt, "\\$&") : d
        }
        var Jre = n0(function (d, m, P) {
            return d + (P ? "-" : "") + m.toLowerCase()
          }),
          Xre = n0(function (d, m, P) {
            return d + (P ? " " : "") + m.toLowerCase()
          }),
          Zre = OP("toLowerCase");

        function eie(d, m, P) {
          d = Un(d), m = on(m);
          var z = m ? Qh(d) : 0;
          if (!m || z >= m) return d;
          var Y = (m - z) / 2;
          return Tv(hv(Y), P) + d + Tv(fv(Y), P)
        }

        function tie(d, m, P) {
          d = Un(d), m = on(m);
          var z = m ? Qh(d) : 0;
          return m && z < m ? d + Tv(m - z, P) : d
        }

        function nie(d, m, P) {
          d = Un(d), m = on(m);
          var z = m ? Qh(d) : 0;
          return m && z < m ? Tv(m - z, P) + d : d
        }

        function rie(d, m, P) {
          return P || m == null ? m = 0 : m && (m = +m), uZ(Un(d).replace(vt, ""), m || 0)
        }

        function iie(d, m, P) {
          return (P ? ys(d, m, P) : m === n) ? m = 1 : m = on(m), JE(Un(d), m)
        }

        function sie() {
          var d = arguments,
            m = Un(d[0]);
          return d.length < 3 ? m : m.replace(d[1], d[2])
        }
        var oie = n0(function (d, m, P) {
          return d + (P ? "_" : "") + m.toLowerCase()
        });

        function aie(d, m, P) {
          return P && typeof P != "number" && ys(d, m, P) && (m = P = n), P = P === n ? W : P >>> 0, P ? (d = Un(d), d && (typeof m == "string" || m != null && !w4(m)) && (m = xo(m), !m && Kh(d)) ? Fu(Wa(d), 0, P) : d.split(m, P)) : []
        }
        var cie = n0(function (d, m, P) {
          return d + (P ? " " : "") + S4(m)
        });

        function lie(d, m, P) {
          return d = Un(d), P = P == null ? 0 : cf(on(P), 0, d.length), m = xo(m), d.slice(P, P + m.length) == m
        }

        function uie(d, m, P) {
          var z = ee.templateSettings;
          P && ys(d, m, P) && (m = n), d = Un(d), m = Bv({}, m, z, FP);
          var Y = Bv({}, m.imports, z.imports, FP),
            re = gi(Y),
            le = NE(Y, re),
            fe, xe, Re = 0,
            De = m.interpolate || _c,
            je = "__p += '",
            rt = $E((m.escape || _c).source + "|" + De.source + "|" + (De === Dt ? js : _c).source + "|" + (m.evaluate || _c).source + "|$", "g"),
            bt = "//# sourceURL=" + (Wn.call(m, "sourceURL") ? (m.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++TE + "]") + `
`;
          d.replace(rt, function (Bt, fn, Sn, So, vs, Co) {
            return Sn || (Sn = So), je += d.slice(Re, Co).replace(qd, FX), fn && (fe = !0, je += `' +
__e(` + fn + `) +
'`), vs && (xe = !0, je += `';
` + vs + `;
__p += '`), Sn && (je += `' +
((__t = (` + Sn + `)) == null ? '' : __t) +
'`), Re = Co + Bt.length, Bt
          }), je += `';
`;
          var Lt = Wn.call(m, "variable") && m.variable;
          if (!Lt) je = `with (obj) {
` + je + `
}
`;
          else if (Rn.test(Lt)) throw new qt(a);
          je = (xe ? je.replace(tt, "") : je).replace(dt, "$1").replace(xn, "$1;"), je = "function(" + (Lt || "obj") + `) {
` + (Lt ? "" : `obj || (obj = {});
`) + "var __t, __p = ''" + (fe ? ", __e = _.escape" : "") + (xe ? `, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
` : `;
`) + je + `return __p
}`;
          var ln = RR(function () {
            return Ln(re, bt + "return " + je).apply(n, le)
          });
          if (ln.source = je, b4(ln)) throw ln;
          return ln
        }

        function die(d) {
          return Un(d).toLowerCase()
        }

        function fie(d) {
          return Un(d).toUpperCase()
        }

        function hie(d, m, P) {
          if (d = Un(d), d && (P || m === n)) return jI(d);
          if (!d || !(m = xo(m))) return d;
          var z = Wa(d),
            Y = Wa(m),
            re = UI(z, Y),
            le = zI(z, Y) + 1;
          return Fu(z, re, le).join("")
        }

        function pie(d, m, P) {
          if (d = Un(d), d && (P || m === n)) return d.slice(0, VI(d) + 1);
          if (!d || !(m = xo(m))) return d;
          var z = Wa(d),
            Y = zI(z, Wa(m)) + 1;
          return Fu(z, 0, Y).join("")
        }

        function mie(d, m, P) {
          if (d = Un(d), d && (P || m === n)) return d.replace(vt, "");
          if (!d || !(m = xo(m))) return d;
          var z = Wa(d),
            Y = UI(z, Wa(m));
          return Fu(z, Y).join("")
        }

        function gie(d, m) {
          var P = $,
            z = V;
          if (Tr(m)) {
            var Y = "separator" in m ? m.separator : Y;
            P = "length" in m ? on(m.length) : P, z = "omission" in m ? xo(m.omission) : z
          }
          d = Un(d);
          var re = d.length;
          if (Kh(d)) {
            var le = Wa(d);
            re = le.length
          }
          if (P >= re) return d;
          var fe = P - Qh(z);
          if (fe < 1) return z;
          var xe = le ? Fu(le, 0, fe).join("") : d.slice(0, fe);
          if (Y === n) return xe + z;
          if (le && (fe += xe.length - fe), w4(Y)) {
            if (d.slice(fe).search(Y)) {
              var Re, De = xe;
              for (Y.global || (Y = $E(Y.source, Un(cn.exec(Y)) + "g")), Y.lastIndex = 0; Re = Y.exec(De);) var je = Re.index;
              xe = xe.slice(0, je === n ? fe : je)
            }
          } else if (d.indexOf(xo(Y), fe) != fe) {
            var rt = xe.lastIndexOf(Y);
            rt > -1 && (xe = xe.slice(0, rt))
          }
          return xe + z
        }

        function yie(d) {
          return d = Un(d), d && tn.test(d) ? d.replace(Ht, qX) : d
        }
        var vie = n0(function (d, m, P) {
            return d + (P ? " " : "") + m.toUpperCase()
          }),
          S4 = OP("toUpperCase");

        function PR(d, m, P) {
          return d = Un(d), m = P ? n : m, m === n ? UX(d) ? QX(d) : OX(d) : d.match(m) || []
        }
        var RR = un(function (d, m) {
            try {
              return mi(d, n, m)
            } catch (P) {
              return b4(P) ? P : new qt(P)
            }
          }),
          bie = Il(function (d, m) {
            return Jo(m, function (P) {
              P = Mc(P), kl(d, P, y4(d[P], d))
            }), d
          });

        function wie(d) {
          var m = d == null ? 0 : d.length,
            P = Nt();
          return d = m ? br(d, function (z) {
            if (typeof z[1] != "function") throw new Xo(o);
            return [P(z[0]), z[1]]
          }) : [], un(function (z) {
            for (var Y = -1; ++Y < m;) {
              var re = d[Y];
              if (mi(re[0], this, z)) return mi(re[1], this, z)
            }
          })
        }

        function xie(d) {
          return qZ(ea(d, f))
        }

        function C4(d) {
          return function () {
            return d
          }
        }

        function Eie(d, m) {
          return d == null || d !== d ? m : d
        }
        var Sie = NP(),
          Cie = NP(!0);

        function Gs(d) {
          return d
        }

        function A4(d) {
          return uP(typeof d == "function" ? d : ea(d, f))
        }

        function Aie(d) {
          return fP(ea(d, f))
        }

        function Tie(d, m) {
          return hP(d, ea(m, f))
        }
        var kie = un(function (d, m) {
            return function (P) {
              return og(P, d, m)
            }
          }),
          _ie = un(function (d, m) {
            return function (P) {
              return og(d, P, m)
            }
          });

        function T4(d, m, P) {
          var z = gi(m),
            Y = bv(m, z);
          P == null && !(Tr(m) && (Y.length || !z.length)) && (P = m, m = d, d = this, Y = bv(m, gi(m)));
          var re = !(Tr(P) && "chain" in P) || !!P.chain,
            le = Rl(d);
          return Jo(Y, function (fe) {
            var xe = m[fe];
            d[fe] = xe, le && (d.prototype[fe] = function () {
              var Re = this.__chain__;
              if (re || Re) {
                var De = d(this.__wrapped__),
                  je = De.__actions__ = Vs(this.__actions__);
                return je.push({
                  func: xe,
                  args: arguments,
                  thisArg: d
                }), De.__chain__ = Re, De
              }
              return xe.apply(d, Du([this.value()], arguments))
            })
          }), d
        }

        function Iie() {
          return En._ === this && (En._ = tZ), this
        }

        function k4() {}

        function Pie(d) {
          return d = on(d), un(function (m) {
            return pP(m, d)
          })
        }
        var Rie = i4(br),
          Oie = i4(MI),
          Die = i4(IE);

        function OR(d) {
          return d4(d) ? PE(Mc(d)) : lee(d)
        }

        function Nie(d) {
          return function (m) {
            return d == null ? n : lf(d, m)
          }
        }
        var Mie = $P(),
          $ie = $P(!0);

        function _4() {
          return []
        }

        function I4() {
          return !1
        }

        function Lie() {
          return {}
        }

        function Bie() {
          return ""
        }

        function Fie() {
          return !0
        }

        function jie(d, m) {
          if (d = on(d), d < 1 || d > O) return [];
          var P = W,
            z = Ki(d, W);
          m = Nt(m), d -= W;
          for (var Y = DE(z, m); ++P < d;) m(P);
          return Y
        }

        function Uie(d) {
          return Qt(d) ? br(d, Mc) : Eo(d) ? [d] : Vs(XP(Un(d)))
        }

        function zie(d) {
          var m = ++ZX;
          return Un(d) + m
        }
        var Hie = Av(function (d, m) {
            return d + m
          }, 0),
          Vie = s4("ceil"),
          Wie = Av(function (d, m) {
            return d / m
          }, 1),
          qie = s4("floor");

        function Gie(d) {
          return d && d.length ? vv(d, Gs, VE) : n
        }

        function Kie(d, m) {
          return d && d.length ? vv(d, Nt(m, 2), VE) : n
        }

        function Qie(d) {
          return BI(d, Gs)
        }

        function Yie(d, m) {
          return BI(d, Nt(m, 2))
        }

        function Jie(d) {
          return d && d.length ? vv(d, Gs, KE) : n
        }

        function Xie(d, m) {
          return d && d.length ? vv(d, Nt(m, 2), KE) : n
        }
        var Zie = Av(function (d, m) {
            return d * m
          }, 1),
          ese = s4("round"),
          tse = Av(function (d, m) {
            return d - m
          }, 0);

        function nse(d) {
          return d && d.length ? OE(d, Gs) : 0
        }

        function rse(d, m) {
          return d && d.length ? OE(d, Nt(m, 2)) : 0
        }
        return ee.after = Ane, ee.ary = lR, ee.assign = fre, ee.assignIn = SR, ee.assignInWith = Bv, ee.assignWith = hre, ee.at = pre, ee.before = uR, ee.bind = y4, ee.bindAll = bie, ee.bindKey = dR, ee.castArray = Lne, ee.chain = oR, ee.chunk = qee, ee.compact = Gee, ee.concat = Kee, ee.cond = wie, ee.conforms = xie, ee.constant = C4, ee.countBy = nne, ee.create = mre, ee.curry = fR, ee.curryRight = hR, ee.debounce = pR, ee.defaults = gre, ee.defaultsDeep = yre, ee.defer = Tne, ee.delay = kne, ee.difference = Qee, ee.differenceBy = Yee, ee.differenceWith = Jee, ee.drop = Xee, ee.dropRight = Zee, ee.dropRightWhile = ete, ee.dropWhile = tte, ee.fill = nte, ee.filter = ine, ee.flatMap = ane, ee.flatMapDeep = cne, ee.flatMapDepth = lne, ee.flatten = nR, ee.flattenDeep = rte, ee.flattenDepth = ite, ee.flip = _ne, ee.flow = Sie, ee.flowRight = Cie, ee.fromPairs = ste, ee.functions = Cre, ee.functionsIn = Are, ee.groupBy = une, ee.initial = ate, ee.intersection = cte, ee.intersectionBy = lte, ee.intersectionWith = ute, ee.invert = kre, ee.invertBy = _re, ee.invokeMap = fne, ee.iteratee = A4, ee.keyBy = hne, ee.keys = gi, ee.keysIn = qs, ee.map = Ov, ee.mapKeys = Pre, ee.mapValues = Rre, ee.matches = Aie, ee.matchesProperty = Tie, ee.memoize = Nv, ee.merge = Ore, ee.mergeWith = CR, ee.method = kie, ee.methodOf = _ie, ee.mixin = T4, ee.negate = Mv, ee.nthArg = Pie, ee.omit = Dre, ee.omitBy = Nre, ee.once = Ine, ee.orderBy = pne, ee.over = Rie, ee.overArgs = Pne, ee.overEvery = Oie, ee.overSome = Die, ee.partial = v4, ee.partialRight = mR, ee.partition = mne, ee.pick = Mre, ee.pickBy = AR, ee.property = OR, ee.propertyOf = Nie, ee.pull = pte, ee.pullAll = iR, ee.pullAllBy = mte, ee.pullAllWith = gte, ee.pullAt = yte, ee.range = Mie, ee.rangeRight = $ie, ee.rearg = Rne, ee.reject = vne, ee.remove = vte, ee.rest = One, ee.reverse = m4, ee.sampleSize = wne, ee.set = Lre, ee.setWith = Bre, ee.shuffle = xne, ee.slice = bte, ee.sortBy = Cne, ee.sortedUniq = Tte, ee.sortedUniqBy = kte, ee.split = aie, ee.spread = Dne, ee.tail = _te, ee.take = Ite, ee.takeRight = Pte, ee.takeRightWhile = Rte, ee.takeWhile = Ote, ee.tap = Gte, ee.throttle = Nne, ee.thru = Rv, ee.toArray = wR, ee.toPairs = TR, ee.toPairsIn = kR, ee.toPath = Uie, ee.toPlainObject = ER, ee.transform = Fre, ee.unary = Mne, ee.union = Dte, ee.unionBy = Nte, ee.unionWith = Mte, ee.uniq = $te, ee.uniqBy = Lte, ee.uniqWith = Bte, ee.unset = jre, ee.unzip = g4, ee.unzipWith = sR, ee.update = Ure, ee.updateWith = zre, ee.values = s0, ee.valuesIn = Hre, ee.without = Fte, ee.words = PR, ee.wrap = $ne, ee.xor = jte, ee.xorBy = Ute, ee.xorWith = zte, ee.zip = Hte, ee.zipObject = Vte, ee.zipObjectDeep = Wte, ee.zipWith = qte, ee.entries = TR, ee.entriesIn = kR, ee.extend = SR, ee.extendWith = Bv, T4(ee, ee), ee.add = Hie, ee.attempt = RR, ee.camelCase = Gre, ee.capitalize = _R, ee.ceil = Vie, ee.clamp = Vre, ee.clone = Bne, ee.cloneDeep = jne, ee.cloneDeepWith = Une, ee.cloneWith = Fne, ee.conformsTo = zne, ee.deburr = IR, ee.defaultTo = Eie, ee.divide = Wie, ee.endsWith = Kre, ee.eq = Ga, ee.escape = Qre, ee.escapeRegExp = Yre, ee.every = rne, ee.find = sne, ee.findIndex = eR, ee.findKey = vre, ee.findLast = one, ee.findLastIndex = tR, ee.findLastKey = bre, ee.floor = qie, ee.forEach = aR, ee.forEachRight = cR, ee.forIn = wre, ee.forInRight = xre, ee.forOwn = Ere, ee.forOwnRight = Sre, ee.get = x4, ee.gt = Hne, ee.gte = Vne, ee.has = Tre, ee.hasIn = E4, ee.head = rR, ee.identity = Gs, ee.includes = dne, ee.indexOf = ote, ee.inRange = Wre, ee.invoke = Ire, ee.isArguments = ff, ee.isArray = Qt, ee.isArrayBuffer = Wne, ee.isArrayLike = Ws, ee.isArrayLikeObject = Vr, ee.isBoolean = qne, ee.isBuffer = ju, ee.isDate = Gne, ee.isElement = Kne, ee.isEmpty = Qne, ee.isEqual = Yne, ee.isEqualWith = Jne, ee.isError = b4, ee.isFinite = Xne, ee.isFunction = Rl, ee.isInteger = gR, ee.isLength = $v, ee.isMap = yR, ee.isMatch = Zne, ee.isMatchWith = ere, ee.isNaN = tre, ee.isNative = nre, ee.isNil = ire, ee.isNull = rre, ee.isNumber = vR, ee.isObject = Tr, ee.isObjectLike = Nr, ee.isPlainObject = fg, ee.isRegExp = w4, ee.isSafeInteger = sre, ee.isSet = bR, ee.isString = Lv, ee.isSymbol = Eo, ee.isTypedArray = i0, ee.isUndefined = ore, ee.isWeakMap = are, ee.isWeakSet = cre, ee.join = dte, ee.kebabCase = Jre, ee.last = na, ee.lastIndexOf = fte, ee.lowerCase = Xre, ee.lowerFirst = Zre, ee.lt = lre, ee.lte = ure, ee.max = Gie, ee.maxBy = Kie, ee.mean = Qie, ee.meanBy = Yie, ee.min = Jie, ee.minBy = Xie, ee.stubArray = _4, ee.stubFalse = I4, ee.stubObject = Lie, ee.stubString = Bie, ee.stubTrue = Fie, ee.multiply = Zie, ee.nth = hte, ee.noConflict = Iie, ee.noop = k4, ee.now = Dv, ee.pad = eie, ee.padEnd = tie, ee.padStart = nie, ee.parseInt = rie, ee.random = qre, ee.reduce = gne, ee.reduceRight = yne, ee.repeat = iie, ee.replace = sie, ee.result = $re, ee.round = ese, ee.runInContext = ve, ee.sample = bne, ee.size = Ene, ee.snakeCase = oie, ee.some = Sne, ee.sortedIndex = wte, ee.sortedIndexBy = xte, ee.sortedIndexOf = Ete, ee.sortedLastIndex = Ste, ee.sortedLastIndexBy = Cte, ee.sortedLastIndexOf = Ate, ee.startCase = cie, ee.startsWith = lie, ee.subtract = tse, ee.sum = nse, ee.sumBy = rse, ee.template = uie, ee.times = jie, ee.toFinite = Ol, ee.toInteger = on, ee.toLength = xR, ee.toLower = die, ee.toNumber = ra, ee.toSafeInteger = dre, ee.toString = Un, ee.toUpper = fie, ee.trim = hie, ee.trimEnd = pie, ee.trimStart = mie, ee.truncate = gie, ee.unescape = yie, ee.uniqueId = zie, ee.upperCase = vie, ee.upperFirst = S4, ee.each = aR, ee.eachRight = cR, ee.first = rR, T4(ee, function () {
          var d = {};
          return Dc(ee, function (m, P) {
            Wn.call(ee.prototype, P) || (d[P] = m)
          }), d
        }(), {
          chain: !1
        }), ee.VERSION = r, Jo(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function (d) {
          ee[d].placeholder = ee
        }), Jo(["drop", "take"], function (d, m) {
          mn.prototype[d] = function (P) {
            P = P === n ? 1 : ai(on(P), 0);
            var z = this.__filtered__ && !m ? new mn(this) : this.clone();
            return z.__filtered__ ? z.__takeCount__ = Ki(P, z.__takeCount__) : z.__views__.push({
              size: Ki(P, W),
              type: d + (z.__dir__ < 0 ? "Right" : "")
            }), z
          }, mn.prototype[d + "Right"] = function (P) {
            return this.reverse()[d](P).reverse()
          }
        }), Jo(["filter", "map", "takeWhile"], function (d, m) {
          var P = m + 1,
            z = P == b || P == R;
          mn.prototype[d] = function (Y) {
            var re = this.clone();
            return re.__iteratees__.push({
              iteratee: Nt(Y, 3),
              type: P
            }), re.__filtered__ = re.__filtered__ || z, re
          }
        }), Jo(["head", "last"], function (d, m) {
          var P = "take" + (m ? "Right" : "");
          mn.prototype[d] = function () {
            return this[P](1).value()[0]
          }
        }), Jo(["initial", "tail"], function (d, m) {
          var P = "drop" + (m ? "" : "Right");
          mn.prototype[d] = function () {
            return this.__filtered__ ? new mn(this) : this[P](1)
          }
        }), mn.prototype.compact = function () {
          return this.filter(Gs)
        }, mn.prototype.find = function (d) {
          return this.filter(d).head()
        }, mn.prototype.findLast = function (d) {
          return this.reverse().find(d)
        }, mn.prototype.invokeMap = un(function (d, m) {
          return typeof d == "function" ? new mn(this) : this.map(function (P) {
            return og(P, d, m)
          })
        }), mn.prototype.reject = function (d) {
          return this.filter(Mv(Nt(d)))
        }, mn.prototype.slice = function (d, m) {
          d = on(d);
          var P = this;
          return P.__filtered__ && (d > 0 || m < 0) ? new mn(P) : (d < 0 ? P = P.takeRight(-d) : d && (P = P.drop(d)), m !== n && (m = on(m), P = m < 0 ? P.dropRight(-m) : P.take(m - d)), P)
        }, mn.prototype.takeRightWhile = function (d) {
          return this.reverse().takeWhile(d).reverse()
        }, mn.prototype.toArray = function () {
          return this.take(W)
        }, Dc(mn.prototype, function (d, m) {
          var P = /^(?:filter|find|map|reject)|While$/.test(m),
            z = /^(?:head|last)$/.test(m),
            Y = ee[z ? "take" + (m == "last" ? "Right" : "") : m],
            re = z || /^find/.test(m);
          Y && (ee.prototype[m] = function () {
            var le = this.__wrapped__,
              fe = z ? [1] : arguments,
              xe = le instanceof mn,
              Re = fe[0],
              De = xe || Qt(le),
              je = function (fn) {
                var Sn = Y.apply(ee, Du([fn], fe));
                return z && rt ? Sn[0] : Sn
              };
            De && P && typeof Re == "function" && Re.length != 1 && (xe = De = !1);
            var rt = this.__chain__,
              bt = !!this.__actions__.length,
              Lt = re && !rt,
              ln = xe && !bt;
            if (!re && De) {
              le = ln ? le : new mn(this);
              var Bt = d.apply(le, fe);
              return Bt.__actions__.push({
                func: Rv,
                args: [je],
                thisArg: n
              }), new Zo(Bt, rt)
            }
            return Lt && ln ? d.apply(this, fe) : (Bt = this.thru(je), Lt ? z ? Bt.value()[0] : Bt.value() : Bt)
          })
        }), Jo(["pop", "push", "shift", "sort", "splice", "unshift"], function (d) {
          var m = rv[d],
            P = /^(?:push|sort|unshift)$/.test(d) ? "tap" : "thru",
            z = /^(?:pop|shift)$/.test(d);
          ee.prototype[d] = function () {
            var Y = arguments;
            if (z && !this.__chain__) {
              var re = this.value();
              return m.apply(Qt(re) ? re : [], Y)
            }
            return this[P](function (le) {
              return m.apply(Qt(le) ? le : [], Y)
            })
          }
        }), Dc(mn.prototype, function (d, m) {
          var P = ee[m];
          if (P) {
            var z = P.name + "";
            Wn.call(Zh, z) || (Zh[z] = []), Zh[z].push({
              name: m,
              func: P
            })
          }
        }), Zh[Cv(n, _).name] = [{
          name: "wrapper",
          func: n
        }], mn.prototype.clone = yZ, mn.prototype.reverse = vZ, mn.prototype.value = bZ, ee.prototype.at = Kte, ee.prototype.chain = Qte, ee.prototype.commit = Yte, ee.prototype.next = Jte, ee.prototype.plant = Zte, ee.prototype.reverse = ene, ee.prototype.toJSON = ee.prototype.valueOf = ee.prototype.value = tne, ee.prototype.first = ee.prototype.head, Zm && (ee.prototype[Zm] = Xte), ee
      },
      Yh = YX();
    Hr ? ((Hr.exports = Yh)._ = Yh, nr._ = Yh) : En._ = Yh
  }).call(Gg)
})(c9, c9.exports);
var jUe = Object.defineProperty,
  UUe = Object.defineProperties,
  zUe = Object.getOwnPropertyDescriptors,
  mB = Object.getOwnPropertySymbols,
  HUe = Object.prototype.hasOwnProperty,
  VUe = Object.prototype.propertyIsEnumerable,
  gB = (e, t, n) => t in e ? jUe(e, t, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: n
  }) : e[t] = n,
  jb = (e, t) => {
    for (var n in t || (t = {})) HUe.call(t, n) && gB(e, n, t[n]);
    if (mB)
      for (var n of mB(t)) VUe.call(t, n) && gB(e, n, t[n]);
    return e
  },
  WUe = (e, t) => UUe(e, zUe(t));

function Nd(e, t, n) {
  var r;
  const i = PUe(e);
  return ((r = t.rpcMap) == null ? void 0 : r[i.reference]) || `${FUe}?chainId=${i.namespace}:${i.reference}&projectId=${n}`
}

function zh(e) {
  return e.includes(":") ? e.split(":")[1] : e
}

function pJ(e) {
  return e.map(t => `${t.split(":")[0]}:${t.split(":")[1]}`)
}

function qUe(e, t) {
  const n = Object.keys(t.namespaces).filter(i => i.includes(e));
  if (!n.length) return [];
  const r = [];
  return n.forEach(i => {
    const s = t.namespaces[i].accounts;
    r.push(...s)
  }), r
}

function yB(e = {}, t = {}) {
  const n = vB(e),
    r = vB(t);
  return c9.exports.merge(n, r)
}

function vB(e) {
  var t, n, r, i;
  const s = {};
  if (!OUe(e)) return s;
  for (const [o, a] of Object.entries(e)) {
    const c = A_(o) ? [o] : a.chains,
      l = a.methods || [],
      u = a.events || [],
      f = a.rpcMap || {},
      h = s1(o);
    s[h] = WUe(jb(jb({}, s[h]), a), {
      chains: R8(c, (t = s[h]) == null ? void 0 : t.chains),
      methods: R8(l, (n = s[h]) == null ? void 0 : n.methods),
      events: R8(u, (r = s[h]) == null ? void 0 : r.events),
      rpcMap: jb(jb({}, f), (i = s[h]) == null ? void 0 : i.rpcMap)
    })
  }
  return s
}

function GUe(e) {
  return e.includes(":") ? e.split(":")[2] : e
}

function KUe(e) {
  const t = {};
  for (const [n, r] of Object.entries(e)) {
    const i = r.methods || [],
      s = r.events || [],
      o = r.accounts || [],
      a = A_(n) ? [n] : r.chains ? r.chains : pJ(r.accounts);
    t[n] = {
      chains: a,
      methods: i,
      events: s,
      accounts: o
    }
  }
  return t
}

function O8(e) {
  return typeof e == "number" ? e : e.includes("0x") ? parseInt(e, 16) : (e = e.includes(":") ? e.split(":")[1] : e, isNaN(Number(e)) ? e : Number(e))
}
const mJ = {},
  Ar = e => mJ[e],
  D8 = (e, t) => {
    mJ[e] = t
  };
class QUe {
  constructor(t) {
    this.name = "polkadot", this.namespace = t.namespace, this.events = Ar("events"), this.client = Ar("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders()
  }
  updateNamespace(t) {
    this.namespace = Object.assign(this.namespace, t)
  }
  requestAccounts() {
    return this.getAccounts()
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t = this.namespace.chains[0];
    if (!t) throw new Error("ChainId not found");
    return t.split(":")[1]
  }
  request(t) {
    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request)
  }
  setDefaultChain(t, n) {
    this.httpProviders[t] || this.setHttpProvider(t, n), this.chainId = t, this.events.emit(Tu.DEFAULT_CHAIN_CHANGED, `${this.name}:${t}`)
  }
  getAccounts() {
    const t = this.namespace.accounts;
    return t ? t.filter(n => n.split(":")[1] === this.chainId.toString()).map(n => n.split(":")[2]) || [] : []
  }
  createHttpProviders() {
    const t = {};
    return this.namespace.chains.forEach(n => {
      var r;
      const i = zh(n);
      t[i] = this.createHttpProvider(i, (r = this.namespace.rpcMap) == null ? void 0 : r[n])
    }), t
  }
  getHttpProvider() {
    const t = `${this.name}:${this.chainId}`,
      n = this.httpProviders[t];
    if (typeof n > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
    return n
  }
  setHttpProvider(t, n) {
    const r = this.createHttpProvider(t, n);
    r && (this.httpProviders[t] = r)
  }
  createHttpProvider(t, n) {
    const r = n || Nd(t, this.namespace, this.client.core.projectId);
    if (!r) throw new Error(`No RPC url provided for chainId: ${t}`);
    return new Au(new Wd(r, Ar("disableProviderPing")))
  }
}
class YUe {
  constructor(t) {
    this.name = "eip155", this.namespace = t.namespace, this.events = Ar("events"), this.client = Ar("client"), this.httpProviders = this.createHttpProviders(), this.chainId = parseInt(this.getDefaultChain())
  }
  async request(t) {
    switch (t.request.method) {
      case "eth_requestAccounts":
        return this.getAccounts();
      case "eth_accounts":
        return this.getAccounts();
      case "wallet_switchEthereumChain":
        return await this.handleSwitchChain(t);
      case "eth_chainId":
        return parseInt(this.getDefaultChain())
    }
    return this.namespace.methods.includes(t.request.method) ? await this.client.request(t) : this.getHttpProvider().request(t.request)
  }
  updateNamespace(t) {
    this.namespace = Object.assign(this.namespace, t)
  }
  setDefaultChain(t, n) {
    this.httpProviders[t] || this.setHttpProvider(parseInt(t), n), this.chainId = parseInt(t), this.events.emit(Tu.DEFAULT_CHAIN_CHANGED, `${this.name}:${t}`)
  }
  requestAccounts() {
    return this.getAccounts()
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId.toString();
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t = this.namespace.chains[0];
    if (!t) throw new Error("ChainId not found");
    return t.split(":")[1]
  }
  createHttpProvider(t, n) {
    const r = n || Nd(`${this.name}:${t}`, this.namespace, this.client.core.projectId);
    if (!r) throw new Error(`No RPC url provided for chainId: ${t}`);
    return new Au(new Wd(r, Ar("disableProviderPing")))
  }
  setHttpProvider(t, n) {
    const r = this.createHttpProvider(t, n);
    r && (this.httpProviders[t] = r)
  }
  createHttpProviders() {
    const t = {};
    return this.namespace.chains.forEach(n => {
      var r;
      const i = parseInt(zh(n));
      t[i] = this.createHttpProvider(i, (r = this.namespace.rpcMap) == null ? void 0 : r[n])
    }), t
  }
  getAccounts() {
    const t = this.namespace.accounts;
    return t ? [...new Set(t.filter(n => n.split(":")[1] === this.chainId.toString()).map(n => n.split(":")[2]))] : []
  }
  getHttpProvider() {
    const t = this.chainId,
      n = this.httpProviders[t];
    if (typeof n > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
    return n
  }
  async handleSwitchChain(t) {
    var n, r;
    let i = t.request.params ? (n = t.request.params[0]) == null ? void 0 : n.chainId : "0x0";
    i = i.startsWith("0x") ? i : `0x${i}`;
    const s = parseInt(i, 16);
    if (this.isChainApproved(s)) this.setDefaultChain(`${s}`);
    else if (this.namespace.methods.includes("wallet_switchEthereumChain")) await this.client.request({
      topic: t.topic,
      request: {
        method: t.request.method,
        params: [{
          chainId: i
        }]
      },
      chainId: (r = this.namespace.chains) == null ? void 0 : r[0]
    }), this.setDefaultChain(`${s}`);
    else throw new Error(`Failed to switch to chain 'eip155:${s}'. The chain is not approved or the wallet does not support 'wallet_switchEthereumChain' method.`);
    return null
  }
  isChainApproved(t) {
    return this.namespace.chains.includes(`${this.name}:${t}`)
  }
}
class JUe {
  constructor(t) {
    this.name = "solana", this.namespace = t.namespace, this.events = Ar("events"), this.client = Ar("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders()
  }
  updateNamespace(t) {
    this.namespace = Object.assign(this.namespace, t)
  }
  requestAccounts() {
    return this.getAccounts()
  }
  request(t) {
    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request)
  }
  setDefaultChain(t, n) {
    this.httpProviders[t] || this.setHttpProvider(t, n), this.chainId = t, this.events.emit(Tu.DEFAULT_CHAIN_CHANGED, `${this.name}:${t}`)
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t = this.namespace.chains[0];
    if (!t) throw new Error("ChainId not found");
    return t.split(":")[1]
  }
  getAccounts() {
    const t = this.namespace.accounts;
    return t ? [...new Set(t.filter(n => n.split(":")[1] === this.chainId.toString()).map(n => n.split(":")[2]))] : []
  }
  createHttpProviders() {
    const t = {};
    return this.namespace.chains.forEach(n => {
      var r;
      const i = zh(n);
      t[i] = this.createHttpProvider(i, (r = this.namespace.rpcMap) == null ? void 0 : r[n])
    }), t
  }
  getHttpProvider() {
    const t = `${this.name}:${this.chainId}`,
      n = this.httpProviders[t];
    if (typeof n > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
    return n
  }
  setHttpProvider(t, n) {
    const r = this.createHttpProvider(t, n);
    r && (this.httpProviders[t] = r)
  }
  createHttpProvider(t, n) {
    const r = n || Nd(t, this.namespace, this.client.core.projectId);
    if (!r) throw new Error(`No RPC url provided for chainId: ${t}`);
    return new Au(new Wd(r, Ar("disableProviderPing")))
  }
}
class XUe {
  constructor(t) {
    this.name = "cosmos", this.namespace = t.namespace, this.events = Ar("events"), this.client = Ar("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders()
  }
  updateNamespace(t) {
    this.namespace = Object.assign(this.namespace, t)
  }
  requestAccounts() {
    return this.getAccounts()
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t = this.namespace.chains[0];
    if (!t) throw new Error("ChainId not found");
    return t.split(":")[1]
  }
  request(t) {
    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request)
  }
  setDefaultChain(t, n) {
    this.httpProviders[t] || this.setHttpProvider(t, n), this.chainId = t, this.events.emit(Tu.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`)
  }
  getAccounts() {
    const t = this.namespace.accounts;
    return t ? [...new Set(t.filter(n => n.split(":")[1] === this.chainId.toString()).map(n => n.split(":")[2]))] : []
  }
  createHttpProviders() {
    const t = {};
    return this.namespace.chains.forEach(n => {
      var r;
      const i = zh(n);
      t[i] = this.createHttpProvider(i, (r = this.namespace.rpcMap) == null ? void 0 : r[n])
    }), t
  }
  getHttpProvider() {
    const t = `${this.name}:${this.chainId}`,
      n = this.httpProviders[t];
    if (typeof n > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
    return n
  }
  setHttpProvider(t, n) {
    const r = this.createHttpProvider(t, n);
    r && (this.httpProviders[t] = r)
  }
  createHttpProvider(t, n) {
    const r = n || Nd(t, this.namespace, this.client.core.projectId);
    if (!r) throw new Error(`No RPC url provided for chainId: ${t}`);
    return new Au(new Wd(r, Ar("disableProviderPing")))
  }
}
class ZUe {
  constructor(t) {
    this.name = "cip34", this.namespace = t.namespace, this.events = Ar("events"), this.client = Ar("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders()
  }
  updateNamespace(t) {
    this.namespace = Object.assign(this.namespace, t)
  }
  requestAccounts() {
    return this.getAccounts()
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t = this.namespace.chains[0];
    if (!t) throw new Error("ChainId not found");
    return t.split(":")[1]
  }
  request(t) {
    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request)
  }
  setDefaultChain(t, n) {
    this.httpProviders[t] || this.setHttpProvider(t, n), this.chainId = t, this.events.emit(Tu.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`)
  }
  getAccounts() {
    const t = this.namespace.accounts;
    return t ? [...new Set(t.filter(n => n.split(":")[1] === this.chainId.toString()).map(n => n.split(":")[2]))] : []
  }
  createHttpProviders() {
    const t = {};
    return this.namespace.chains.forEach(n => {
      const r = this.getCardanoRPCUrl(n),
        i = zh(n);
      t[i] = this.createHttpProvider(i, r)
    }), t
  }
  getHttpProvider() {
    const t = `${this.name}:${this.chainId}`,
      n = this.httpProviders[t];
    if (typeof n > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
    return n
  }
  getCardanoRPCUrl(t) {
    const n = this.namespace.rpcMap;
    if (n) return n[t]
  }
  setHttpProvider(t, n) {
    const r = this.createHttpProvider(t, n);
    r && (this.httpProviders[t] = r)
  }
  createHttpProvider(t, n) {
    const r = n || this.getCardanoRPCUrl(t);
    if (!r) throw new Error(`No RPC url provided for chainId: ${t}`);
    return new Au(new Wd(r, Ar("disableProviderPing")))
  }
}
class eze {
  constructor(t) {
    this.name = "elrond", this.namespace = t.namespace, this.events = Ar("events"), this.client = Ar("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders()
  }
  updateNamespace(t) {
    this.namespace = Object.assign(this.namespace, t)
  }
  requestAccounts() {
    return this.getAccounts()
  }
  request(t) {
    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request)
  }
  setDefaultChain(t, n) {
    this.httpProviders[t] || this.setHttpProvider(t, n), this.chainId = t, this.events.emit(Tu.DEFAULT_CHAIN_CHANGED, `${this.name}:${t}`)
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t = this.namespace.chains[0];
    if (!t) throw new Error("ChainId not found");
    return t.split(":")[1]
  }
  getAccounts() {
    const t = this.namespace.accounts;
    return t ? [...new Set(t.filter(n => n.split(":")[1] === this.chainId.toString()).map(n => n.split(":")[2]))] : []
  }
  createHttpProviders() {
    const t = {};
    return this.namespace.chains.forEach(n => {
      var r;
      const i = zh(n);
      t[i] = this.createHttpProvider(i, (r = this.namespace.rpcMap) == null ? void 0 : r[n])
    }), t
  }
  getHttpProvider() {
    const t = `${this.name}:${this.chainId}`,
      n = this.httpProviders[t];
    if (typeof n > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
    return n
  }
  setHttpProvider(t, n) {
    const r = this.createHttpProvider(t, n);
    r && (this.httpProviders[t] = r)
  }
  createHttpProvider(t, n) {
    const r = n || Nd(t, this.namespace, this.client.core.projectId);
    if (!r) throw new Error(`No RPC url provided for chainId: ${t}`);
    return new Au(new Wd(r, Ar("disableProviderPing")))
  }
}
class tze {
  constructor(t) {
    this.name = "multiversx", this.namespace = t.namespace, this.events = Ar("events"), this.client = Ar("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders()
  }
  updateNamespace(t) {
    this.namespace = Object.assign(this.namespace, t)
  }
  requestAccounts() {
    return this.getAccounts()
  }
  request(t) {
    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request)
  }
  setDefaultChain(t, n) {
    this.httpProviders[t] || this.setHttpProvider(t, n), this.chainId = t, this.events.emit(Tu.DEFAULT_CHAIN_CHANGED, `${this.name}:${t}`)
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t = this.namespace.chains[0];
    if (!t) throw new Error("ChainId not found");
    return t.split(":")[1]
  }
  getAccounts() {
    const t = this.namespace.accounts;
    return t ? [...new Set(t.filter(n => n.split(":")[1] === this.chainId.toString()).map(n => n.split(":")[2]))] : []
  }
  createHttpProviders() {
    const t = {};
    return this.namespace.chains.forEach(n => {
      var r;
      const i = zh(n);
      t[i] = this.createHttpProvider(i, (r = this.namespace.rpcMap) == null ? void 0 : r[n])
    }), t
  }
  getHttpProvider() {
    const t = `${this.name}:${this.chainId}`,
      n = this.httpProviders[t];
    if (typeof n > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
    return n
  }
  setHttpProvider(t, n) {
    const r = this.createHttpProvider(t, n);
    r && (this.httpProviders[t] = r)
  }
  createHttpProvider(t, n) {
    const r = n || Nd(t, this.namespace, this.client.core.projectId);
    if (!r) throw new Error(`No RPC url provided for chainId: ${t}`);
    return new Au(new Wd(r, Ar("disableProviderPing")))
  }
}
class nze {
  constructor(t) {
    this.name = "near", this.namespace = t.namespace, this.events = Ar("events"), this.client = Ar("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders()
  }
  updateNamespace(t) {
    this.namespace = Object.assign(this.namespace, t)
  }
  requestAccounts() {
    return this.getAccounts()
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t = this.namespace.chains[0];
    if (!t) throw new Error("ChainId not found");
    return t.split(":")[1]
  }
  request(t) {
    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request)
  }
  setDefaultChain(t, n) {
    if (this.chainId = t, !this.httpProviders[t]) {
      const r = n || Nd(`${this.name}:${t}`, this.namespace);
      if (!r) throw new Error(`No RPC url provided for chainId: ${t}`);
      this.setHttpProvider(t, r)
    }
    this.events.emit(Tu.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`)
  }
  getAccounts() {
    const t = this.namespace.accounts;
    return t ? t.filter(n => n.split(":")[1] === this.chainId.toString()).map(n => n.split(":")[2]) || [] : []
  }
  createHttpProviders() {
    const t = {};
    return this.namespace.chains.forEach(n => {
      var r;
      t[n] = this.createHttpProvider(n, (r = this.namespace.rpcMap) == null ? void 0 : r[n])
    }), t
  }
  getHttpProvider() {
    const t = `${this.name}:${this.chainId}`,
      n = this.httpProviders[t];
    if (typeof n > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
    return n
  }
  setHttpProvider(t, n) {
    const r = this.createHttpProvider(t, n);
    r && (this.httpProviders[t] = r)
  }
  createHttpProvider(t, n) {
    const r = n || Nd(t, this.namespace);
    return typeof r > "u" ? void 0 : new Au(new Wd(r, Ar("disableProviderPing")))
  }
}
var rze = Object.defineProperty,
  ize = Object.defineProperties,
  sze = Object.getOwnPropertyDescriptors,
  bB = Object.getOwnPropertySymbols,
  oze = Object.prototype.hasOwnProperty,
  aze = Object.prototype.propertyIsEnumerable,
  wB = (e, t, n) => t in e ? rze(e, t, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: n
  }) : e[t] = n,
  Ub = (e, t) => {
    for (var n in t || (t = {})) oze.call(t, n) && wB(e, n, t[n]);
    if (bB)
      for (var n of bB(t)) aze.call(t, n) && wB(e, n, t[n]);
    return e
  },
  N8 = (e, t) => ize(e, sze(t));
class T_ {
  constructor(t) {
    this.events = new Wk, this.rpcProviders = {}, this.shouldAbortPairingAttempt = !1, this.maxPairingAttempts = 10, this.disableProviderPing = !1, this.providerOpts = t, this.logger = typeof (t == null ? void 0 : t.logger) < "u" && typeof (t == null ? void 0 : t.logger) != "string" ? t.logger : vn.pino(vn.getDefaultLoggerOptions({
      level: (t == null ? void 0 : t.logger) || hB
    })), this.disableProviderPing = (t == null ? void 0 : t.disableProviderPing) || !1
  }
  static async init(t) {
    const n = new T_(t);
    return await n.initialize(), n
  }
  async request(t, n, r) {
    const [i, s] = this.validateChain(n);
    if (!this.session) throw new Error("Please call connect() before request()");
    return await this.getProvider(i).request({
      request: Ub({}, t),
      chainId: `${i}:${s}`,
      topic: this.session.topic,
      expiry: r
    })
  }
  sendAsync(t, n, r, i) {
    const s = new Date().getTime();
    this.request(t, r, i).then(o => n(null, aE(s, o))).catch(o => n(o, void 0))
  }
  async enable() {
    if (!this.client) throw new Error("Sign Client not initialized");
    return this.session || await this.connect({
      namespaces: this.namespaces,
      optionalNamespaces: this.optionalNamespaces,
      sessionProperties: this.sessionProperties
    }), await this.requestAccounts()
  }
  async disconnect() {
    var t;
    if (!this.session) throw new Error("Please call connect() before enable()");
    await this.client.disconnect({
      topic: (t = this.session) == null ? void 0 : t.topic,
      reason: cB("USER_DISCONNECTED")
    }), await this.cleanup()
  }
  async connect(t) {
    if (!this.client) throw new Error("Sign Client not initialized");
    if (this.setNamespaces(t), await this.cleanupPendingPairings(), !t.skipPairing) return await this.pair(t.pairingTopic)
  }
  on(t, n) {
    this.events.on(t, n)
  }
  once(t, n) {
    this.events.once(t, n)
  }
  removeListener(t, n) {
    this.events.removeListener(t, n)
  }
  off(t, n) {
    this.events.off(t, n)
  }
  get isWalletConnect() {
    return !0
  }
  async pair(t) {
    this.shouldAbortPairingAttempt = !1;
    let n = 0;
    do {
      if (this.shouldAbortPairingAttempt) throw new Error("Pairing aborted");
      if (n >= this.maxPairingAttempts) throw new Error("Max auto pairing attempts reached");
      const {
        uri: r,
        approval: i
      } = await this.client.connect({
        pairingTopic: t,
        requiredNamespaces: this.namespaces,
        optionalNamespaces: this.optionalNamespaces,
        sessionProperties: this.sessionProperties
      });
      r && (this.uri = r, this.events.emit("display_uri", r)), await i().then(s => {
        this.session = s;
        const o = KUe(s.namespaces);
        this.namespaces = yB(this.namespaces, o), this.persist("namespaces", this.namespaces)
      }).catch(s => {
        if (s.message !== fJ) throw s;
        n++
      })
    } while (!this.session);
    return this.onConnect(), this.session
  }
  setDefaultChain(t, n) {
    try {
      if (!this.session) return;
      const [r, i] = this.validateChain(t);
      this.getProvider(r).setDefaultChain(i, n)
    } catch (r) {
      if (!/Please call connect/.test(r.message)) throw r
    }
  }
  async cleanupPendingPairings(t = {}) {
    this.logger.info("Cleaning up inactive pairings...");
    const n = this.client.pairing.getAll();
    if (lB(n)) {
      for (const r of n) t.deletePairings ? this.client.core.expirer.set(r.topic, 0) : await this.client.core.relayer.subscriber.unsubscribe(r.topic);
      this.logger.info(`Inactive pairings cleared: ${n.length}`)
    }
  }
  abortPairingAttempt() {
    this.shouldAbortPairingAttempt = !0
  }
  async checkStorage() {
    if (this.namespaces = await this.getFromStore("namespaces"), this.optionalNamespaces = await this.getFromStore("optionalNamespaces") || {}, this.client.session.length) {
      const t = this.client.session.keys.length - 1;
      this.session = this.client.session.get(this.client.session.keys[t]), this.createProviders()
    }
  }
  async initialize() {
    this.logger.trace("Initialized"), await this.createClient(), await this.checkStorage(), this.registerEventListeners()
  }
  async createClient() {
    this.client = this.providerOpts.client || await kUe.init({
      logger: this.providerOpts.logger || hB,
      relayUrl: this.providerOpts.relayUrl || $Ue,
      projectId: this.providerOpts.projectId,
      metadata: this.providerOpts.metadata,
      storageOptions: this.providerOpts.storageOptions,
      storage: this.providerOpts.storage,
      name: this.providerOpts.name
    }), this.logger.trace("SignClient Initialized")
  }
  createProviders() {
    if (!this.client) throw new Error("Sign Client not initialized");
    if (!this.session) throw new Error("Session not initialized. Please call connect() before enable()");
    const t = [...new Set(Object.keys(this.session.namespaces).map(n => s1(n)))];
    D8("client", this.client), D8("events", this.events), D8("disableProviderPing", this.disableProviderPing), t.forEach(n => {
      if (!this.session) return;
      const r = qUe(n, this.session),
        i = pJ(r),
        s = yB(this.namespaces, this.optionalNamespaces),
        o = N8(Ub({}, s[n]), {
          accounts: r,
          chains: i
        });
      switch (n) {
        case "eip155":
          this.rpcProviders[n] = new YUe({
            namespace: o
          });
          break;
        case "solana":
          this.rpcProviders[n] = new JUe({
            namespace: o
          });
          break;
        case "cosmos":
          this.rpcProviders[n] = new XUe({
            namespace: o
          });
          break;
        case "polkadot":
          this.rpcProviders[n] = new QUe({
            namespace: o
          });
          break;
        case "cip34":
          this.rpcProviders[n] = new ZUe({
            namespace: o
          });
          break;
        case "elrond":
          this.rpcProviders[n] = new eze({
            namespace: o
          });
          break;
        case "multiversx":
          this.rpcProviders[n] = new tze({
            namespace: o
          });
          break;
        case "near":
          this.rpcProviders[n] = new nze({
            namespace: o
          });
          break
      }
    })
  }
  registerEventListeners() {
    if (typeof this.client > "u") throw new Error("Sign Client is not initialized");
    this.client.on("session_ping", t => {
      this.events.emit("session_ping", t)
    }), this.client.on("session_event", t => {
      const {
        params: n
      } = t, {
        event: r
      } = n;
      if (r.name === "accountsChanged") {
        const i = r.data;
        i && lB(i) && this.events.emit("accountsChanged", i.map(GUe))
      } else if (r.name === "chainChanged") {
        const i = n.chainId,
          s = n.event.data,
          o = s1(i),
          a = O8(i) !== O8(s) ? `${o}:${O8(s)}` : i;
        this.onChainChanged(a)
      } else this.events.emit(r.name, r.data);
      this.events.emit("session_event", t)
    }), this.client.on("session_update", ({
      topic: t,
      params: n
    }) => {
      var r;
      const {
        namespaces: i
      } = n, s = (r = this.client) == null ? void 0 : r.session.get(t);
      this.session = N8(Ub({}, s), {
        namespaces: i
      }), this.onSessionUpdate(), this.events.emit("session_update", {
        topic: t,
        params: n
      })
    }), this.client.on("session_delete", async t => {
      await this.cleanup(), this.events.emit("session_delete", t), this.events.emit("disconnect", N8(Ub({}, cB("USER_DISCONNECTED")), {
        data: t.topic
      }))
    }), this.on(Tu.DEFAULT_CHAIN_CHANGED, t => {
      this.onChainChanged(t, !0)
    })
  }
  getProvider(t) {
    if (!this.rpcProviders[t]) throw new Error(`Provider not found: ${t}`);
    return this.rpcProviders[t]
  }
  onSessionUpdate() {
    Object.keys(this.rpcProviders).forEach(t => {
      var n;
      this.getProvider(t).updateNamespace((n = this.session) == null ? void 0 : n.namespaces[t])
    })
  }
  setNamespaces(t) {
    const {
      namespaces: n,
      optionalNamespaces: r,
      sessionProperties: i
    } = t;
    n && Object.keys(n).length && (this.namespaces = n), r && Object.keys(r).length && (this.optionalNamespaces = r), this.sessionProperties = i, this.persist("namespaces", n), this.persist("optionalNamespaces", r)
  }
  validateChain(t) {
    const [n, r] = (t == null ? void 0 : t.split(":")) || ["", ""];
    if (!this.namespaces || !Object.keys(this.namespaces).length) return [n, r];
    if (n && !Object.keys(this.namespaces || {}).map(o => s1(o)).includes(n)) throw new Error(`Namespace '${n}' is not configured. Please call connect() first with namespace config.`);
    if (n && r) return [n, r];
    const i = s1(Object.keys(this.namespaces)[0]),
      s = this.rpcProviders[i].getDefaultChain();
    return [i, s]
  }
  async requestAccounts() {
    const [t] = this.validateChain();
    return await this.getProvider(t).requestAccounts()
  }
  onChainChanged(t, n = !1) {
    if (!this.namespaces) return;
    const [r, i] = this.validateChain(t);
    i && (n || this.getProvider(r).setDefaultChain(i), this.namespaces[r] ? this.namespaces[r].defaultChain = i : this.namespaces[`${r}:${i}`] ? this.namespaces[`${r}:${i}`].defaultChain = i : this.namespaces[`${r}:${i}`] = {
      defaultChain: i
    }, this.persist("namespaces", this.namespaces), this.events.emit("chainChanged", i))
  }
  onConnect() {
    this.createProviders(), this.events.emit("connect", {
      session: this.session
    })
  }
  async cleanup() {
    this.session = void 0, this.namespaces = void 0, this.optionalNamespaces = void 0, this.sessionProperties = void 0, this.persist("namespaces", void 0), this.persist("optionalNamespaces", void 0), this.persist("sessionProperties", void 0), await this.cleanupPendingPairings({
      deletePairings: !0
    })
  }
  persist(t, n) {
    this.client.core.storage.setItem(`${pB}/${t}`, n)
  }
  async getFromStore(t) {
    return await this.client.core.storage.getItem(`${pB}/${t}`)
  }
}
const cze = T_,
  lze = "wc",
  uze = "ethereum_provider",
  dze = `${lze}@2:${uze}:`,
  fze = "https://rpc.walletconnect.com/v1/",
  l9 = ["eth_sendTransaction", "personal_sign"],
  hze = ["eth_accounts", "eth_requestAccounts", "eth_sendRawTransaction", "eth_sign", "eth_signTransaction", "eth_signTypedData", "eth_signTypedData_v3", "eth_signTypedData_v4", "eth_sendTransaction", "personal_sign", "wallet_switchEthereumChain", "wallet_addEthereumChain", "wallet_getPermissions", "wallet_requestPermissions", "wallet_registerOnboarding", "wallet_watchAsset", "wallet_scanQRCode"],
  u9 = ["chainChanged", "accountsChanged"],
  pze = ["chainChanged", "accountsChanged", "message", "disconnect", "connect"];
var mze = Object.defineProperty,
  gze = Object.defineProperties,
  yze = Object.getOwnPropertyDescriptors,
  xB = Object.getOwnPropertySymbols,
  vze = Object.prototype.hasOwnProperty,
  bze = Object.prototype.propertyIsEnumerable,
  EB = (e, t, n) => t in e ? mze(e, t, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: n
  }) : e[t] = n,
  o1 = (e, t) => {
    for (var n in t || (t = {})) vze.call(t, n) && EB(e, n, t[n]);
    if (xB)
      for (var n of xB(t)) bze.call(t, n) && EB(e, n, t[n]);
    return e
  },
  SB = (e, t) => gze(e, yze(t));

function vx(e) {
  return Number(e[0].split(":")[1])
}

function M8(e) {
  return `0x${e.toString(16)}`
}

function wze(e) {
  const {
    chains: t,
    optionalChains: n,
    methods: r,
    optionalMethods: i,
    events: s,
    optionalEvents: o,
    rpcMap: a
  } = e;
  if (!JA(t)) throw new Error("Invalid chains");
  const c = {
      chains: t,
      methods: r || l9,
      events: s || u9,
      rpcMap: o1({}, t.length ? {
        [vx(t)]: a[vx(t)]
      } : {})
    },
    l = s == null ? void 0 : s.filter(g => !u9.includes(g)),
    u = r == null ? void 0 : r.filter(g => !l9.includes(g));
  if (!n && !o && !i && !(l != null && l.length) && !(u != null && u.length)) return {
    required: t.length ? c : void 0
  };
  const f = (l == null ? void 0 : l.length) && (u == null ? void 0 : u.length) || !n,
    h = {
      chains: [...new Set(f ? c.chains.concat(n || []) : n)],
      methods: [...new Set(c.methods.concat(i != null && i.length ? i : hze))],
      events: [...new Set(c.events.concat(o != null && o.length ? o : pze))],
      rpcMap: a
    };
  return {
    required: t.length ? c : void 0,
    optional: n.length ? h : void 0
  }
}
class k_ {
  constructor() {
    this.events = new si.EventEmitter, this.namespace = "eip155", this.accounts = [], this.chainId = 1, this.STORAGE_KEY = dze, this.on = (t, n) => (this.events.on(t, n), this), this.once = (t, n) => (this.events.once(t, n), this), this.removeListener = (t, n) => (this.events.removeListener(t, n), this), this.off = (t, n) => (this.events.off(t, n), this), this.parseAccount = t => this.isCompatibleChainId(t) ? this.parseAccountId(t).address : t, this.signer = {}, this.rpc = {}
  }
  static async init(t) {
    const n = new k_;
    return await n.initialize(t), n
  }
  async request(t, n) {
    return await this.signer.request(t, this.formatChainId(this.chainId), n)
  }
  sendAsync(t, n, r) {
    this.signer.sendAsync(t, n, this.formatChainId(this.chainId), r)
  }
  get connected() {
    return this.signer.client ? this.signer.client.core.relayer.connected : !1
  }
  get connecting() {
    return this.signer.client ? this.signer.client.core.relayer.connecting : !1
  }
  async enable() {
    return this.session || await this.connect(), await this.request({
      method: "eth_requestAccounts"
    })
  }
  async connect(t) {
    if (!this.signer.client) throw new Error("Provider not initialized. Call init() first");
    this.loadConnectOpts(t);
    const {
      required: n,
      optional: r
    } = wze(this.rpc);
    try {
      const i = await new Promise(async (o, a) => {
        var c;
        this.rpc.showQrModal && ((c = this.modal) == null || c.subscribeModal(l => {
          !l.open && !this.signer.session && (this.signer.abortPairingAttempt(), a(new Error("Connection request reset. Please try again.")))
        })), await this.signer.connect(SB(o1({
          namespaces: o1({}, n && {
            [this.namespace]: n
          })
        }, r && {
          optionalNamespaces: {
            [this.namespace]: r
          }
        }), {
          pairingTopic: t == null ? void 0 : t.pairingTopic
        })).then(l => {
          o(l)
        }).catch(l => {
          a(new Error(l.message))
        })
      });
      if (!i) return;
      const s = vMe(i.namespaces, [this.namespace]);
      this.setChainIds(this.rpc.chains.length ? this.rpc.chains : s), this.setAccounts(s), this.events.emit("connect", {
        chainId: M8(this.chainId)
      })
    } catch (i) {
      throw this.signer.logger.error(i), i
    } finally {
      this.modal && this.modal.closeModal()
    }
  }
  async disconnect() {
    this.session && await this.signer.disconnect(), this.reset()
  }
  get isWalletConnect() {
    return !0
  }
  get session() {
    return this.signer.session
  }
  registerEventListeners() {
    this.signer.on("session_event", t => {
      const {
        params: n
      } = t, {
        event: r
      } = n;
      r.name === "accountsChanged" ? (this.accounts = this.parseAccounts(r.data), this.events.emit("accountsChanged", this.accounts)) : r.name === "chainChanged" ? this.setChainId(this.formatChainId(r.data)) : this.events.emit(r.name, r.data), this.events.emit("session_event", t)
    }), this.signer.on("chainChanged", t => {
      const n = parseInt(t);
      this.chainId = n, this.events.emit("chainChanged", M8(this.chainId)), this.persist()
    }), this.signer.on("session_update", t => {
      this.events.emit("session_update", t)
    }), this.signer.on("session_delete", t => {
      this.reset(), this.events.emit("session_delete", t), this.events.emit("disconnect", SB(o1({}, wMe("USER_DISCONNECTED")), {
        data: t.topic,
        name: "USER_DISCONNECTED"
      }))
    }), this.signer.on("display_uri", t => {
      var n, r;
      this.rpc.showQrModal && ((n = this.modal) == null || n.closeModal(), (r = this.modal) == null || r.openModal({
        uri: t
      })), this.events.emit("display_uri", t)
    })
  }
  switchEthereumChain(t) {
    this.request({
      method: "wallet_switchEthereumChain",
      params: [{
        chainId: t.toString(16)
      }]
    })
  }
  isCompatibleChainId(t) {
    return typeof t == "string" ? t.startsWith(`${this.namespace}:`) : !1
  }
  formatChainId(t) {
    return `${this.namespace}:${t}`
  }
  parseChainId(t) {
    return Number(t.split(":")[1])
  }
  setChainIds(t) {
    const n = t.filter(r => this.isCompatibleChainId(r)).map(r => this.parseChainId(r));
    n.length && (this.chainId = n[0], this.events.emit("chainChanged", M8(this.chainId)), this.persist())
  }
  setChainId(t) {
    if (this.isCompatibleChainId(t)) {
      const n = this.parseChainId(t);
      this.chainId = n, this.switchEthereumChain(n)
    }
  }
  parseAccountId(t) {
    const [n, r, i] = t.split(":");
    return {
      chainId: `${n}:${r}`,
      address: i
    }
  }
  setAccounts(t) {
    this.accounts = t.filter(n => this.parseChainId(this.parseAccountId(n).chainId) === this.chainId).map(n => this.parseAccountId(n).address), this.events.emit("accountsChanged", this.accounts)
  }
  getRpcConfig(t) {
    var n, r;
    const i = (n = t == null ? void 0 : t.chains) != null ? n : [],
      s = (r = t == null ? void 0 : t.optionalChains) != null ? r : [],
      o = i.concat(s);
    if (!o.length) throw new Error("No chains specified in either `chains` or `optionalChains`");
    const a = i.length ? (t == null ? void 0 : t.methods) || l9 : [],
      c = i.length ? (t == null ? void 0 : t.events) || u9 : [],
      l = (t == null ? void 0 : t.optionalMethods) || [],
      u = (t == null ? void 0 : t.optionalEvents) || [],
      f = (t == null ? void 0 : t.rpcMap) || this.buildRpcMap(o, t.projectId),
      h = (t == null ? void 0 : t.qrModalOptions) || void 0;
    return {
      chains: i == null ? void 0 : i.map(g => this.formatChainId(g)),
      optionalChains: s.map(g => this.formatChainId(g)),
      methods: a,
      events: c,
      optionalMethods: l,
      optionalEvents: u,
      rpcMap: f,
      showQrModal: !!(t != null && t.showQrModal),
      qrModalOptions: h,
      projectId: t.projectId,
      metadata: t.metadata
    }
  }
  buildRpcMap(t, n) {
    const r = {};
    return t.forEach(i => {
      r[i] = this.getRpcUrl(i, n)
    }), r
  }
  async initialize(t) {
    if (this.rpc = this.getRpcConfig(t), this.chainId = this.rpc.chains.length ? vx(this.rpc.chains) : vx(this.rpc.optionalChains), this.signer = await cze.init({
        projectId: this.rpc.projectId,
        metadata: this.rpc.metadata,
        disableProviderPing: t.disableProviderPing,
        relayUrl: t.relayUrl,
        storageOptions: t.storageOptions
      }), this.registerEventListeners(), await this.loadPersistedSession(), this.rpc.showQrModal) {
      let n;
      try {
        const {
          WalletConnectModal: r
        } = await I7(() => import("./index--gPoeLV5.js").then(i => i.i), __vite__mapDeps([]));
        n = r
      } catch {
        throw new Error("To use QR modal, please install @walletconnect/modal package")
      }
      if (n) try {
        this.modal = new n(o1({
          projectId: this.rpc.projectId
        }, this.rpc.qrModalOptions))
      } catch (r) {
        throw this.signer.logger.error(r), new Error("Could not generate WalletConnectModal Instance")
      }
    }
  }
  loadConnectOpts(t) {
    if (!t) return;
    const {
      chains: n,
      optionalChains: r,
      rpcMap: i
    } = t;
    n && JA(n) && (this.rpc.chains = n.map(s => this.formatChainId(s)), n.forEach(s => {
      this.rpc.rpcMap[s] = (i == null ? void 0 : i[s]) || this.getRpcUrl(s)
    })), r && JA(r) && (this.rpc.optionalChains = [], this.rpc.optionalChains = r == null ? void 0 : r.map(s => this.formatChainId(s)), r.forEach(s => {
      this.rpc.rpcMap[s] = (i == null ? void 0 : i[s]) || this.getRpcUrl(s)
    }))
  }
  getRpcUrl(t, n) {
    var r;
    return ((r = this.rpc.rpcMap) == null ? void 0 : r[t]) || `${fze}?chainId=eip155:${t}&projectId=${n||this.rpc.projectId}`
  }
  async loadPersistedSession() {
    if (!this.session) return;
    const t = await this.signer.client.core.storage.getItem(`${this.STORAGE_KEY}/chainId`),
      n = this.session.namespaces[`${this.namespace}:${t}`] ? this.session.namespaces[`${this.namespace}:${t}`] : this.session.namespaces[this.namespace];
    this.setChainIds(t ? [this.formatChainId(t)] : n == null ? void 0 : n.accounts), this.setAccounts(n == null ? void 0 : n.accounts)
  }
  reset() {
    this.chainId = 1, this.accounts = []
  }
  persist() {
    this.session && this.signer.client.core.storage.setItem(`${this.STORAGE_KEY}/chainId`, this.chainId)
  }
  parseAccounts(t) {
    return typeof t == "string" || t instanceof String ? [this.parseAccount(t)] : t.map(n => this.parseAccount(n))
  }
}
class xze extends si.EventEmitter {
  constructor(t) {
    super(), this.isActivationInProgress = !1, this.options = t.options, this.name = t.name, this.icon = t.icon, this.installed = t.installed
  }
  async startListening() {
    var t, n, r;
    (t = this.provider) == null || t.on("accountsChanged", async i => {
      if (!i.length) {
        this.account = void 0, this.emit("walletAccountChanged", this);
        return
      }
      await this.calcAccountData()
    }), (n = this.provider) == null || n.on("chainChanged", async i => {
      await this.calcAccountData()
    }), (r = this.provider) == null || r.on("disconnect", async (i, s) => {})
  }
  async connect() {
    var t;
    if (!this.isActivationInProgress) {
      this.isActivationInProgress = !0, this.walletConnectProvider || (this.walletConnectProvider = await k_.init(this.options)), this.provider = this.walletConnectProvider;
      try {
        await ((t = this.walletConnectProvider) == null ? void 0 : t.enable()), this.startListening(), await this.calcAccountData()
      } catch (n) {
        throw this.isActivationInProgress = !1, n
      }
      this.isActivationInProgress = !1
    }
  }
  async disconnect() {
    var t, n;
    this.provider && (await ((t = this.provider) == null ? void 0 : t.disconnect()), await ((n = this.walletConnectProvider) == null ? void 0 : n.disconnect()), this.provider = void 0, this.walletConnectProvider = void 0, this.isActivationInProgress = !1, this.account = void 0, this.emit("walletAccountChanged", this))
  }
  async switchChain(t) {
    if (!this.provider) throw new Error("Provider is not defined.");
    return o6(this.walletConnectProvider, t)
  }
  async addChain(t) {
    if (!this.provider) throw new Error("Provider is not defined.");
    return a6(this.walletConnectProvider, t)
  }
  async addToken(t, n) {
    if (!this.provider) throw new Error("Provider is not defined.");
    return Kk(this.walletConnectProvider, t, n)
  }
  async calcAccountData() {
    if (!this.walletConnectProvider) throw new Error("Provider is not defined.");
    const t = new Y5(this.walletConnectProvider, "any"),
      n = t.getSigner();
    this.account = {
      chainId: await n.getChainId(),
      address: await n.getAddress(),
      signer: n,
      provider: t
    }, this.emit("walletAccountChanged", this)
  }
}
const Eze = fs({
    id: 42161,
    name: "Arbitrum One",
    network: "arbitrum",
    nativeCurrency: {
      name: "Ether",
      symbol: "ETH",
      decimals: 18
    },
    rpcUrls: {
      alchemy: {
        http: ["https://arb-mainnet.g.alchemy.com/v2"],
        webSocket: ["wss://arb-mainnet.g.alchemy.com/v2"]
      },
      infura: {
        http: ["https://arbitrum-mainnet.infura.io/v3"],
        webSocket: ["wss://arbitrum-mainnet.infura.io/ws/v3"]
      },
      default: {
        http: ["https://arb1.arbitrum.io/rpc"]
      },
      public: {
        http: ["https://arb1.arbitrum.io/rpc"]
      }
    },
    blockExplorers: {
      etherscan: {
        name: "Arbiscan",
        url: "https://arbiscan.io"
      },
      default: {
        name: "Arbiscan",
        url: "https://arbiscan.io"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 7654707
      }
    }
  }),
  Sze = fs({
    id: 421613,
    name: "Arbitrum Goerli",
    network: "arbitrum-goerli",
    nativeCurrency: {
      name: "Arbitrum Goerli Ether",
      symbol: "ETH",
      decimals: 18
    },
    rpcUrls: {
      alchemy: {
        http: ["https://arb-goerli.g.alchemy.com/v2"],
        webSocket: ["wss://arb-goerli.g.alchemy.com/v2"]
      },
      infura: {
        http: ["https://arbitrum-goerli.infura.io/v3"],
        webSocket: ["wss://arbitrum-goerli.infura.io/ws/v3"]
      },
      default: {
        http: ["https://goerli-rollup.arbitrum.io/rpc"]
      },
      public: {
        http: ["https://goerli-rollup.arbitrum.io/rpc"]
      }
    },
    blockExplorers: {
      etherscan: {
        name: "Arbiscan",
        url: "https://goerli.arbiscan.io"
      },
      default: {
        name: "Arbiscan",
        url: "https://goerli.arbiscan.io"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 88114
      }
    },
    testnet: !0
  }),
  hE = {
    block: IK({
      format(e) {
        var n;
        return {
          transactions: (n = e.transactions) == null ? void 0 : n.map(r => {
            if (typeof r == "string") return r;
            const i = vy(r);
            return i.typeHex === "0x7e" && (i.isSystemTx = r.isSystemTx, i.mint = r.mint ? Jn(r.mint) : void 0, i.sourceHash = r.sourceHash, i.type = "deposit"), i
          }),
          stateRoot: e.stateRoot
        }
      }
    }),
    transaction: _K({
      format(e) {
        const t = {};
        return e.type === "0x7e" && (t.isSystemTx = e.isSystemTx, t.mint = e.mint ? Jn(e.mint) : void 0, t.sourceHash = e.sourceHash, t.type = "deposit"), t
      }
    }),
    transactionReceipt: dQ({
      format(e) {
        return {
          l1GasPrice: e.l1GasPrice ? Jn(e.l1GasPrice) : null,
          l1GasUsed: e.l1GasUsed ? Jn(e.l1GasUsed) : null,
          l1Fee: e.l1Fee ? Jn(e.l1Fee) : null,
          l1FeeScalar: e.l1FeeScalar ? Number(e.l1FeeScalar) : null
        }
      }
    })
  },
  Cze = fs({
    id: 8453,
    network: "base",
    name: "Base",
    nativeCurrency: {
      name: "Ether",
      symbol: "ETH",
      decimals: 18
    },
    rpcUrls: {
      alchemy: {
        http: ["https://base-mainnet.g.alchemy.com/v2"],
        webSocket: ["wss://base-mainnet.g.alchemy.com/v2"]
      },
      infura: {
        http: ["https://base-mainnet.infura.io/v3"],
        webSocket: ["wss://base-mainnet.infura.io/ws/v3"]
      },
      default: {
        http: ["https://mainnet.base.org"]
      },
      public: {
        http: ["https://mainnet.base.org"]
      }
    },
    blockExplorers: {
      blockscout: {
        name: "Basescout",
        url: "https://base.blockscout.com"
      },
      default: {
        name: "Basescan",
        url: "https://basescan.org"
      },
      etherscan: {
        name: "Basescan",
        url: "https://basescan.org"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 5022
      }
    }
  }, {
    formatters: hE
  }),
  Aze = fs({
    id: 84531,
    network: "base-goerli",
    name: "Base Goerli",
    nativeCurrency: {
      name: "Goerli Ether",
      symbol: "ETH",
      decimals: 18
    },
    rpcUrls: {
      alchemy: {
        http: ["https://base-goerli.g.alchemy.com/v2"],
        webSocket: ["wss://base-goerli.g.alchemy.com/v2"]
      },
      default: {
        http: ["https://goerli.base.org"]
      },
      public: {
        http: ["https://goerli.base.org"]
      }
    },
    blockExplorers: {
      etherscan: {
        name: "Basescan",
        url: "https://goerli.basescan.org"
      },
      default: {
        name: "Basescan",
        url: "https://goerli.basescan.org"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 1376988
      }
    },
    testnet: !0,
    sourceId: 5
  }, {
    formatters: hE
  }),
  gJ = fs({
    id: 56,
    name: "BNB Smart Chain",
    network: "bsc",
    nativeCurrency: {
      decimals: 18,
      name: "BNB",
      symbol: "BNB"
    },
    rpcUrls: {
      default: {
        http: ["https://rpc.ankr.com/bsc"]
      },
      public: {
        http: ["https://rpc.ankr.com/bsc"]
      }
    },
    blockExplorers: {
      etherscan: {
        name: "BscScan",
        url: "https://bscscan.com"
      },
      default: {
        name: "BscScan",
        url: "https://bscscan.com"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 15921452
      }
    }
  }),
  yJ = fs({
    id: 97,
    name: "Binance Smart Chain Testnet",
    network: "bsc-testnet",
    nativeCurrency: {
      decimals: 18,
      name: "BNB",
      symbol: "tBNB"
    },
    rpcUrls: {
      default: {
        http: ["https://data-seed-prebsc-1-s1.bnbchain.org:8545"]
      },
      public: {
        http: ["https://data-seed-prebsc-1-s1.bnbchain.org:8545"]
      }
    },
    blockExplorers: {
      etherscan: {
        name: "BscScan",
        url: "https://testnet.bscscan.com"
      },
      default: {
        name: "BscScan",
        url: "https://testnet.bscscan.com"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 17422483
      }
    },
    testnet: !0
  }),
  Tze = fs({
    id: 59144,
    name: "Linea Mainnet",
    network: "linea-mainnet",
    nativeCurrency: {
      name: "Linea Ether",
      symbol: "ETH",
      decimals: 18
    },
    rpcUrls: {
      infura: {
        http: ["https://linea-mainnet.infura.io/v3"],
        webSocket: ["wss://linea-mainnet.infura.io/ws/v3"]
      },
      default: {
        http: ["https://rpc.linea.build"],
        webSocket: ["wss://rpc.linea.build"]
      },
      public: {
        http: ["https://rpc.linea.build"],
        webSocket: ["wss://rpc.linea.build"]
      }
    },
    blockExplorers: {
      default: {
        name: "Etherscan",
        url: "https://lineascan.build"
      },
      etherscan: {
        name: "Etherscan",
        url: "https://lineascan.build"
      },
      blockscout: {
        name: "Blockscout",
        url: "https://explorer.linea.build"
      }
    },
    contracts: {
      multicall3: {
        address: "0xcA11bde05977b3631167028862bE2a173976CA11",
        blockCreated: 42
      }
    },
    testnet: !1
  }),
  kze = fs({
    id: 59140,
    name: "Linea Goerli Testnet",
    network: "linea-testnet",
    nativeCurrency: {
      name: "Linea Ether",
      symbol: "ETH",
      decimals: 18
    },
    rpcUrls: {
      infura: {
        http: ["https://linea-goerli.infura.io/v3"],
        webSocket: ["wss://linea-goerli.infura.io/ws/v3"]
      },
      default: {
        http: ["https://rpc.goerli.linea.build"],
        webSocket: ["wss://rpc.goerli.linea.build"]
      },
      public: {
        http: ["https://rpc.goerli.linea.build"],
        webSocket: ["wss://rpc.goerli.linea.build"]
      }
    },
    blockExplorers: {
      default: {
        name: "Etherscan",
        url: "https://goerli.lineascan.build"
      },
      etherscan: {
        name: "Etherscan",
        url: "https://goerli.lineascan.build"
      },
      blockscout: {
        name: "Blockscout",
        url: "https://explorer.goerli.linea.build"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 498623
      }
    },
    testnet: !0
  }),
  _ze = fs({
    id: 1,
    network: "homestead",
    name: "Ethereum",
    nativeCurrency: {
      name: "Ether",
      symbol: "ETH",
      decimals: 18
    },
    rpcUrls: {
      alchemy: {
        http: ["https://eth-mainnet.g.alchemy.com/v2"],
        webSocket: ["wss://eth-mainnet.g.alchemy.com/v2"]
      },
      infura: {
        http: ["https://mainnet.infura.io/v3"],
        webSocket: ["wss://mainnet.infura.io/ws/v3"]
      },
      default: {
        http: ["https://cloudflare-eth.com"]
      },
      public: {
        http: ["https://cloudflare-eth.com"]
      }
    },
    blockExplorers: {
      etherscan: {
        name: "Etherscan",
        url: "https://etherscan.io"
      },
      default: {
        name: "Etherscan",
        url: "https://etherscan.io"
      }
    },
    contracts: {
      ensRegistry: {
        address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
      },
      ensUniversalResolver: {
        address: "0xc0497E381f536Be9ce14B0dD3817cBcAe57d2F62",
        blockCreated: 16966585
      },
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 14353601
      }
    }
  }),
  Ize = fs({
    id: 10,
    name: "OP Mainnet",
    network: "optimism",
    nativeCurrency: {
      name: "Ether",
      symbol: "ETH",
      decimals: 18
    },
    rpcUrls: {
      alchemy: {
        http: ["https://opt-mainnet.g.alchemy.com/v2"],
        webSocket: ["wss://opt-mainnet.g.alchemy.com/v2"]
      },
      infura: {
        http: ["https://optimism-mainnet.infura.io/v3"],
        webSocket: ["wss://optimism-mainnet.infura.io/ws/v3"]
      },
      default: {
        http: ["https://mainnet.optimism.io"]
      },
      public: {
        http: ["https://mainnet.optimism.io"]
      }
    },
    blockExplorers: {
      etherscan: {
        name: "Etherscan",
        url: "https://optimistic.etherscan.io"
      },
      default: {
        name: "Optimism Explorer",
        url: "https://explorer.optimism.io"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 4286263
      }
    }
  }, {
    formatters: hE
  }),
  Pze = fs({
    id: 420,
    name: "Optimism Goerli",
    network: "optimism-goerli",
    nativeCurrency: {
      name: "Goerli Ether",
      symbol: "ETH",
      decimals: 18
    },
    rpcUrls: {
      alchemy: {
        http: ["https://opt-goerli.g.alchemy.com/v2"],
        webSocket: ["wss://opt-goerli.g.alchemy.com/v2"]
      },
      infura: {
        http: ["https://optimism-goerli.infura.io/v3"],
        webSocket: ["wss://optimism-goerli.infura.io/ws/v3"]
      },
      default: {
        http: ["https://goerli.optimism.io"]
      },
      public: {
        http: ["https://goerli.optimism.io"]
      }
    },
    blockExplorers: {
      etherscan: {
        name: "Etherscan",
        url: "https://goerli-optimism.etherscan.io"
      },
      default: {
        name: "Etherscan",
        url: "https://goerli-optimism.etherscan.io"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 49461
      }
    },
    testnet: !0
  }, {
    formatters: hE
  }),
  Rze = fs({
    id: 137,
    name: "Polygon",
    network: "matic",
    nativeCurrency: {
      name: "MATIC",
      symbol: "MATIC",
      decimals: 18
    },
    rpcUrls: {
      alchemy: {
        http: ["https://polygon-mainnet.g.alchemy.com/v2"],
        webSocket: ["wss://polygon-mainnet.g.alchemy.com/v2"]
      },
      infura: {
        http: ["https://polygon-mainnet.infura.io/v3"],
        webSocket: ["wss://polygon-mainnet.infura.io/ws/v3"]
      },
      default: {
        http: ["https://polygon-rpc.com"]
      },
      public: {
        http: ["https://polygon-rpc.com"]
      }
    },
    blockExplorers: {
      etherscan: {
        name: "PolygonScan",
        url: "https://polygonscan.com"
      },
      default: {
        name: "PolygonScan",
        url: "https://polygonscan.com"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 25770160
      }
    }
  }),
  Oze = fs({
    id: 80001,
    name: "Polygon Mumbai",
    network: "maticmum",
    nativeCurrency: {
      name: "MATIC",
      symbol: "MATIC",
      decimals: 18
    },
    rpcUrls: {
      alchemy: {
        http: ["https://polygon-mumbai.g.alchemy.com/v2"],
        webSocket: ["wss://polygon-mumbai.g.alchemy.com/v2"]
      },
      infura: {
        http: ["https://polygon-mumbai.infura.io/v3"],
        webSocket: ["wss://polygon-mumbai.infura.io/ws/v3"]
      },
      default: {
        http: ["https://rpc.ankr.com/polygon_mumbai"]
      },
      public: {
        http: ["https://rpc.ankr.com/polygon_mumbai"]
      }
    },
    blockExplorers: {
      etherscan: {
        name: "PolygonScan",
        url: "https://mumbai.polygonscan.com"
      },
      default: {
        name: "PolygonScan",
        url: "https://mumbai.polygonscan.com"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 25770160
      }
    },
    testnet: !0
  }),
  Dze = fs({
    id: 534352,
    name: "Scroll",
    network: "scroll",
    nativeCurrency: {
      name: "Ether",
      symbol: "ETH",
      decimals: 18
    },
    rpcUrls: {
      default: {
        http: ["https://rpc.scroll.io"],
        webSocket: ["wss://wss-rpc.scroll.io/ws"]
      },
      public: {
        http: ["https://rpc.scroll.io"],
        webSocket: ["wss://wss-rpc.scroll.io/ws"]
      }
    },
    blockExplorers: {
      default: {
        name: "Scrollscan",
        url: "https://scrollscan.com"
      },
      blockscout: {
        name: "Blockscout",
        url: "https://blockscout.scroll.io"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 14
      }
    },
    testnet: !1
  }),
  Nze = fs({
    id: 534351,
    name: "Scroll Sepolia",
    network: "scroll-sepolia",
    nativeCurrency: {
      name: "Ether",
      symbol: "ETH",
      decimals: 18
    },
    rpcUrls: {
      default: {
        http: ["https://sepolia-rpc.scroll.io"]
      },
      public: {
        http: ["https://sepolia-rpc.scroll.io"]
      }
    },
    blockExplorers: {
      default: {
        name: "Blockscout",
        url: "https://sepolia-blockscout.scroll.io"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 9473
      }
    },
    testnet: !0
  });
var Mze = Object.defineProperty,
  $ze = Object.defineProperties,
  Lze = Object.getOwnPropertyDescriptors,
  CB = Object.getOwnPropertySymbols,
  Bze = Object.prototype.hasOwnProperty,
  Fze = Object.prototype.propertyIsEnumerable,
  AB = (e, t, n) => t in e ? Mze(e, t, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: n
  }) : e[t] = n,
  __ = (e, t) => {
    for (var n in t || (t = {})) Bze.call(t, n) && AB(e, n, t[n]);
    if (CB)
      for (var n of CB(t)) Fze.call(t, n) && AB(e, n, t[n]);
    return e
  },
  I_ = (e, t) => $ze(e, Lze(t)),
  Kf = (e, t, n) => new Promise((r, i) => {
    var s = c => {
        try {
          a(n.next(c))
        } catch (l) {
          i(l)
        }
      },
      o = c => {
        try {
          a(n.throw(c))
        } catch (l) {
          i(l)
        }
      },
      a = c => c.done ? r(c.value) : Promise.resolve(c.value).then(s, o);
    a((n = n.apply(e, t)).next())
  }),
  jze = class {
    constructor({
      walletWindow: e,
      appInfo: t
    }) {
      this.walletWindow = e, this.appWindow = window, this.appInfo = t
    }
    sendMessage(e) {
      const t = crypto.randomUUID();
      return this.postMessage({
        appId: crypto.randomUUID(),
        appInfo: this.appInfo,
        messageId: t,
        target: "CyberWallet",
        event: e
      }), t
    }
    onMessage(e) {
      this.appWindow.onmessage = t => {
        e(t.data)
      }
    }
    postMessage(e) {
      this.walletWindow.postMessage(e, "*")
    }
  },
  vJ = jze,
  Uze = class {
    constructor({
      id: e,
      sendTransaction: t,
      appId: n
    }) {
      this.cyberAccount = null, this.id = e, this.sendTransactionBase = t, this.appId = n
    }
    setCyberAccount(e) {
      this.cyberAccount = e
    }
    sendTransaction(e, t) {
      return Kf(this, null, function* () {
        if (this.cyberAccount) return yield this.sendTransactionBase(I_(__({}, e), {
          from: e.from || this.cyberAccount.address,
          ctx: {
            chainId: this.id,
            owner: this.cyberAccount.ownerAddress,
            appId: this.appId
          }
        }), t)
      })
    }
  },
  zze = Uze,
  Hze = {
    id: 204,
    name: "opBNB",
    network: "opBNB",
    rpcUrls: {
      public: {
        http: ["https://opbnb-mainnet.nodereal.io/v1/64a9df0874fb4a93b9d0a3849de012d3"]
      },
      default: {
        http: ["https://opbnb-mainnet.nodereal.io/v1/64a9df0874fb4a93b9d0a3849de012d3"]
      }
    },
    blockExplorers: {
      default: {
        name: "BlockScout",
        url: "https://opbnbscan.com"
      }
    },
    nativeCurrency: gJ.nativeCurrency
  };
yJ.nativeCurrency;
var _1 = {
    optimism: Ize,
    optimismGoerli: Pze,
    polygon: Rze,
    polygonMumbai: Oze,
    arbitrum: Eze,
    arbitrumGoerli: Sze,
    linea: Tze,
    lineaTestnet: kze,
    base: Cze,
    baseGoerli: Aze,
    opBnb: Hze,
    scrollSepolia: Nze,
    scroll: Dze,
    mainnet: _ze,
    bscTestnet: yJ,
    bsc: gJ
  },
  Vze = class extends Error {
    constructor({
      name: e,
      details: t,
      shortMessage: n
    }) {
      super(`${e||"UnknownEventError"}: ${n||"Unknown error, please check the details"}`), this.name = e || "UnknownEventError", this.details = t, this.shortMessage = n || "Unknown error, please check the details"
    }
  },
  TB = Vze,
  Wze = class {
    constructor({
      contextWindow: e,
      appInfo: t
    }) {
      this.cyberAccount = null, this.bindedSendTransaction = this.sendTransaction.bind(this), this.contextWindow = e, this.connected = !1, this.messenger = new vJ({
        walletWindow: this.contextWindow,
        appInfo: t
      }), this.cyberAccount = null, Object.entries(_1).forEach(([n, r]) => {
        this[n] = new zze({
          id: r.id,
          sendTransaction: this.bindedSendTransaction,
          appId: t.appId
        })
      })
    }
    setConnection(e) {
      this.connected = e
    }
    setCyberAccount(e) {
      this.cyberAccount = e, localStorage.removeItem("cyber-app-sdk"), localStorage.setItem("cyber-app-sdk", JSON.stringify(e)), Object.keys(_1).forEach(t => {
        this[t].setCyberAccount(e)
      })
    }
    resolveActionResponse(e, t, n) {
      var r, i, s;
      e.target === "CyberApp" && e.event.name === "action" && ((r = e.event.data) != null && r.error ? ((i = e.event.data) == null ? void 0 : i.method) === "sendTransaction" ? t(new TB({
        name: "SendTransactionError",
        details: e.event.data.error,
        shortMessage: "Transaction failed"
      })) : t(new TB({
        details: e.event.data.error
      })) : n((s = e.event.data) == null ? void 0 : s.data))
    }
    sendTransaction(e) {
      var t;
      return this.messenger.sendMessage({
        name: "action",
        data: {
          type: "request",
          method: "sendTransaction",
          data: {
            transaction: I_(__({}, e), {
              from: e.from || ((t = this.cyberAccount) == null ? void 0 : t.address)
            })
          }
        }
      }), new Promise((n, r) => {
        this.messenger.onMessage(i => {
          this.resolveActionResponse(i, r, n)
        })
      })
    }
    signMessage(e) {
      return this.messenger.sendMessage({
        name: "action",
        data: {
          type: "request",
          method: "signMessage",
          data: {
            message: e
          }
        }
      }), new Promise((t, n) => {
        this.messenger.onMessage(r => {
          this.resolveActionResponse(r, n, t)
        })
      })
    }
    signTypedData(e) {
      return this.messenger.sendMessage({
        name: "action",
        data: {
          type: "request",
          method: "signTypedData",
          data: {
            typedData: e
          }
        }
      }), new Promise((t, n) => {
        this.messenger.onMessage(r => {
          this.resolveActionResponse(r, n, t)
        })
      })
    }
    getAuthToken() {
      return Kf(this, null, function* () {
        return this.messenger.sendMessage({
          name: "action",
          data: {
            type: "request",
            method: "getAuthToken"
          }
        }), new Promise((e, t) => {
          this.messenger.onMessage(n => {
            this.resolveActionResponse(n, t, e)
          })
        })
      })
    }
  },
  qze = Wze,
  Gze = class {
    constructor({
      appId: e,
      name: t,
      icon: n
    }) {
      this.appId = e, this.name = t, this.icon = n, this.cyberWallet = new qze({
        contextWindow: window.parent,
        appInfo: {
          name: t,
          icon: n,
          appId: e
        }
      }), this.messenger = new vJ({
        walletWindow: this.cyberWallet.contextWindow
      })
    }
    start() {
      return Kf(this, null, function* () {
        return yield this.connect()
      })
    }
    connect() {
      return Kf(this, null, function* () {
        return this.messenger.sendMessage({
          name: "connect"
        }), yield new Promise((e, t) => {
          this.messenger.onMessage(n => {
            var r, i, s, o, a, c, l, u, f, h;
            n.target === "CyberApp" && n.event.name === "connect" && (((i = (r = n.event.data) == null ? void 0 : r.data) == null ? void 0 : i.result) === "success" ? ((s = this.cyberWallet) == null || s.setConnection(!0), (c = this.cyberWallet) == null || c.setCyberAccount((a = (o = n.event.data) == null ? void 0 : o.data) == null ? void 0 : a.cyberAccount), e((u = (l = n.event.data) == null ? void 0 : l.data) == null ? void 0 : u.cyberAccount)) : (f = n.event.data) != null && f.error && t((h = n.event.data) == null ? void 0 : h.error))
          })
        })
      })
    }
  },
  Kze = Gze,
  Qze = class extends si.EventEmitter {
    constructor({
      app: e,
      chainId: t
    }) {
      super(), this.name = "CyberWallet", this.cyberApp = e, this.chainId = t, this.isMetaMask = !1, this.chain = this.getChainByChainId(this.chainId), this._events = {}, this.publicClient = this.setPublicClient(this.chainId)
    }
    setPublicClient(e) {
      return Object.values(_1).find(n => n.id === e) ? MQ({
        chain: Object.values(_1).find(n => n.id === e),
        transport: zK()
      }) : void 0
    }
    connect() {
      return Kf(this, null, function* () {
        this.emit("connect", {
          chainId: `0x${this.chainId.toString(16)}`
        })
      })
    }
    disconnect() {
      return Kf(this, null, function* () {
        this.emit("disconnect", new yh(Error()))
      })
    }
    getChainKeyByChainId(e) {
      const t = Object.entries(_1).find(([n, r]) => r.id === e);
      if (!t) {
        console.error(`ChainId ${e} is not supported.`);
        return
      }
      return t[0]
    }
    getChainByChainId(e) {
      var t;
      const n = this.getChainKeyByChainId(e);
      return n ? (t = this.cyberApp.cyberWallet) == null ? void 0 : t[n] : void 0
    }
    request(e) {
      return Kf(this, null, function* () {
        var t, n, r, i, s, o, a, c, l, u;
        const {
          method: f,
          params: h = []
        } = e;
        switch (f) {
          case "wallet_switchEthereumChain": {
            this.chainId = Number(h[0].chainId), this.chain = this.getChainByChainId(this.chainId), this.publicClient = this.setPublicClient(this.chainId), this.emit("chainChanged", h[0].chainId);
            return
          }
          case "personal_sign":
            return (t = this.cyberApp.cyberWallet) == null ? void 0 : t.signMessage(w6(h[0]));
          case "eth_signTypedData":
          case "eth_signTypedData_v4": {
            const [g, y] = h, x = typeof y == "string" ? JSON.parse(y) : y;
            if (((n = this.cyberApp.cyberWallet.cyberAccount) == null ? void 0 : n.address.toLowerCase()) !== g.toLowerCase()) throw new Error("The address is invalid");
            return (yield this.cyberApp.cyberWallet.signTypedData(x)) || "0x"
          }
          case "eth_chainId":
            return `0x${this.chainId.toString(16)}`;
          case "eth_sendTransaction": {
            const g = h[0].data || "0x";
            return (r = this.chain) == null ? void 0 : r.sendTransaction(I_(__({}, h[0]), {
              data: g
            }))
          }
          case "eth_requestAccounts":
            return (i = this.cyberApp.cyberWallet) != null && i.cyberAccount || (yield this.cyberApp.connect()), [(o = (s = this.cyberApp.cyberWallet) == null ? void 0 : s.cyberAccount) == null ? void 0 : o.address];
          case "eth_accounts":
            return (a = this.cyberApp.cyberWallet) != null && a.cyberAccount || (yield this.cyberApp.connect()), [(l = (c = this.cyberApp.cyberWallet) == null ? void 0 : c.cyberAccount) == null ? void 0 : l.address];
          default:
            return yield(u = this.publicClient) == null ? void 0 : u.request({
              method: f,
              params: h
            })
        }
      })
    }
  },
  Yze = Qze,
  Jze = () => typeof document < "u" && ["https://next.wallet.cyber.co/", "https://wallet-sandbox.cyber.co/", "https://wallet.cyber.co/", "https://cyberwallet-sandbox-cyberconnect.vercel.app/"].includes(document.referrer);
const Xze = 42161;
class Zze extends si.EventEmitter {
  constructor(t) {
    super(), this.isActivationInProgress = !1, this.autoConnect = async () => {
      await this.calcAccountData()
    }, this.disconnect = () => {
      this.account = void 0
    }, this.connect = async () => {
      await this.calcAccountData()
    }, this.switchChain = async n => this.calcAccountData(n), this.addChain = () => (console.warn("Method addChain not allowed"), null), this.addToken = () => (console.warn("Method addToken not allowed"), null), this.name = t.name, this.icon = t.icon, this.installed = t.installed, this.calcAccountData()
  }
  async calcAccountData(t = Xze) {
    const n = new Kze({
        appId: "jumper.exchange",
        name: "Jumper.Exchange",
        icon: "https://raw.githubusercontent.com/lifinance/jumper.exchange/e9ead2e32981db0bf47adf2b1b2781e31ad14650/packages/dapp/public/logo-144x144.svg"
      }),
      r = new Yze({
        app: n,
        chainId: t
      }),
      i = new Y5(r, "any"),
      s = i.getSigner();
    this.account = {
      chainId: t,
      address: await s.getAddress(),
      signer: s,
      provider: i,
      isMultisigWallet: !0
    }, this.emit("walletAccountChanged", this)
  }
}
const eHe = new Vn({
    name: "Default Wallet",
    installed: async () => {
      var e;
      return !!window.ethereum && !((e = window == null ? void 0 : window.ethereum) != null && e[_i.MetaMask])
    },
    icon: Tn.placeholder
  }),
  tHe = new Vn({
    name: "MetaMask",
    installed: async () => {
      var e;
      return !!((e = window == null ? void 0 : window.ethereum) != null && e[_i.MetaMask])
    },
    icon: Tn.metamask
  }),
  nHe = new xze({
    name: "WalletConnect",
    installed: async () => !0,
    icon: Tn.walletConnect,
    options: {
      projectId: "5432e3507d41270bee46b7b85bbc2ef8",
      rpcMap: HM.reduce((e, t) => (t.chainType === At.EVM && (e[`eip155:${t.id}`] = t.metamask.rpcUrls[0] || ""), e), {}),
      chains: [1],
      optionalChains: HM.filter(e => e.chainType === At.EVM).map(e => e.id),
      showQrModal: !0,
      qrModalOptions: {
        themeVariables: {
          "--w3m-z-index": "3000"
        }
      }
    }
  });
var uF;
const rHe = new Vn({
    name: "Bitget Wallet",
    installed: async () => {
      var e;
      return window.bitkeep && ((e = window.bitkeep) == null ? void 0 : e.ethereum)
    },
    icon: Tn.bitGet
  }, (uF = window.bitkeep) == null ? void 0 : uF.ethereum),
  iHe = new Vn({
    name: "Gate Wallet",
    installed: async () => window.gatewallet,
    icon: Tn.gate
  }, window.gatewallet);
var dF;
const sHe = new Vn({
    name: "Frontier",
    installed: async () => window.frontier,
    icon: Tn.frontier
  }, (dF = window.frontier) == null ? void 0 : dF.ethereum),
  oHe = new Vn({
    name: "SafePal",
    installed: async () => window.safepal,
    icon: Tn.safepal
  }),
  aHe = new Vn({
    name: "Brave",
    installed: async () => navigator.brave && window._web3Ref,
    icon: Tn.brave
  }),
  cHe = new Vn({
    name: "MathWallet",
    installed: async () => {
      var e;
      return (e = window.ethereum) == null ? void 0 : e[_i.MathWallet]
    },
    icon: Tn.mathwallet
  }),
  lHe = new Vn({
    name: "Taho",
    installed: async () => {
      var e;
      return window.tally && ((e = window.tally) == null ? void 0 : e[_i.TallyHo])
    },
    icon: Tn.tallyho
  }, window.tally),
  uHe = new Vn({
    name: "BlockWallet",
    installed: async () => {
      var e;
      return (e = window.ethereum) == null ? void 0 : e[_i.BlockWallet]
    },
    icon: Tn.blockwallet
  }),
  dHe = new Vn({
    name: "Binance",
    installed: async () => window.BinanceChain,
    icon: Tn.binance
  }, window.BinanceChain),
  fHe = new Vn({
    name: "Coinbase",
    installed: async () => window.coinbaseWalletExtension,
    icon: Tn.coinbase
  }, window.coinbaseWalletExtension),
  hHe = new Vn({
    name: "Trust",
    installed: async () => window.trustWallet,
    icon: Tn.trust
  }, window.trustWallet),
  pHe = new Vn({
    name: "Status",
    installed: async () => {
      var e;
      return (e = window.ethereum) == null ? void 0 : e[_i.Status]
    },
    icon: Tn.status
  }),
  mHe = new Vn({
    name: "AlphaWallet",
    installed: async () => {
      var e;
      return (e = window.ethereum) == null ? void 0 : e[_i.AlphaWallet]
    },
    icon: Tn.alphawallet
  }),
  gHe = new Vn({
    name: "Apex Wallet",
    installed: async () => {
      var e;
      return (e = window.ethereum) == null ? void 0 : e[_i.ApexWallet]
    },
    icon: Tn.placeholder
  }),
  yHe = new Vn({
    name: "Bitpie",
    installed: async () => {
      var e;
      return (e = window.ethereum) == null ? void 0 : e.Bitpie
    },
    icon: Tn.bitpie
  }),
  vHe = new Vn({
    name: "Dcent",
    installed: async () => {
      var e;
      return (e = window.ethereum) == null ? void 0 : e[_i.Dcent]
    },
    icon: Tn.dcent
  }),
  bHe = new Vn({
    name: "Frame",
    installed: async () => window.frame,
    icon: Tn.frame
  }, window.frame),
  wHe = new Vn({
    name: "HyperPay",
    installed: async () => {
      var e;
      return (e = window.ethereum) == null ? void 0 : e.hiWallet
    },
    icon: Tn.hyperpay
  }),
  xHe = new Vn({
    name: "ImToken",
    installed: async () => {
      var e;
      return (e = window.ethereum) == null ? void 0 : e[_i.ImToken]
    },
    icon: Tn.imtoken
  }),
  EHe = new Vn({
    name: "Liquality",
    installed: async () => window.liquality,
    icon: Tn.liquality
  }, window.liquality),
  SHe = new Vn({
    name: "OwnBit",
    installed: async () => {
      var e;
      return (e = window.ethereum) == null ? void 0 : e[_i.OwnBit]
    },
    icon: Tn.ownbit
  }),
  CHe = new Vn({
    name: "TokenPocket",
    installed: async () => {
      var e, t;
      return ((e = window.ethereum) == null ? void 0 : e[_i.TokenPocket]) && !((t = window.ethereum) != null && t[_i.TP])
    },
    icon: Tn.tokenpocket
  }),
  AHe = new Vn({
    name: "XDEFI",
    installed: async () => {
      var e;
      return (e = window.ethereum) == null ? void 0 : e[_i.XDEFI]
    },
    icon: Tn.xdefi
  }),
  THe = new Vn({
    name: "OneInch",
    installed: async () => {
      var e;
      return (e = window.ethereum) == null ? void 0 : e[_i.OneInch]
    },
    icon: Tn.oneInch
  }),
  kHe = new Vn({
    name: "Tokenary",
    installed: async () => {
      var e;
      return (e = window.ethereum) == null ? void 0 : e[_i.Tokenary]
    },
    icon: Tn.tokenary
  }),
  _He = new Vn({
    name: "OKX",
    installed: async () => window.okxwallet,
    icon: Tn.okx
  }, window.okxwallet),
  IHe = new Vn({
    name: "Rabby Wallet",
    installed: async () => window.rabby,
    icon: Tn.rabbywallet
  }, window.rabby);
var fF;
const PHe = new Vn({
    name: "Exodus",
    installed: async () => {
      var e;
      return (e = window.exodus) == null ? void 0 : e.ethereum
    },
    icon: Tn.exodus
  }, (fF = window.exodus) == null ? void 0 : fF.ethereum),
  RHe = new OOe({
    name: "Safe",
    installed: async () => {
      if (!((window == null ? void 0 : window.parent) !== window)) return !1;
      const t = new ZQ;
      try {
        const n = await Promise.race([t.safe.getInfo(), new Promise(r => setTimeout(r, 200))]);
        return !!(n != null && n.safeAddress)
      } catch {
        return !1
      }
    },
    icon: Tn.safe
  }),
  OHe = new Zze({
    name: "CyberConnect",
    installed: async () => Jze(),
    icon: Tn.cyberconnect
  }),
  Pw = [eHe, RHe, tHe, nHe, rHe, iHe, PHe, lHe, dHe, sHe, fHe, _He, hHe, pHe, mHe, uHe, yHe, aHe, gHe, vHe, bHe, wHe, xHe, EHe, SHe, CHe, AHe, THe, kHe, cHe, OHe, oHe, IHe];
var wh;
(function (e) {
  e.FromAmount = "fromAmount", e.FromToken = "fromToken", e.ToAddress = "toAddress", e.ToToken = "toToken"
})(wh || (wh = {}));
var Ui;
(function (e) {
  e.Appearance = "appearance", e.DrawerButton = "drawerButton", e.DrawerCloseButton = "drawerCloseButton", e.History = "history", e.Language = "language", e.PoweredBy = "poweredBy", e.ToAddress = "toAddress", e.ToToken = "toToken", e.WalletMenu = "walletMenu"
})(Ui || (Ui = {}));
var bx;
(function (e) {
  e.ToAddress = "toAddress"
})(bx || (bx = {}));
const $8 = new bAe,
  Kg = () => {
    throw new Error(`You forgot to wrap your component in <${wJ.name}>.`)
  },
  DHe = {
    connect: Kg,
    disconnect: Kg,
    switchChain: Kg,
    addChain: Kg,
    addToken: Kg,
    account: {}
  },
  bJ = j.createContext(DHe),
  Ri = () => j.useContext(bJ),
  wJ = ({
    children: e
  }) => {
    var y, x;
    const t = Pm(),
      {
        walletManagement: n
      } = Wt(),
      [r, i] = j.useState({}),
      [s, o] = j.useState(),
      a = async k => {
        var p;
        o(k);
        const _ = await zb((p = k == null ? void 0 : k.account) == null ? void 0 : p.signer);
        return i(_), _
      }, c = j.useCallback(async k => {
        if (n) {
          const p = await n.connect(),
            v = await zb(p);
          i(v), t.emit(Cs.WalletConnected, {
            address: v.address,
            chainId: v.chainId
          });
          return
        }
        await $8.connect(k), k.on("walletAccountChanged", a);
        const _ = await a(k);
        t.emit(Cs.WalletConnected, {
          address: _.address,
          chainId: _.chainId
        })
      }, [t, n]), l = j.useCallback(async () => {
        if (n) {
          await n.disconnect(), i({});
          return
        }
        s && (await $8.disconnect(s), s.removeAllListeners(), await a(void 0))
      }, [s, n]), u = j.useCallback(async k => {
        var _;
        try {
          if (n != null && n.switchChain) {
            const p = await n.switchChain(k),
              v = await zb(p);
            return i(v), p
          } else if (s) await (s == null ? void 0 : s.switchChain(k)), await a(s);
          else {
            const p = (_ = r.signer) == null ? void 0 : _.provider;
            if (!p) throw new Error("Switch chain: No provider available");
            await o6(p, k)
          }
          return r.signer
        } catch {
          return r.signer
        }
      }, [r.signer, s, n]), f = j.useCallback(async k => {
        var _;
        try {
          if (n != null && n.addChain) return n.addChain(k);
          if (s) await (s == null ? void 0 : s.addChain(k)), await a(s);
          else {
            const p = (_ = r.signer) == null ? void 0 : _.provider;
            if (!p) throw new Error("Add chain: No provider available");
            await a6(p, k)
          }
          return !0
        } catch {
          return !1
        }
      }, [(y = r.signer) == null ? void 0 : y.provider, s, n]), h = j.useCallback(async (k, _) => {
        var p;
        try {
          if (n != null && n.addToken) return n.addToken(_, k);
          if (s) await (s == null ? void 0 : s.addToken(k, _)), await a(s);
          else {
            const v = (p = r.signer) == null ? void 0 : p.provider;
            if (!v) throw new Error("Add token: No provider available");
            await Kk(v, k, _)
          }
        } catch {}
      }, [(x = r.signer) == null ? void 0 : x.provider, s, n]);
    j.useEffect(() => {
      (async () => {
        const _ = qk(),
          p = Pw.filter(v => _.some(S => S.name === v.name));
        p.length && (await $8.autoConnect(p), p[0].on("walletAccountChanged", a), await a(p[0]))
      })()
    }, []), j.useEffect(() => {
      if (n) {
        let k = !1;
        return (async () => {
          const p = await zb(n == null ? void 0 : n.signer);
          k || i(p)
        })(), () => {
          k = !0
        }
      }
    }, [n]);
    const g = j.useMemo(() => ({
      connect: c,
      disconnect: l,
      switchChain: u,
      addChain: f,
      addToken: h,
      account: r
    }), [r, f, h, c, l, u]);
    return C.jsx(bJ.Provider, {
      value: g,
      children: e
    })
  },
  zb = async e => {
    try {
      return {
        address: await (e == null ? void 0 : e.getAddress()),
        isActive: e && !!await e.getAddress() === null || !!e,
        signer: e,
        chainId: await (e == null ? void 0 : e.getChainId())
      }
    } catch (t) {
      return console.error(t), {}
    }
  }, NHe = ({
    defaultValues: e
  }) => {
    const {
      fromChain: t,
      toChain: n,
      chains: r
    } = Wt(), {
      account: i
    } = Ri(), {
      setValue: s,
      getValues: o,
      getFieldState: a,
      resetField: c,
      formState: {
        touchedFields: l
      }
    } = Ls(), u = j.useRef(e);
    return j.useEffect(() => {
      if (!i.isActive || !i.chainId || !Np(i.chainId, r)) return;
      const {
        isTouched: h
      } = a(Qe.FromChain), {
        isTouched: g
      } = a(Qe.ToChain), {
        isTouched: y
      } = a(Qe.FromToken), {
        isTouched: x
      } = a(Qe.ToToken), {
        isTouched: k
      } = a(Qe.FromAmount);
      !t && !h && !y && (c(Qe.FromChain, {
        defaultValue: i.chainId
      }), s(Qe.FromChain, i.chainId), s(Qe.FromToken, ""), k && s(Qe.FromAmount, "")), !n && !g && !x && (c(Qe.ToChain, {
        defaultValue: i.chainId
      }), s(Qe.ToChain, i.chainId), s(Qe.ToToken, ""))
    }, [i.chainId, i.isActive, r, t, a, o, c, s, n]), j.useEffect(() => {
      Object.keys(e).forEach(f => {
        if (u.current[f] !== e[f]) {
          const h = e[f] || (f === Qe.FromChain || f === Qe.ToChain) && i.chainId || "";
          s(f, h), c(f, {
            defaultValue: h
          })
        }
      }), u.current = e
    }, [e, o, c, s]), null
  };
var Qe;
(function (e) {
  e.ContractOutputsToken = "contractOutputsToken", e.FromAmount = "fromAmount", e.FromChain = "fromChain", e.FromToken = "fromToken", e.ToAddress = "toAddress", e.ToAmount = "toAmount", e.ToChain = "toChain", e.ToContractAddress = "toContractAddress", e.ToContractCallData = "toContractCallData", e.ToContractGasLimit = "ToContractGasLimit", e.ToToken = "toToken", e.TokenSearchFilter = "tokenSearchFilter"
})(Qe || (Qe = {}));
const sr = {
    getChainKey: e => `${e}Chain`,
    getTokenKey: e => `${e}Token`,
    getAmountKey: e => `${e}Amount`
  },
  L8 = {
    [Qe.FromAmount]: "",
    [Qe.ToAddress]: "",
    [Qe.TokenSearchFilter]: "",
    [Qe.ContractOutputsToken]: "",
    [Qe.ToContractAddress]: "",
    [Qe.ToContractCallData]: "",
    [Qe.ToContractGasLimit]: "",
    [Qe.ToAmount]: ""
  },
  MHe = ({
    children: e
  }) => {
    const {
      fromChain: t,
      fromToken: n,
      fromAmount: r,
      toChain: i,
      toToken: s,
      toAddress: o
    } = Wt(), a = j.useMemo(() => ({
      ...L8,
      fromChain: t,
      fromToken: n,
      fromAmount: (typeof r == "number" ? r == null ? void 0 : r.toPrecision() : r) || L8.fromAmount,
      toChain: i,
      toToken: s,
      toAddress: o || L8.toAddress
    }), [r, t, n, o, i, s]), c = Yxe({
      defaultValues: a
    });
    return C.jsxs(Bxe, {
      ...c,
      children: [C.jsx(NHe, {
        defaultValues: a
      }), e]
    })
  },
  kB = [Qe.FromAmount, Qe.FromChain, Qe.FromToken, Qe.ToAddress, Qe.ToChain, Qe.ToToken],
  $He = () => {
    const {
      pathname: e
    } = yu(), {
      touchedFields: {
        ...t
      }
    } = xm(), n = ds({
      name: kB
    });
    return j.useEffect(() => {
      const r = new URL(window.location);
      kB.forEach((i, s) => {
        t[i] && n[s] ? r.searchParams.set(i, n[s]) : r.searchParams.has(i) && !n[s] && r.searchParams.delete(i)
      }), r.searchParams.sort(), window.history.replaceState(window.history.state, "", r)
    }, [e, t, n]), null
  },
  LHe = {
    type: "logger",
    log(e) {
      this.output("log", e)
    },
    warn(e) {
      this.output("warn", e)
    },
    error(e) {
      this.output("error", e)
    },
    output(e, t) {
      console && console[e] && console[e].apply(console, t)
    }
  };
class wx {
  constructor(t) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.init(t, n)
  }
  init(t) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.prefix = n.prefix || "i18next:", this.logger = t || LHe, this.options = n, this.debug = n.debug
  }
  log() {
    for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++) n[r] = arguments[r];
    return this.forward(n, "log", "", !0)
  }
  warn() {
    for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++) n[r] = arguments[r];
    return this.forward(n, "warn", "", !0)
  }
  error() {
    for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++) n[r] = arguments[r];
    return this.forward(n, "error", "")
  }
  deprecate() {
    for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++) n[r] = arguments[r];
    return this.forward(n, "warn", "WARNING DEPRECATED: ", !0)
  }
  forward(t, n, r, i) {
    return i && !this.debug ? null : (typeof t[0] == "string" && (t[0] = `${r}${this.prefix} ${t[0]}`), this.logger[n](t))
  }
  create(t) {
    return new wx(this.logger, {
      prefix: `${this.prefix}:${t}:`,
      ...this.options
    })
  }
  clone(t) {
    return t = t || this.options, t.prefix = t.prefix || this.prefix, new wx(this.logger, t)
  }
}
var tl = new wx;
class pE {
  constructor() {
    this.observers = {}
  }
  on(t, n) {
    return t.split(" ").forEach(r => {
      this.observers[r] || (this.observers[r] = new Map);
      const i = this.observers[r].get(n) || 0;
      this.observers[r].set(n, i + 1)
    }), this
  }
  off(t, n) {
    if (this.observers[t]) {
      if (!n) {
        delete this.observers[t];
        return
      }
      this.observers[t].delete(n)
    }
  }
  emit(t) {
    for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++) r[i - 1] = arguments[i];
    this.observers[t] && Array.from(this.observers[t].entries()).forEach(o => {
      let [a, c] = o;
      for (let l = 0; l < c; l++) a(...r)
    }), this.observers["*"] && Array.from(this.observers["*"].entries()).forEach(o => {
      let [a, c] = o;
      for (let l = 0; l < c; l++) a.apply(a, [t, ...r])
    })
  }
}

function Qg() {
  let e, t;
  const n = new Promise((r, i) => {
    e = r, t = i
  });
  return n.resolve = e, n.reject = t, n
}

function _B(e) {
  return e == null ? "" : "" + e
}

function BHe(e, t, n) {
  e.forEach(r => {
    t[r] && (n[r] = t[r])
  })
}
const FHe = /###/g;

function I1(e, t, n) {
  function r(a) {
    return a && a.indexOf("###") > -1 ? a.replace(FHe, ".") : a
  }

  function i() {
    return !e || typeof e == "string"
  }
  const s = typeof t != "string" ? t : t.split(".");
  let o = 0;
  for (; o < s.length - 1;) {
    if (i()) return {};
    const a = r(s[o]);
    !e[a] && n && (e[a] = new n), Object.prototype.hasOwnProperty.call(e, a) ? e = e[a] : e = {}, ++o
  }
  return i() ? {} : {
    obj: e,
    k: r(s[o])
  }
}

function IB(e, t, n) {
  const {
    obj: r,
    k: i
  } = I1(e, t, Object);
  if (r !== void 0 || t.length === 1) {
    r[i] = n;
    return
  }
  let s = t[t.length - 1],
    o = t.slice(0, t.length - 1),
    a = I1(e, o, Object);
  for (; a.obj === void 0 && o.length;) s = `${o[o.length-1]}.${s}`, o = o.slice(0, o.length - 1), a = I1(e, o, Object), a && a.obj && typeof a.obj[`${a.k}.${s}`] < "u" && (a.obj = void 0);
  a.obj[`${a.k}.${s}`] = n
}

function jHe(e, t, n, r) {
  const {
    obj: i,
    k: s
  } = I1(e, t, Object);
  i[s] = i[s] || [], r && (i[s] = i[s].concat(n)), r || i[s].push(n)
}

function xx(e, t) {
  const {
    obj: n,
    k: r
  } = I1(e, t);
  if (n) return n[r]
}

function UHe(e, t, n) {
  const r = xx(e, n);
  return r !== void 0 ? r : xx(t, n)
}

function xJ(e, t, n) {
  for (const r in t) r !== "__proto__" && r !== "constructor" && (r in e ? typeof e[r] == "string" || e[r] instanceof String || typeof t[r] == "string" || t[r] instanceof String ? n && (e[r] = t[r]) : xJ(e[r], t[r], n) : e[r] = t[r]);
  return e
}

function b0(e) {
  return e.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&")
}
var zHe = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;"
};

function HHe(e) {
  return typeof e == "string" ? e.replace(/[&<>"'\/]/g, t => zHe[t]) : e
}
class VHe {
  constructor(t) {
    this.capacity = t, this.regExpMap = new Map, this.regExpQueue = []
  }
  getRegExp(t) {
    const n = this.regExpMap.get(t);
    if (n !== void 0) return n;
    const r = new RegExp(t);
    return this.regExpQueue.length === this.capacity && this.regExpMap.delete(this.regExpQueue.shift()), this.regExpMap.set(t, r), this.regExpQueue.push(t), r
  }
}
const WHe = [" ", ",", "?", "!", ";"],
  qHe = new VHe(20);

function GHe(e, t, n) {
  t = t || "", n = n || "";
  const r = WHe.filter(o => t.indexOf(o) < 0 && n.indexOf(o) < 0);
  if (r.length === 0) return !0;
  const i = qHe.getRegExp(`(${r.map(o=>o==="?"?"\\?":o).join("|")})`);
  let s = !i.test(e);
  if (!s) {
    const o = e.indexOf(n);
    o > 0 && !i.test(e.substring(0, o)) && (s = !0)
  }
  return s
}

function d9(e, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ".";
  if (!e) return;
  if (e[t]) return e[t];
  const r = t.split(n);
  let i = e;
  for (let s = 0; s < r.length;) {
    if (!i || typeof i != "object") return;
    let o, a = "";
    for (let c = s; c < r.length; ++c)
      if (c !== s && (a += n), a += r[c], o = i[a], o !== void 0) {
        if (["string", "number", "boolean"].indexOf(typeof o) > -1 && c < r.length - 1) continue;
        s += c - s + 1;
        break
      } i = o
  }
  return i
}

function Ex(e) {
  return e && e.indexOf("_") > 0 ? e.replace("_", "-") : e
}
class PB extends pE {
  constructor(t) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      ns: ["translation"],
      defaultNS: "translation"
    };
    super(), this.data = t || {}, this.options = n, this.options.keySeparator === void 0 && (this.options.keySeparator = "."), this.options.ignoreJSONStructure === void 0 && (this.options.ignoreJSONStructure = !0)
  }
  addNamespaces(t) {
    this.options.ns.indexOf(t) < 0 && this.options.ns.push(t)
  }
  removeNamespaces(t) {
    const n = this.options.ns.indexOf(t);
    n > -1 && this.options.ns.splice(n, 1)
  }
  getResource(t, n, r) {
    let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    const s = i.keySeparator !== void 0 ? i.keySeparator : this.options.keySeparator,
      o = i.ignoreJSONStructure !== void 0 ? i.ignoreJSONStructure : this.options.ignoreJSONStructure;
    let a;
    t.indexOf(".") > -1 ? a = t.split(".") : (a = [t, n], r && (Array.isArray(r) ? a.push(...r) : typeof r == "string" && s ? a.push(...r.split(s)) : a.push(r)));
    const c = xx(this.data, a);
    return !c && !n && !r && t.indexOf(".") > -1 && (t = a[0], n = a[1], r = a.slice(2).join(".")), c || !o || typeof r != "string" ? c : d9(this.data && this.data[t] && this.data[t][n], r, s)
  }
  addResource(t, n, r, i) {
    let s = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
      silent: !1
    };
    const o = s.keySeparator !== void 0 ? s.keySeparator : this.options.keySeparator;
    let a = [t, n];
    r && (a = a.concat(o ? r.split(o) : r)), t.indexOf(".") > -1 && (a = t.split("."), i = n, n = a[1]), this.addNamespaces(n), IB(this.data, a, i), s.silent || this.emit("added", t, n, r, i)
  }
  addResources(t, n, r) {
    let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
      silent: !1
    };
    for (const s in r)(typeof r[s] == "string" || Object.prototype.toString.apply(r[s]) === "[object Array]") && this.addResource(t, n, s, r[s], {
      silent: !0
    });
    i.silent || this.emit("added", t, n, r)
  }
  addResourceBundle(t, n, r, i, s) {
    let o = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {
        silent: !1,
        skipCopy: !1
      },
      a = [t, n];
    t.indexOf(".") > -1 && (a = t.split("."), i = r, r = n, n = a[1]), this.addNamespaces(n);
    let c = xx(this.data, a) || {};
    o.skipCopy || (r = JSON.parse(JSON.stringify(r))), i ? xJ(c, r, s) : c = {
      ...c,
      ...r
    }, IB(this.data, a, c), o.silent || this.emit("added", t, n, r)
  }
  removeResourceBundle(t, n) {
    this.hasResourceBundle(t, n) && delete this.data[t][n], this.removeNamespaces(n), this.emit("removed", t, n)
  }
  hasResourceBundle(t, n) {
    return this.getResource(t, n) !== void 0
  }
  getResourceBundle(t, n) {
    return n || (n = this.options.defaultNS), this.options.compatibilityAPI === "v1" ? {
      ...this.getResource(t, n)
    } : this.getResource(t, n)
  }
  getDataByLanguage(t) {
    return this.data[t]
  }
  hasLanguageSomeTranslations(t) {
    const n = this.getDataByLanguage(t);
    return !!(n && Object.keys(n) || []).find(i => n[i] && Object.keys(n[i]).length > 0)
  }
  toJSON() {
    return this.data
  }
}
var EJ = {
  processors: {},
  addPostProcessor(e) {
    this.processors[e.name] = e
  },
  handle(e, t, n, r, i) {
    return e.forEach(s => {
      this.processors[s] && (t = this.processors[s].process(t, n, r, i))
    }), t
  }
};
const RB = {};
class Sx extends pE {
  constructor(t) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(), BHe(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], t, this), this.options = n, this.options.keySeparator === void 0 && (this.options.keySeparator = "."), this.logger = tl.create("translator")
  }
  changeLanguage(t) {
    t && (this.language = t)
  }
  exists(t) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      interpolation: {}
    };
    if (t == null) return !1;
    const r = this.resolve(t, n);
    return r && r.res !== void 0
  }
  extractFromKey(t, n) {
    let r = n.nsSeparator !== void 0 ? n.nsSeparator : this.options.nsSeparator;
    r === void 0 && (r = ":");
    const i = n.keySeparator !== void 0 ? n.keySeparator : this.options.keySeparator;
    let s = n.ns || this.options.defaultNS || [];
    const o = r && t.indexOf(r) > -1,
      a = !this.options.userDefinedKeySeparator && !n.keySeparator && !this.options.userDefinedNsSeparator && !n.nsSeparator && !GHe(t, r, i);
    if (o && !a) {
      const c = t.match(this.interpolator.nestingRegexp);
      if (c && c.length > 0) return {
        key: t,
        namespaces: s
      };
      const l = t.split(r);
      (r !== i || r === i && this.options.ns.indexOf(l[0]) > -1) && (s = l.shift()), t = l.join(i)
    }
    return typeof s == "string" && (s = [s]), {
      key: t,
      namespaces: s
    }
  }
  translate(t, n, r) {
    if (typeof n != "object" && this.options.overloadTranslationOptionHandler && (n = this.options.overloadTranslationOptionHandler(arguments)), typeof n == "object" && (n = {
        ...n
      }), n || (n = {}), t == null) return "";
    Array.isArray(t) || (t = [String(t)]);
    const i = n.returnDetails !== void 0 ? n.returnDetails : this.options.returnDetails,
      s = n.keySeparator !== void 0 ? n.keySeparator : this.options.keySeparator,
      {
        key: o,
        namespaces: a
      } = this.extractFromKey(t[t.length - 1], n),
      c = a[a.length - 1],
      l = n.lng || this.language,
      u = n.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
    if (l && l.toLowerCase() === "cimode") {
      if (u) {
        const S = n.nsSeparator || this.options.nsSeparator;
        return i ? {
          res: `${c}${S}${o}`,
          usedKey: o,
          exactUsedKey: o,
          usedLng: l,
          usedNS: c,
          usedParams: this.getUsedParamsDetails(n)
        } : `${c}${S}${o}`
      }
      return i ? {
        res: o,
        usedKey: o,
        exactUsedKey: o,
        usedLng: l,
        usedNS: c,
        usedParams: this.getUsedParamsDetails(n)
      } : o
    }
    const f = this.resolve(t, n);
    let h = f && f.res;
    const g = f && f.usedKey || o,
      y = f && f.exactUsedKey || o,
      x = Object.prototype.toString.apply(h),
      k = ["[object Number]", "[object Function]", "[object RegExp]"],
      _ = n.joinArrays !== void 0 ? n.joinArrays : this.options.joinArrays,
      p = !this.i18nFormat || this.i18nFormat.handleAsObject;
    if (p && h && (typeof h != "string" && typeof h != "boolean" && typeof h != "number") && k.indexOf(x) < 0 && !(typeof _ == "string" && x === "[object Array]")) {
      if (!n.returnObjects && !this.options.returnObjects) {
        this.options.returnedObjectHandler || this.logger.warn("accessing an object - but returnObjects options is not enabled!");
        const S = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(g, h, {
          ...n,
          ns: a
        }) : `key '${o} (${this.language})' returned an object instead of string.`;
        return i ? (f.res = S, f.usedParams = this.getUsedParamsDetails(n), f) : S
      }
      if (s) {
        const S = x === "[object Array]",
          I = S ? [] : {},
          A = S ? y : g;
        for (const w in h)
          if (Object.prototype.hasOwnProperty.call(h, w)) {
            const E = `${A}${s}${w}`;
            I[w] = this.translate(E, {
              ...n,
              joinArrays: !1,
              ns: a
            }), I[w] === E && (I[w] = h[w])
          } h = I
      }
    } else if (p && typeof _ == "string" && x === "[object Array]") h = h.join(_), h && (h = this.extendTranslation(h, t, n, r));
    else {
      let S = !1,
        I = !1;
      const A = n.count !== void 0 && typeof n.count != "string",
        w = Sx.hasDefaultValue(n),
        E = A ? this.pluralResolver.getSuffix(l, n.count, n) : "",
        D = n.ordinal && A ? this.pluralResolver.getSuffix(l, n.count, {
          ordinal: !1
        }) : "",
        $ = A && !n.ordinal && n.count === 0 && this.pluralResolver.shouldUseIntlApi(),
        V = $ && n[`defaultValue${this.options.pluralSeparator}zero`] || n[`defaultValue${E}`] || n[`defaultValue${D}`] || n.defaultValue;
      !this.isValidLookup(h) && w && (S = !0, h = V), this.isValidLookup(h) || (I = !0, h = o);
      const L = (n.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey) && I ? void 0 : h,
        b = w && V !== h && this.options.updateMissing;
      if (I || S || b) {
        if (this.logger.log(b ? "updateKey" : "missingKey", l, c, o, b ? V : h), s) {
          const O = this.resolve(o, {
            ...n,
            keySeparator: !1
          });
          O && O.res && this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.")
        }
        let T = [];
        const R = this.languageUtils.getFallbackCodes(this.options.fallbackLng, n.lng || this.language);
        if (this.options.saveMissingTo === "fallback" && R && R[0])
          for (let O = 0; O < R.length; O++) T.push(R[O]);
        else this.options.saveMissingTo === "all" ? T = this.languageUtils.toResolveHierarchy(n.lng || this.language) : T.push(n.lng || this.language);
        const N = (O, U, q) => {
          const W = w && q !== h ? q : L;
          this.options.missingKeyHandler ? this.options.missingKeyHandler(O, c, U, W, b, n) : this.backendConnector && this.backendConnector.saveMissing && this.backendConnector.saveMissing(O, c, U, W, b, n), this.emit("missingKey", O, c, U, h)
        };
        this.options.saveMissing && (this.options.saveMissingPlurals && A ? T.forEach(O => {
          const U = this.pluralResolver.getSuffixes(O, n);
          $ && n[`defaultValue${this.options.pluralSeparator}zero`] && U.indexOf(`${this.options.pluralSeparator}zero`) < 0 && U.push(`${this.options.pluralSeparator}zero`), U.forEach(q => {
            N([O], o + q, n[`defaultValue${q}`] || V)
          })
        }) : N(T, o, V))
      }
      h = this.extendTranslation(h, t, n, f, r), I && h === o && this.options.appendNamespaceToMissingKey && (h = `${c}:${o}`), (I || S) && this.options.parseMissingKeyHandler && (this.options.compatibilityAPI !== "v1" ? h = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? `${c}:${o}` : o, S ? h : void 0) : h = this.options.parseMissingKeyHandler(h))
    }
    return i ? (f.res = h, f.usedParams = this.getUsedParamsDetails(n), f) : h
  }
  extendTranslation(t, n, r, i, s) {
    var o = this;
    if (this.i18nFormat && this.i18nFormat.parse) t = this.i18nFormat.parse(t, {
      ...this.options.interpolation.defaultVariables,
      ...r
    }, r.lng || this.language || i.usedLng, i.usedNS, i.usedKey, {
      resolved: i
    });
    else if (!r.skipInterpolation) {
      r.interpolation && this.interpolator.init({
        ...r,
        interpolation: {
          ...this.options.interpolation,
          ...r.interpolation
        }
      });
      const l = typeof t == "string" && (r && r.interpolation && r.interpolation.skipOnVariables !== void 0 ? r.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);
      let u;
      if (l) {
        const h = t.match(this.interpolator.nestingRegexp);
        u = h && h.length
      }
      let f = r.replace && typeof r.replace != "string" ? r.replace : r;
      if (this.options.interpolation.defaultVariables && (f = {
          ...this.options.interpolation.defaultVariables,
          ...f
        }), t = this.interpolator.interpolate(t, f, r.lng || this.language, r), l) {
        const h = t.match(this.interpolator.nestingRegexp),
          g = h && h.length;
        u < g && (r.nest = !1)
      }!r.lng && this.options.compatibilityAPI !== "v1" && i && i.res && (r.lng = i.usedLng), r.nest !== !1 && (t = this.interpolator.nest(t, function () {
        for (var h = arguments.length, g = new Array(h), y = 0; y < h; y++) g[y] = arguments[y];
        return s && s[0] === g[0] && !r.context ? (o.logger.warn(`It seems you are nesting recursively key: ${g[0]} in key: ${n[0]}`), null) : o.translate(...g, n)
      }, r)), r.interpolation && this.interpolator.reset()
    }
    const a = r.postProcess || this.options.postProcess,
      c = typeof a == "string" ? [a] : a;
    return t != null && c && c.length && r.applyPostProcessor !== !1 && (t = EJ.handle(c, t, n, this.options && this.options.postProcessPassResolved ? {
      i18nResolved: {
        ...i,
        usedParams: this.getUsedParamsDetails(r)
      },
      ...r
    } : r, this)), t
  }
  resolve(t) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
      r, i, s, o, a;
    return typeof t == "string" && (t = [t]), t.forEach(c => {
      if (this.isValidLookup(r)) return;
      const l = this.extractFromKey(c, n),
        u = l.key;
      i = u;
      let f = l.namespaces;
      this.options.fallbackNS && (f = f.concat(this.options.fallbackNS));
      const h = n.count !== void 0 && typeof n.count != "string",
        g = h && !n.ordinal && n.count === 0 && this.pluralResolver.shouldUseIntlApi(),
        y = n.context !== void 0 && (typeof n.context == "string" || typeof n.context == "number") && n.context !== "",
        x = n.lngs ? n.lngs : this.languageUtils.toResolveHierarchy(n.lng || this.language, n.fallbackLng);
      f.forEach(k => {
        this.isValidLookup(r) || (a = k, !RB[`${x[0]}-${k}`] && this.utils && this.utils.hasLoadedNamespace && !this.utils.hasLoadedNamespace(a) && (RB[`${x[0]}-${k}`] = !0, this.logger.warn(`key "${i}" for languages "${x.join(", ")}" won't get resolved as namespace "${a}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!")), x.forEach(_ => {
          if (this.isValidLookup(r)) return;
          o = _;
          const p = [u];
          if (this.i18nFormat && this.i18nFormat.addLookupKeys) this.i18nFormat.addLookupKeys(p, u, _, k, n);
          else {
            let S;
            h && (S = this.pluralResolver.getSuffix(_, n.count, n));
            const I = `${this.options.pluralSeparator}zero`,
              A = `${this.options.pluralSeparator}ordinal${this.options.pluralSeparator}`;
            if (h && (p.push(u + S), n.ordinal && S.indexOf(A) === 0 && p.push(u + S.replace(A, this.options.pluralSeparator)), g && p.push(u + I)), y) {
              const w = `${u}${this.options.contextSeparator}${n.context}`;
              p.push(w), h && (p.push(w + S), n.ordinal && S.indexOf(A) === 0 && p.push(w + S.replace(A, this.options.pluralSeparator)), g && p.push(w + I))
            }
          }
          let v;
          for (; v = p.pop();) this.isValidLookup(r) || (s = v, r = this.getResource(_, k, v, n))
        }))
      })
    }), {
      res: r,
      usedKey: i,
      exactUsedKey: s,
      usedLng: o,
      usedNS: a
    }
  }
  isValidLookup(t) {
    return t !== void 0 && !(!this.options.returnNull && t === null) && !(!this.options.returnEmptyString && t === "")
  }
  getResource(t, n, r) {
    let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    return this.i18nFormat && this.i18nFormat.getResource ? this.i18nFormat.getResource(t, n, r, i) : this.resourceStore.getResource(t, n, r, i)
  }
  getUsedParamsDetails() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const n = ["defaultValue", "ordinal", "context", "replace", "lng", "lngs", "fallbackLng", "ns", "keySeparator", "nsSeparator", "returnObjects", "returnDetails", "joinArrays", "postProcess", "interpolation"],
      r = t.replace && typeof t.replace != "string";
    let i = r ? t.replace : t;
    if (r && typeof t.count < "u" && (i.count = t.count), this.options.interpolation.defaultVariables && (i = {
        ...this.options.interpolation.defaultVariables,
        ...i
      }), !r) {
      i = {
        ...i
      };
      for (const s of n) delete i[s]
    }
    return i
  }
  static hasDefaultValue(t) {
    const n = "defaultValue";
    for (const r in t)
      if (Object.prototype.hasOwnProperty.call(t, r) && n === r.substring(0, n.length) && t[r] !== void 0) return !0;
    return !1
  }
}

function B8(e) {
  return e.charAt(0).toUpperCase() + e.slice(1)
}
class OB {
  constructor(t) {
    this.options = t, this.supportedLngs = this.options.supportedLngs || !1, this.logger = tl.create("languageUtils")
  }
  getScriptPartFromCode(t) {
    if (t = Ex(t), !t || t.indexOf("-") < 0) return null;
    const n = t.split("-");
    return n.length === 2 || (n.pop(), n[n.length - 1].toLowerCase() === "x") ? null : this.formatLanguageCode(n.join("-"))
  }
  getLanguagePartFromCode(t) {
    if (t = Ex(t), !t || t.indexOf("-") < 0) return t;
    const n = t.split("-");
    return this.formatLanguageCode(n[0])
  }
  formatLanguageCode(t) {
    if (typeof t == "string" && t.indexOf("-") > -1) {
      const n = ["hans", "hant", "latn", "cyrl", "cans", "mong", "arab"];
      let r = t.split("-");
      return this.options.lowerCaseLng ? r = r.map(i => i.toLowerCase()) : r.length === 2 ? (r[0] = r[0].toLowerCase(), r[1] = r[1].toUpperCase(), n.indexOf(r[1].toLowerCase()) > -1 && (r[1] = B8(r[1].toLowerCase()))) : r.length === 3 && (r[0] = r[0].toLowerCase(), r[1].length === 2 && (r[1] = r[1].toUpperCase()), r[0] !== "sgn" && r[2].length === 2 && (r[2] = r[2].toUpperCase()), n.indexOf(r[1].toLowerCase()) > -1 && (r[1] = B8(r[1].toLowerCase())), n.indexOf(r[2].toLowerCase()) > -1 && (r[2] = B8(r[2].toLowerCase()))), r.join("-")
    }
    return this.options.cleanCode || this.options.lowerCaseLng ? t.toLowerCase() : t
  }
  isSupportedCode(t) {
    return (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) && (t = this.getLanguagePartFromCode(t)), !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(t) > -1
  }
  getBestMatchFromCodes(t) {
    if (!t) return null;
    let n;
    return t.forEach(r => {
      if (n) return;
      const i = this.formatLanguageCode(r);
      (!this.options.supportedLngs || this.isSupportedCode(i)) && (n = i)
    }), !n && this.options.supportedLngs && t.forEach(r => {
      if (n) return;
      const i = this.getLanguagePartFromCode(r);
      if (this.isSupportedCode(i)) return n = i;
      n = this.options.supportedLngs.find(s => {
        if (s === i) return s;
        if (!(s.indexOf("-") < 0 && i.indexOf("-") < 0) && (s.indexOf("-") > 0 && i.indexOf("-") < 0 && s.substring(0, s.indexOf("-")) === i || s.indexOf(i) === 0 && i.length > 1)) return s
      })
    }), n || (n = this.getFallbackCodes(this.options.fallbackLng)[0]), n
  }
  getFallbackCodes(t, n) {
    if (!t) return [];
    if (typeof t == "function" && (t = t(n)), typeof t == "string" && (t = [t]), Object.prototype.toString.apply(t) === "[object Array]") return t;
    if (!n) return t.default || [];
    let r = t[n];
    return r || (r = t[this.getScriptPartFromCode(n)]), r || (r = t[this.formatLanguageCode(n)]), r || (r = t[this.getLanguagePartFromCode(n)]), r || (r = t.default), r || []
  }
  toResolveHierarchy(t, n) {
    const r = this.getFallbackCodes(n || this.options.fallbackLng || [], t),
      i = [],
      s = o => {
        o && (this.isSupportedCode(o) ? i.push(o) : this.logger.warn(`rejecting language code not found in supportedLngs: ${o}`))
      };
    return typeof t == "string" && (t.indexOf("-") > -1 || t.indexOf("_") > -1) ? (this.options.load !== "languageOnly" && s(this.formatLanguageCode(t)), this.options.load !== "languageOnly" && this.options.load !== "currentOnly" && s(this.getScriptPartFromCode(t)), this.options.load !== "currentOnly" && s(this.getLanguagePartFromCode(t))) : typeof t == "string" && s(this.formatLanguageCode(t)), r.forEach(o => {
      i.indexOf(o) < 0 && s(this.formatLanguageCode(o))
    }), i
  }
}
let KHe = [{
    lngs: ["ach", "ak", "am", "arn", "br", "fil", "gun", "ln", "mfe", "mg", "mi", "oc", "pt", "pt-BR", "tg", "tl", "ti", "tr", "uz", "wa"],
    nr: [1, 2],
    fc: 1
  }, {
    lngs: ["af", "an", "ast", "az", "bg", "bn", "ca", "da", "de", "dev", "el", "en", "eo", "es", "et", "eu", "fi", "fo", "fur", "fy", "gl", "gu", "ha", "hi", "hu", "hy", "ia", "it", "kk", "kn", "ku", "lb", "mai", "ml", "mn", "mr", "nah", "nap", "nb", "ne", "nl", "nn", "no", "nso", "pa", "pap", "pms", "ps", "pt-PT", "rm", "sco", "se", "si", "so", "son", "sq", "sv", "sw", "ta", "te", "tk", "ur", "yo"],
    nr: [1, 2],
    fc: 2
  }, {
    lngs: ["ay", "bo", "cgg", "fa", "ht", "id", "ja", "jbo", "ka", "km", "ko", "ky", "lo", "ms", "sah", "su", "th", "tt", "ug", "vi", "wo", "zh"],
    nr: [1],
    fc: 3
  }, {
    lngs: ["be", "bs", "cnr", "dz", "hr", "ru", "sr", "uk"],
    nr: [1, 2, 5],
    fc: 4
  }, {
    lngs: ["ar"],
    nr: [0, 1, 2, 3, 11, 100],
    fc: 5
  }, {
    lngs: ["cs", "sk"],
    nr: [1, 2, 5],
    fc: 6
  }, {
    lngs: ["csb", "pl"],
    nr: [1, 2, 5],
    fc: 7
  }, {
    lngs: ["cy"],
    nr: [1, 2, 3, 8],
    fc: 8
  }, {
    lngs: ["fr"],
    nr: [1, 2],
    fc: 9
  }, {
    lngs: ["ga"],
    nr: [1, 2, 3, 7, 11],
    fc: 10
  }, {
    lngs: ["gd"],
    nr: [1, 2, 3, 20],
    fc: 11
  }, {
    lngs: ["is"],
    nr: [1, 2],
    fc: 12
  }, {
    lngs: ["jv"],
    nr: [0, 1],
    fc: 13
  }, {
    lngs: ["kw"],
    nr: [1, 2, 3, 4],
    fc: 14
  }, {
    lngs: ["lt"],
    nr: [1, 2, 10],
    fc: 15
  }, {
    lngs: ["lv"],
    nr: [1, 2, 0],
    fc: 16
  }, {
    lngs: ["mk"],
    nr: [1, 2],
    fc: 17
  }, {
    lngs: ["mnk"],
    nr: [0, 1, 2],
    fc: 18
  }, {
    lngs: ["mt"],
    nr: [1, 2, 11, 20],
    fc: 19
  }, {
    lngs: ["or"],
    nr: [2, 1],
    fc: 2
  }, {
    lngs: ["ro"],
    nr: [1, 2, 20],
    fc: 20
  }, {
    lngs: ["sl"],
    nr: [5, 1, 2, 3],
    fc: 21
  }, {
    lngs: ["he", "iw"],
    nr: [1, 2, 20, 21],
    fc: 22
  }],
  QHe = {
    1: function (e) {
      return +(e > 1)
    },
    2: function (e) {
      return +(e != 1)
    },
    3: function (e) {
      return 0
    },
    4: function (e) {
      return e % 10 == 1 && e % 100 != 11 ? 0 : e % 10 >= 2 && e % 10 <= 4 && (e % 100 < 10 || e % 100 >= 20) ? 1 : 2
    },
    5: function (e) {
      return e == 0 ? 0 : e == 1 ? 1 : e == 2 ? 2 : e % 100 >= 3 && e % 100 <= 10 ? 3 : e % 100 >= 11 ? 4 : 5
    },
    6: function (e) {
      return e == 1 ? 0 : e >= 2 && e <= 4 ? 1 : 2
    },
    7: function (e) {
      return e == 1 ? 0 : e % 10 >= 2 && e % 10 <= 4 && (e % 100 < 10 || e % 100 >= 20) ? 1 : 2
    },
    8: function (e) {
      return e == 1 ? 0 : e == 2 ? 1 : e != 8 && e != 11 ? 2 : 3
    },
    9: function (e) {
      return +(e >= 2)
    },
    10: function (e) {
      return e == 1 ? 0 : e == 2 ? 1 : e < 7 ? 2 : e < 11 ? 3 : 4
    },
    11: function (e) {
      return e == 1 || e == 11 ? 0 : e == 2 || e == 12 ? 1 : e > 2 && e < 20 ? 2 : 3
    },
    12: function (e) {
      return +(e % 10 != 1 || e % 100 == 11)
    },
    13: function (e) {
      return +(e !== 0)
    },
    14: function (e) {
      return e == 1 ? 0 : e == 2 ? 1 : e == 3 ? 2 : 3
    },
    15: function (e) {
      return e % 10 == 1 && e % 100 != 11 ? 0 : e % 10 >= 2 && (e % 100 < 10 || e % 100 >= 20) ? 1 : 2
    },
    16: function (e) {
      return e % 10 == 1 && e % 100 != 11 ? 0 : e !== 0 ? 1 : 2
    },
    17: function (e) {
      return e == 1 || e % 10 == 1 && e % 100 != 11 ? 0 : 1
    },
    18: function (e) {
      return e == 0 ? 0 : e == 1 ? 1 : 2
    },
    19: function (e) {
      return e == 1 ? 0 : e == 0 || e % 100 > 1 && e % 100 < 11 ? 1 : e % 100 > 10 && e % 100 < 20 ? 2 : 3
    },
    20: function (e) {
      return e == 1 ? 0 : e == 0 || e % 100 > 0 && e % 100 < 20 ? 1 : 2
    },
    21: function (e) {
      return e % 100 == 1 ? 1 : e % 100 == 2 ? 2 : e % 100 == 3 || e % 100 == 4 ? 3 : 0
    },
    22: function (e) {
      return e == 1 ? 0 : e == 2 ? 1 : (e < 0 || e > 10) && e % 10 == 0 ? 2 : 3
    }
  };
const YHe = ["v1", "v2", "v3"],
  JHe = ["v4"],
  DB = {
    zero: 0,
    one: 1,
    two: 2,
    few: 3,
    many: 4,
    other: 5
  };

function XHe() {
  const e = {};
  return KHe.forEach(t => {
    t.lngs.forEach(n => {
      e[n] = {
        numbers: t.nr,
        plurals: QHe[t.fc]
      }
    })
  }), e
}
class ZHe {
  constructor(t) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.languageUtils = t, this.options = n, this.logger = tl.create("pluralResolver"), (!this.options.compatibilityJSON || JHe.includes(this.options.compatibilityJSON)) && (typeof Intl > "u" || !Intl.PluralRules) && (this.options.compatibilityJSON = "v3", this.logger.error("Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.")), this.rules = XHe()
  }
  addRule(t, n) {
    this.rules[t] = n
  }
  getRule(t) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (this.shouldUseIntlApi()) try {
      return new Intl.PluralRules(Ex(t === "dev" ? "en" : t), {
        type: n.ordinal ? "ordinal" : "cardinal"
      })
    } catch {
      return
    }
    return this.rules[t] || this.rules[this.languageUtils.getLanguagePartFromCode(t)]
  }
  needsPlural(t) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const r = this.getRule(t, n);
    return this.shouldUseIntlApi() ? r && r.resolvedOptions().pluralCategories.length > 1 : r && r.numbers.length > 1
  }
  getPluralFormsOfKey(t, n) {
    let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return this.getSuffixes(t, r).map(i => `${n}${i}`)
  }
  getSuffixes(t) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const r = this.getRule(t, n);
    return r ? this.shouldUseIntlApi() ? r.resolvedOptions().pluralCategories.sort((i, s) => DB[i] - DB[s]).map(i => `${this.options.prepend}${n.ordinal?`ordinal${this.options.prepend}`:""}${i}`) : r.numbers.map(i => this.getSuffix(t, i, n)) : []
  }
  getSuffix(t, n) {
    let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const i = this.getRule(t, r);
    return i ? this.shouldUseIntlApi() ? `${this.options.prepend}${r.ordinal?`ordinal${this.options.prepend}`:""}${i.select(n)}` : this.getSuffixRetroCompatible(i, n) : (this.logger.warn(`no plural rule found for: ${t}`), "")
  }
  getSuffixRetroCompatible(t, n) {
    const r = t.noAbs ? t.plurals(n) : t.plurals(Math.abs(n));
    let i = t.numbers[r];
    this.options.simplifyPluralSuffix && t.numbers.length === 2 && t.numbers[0] === 1 && (i === 2 ? i = "plural" : i === 1 && (i = ""));
    const s = () => this.options.prepend && i.toString() ? this.options.prepend + i.toString() : i.toString();
    return this.options.compatibilityJSON === "v1" ? i === 1 ? "" : typeof i == "number" ? `_plural_${i.toString()}` : s() : this.options.compatibilityJSON === "v2" || this.options.simplifyPluralSuffix && t.numbers.length === 2 && t.numbers[0] === 1 ? s() : this.options.prepend && r.toString() ? this.options.prepend + r.toString() : r.toString()
  }
  shouldUseIntlApi() {
    return !YHe.includes(this.options.compatibilityJSON)
  }
}

function NB(e, t, n) {
  let r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : ".",
    i = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !0,
    s = UHe(e, t, n);
  return !s && i && typeof n == "string" && (s = d9(e, n, r), s === void 0 && (s = d9(t, n, r))), s
}
class eVe {
  constructor() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.logger = tl.create("interpolator"), this.options = t, this.format = t.interpolation && t.interpolation.format || (n => n), this.init(t)
  }
  init() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    t.interpolation || (t.interpolation = {
      escapeValue: !0
    });
    const n = t.interpolation;
    this.escape = n.escape !== void 0 ? n.escape : HHe, this.escapeValue = n.escapeValue !== void 0 ? n.escapeValue : !0, this.useRawValueToEscape = n.useRawValueToEscape !== void 0 ? n.useRawValueToEscape : !1, this.prefix = n.prefix ? b0(n.prefix) : n.prefixEscaped || "{{", this.suffix = n.suffix ? b0(n.suffix) : n.suffixEscaped || "}}", this.formatSeparator = n.formatSeparator ? n.formatSeparator : n.formatSeparator || ",", this.unescapePrefix = n.unescapeSuffix ? "" : n.unescapePrefix || "-", this.unescapeSuffix = this.unescapePrefix ? "" : n.unescapeSuffix || "", this.nestingPrefix = n.nestingPrefix ? b0(n.nestingPrefix) : n.nestingPrefixEscaped || b0("$t("), this.nestingSuffix = n.nestingSuffix ? b0(n.nestingSuffix) : n.nestingSuffixEscaped || b0(")"), this.nestingOptionsSeparator = n.nestingOptionsSeparator ? n.nestingOptionsSeparator : n.nestingOptionsSeparator || ",", this.maxReplaces = n.maxReplaces ? n.maxReplaces : 1e3, this.alwaysFormat = n.alwaysFormat !== void 0 ? n.alwaysFormat : !1, this.resetRegExp()
  }
  reset() {
    this.options && this.init(this.options)
  }
  resetRegExp() {
    const t = (n, r) => n && n.source === r ? (n.lastIndex = 0, n) : new RegExp(r, "g");
    this.regexp = t(this.regexp, `${this.prefix}(.+?)${this.suffix}`), this.regexpUnescape = t(this.regexpUnescape, `${this.prefix}${this.unescapePrefix}(.+?)${this.unescapeSuffix}${this.suffix}`), this.nestingRegexp = t(this.nestingRegexp, `${this.nestingPrefix}(.+?)${this.nestingSuffix}`)
  }
  interpolate(t, n, r, i) {
    let s, o, a;
    const c = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};

    function l(y) {
      return y.replace(/\$/g, "$$$$")
    }
    const u = y => {
      if (y.indexOf(this.formatSeparator) < 0) {
        const p = NB(n, c, y, this.options.keySeparator, this.options.ignoreJSONStructure);
        return this.alwaysFormat ? this.format(p, void 0, r, {
          ...i,
          ...n,
          interpolationkey: y
        }) : p
      }
      const x = y.split(this.formatSeparator),
        k = x.shift().trim(),
        _ = x.join(this.formatSeparator).trim();
      return this.format(NB(n, c, k, this.options.keySeparator, this.options.ignoreJSONStructure), _, r, {
        ...i,
        ...n,
        interpolationkey: k
      })
    };
    this.resetRegExp();
    const f = i && i.missingInterpolationHandler || this.options.missingInterpolationHandler,
      h = i && i.interpolation && i.interpolation.skipOnVariables !== void 0 ? i.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;
    return [{
      regex: this.regexpUnescape,
      safeValue: y => l(y)
    }, {
      regex: this.regexp,
      safeValue: y => this.escapeValue ? l(this.escape(y)) : l(y)
    }].forEach(y => {
      for (a = 0; s = y.regex.exec(t);) {
        const x = s[1].trim();
        if (o = u(x), o === void 0)
          if (typeof f == "function") {
            const _ = f(t, s, i);
            o = typeof _ == "string" ? _ : ""
          } else if (i && Object.prototype.hasOwnProperty.call(i, x)) o = "";
        else if (h) {
          o = s[0];
          continue
        } else this.logger.warn(`missed to pass in variable ${x} for interpolating ${t}`), o = "";
        else typeof o != "string" && !this.useRawValueToEscape && (o = _B(o));
        const k = y.safeValue(o);
        if (t = t.replace(s[0], k), h ? (y.regex.lastIndex += o.length, y.regex.lastIndex -= s[0].length) : y.regex.lastIndex = 0, a++, a >= this.maxReplaces) break
      }
    }), t
  }
  nest(t, n) {
    let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},
      i, s, o;

    function a(c, l) {
      const u = this.nestingOptionsSeparator;
      if (c.indexOf(u) < 0) return c;
      const f = c.split(new RegExp(`${u}[ ]*{`));
      let h = `{${f[1]}`;
      c = f[0], h = this.interpolate(h, o);
      const g = h.match(/'/g),
        y = h.match(/"/g);
      (g && g.length % 2 === 0 && !y || y.length % 2 !== 0) && (h = h.replace(/'/g, '"'));
      try {
        o = JSON.parse(h), l && (o = {
          ...l,
          ...o
        })
      } catch (x) {
        return this.logger.warn(`failed parsing options string in nesting for key ${c}`, x), `${c}${u}${h}`
      }
      return delete o.defaultValue, c
    }
    for (; i = this.nestingRegexp.exec(t);) {
      let c = [];
      o = {
        ...r
      }, o = o.replace && typeof o.replace != "string" ? o.replace : o, o.applyPostProcessor = !1, delete o.defaultValue;
      let l = !1;
      if (i[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(i[1])) {
        const u = i[1].split(this.formatSeparator).map(f => f.trim());
        i[1] = u.shift(), c = u, l = !0
      }
      if (s = n(a.call(this, i[1].trim(), o), o), s && i[0] === t && typeof s != "string") return s;
      typeof s != "string" && (s = _B(s)), s || (this.logger.warn(`missed to resolve ${i[1]} for nesting ${t}`), s = ""), l && (s = c.reduce((u, f) => this.format(u, f, r.lng, {
        ...r,
        interpolationkey: i[1].trim()
      }), s.trim())), t = t.replace(i[0], s), this.regexp.lastIndex = 0
    }
    return t
  }
}

function tVe(e) {
  let t = e.toLowerCase().trim();
  const n = {};
  if (e.indexOf("(") > -1) {
    const r = e.split("(");
    t = r[0].toLowerCase().trim();
    const i = r[1].substring(0, r[1].length - 1);
    t === "currency" && i.indexOf(":") < 0 ? n.currency || (n.currency = i.trim()) : t === "relativetime" && i.indexOf(":") < 0 ? n.range || (n.range = i.trim()) : i.split(";").forEach(o => {
      if (!o) return;
      const [a, ...c] = o.split(":"), l = c.join(":").trim().replace(/^'+|'+$/g, "");
      n[a.trim()] || (n[a.trim()] = l), l === "false" && (n[a.trim()] = !1), l === "true" && (n[a.trim()] = !0), isNaN(l) || (n[a.trim()] = parseInt(l, 10))
    })
  }
  return {
    formatName: t,
    formatOptions: n
  }
}

function w0(e) {
  const t = {};
  return function (r, i, s) {
    const o = i + JSON.stringify(s);
    let a = t[o];
    return a || (a = e(Ex(i), s), t[o] = a), a(r)
  }
}
class nVe {
  constructor() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.logger = tl.create("formatter"), this.options = t, this.formats = {
      number: w0((n, r) => {
        const i = new Intl.NumberFormat(n, {
          ...r
        });
        return s => i.format(s)
      }),
      currency: w0((n, r) => {
        const i = new Intl.NumberFormat(n, {
          ...r,
          style: "currency"
        });
        return s => i.format(s)
      }),
      datetime: w0((n, r) => {
        const i = new Intl.DateTimeFormat(n, {
          ...r
        });
        return s => i.format(s)
      }),
      relativetime: w0((n, r) => {
        const i = new Intl.RelativeTimeFormat(n, {
          ...r
        });
        return s => i.format(s, r.range || "day")
      }),
      list: w0((n, r) => {
        const i = new Intl.ListFormat(n, {
          ...r
        });
        return s => i.format(s)
      })
    }, this.init(t)
  }
  init(t) {
    const r = (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      interpolation: {}
    }).interpolation;
    this.formatSeparator = r.formatSeparator ? r.formatSeparator : r.formatSeparator || ","
  }
  add(t, n) {
    this.formats[t.toLowerCase().trim()] = n
  }
  addCached(t, n) {
    this.formats[t.toLowerCase().trim()] = w0(n)
  }
  format(t, n, r) {
    let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    return n.split(this.formatSeparator).reduce((a, c) => {
      const {
        formatName: l,
        formatOptions: u
      } = tVe(c);
      if (this.formats[l]) {
        let f = a;
        try {
          const h = i && i.formatParams && i.formatParams[i.interpolationkey] || {},
            g = h.locale || h.lng || i.locale || i.lng || r;
          f = this.formats[l](a, g, {
            ...u,
            ...i,
            ...h
          })
        } catch (h) {
          this.logger.warn(h)
        }
        return f
      } else this.logger.warn(`there was no format function for ${l}`);
      return a
    }, t)
  }
}

function rVe(e, t) {
  e.pending[t] !== void 0 && (delete e.pending[t], e.pendingCount--)
}
class iVe extends pE {
  constructor(t, n, r) {
    let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    super(), this.backend = t, this.store = n, this.services = r, this.languageUtils = r.languageUtils, this.options = i, this.logger = tl.create("backendConnector"), this.waitingReads = [], this.maxParallelReads = i.maxParallelReads || 10, this.readingCalls = 0, this.maxRetries = i.maxRetries >= 0 ? i.maxRetries : 5, this.retryTimeout = i.retryTimeout >= 1 ? i.retryTimeout : 350, this.state = {}, this.queue = [], this.backend && this.backend.init && this.backend.init(r, i.backend, i)
  }
  queueLoad(t, n, r, i) {
    const s = {},
      o = {},
      a = {},
      c = {};
    return t.forEach(l => {
      let u = !0;
      n.forEach(f => {
        const h = `${l}|${f}`;
        !r.reload && this.store.hasResourceBundle(l, f) ? this.state[h] = 2 : this.state[h] < 0 || (this.state[h] === 1 ? o[h] === void 0 && (o[h] = !0) : (this.state[h] = 1, u = !1, o[h] === void 0 && (o[h] = !0), s[h] === void 0 && (s[h] = !0), c[f] === void 0 && (c[f] = !0)))
      }), u || (a[l] = !0)
    }), (Object.keys(s).length || Object.keys(o).length) && this.queue.push({
      pending: o,
      pendingCount: Object.keys(o).length,
      loaded: {},
      errors: [],
      callback: i
    }), {
      toLoad: Object.keys(s),
      pending: Object.keys(o),
      toLoadLanguages: Object.keys(a),
      toLoadNamespaces: Object.keys(c)
    }
  }
  loaded(t, n, r) {
    const i = t.split("|"),
      s = i[0],
      o = i[1];
    n && this.emit("failedLoading", s, o, n), r && this.store.addResourceBundle(s, o, r, void 0, void 0, {
      skipCopy: !0
    }), this.state[t] = n ? -1 : 2;
    const a = {};
    this.queue.forEach(c => {
      jHe(c.loaded, [s], o), rVe(c, t), n && c.errors.push(n), c.pendingCount === 0 && !c.done && (Object.keys(c.loaded).forEach(l => {
        a[l] || (a[l] = {});
        const u = c.loaded[l];
        u.length && u.forEach(f => {
          a[l][f] === void 0 && (a[l][f] = !0)
        })
      }), c.done = !0, c.errors.length ? c.callback(c.errors) : c.callback())
    }), this.emit("loaded", a), this.queue = this.queue.filter(c => !c.done)
  }
  read(t, n, r) {
    let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0,
      s = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : this.retryTimeout,
      o = arguments.length > 5 ? arguments[5] : void 0;
    if (!t.length) return o(null, {});
    if (this.readingCalls >= this.maxParallelReads) {
      this.waitingReads.push({
        lng: t,
        ns: n,
        fcName: r,
        tried: i,
        wait: s,
        callback: o
      });
      return
    }
    this.readingCalls++;
    const a = (l, u) => {
        if (this.readingCalls--, this.waitingReads.length > 0) {
          const f = this.waitingReads.shift();
          this.read(f.lng, f.ns, f.fcName, f.tried, f.wait, f.callback)
        }
        if (l && u && i < this.maxRetries) {
          setTimeout(() => {
            this.read.call(this, t, n, r, i + 1, s * 2, o)
          }, s);
          return
        }
        o(l, u)
      },
      c = this.backend[r].bind(this.backend);
    if (c.length === 2) {
      try {
        const l = c(t, n);
        l && typeof l.then == "function" ? l.then(u => a(null, u)).catch(a) : a(null, l)
      } catch (l) {
        a(l)
      }
      return
    }
    return c(t, n, a)
  }
  prepareLoading(t, n) {
    let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},
      i = arguments.length > 3 ? arguments[3] : void 0;
    if (!this.backend) return this.logger.warn("No backend was added via i18next.use. Will not load resources."), i && i();
    typeof t == "string" && (t = this.languageUtils.toResolveHierarchy(t)), typeof n == "string" && (n = [n]);
    const s = this.queueLoad(t, n, r, i);
    if (!s.toLoad.length) return s.pending.length || i(), null;
    s.toLoad.forEach(o => {
      this.loadOne(o)
    })
  }
  load(t, n, r) {
    this.prepareLoading(t, n, {}, r)
  }
  reload(t, n, r) {
    this.prepareLoading(t, n, {
      reload: !0
    }, r)
  }
  loadOne(t) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    const r = t.split("|"),
      i = r[0],
      s = r[1];
    this.read(i, s, "read", void 0, void 0, (o, a) => {
      o && this.logger.warn(`${n}loading namespace ${s} for language ${i} failed`, o), !o && a && this.logger.log(`${n}loaded namespace ${s} for language ${i}`, a), this.loaded(t, o, a)
    })
  }
  saveMissing(t, n, r, i, s) {
    let o = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {},
      a = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : () => {};
    if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(n)) {
      this.logger.warn(`did not save key "${r}" as the namespace "${n}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
      return
    }
    if (!(r == null || r === "")) {
      if (this.backend && this.backend.create) {
        const c = {
            ...o,
            isUpdate: s
          },
          l = this.backend.create.bind(this.backend);
        if (l.length < 6) try {
          let u;
          l.length === 5 ? u = l(t, n, r, i, c) : u = l(t, n, r, i), u && typeof u.then == "function" ? u.then(f => a(null, f)).catch(a) : a(null, u)
        } catch (u) {
          a(u)
        } else l(t, n, r, i, a, c)
      }!t || !t[0] || this.store.addResource(t[0], n, r, i)
    }
  }
}

function MB() {
  return {
    debug: !1,
    initImmediate: !0,
    ns: ["translation"],
    defaultNS: ["translation"],
    fallbackLng: ["dev"],
    fallbackNS: !1,
    supportedLngs: !1,
    nonExplicitSupportedLngs: !1,
    load: "all",
    preload: !1,
    simplifyPluralSuffix: !0,
    keySeparator: ".",
    nsSeparator: ":",
    pluralSeparator: "_",
    contextSeparator: "_",
    partialBundledLanguages: !1,
    saveMissing: !1,
    updateMissing: !1,
    saveMissingTo: "fallback",
    saveMissingPlurals: !0,
    missingKeyHandler: !1,
    missingInterpolationHandler: !1,
    postProcess: !1,
    postProcessPassResolved: !1,
    returnNull: !1,
    returnEmptyString: !0,
    returnObjects: !1,
    joinArrays: !1,
    returnedObjectHandler: !1,
    parseMissingKeyHandler: !1,
    appendNamespaceToMissingKey: !1,
    appendNamespaceToCIMode: !1,
    overloadTranslationOptionHandler: function (t) {
      let n = {};
      if (typeof t[1] == "object" && (n = t[1]), typeof t[1] == "string" && (n.defaultValue = t[1]), typeof t[2] == "string" && (n.tDescription = t[2]), typeof t[2] == "object" || typeof t[3] == "object") {
        const r = t[3] || t[2];
        Object.keys(r).forEach(i => {
          n[i] = r[i]
        })
      }
      return n
    },
    interpolation: {
      escapeValue: !0,
      format: e => e,
      prefix: "{{",
      suffix: "}}",
      formatSeparator: ",",
      unescapePrefix: "-",
      nestingPrefix: "$t(",
      nestingSuffix: ")",
      nestingOptionsSeparator: ",",
      maxReplaces: 1e3,
      skipOnVariables: !0
    }
  }
}

function $B(e) {
  return typeof e.ns == "string" && (e.ns = [e.ns]), typeof e.fallbackLng == "string" && (e.fallbackLng = [e.fallbackLng]), typeof e.fallbackNS == "string" && (e.fallbackNS = [e.fallbackNS]), e.supportedLngs && e.supportedLngs.indexOf("cimode") < 0 && (e.supportedLngs = e.supportedLngs.concat(["cimode"])), e
}

function Hb() {}

function sVe(e) {
  Object.getOwnPropertyNames(Object.getPrototypeOf(e)).forEach(n => {
    typeof e[n] == "function" && (e[n] = e[n].bind(e))
  })
}
class C2 extends pE {
  constructor() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
      n = arguments.length > 1 ? arguments[1] : void 0;
    if (super(), this.options = $B(t), this.services = {}, this.logger = tl, this.modules = {
        external: []
      }, sVe(this), n && !this.isInitialized && !t.isClone) {
      if (!this.options.initImmediate) return this.init(t, n), this;
      setTimeout(() => {
        this.init(t, n)
      }, 0)
    }
  }
  init() {
    var t = this;
    let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
      r = arguments.length > 1 ? arguments[1] : void 0;
    this.isInitializing = !0, typeof n == "function" && (r = n, n = {}), !n.defaultNS && n.defaultNS !== !1 && n.ns && (typeof n.ns == "string" ? n.defaultNS = n.ns : n.ns.indexOf("translation") < 0 && (n.defaultNS = n.ns[0]));
    const i = MB();
    this.options = {
      ...i,
      ...this.options,
      ...$B(n)
    }, this.options.compatibilityAPI !== "v1" && (this.options.interpolation = {
      ...i.interpolation,
      ...this.options.interpolation
    }), n.keySeparator !== void 0 && (this.options.userDefinedKeySeparator = n.keySeparator), n.nsSeparator !== void 0 && (this.options.userDefinedNsSeparator = n.nsSeparator);

    function s(u) {
      return u ? typeof u == "function" ? new u : u : null
    }
    if (!this.options.isClone) {
      this.modules.logger ? tl.init(s(this.modules.logger), this.options) : tl.init(null, this.options);
      let u;
      this.modules.formatter ? u = this.modules.formatter : typeof Intl < "u" && (u = nVe);
      const f = new OB(this.options);
      this.store = new PB(this.options.resources, this.options);
      const h = this.services;
      h.logger = tl, h.resourceStore = this.store, h.languageUtils = f, h.pluralResolver = new ZHe(f, {
        prepend: this.options.pluralSeparator,
        compatibilityJSON: this.options.compatibilityJSON,
        simplifyPluralSuffix: this.options.simplifyPluralSuffix
      }), u && (!this.options.interpolation.format || this.options.interpolation.format === i.interpolation.format) && (h.formatter = s(u), h.formatter.init(h, this.options), this.options.interpolation.format = h.formatter.format.bind(h.formatter)), h.interpolator = new eVe(this.options), h.utils = {
        hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
      }, h.backendConnector = new iVe(s(this.modules.backend), h.resourceStore, h, this.options), h.backendConnector.on("*", function (g) {
        for (var y = arguments.length, x = new Array(y > 1 ? y - 1 : 0), k = 1; k < y; k++) x[k - 1] = arguments[k];
        t.emit(g, ...x)
      }), this.modules.languageDetector && (h.languageDetector = s(this.modules.languageDetector), h.languageDetector.init && h.languageDetector.init(h, this.options.detection, this.options)), this.modules.i18nFormat && (h.i18nFormat = s(this.modules.i18nFormat), h.i18nFormat.init && h.i18nFormat.init(this)), this.translator = new Sx(this.services, this.options), this.translator.on("*", function (g) {
        for (var y = arguments.length, x = new Array(y > 1 ? y - 1 : 0), k = 1; k < y; k++) x[k - 1] = arguments[k];
        t.emit(g, ...x)
      }), this.modules.external.forEach(g => {
        g.init && g.init(this)
      })
    }
    if (this.format = this.options.interpolation.format, r || (r = Hb), this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
      const u = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
      u.length > 0 && u[0] !== "dev" && (this.options.lng = u[0])
    }!this.services.languageDetector && !this.options.lng && this.logger.warn("init: no languageDetector is used and no lng is defined"), ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"].forEach(u => {
      this[u] = function () {
        return t.store[u](...arguments)
      }
    }), ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"].forEach(u => {
      this[u] = function () {
        return t.store[u](...arguments), t
      }
    });
    const c = Qg(),
      l = () => {
        const u = (f, h) => {
          this.isInitializing = !1, this.isInitialized && !this.initializedStoreOnce && this.logger.warn("init: i18next is already initialized. You should call init just once!"), this.isInitialized = !0, this.options.isClone || this.logger.log("initialized", this.options), this.emit("initialized", this.options), c.resolve(h), r(f, h)
        };
        if (this.languages && this.options.compatibilityAPI !== "v1" && !this.isInitialized) return u(null, this.t.bind(this));
        this.changeLanguage(this.options.lng, u)
      };
    return this.options.resources || !this.options.initImmediate ? l() : setTimeout(l, 0), c
  }
  loadResources(t) {
    let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Hb;
    const i = typeof t == "string" ? t : this.language;
    if (typeof t == "function" && (r = t), !this.options.resources || this.options.partialBundledLanguages) {
      if (i && i.toLowerCase() === "cimode" && (!this.options.preload || this.options.preload.length === 0)) return r();
      const s = [],
        o = a => {
          if (!a || a === "cimode") return;
          this.services.languageUtils.toResolveHierarchy(a).forEach(l => {
            l !== "cimode" && s.indexOf(l) < 0 && s.push(l)
          })
        };
      i ? o(i) : this.services.languageUtils.getFallbackCodes(this.options.fallbackLng).forEach(c => o(c)), this.options.preload && this.options.preload.forEach(a => o(a)), this.services.backendConnector.load(s, this.options.ns, a => {
        !a && !this.resolvedLanguage && this.language && this.setResolvedLanguage(this.language), r(a)
      })
    } else r(null)
  }
  reloadResources(t, n, r) {
    const i = Qg();
    return t || (t = this.languages), n || (n = this.options.ns), r || (r = Hb), this.services.backendConnector.reload(t, n, s => {
      i.resolve(), r(s)
    }), i
  }
  use(t) {
    if (!t) throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
    if (!t.type) throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
    return t.type === "backend" && (this.modules.backend = t), (t.type === "logger" || t.log && t.warn && t.error) && (this.modules.logger = t), t.type === "languageDetector" && (this.modules.languageDetector = t), t.type === "i18nFormat" && (this.modules.i18nFormat = t), t.type === "postProcessor" && EJ.addPostProcessor(t), t.type === "formatter" && (this.modules.formatter = t), t.type === "3rdParty" && this.modules.external.push(t), this
  }
  setResolvedLanguage(t) {
    if (!(!t || !this.languages) && !(["cimode", "dev"].indexOf(t) > -1))
      for (let n = 0; n < this.languages.length; n++) {
        const r = this.languages[n];
        if (!(["cimode", "dev"].indexOf(r) > -1) && this.store.hasLanguageSomeTranslations(r)) {
          this.resolvedLanguage = r;
          break
        }
      }
  }
  changeLanguage(t, n) {
    var r = this;
    this.isLanguageChangingTo = t;
    const i = Qg();
    this.emit("languageChanging", t);
    const s = c => {
        this.language = c, this.languages = this.services.languageUtils.toResolveHierarchy(c), this.resolvedLanguage = void 0, this.setResolvedLanguage(c)
      },
      o = (c, l) => {
        l ? (s(l), this.translator.changeLanguage(l), this.isLanguageChangingTo = void 0, this.emit("languageChanged", l), this.logger.log("languageChanged", l)) : this.isLanguageChangingTo = void 0, i.resolve(function () {
          return r.t(...arguments)
        }), n && n(c, function () {
          return r.t(...arguments)
        })
      },
      a = c => {
        !t && !c && this.services.languageDetector && (c = []);
        const l = typeof c == "string" ? c : this.services.languageUtils.getBestMatchFromCodes(c);
        l && (this.language || s(l), this.translator.language || this.translator.changeLanguage(l), this.services.languageDetector && this.services.languageDetector.cacheUserLanguage && this.services.languageDetector.cacheUserLanguage(l)), this.loadResources(l, u => {
          o(u, l)
        })
      };
    return !t && this.services.languageDetector && !this.services.languageDetector.async ? a(this.services.languageDetector.detect()) : !t && this.services.languageDetector && this.services.languageDetector.async ? this.services.languageDetector.detect.length === 0 ? this.services.languageDetector.detect().then(a) : this.services.languageDetector.detect(a) : a(t), i
  }
  getFixedT(t, n, r) {
    var i = this;
    const s = function (o, a) {
      let c;
      if (typeof a != "object") {
        for (var l = arguments.length, u = new Array(l > 2 ? l - 2 : 0), f = 2; f < l; f++) u[f - 2] = arguments[f];
        c = i.options.overloadTranslationOptionHandler([o, a].concat(u))
      } else c = {
        ...a
      };
      c.lng = c.lng || s.lng, c.lngs = c.lngs || s.lngs, c.ns = c.ns || s.ns, c.keyPrefix = c.keyPrefix || r || s.keyPrefix;
      const h = i.options.keySeparator || ".";
      let g;
      return c.keyPrefix && Array.isArray(o) ? g = o.map(y => `${c.keyPrefix}${h}${y}`) : g = c.keyPrefix ? `${c.keyPrefix}${h}${o}` : o, i.t(g, c)
    };
    return typeof t == "string" ? s.lng = t : s.lngs = t, s.ns = n, s.keyPrefix = r, s
  }
  t() {
    return this.translator && this.translator.translate(...arguments)
  }
  exists() {
    return this.translator && this.translator.exists(...arguments)
  }
  setDefaultNamespace(t) {
    this.options.defaultNS = t
  }
  hasLoadedNamespace(t) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (!this.isInitialized) return this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages), !1;
    if (!this.languages || !this.languages.length) return this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages), !1;
    const r = n.lng || this.resolvedLanguage || this.languages[0],
      i = this.options ? this.options.fallbackLng : !1,
      s = this.languages[this.languages.length - 1];
    if (r.toLowerCase() === "cimode") return !0;
    const o = (a, c) => {
      const l = this.services.backendConnector.state[`${a}|${c}`];
      return l === -1 || l === 2
    };
    if (n.precheck) {
      const a = n.precheck(this, o);
      if (a !== void 0) return a
    }
    return !!(this.hasResourceBundle(r, t) || !this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages || o(r, t) && (!i || o(s, t)))
  }
  loadNamespaces(t, n) {
    const r = Qg();
    return this.options.ns ? (typeof t == "string" && (t = [t]), t.forEach(i => {
      this.options.ns.indexOf(i) < 0 && this.options.ns.push(i)
    }), this.loadResources(i => {
      r.resolve(), n && n(i)
    }), r) : (n && n(), Promise.resolve())
  }
  loadLanguages(t, n) {
    const r = Qg();
    typeof t == "string" && (t = [t]);
    const i = this.options.preload || [],
      s = t.filter(o => i.indexOf(o) < 0);
    return s.length ? (this.options.preload = i.concat(s), this.loadResources(o => {
      r.resolve(), n && n(o)
    }), r) : (n && n(), Promise.resolve())
  }
  dir(t) {
    if (t || (t = this.resolvedLanguage || (this.languages && this.languages.length > 0 ? this.languages[0] : this.language)), !t) return "rtl";
    const n = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam", "ckb"],
      r = this.services && this.services.languageUtils || new OB(MB());
    return n.indexOf(r.getLanguagePartFromCode(t)) > -1 || t.toLowerCase().indexOf("-arab") > 1 ? "rtl" : "ltr"
  }
  static createInstance() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
      n = arguments.length > 1 ? arguments[1] : void 0;
    return new C2(t, n)
  }
  cloneInstance() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
      n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Hb;
    const r = t.forkResourceStore;
    r && delete t.forkResourceStore;
    const i = {
        ...this.options,
        ...t,
        isClone: !0
      },
      s = new C2(i);
    return (t.debug !== void 0 || t.prefix !== void 0) && (s.logger = s.logger.clone(t)), ["store", "services", "language"].forEach(a => {
      s[a] = this[a]
    }), s.services = {
      ...this.services
    }, s.services.utils = {
      hasLoadedNamespace: s.hasLoadedNamespace.bind(s)
    }, r && (s.store = new PB(this.store.data, i), s.services.resourceStore = s.store), s.translator = new Sx(s.services, i), s.translator.on("*", function (a) {
      for (var c = arguments.length, l = new Array(c > 1 ? c - 1 : 0), u = 1; u < c; u++) l[u - 1] = arguments[u];
      s.emit(a, ...l)
    }), s.init(i, n), s.translator.options = i, s.translator.backendConnector.services.utils = {
      hasLoadedNamespace: s.hasLoadedNamespace.bind(s)
    }, s
  }
  toJSON() {
    return {
      options: this.options,
      store: this.store,
      language: this.language,
      languages: this.languages,
      resolvedLanguage: this.resolvedLanguage
    }
  }
}
const hs = C2.createInstance();
hs.createInstance = C2.createInstance;
hs.createInstance;
hs.dir;
hs.init;
hs.loadResources;
hs.reloadResources;
hs.use;
hs.changeLanguage;
hs.getFixedT;
hs.t;
hs.exists;
hs.setDefaultNamespace;
hs.hasLoadedNamespace;
hs.loadNamespaces;
hs.loadLanguages;

function oVe(e, t) {
  if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
}

function LB(e, t) {
  for (var n = 0; n < t.length; n++) {
    var r = t[n];
    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, sfe(r.key), r)
  }
}

function aVe(e, t, n) {
  return t && LB(e.prototype, t), n && LB(e, n), Object.defineProperty(e, "prototype", {
    writable: !1
  }), e
}
var SJ = [],
  cVe = SJ.forEach,
  lVe = SJ.slice;

function uVe(e) {
  return cVe.call(lVe.call(arguments, 1), function (t) {
    if (t)
      for (var n in t) e[n] === void 0 && (e[n] = t[n])
  }), e
}
var BB = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/,
  dVe = function (t, n, r) {
    var i = r || {};
    i.path = i.path || "/";
    var s = encodeURIComponent(n),
      o = "".concat(t, "=").concat(s);
    if (i.maxAge > 0) {
      var a = i.maxAge - 0;
      if (Number.isNaN(a)) throw new Error("maxAge should be a Number");
      o += "; Max-Age=".concat(Math.floor(a))
    }
    if (i.domain) {
      if (!BB.test(i.domain)) throw new TypeError("option domain is invalid");
      o += "; Domain=".concat(i.domain)
    }
    if (i.path) {
      if (!BB.test(i.path)) throw new TypeError("option path is invalid");
      o += "; Path=".concat(i.path)
    }
    if (i.expires) {
      if (typeof i.expires.toUTCString != "function") throw new TypeError("option expires is invalid");
      o += "; Expires=".concat(i.expires.toUTCString())
    }
    if (i.httpOnly && (o += "; HttpOnly"), i.secure && (o += "; Secure"), i.sameSite) {
      var c = typeof i.sameSite == "string" ? i.sameSite.toLowerCase() : i.sameSite;
      switch (c) {
        case !0:
          o += "; SameSite=Strict";
          break;
        case "lax":
          o += "; SameSite=Lax";
          break;
        case "strict":
          o += "; SameSite=Strict";
          break;
        case "none":
          o += "; SameSite=None";
          break;
        default:
          throw new TypeError("option sameSite is invalid")
      }
    }
    return o
  },
  FB = {
    create: function (t, n, r, i) {
      var s = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
        path: "/",
        sameSite: "strict"
      };
      r && (s.expires = new Date, s.expires.setTime(s.expires.getTime() + r * 60 * 1e3)), i && (s.domain = i), document.cookie = dVe(t, encodeURIComponent(n), s)
    },
    read: function (t) {
      for (var n = "".concat(t, "="), r = document.cookie.split(";"), i = 0; i < r.length; i++) {
        for (var s = r[i]; s.charAt(0) === " ";) s = s.substring(1, s.length);
        if (s.indexOf(n) === 0) return s.substring(n.length, s.length)
      }
      return null
    },
    remove: function (t) {
      this.create(t, "", -1)
    }
  },
  fVe = {
    name: "cookie",
    lookup: function (t) {
      var n;
      if (t.lookupCookie && typeof document < "u") {
        var r = FB.read(t.lookupCookie);
        r && (n = r)
      }
      return n
    },
    cacheUserLanguage: function (t, n) {
      n.lookupCookie && typeof document < "u" && FB.create(n.lookupCookie, t, n.cookieMinutes, n.cookieDomain, n.cookieOptions)
    }
  },
  hVe = {
    name: "querystring",
    lookup: function (t) {
      var n;
      if (typeof window < "u") {
        var r = window.location.search;
        !window.location.search && window.location.hash && window.location.hash.indexOf("?") > -1 && (r = window.location.hash.substring(window.location.hash.indexOf("?")));
        for (var i = r.substring(1), s = i.split("&"), o = 0; o < s.length; o++) {
          var a = s[o].indexOf("=");
          if (a > 0) {
            var c = s[o].substring(0, a);
            c === t.lookupQuerystring && (n = s[o].substring(a + 1))
          }
        }
      }
      return n
    }
  },
  Yg = null,
  jB = function () {
    if (Yg !== null) return Yg;
    try {
      Yg = window !== "undefined" && window.localStorage !== null;
      var t = "i18next.translate.boo";
      window.localStorage.setItem(t, "foo"), window.localStorage.removeItem(t)
    } catch {
      Yg = !1
    }
    return Yg
  },
  pVe = {
    name: "localStorage",
    lookup: function (t) {
      var n;
      if (t.lookupLocalStorage && jB()) {
        var r = window.localStorage.getItem(t.lookupLocalStorage);
        r && (n = r)
      }
      return n
    },
    cacheUserLanguage: function (t, n) {
      n.lookupLocalStorage && jB() && window.localStorage.setItem(n.lookupLocalStorage, t)
    }
  },
  Jg = null,
  UB = function () {
    if (Jg !== null) return Jg;
    try {
      Jg = window !== "undefined" && window.sessionStorage !== null;
      var t = "i18next.translate.boo";
      window.sessionStorage.setItem(t, "foo"), window.sessionStorage.removeItem(t)
    } catch {
      Jg = !1
    }
    return Jg
  },
  mVe = {
    name: "sessionStorage",
    lookup: function (t) {
      var n;
      if (t.lookupSessionStorage && UB()) {
        var r = window.sessionStorage.getItem(t.lookupSessionStorage);
        r && (n = r)
      }
      return n
    },
    cacheUserLanguage: function (t, n) {
      n.lookupSessionStorage && UB() && window.sessionStorage.setItem(n.lookupSessionStorage, t)
    }
  },
  gVe = {
    name: "navigator",
    lookup: function (t) {
      var n = [];
      if (typeof navigator < "u") {
        if (navigator.languages)
          for (var r = 0; r < navigator.languages.length; r++) n.push(navigator.languages[r]);
        navigator.userLanguage && n.push(navigator.userLanguage), navigator.language && n.push(navigator.language)
      }
      return n.length > 0 ? n : void 0
    }
  },
  yVe = {
    name: "htmlTag",
    lookup: function (t) {
      var n, r = t.htmlTag || (typeof document < "u" ? document.documentElement : null);
      return r && typeof r.getAttribute == "function" && (n = r.getAttribute("lang")), n
    }
  },
  vVe = {
    name: "path",
    lookup: function (t) {
      var n;
      if (typeof window < "u") {
        var r = window.location.pathname.match(/\/([a-zA-Z-]*)/g);
        if (r instanceof Array)
          if (typeof t.lookupFromPathIndex == "number") {
            if (typeof r[t.lookupFromPathIndex] != "string") return;
            n = r[t.lookupFromPathIndex].replace("/", "")
          } else n = r[0].replace("/", "")
      }
      return n
    }
  },
  bVe = {
    name: "subdomain",
    lookup: function (t) {
      var n = typeof t.lookupFromSubdomainIndex == "number" ? t.lookupFromSubdomainIndex + 1 : 1,
        r = typeof window < "u" && window.location && window.location.hostname && window.location.hostname.match(/^(\w{2,5})\.(([a-z0-9-]{1,63}\.[a-z]{2,6})|localhost)/i);
      if (r) return r[n]
    }
  };

function wVe() {
  return {
    order: ["querystring", "cookie", "localStorage", "sessionStorage", "navigator", "htmlTag"],
    lookupQuerystring: "lng",
    lookupCookie: "i18next",
    lookupLocalStorage: "i18nextLng",
    lookupSessionStorage: "i18nextLng",
    caches: ["localStorage"],
    excludeCacheFor: ["cimode"],
    convertDetectedLanguage: function (t) {
      return t
    }
  }
}
var CJ = function () {
  function e(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    oVe(this, e), this.type = "languageDetector", this.detectors = {}, this.init(t, n)
  }
  return aVe(e, [{
    key: "init",
    value: function (n) {
      var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
        i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      this.services = n || {
        languageUtils: {}
      }, this.options = uVe(r, this.options || {}, wVe()), typeof this.options.convertDetectedLanguage == "string" && this.options.convertDetectedLanguage.indexOf("15897") > -1 && (this.options.convertDetectedLanguage = function (s) {
        return s.replace("-", "_")
      }), this.options.lookupFromUrlIndex && (this.options.lookupFromPathIndex = this.options.lookupFromUrlIndex), this.i18nOptions = i, this.addDetector(fVe), this.addDetector(hVe), this.addDetector(pVe), this.addDetector(mVe), this.addDetector(gVe), this.addDetector(yVe), this.addDetector(vVe), this.addDetector(bVe)
    }
  }, {
    key: "addDetector",
    value: function (n) {
      this.detectors[n.name] = n
    }
  }, {
    key: "detect",
    value: function (n) {
      var r = this;
      n || (n = this.options.order);
      var i = [];
      return n.forEach(function (s) {
        if (r.detectors[s]) {
          var o = r.detectors[s].lookup(r.options);
          o && typeof o == "string" && (o = [o]), o && (i = i.concat(o))
        }
      }), i = i.map(function (s) {
        return r.options.convertDetectedLanguage(s)
      }), this.services.languageUtils.getBestMatchFromCodes ? i : i.length > 0 ? i[0] : null
    }
  }, {
    key: "cacheUserLanguage",
    value: function (n, r) {
      var i = this;
      r || (r = this.options.caches), r && (this.options.excludeCacheFor && this.options.excludeCacheFor.indexOf(n) > -1 || r.forEach(function (s) {
        i.detectors[s] && i.detectors[s].cacheUserLanguage(n, i.options)
      }))
    }
  }]), e
}();
CJ.type = "languageDetector";
const xVe = {
    auto: "স্বয়ংক্রিয়",
    cancel: "বাতিল করুন",
    connectWallet: "ওয়ালেট সংযুক্ত করুন",
    contactSupport: "সাপোর্ট এ যোগাযোগ করুন",
    continue: "এগিয়ে যান",
    copyAddress: "ঠিকানা কপি করুন",
    dark: "অন্ধকার",
    delete: "মুছে ফেলুন",
    disconnect: "সংযোগ বিচ্ছিন্ন করুন",
    done: "সম্পন্ন হয়েছে",
    getGas: "গ্যাস পান",
    hide: "গোপন করুন",
    learnMore: "আরও জানুন",
    lifiSwap: "লি.ফাই সোওয়াপ",
    light: "লাইট",
    max: "সর্বোচ্চ",
    ok: "ঠিক আছে",
    okay: "ঠিক আছে",
    removeSwap: "সোওয়াপ সরান",
    reset: "পুনরায় সেট করুন",
    resetSettings: "সেটিংস রিসেট করুন",
    restartSwap: "সোওয়াপ পুনরায় চালু করুন",
    reviewGasSwap: "গ্যাস সোওয়াপ পর্যালোচনা করুন",
    reviewSwap: "সোওয়াপ পর্যালোচনা করুন",
    seeDetails: "বিস্তারিত দেখুন",
    showAll: "সবগুলো দেখুন",
    startGasSwap: "গ্যাস সোওয়াপ করুন",
    startSwap: "সোওয়াপ শুরু করুন",
    swap: "সোওয়াপ",
    tryAgain: "আবার চেষ্টা করুন",
    viewCoverage: "কভারেজ দেখুন",
    viewOnExplorer: "এক্সপ্লোরারে দেখুন"
  },
  EVe = {
    currency: "{{value, currency(currency: USD)}}",
    number: "{{value, number(maximumFractionDigits: 9)}}"
  },
  SVe = {
    activeSwaps: "সোওয়াপ সক্রিয়",
    checkout: "চেকআউট",
    from: "থেকে সোওয়াপ করুন",
    gas: "গ্যাস",
    gasSwap: "গ্যাস সোওয়াপ",
    routes: "আপনি পান",
    selectChain: "চেইন নির্বাচন করুন",
    selectWallet: "আপনার ওয়ালেট নির্বাচন করুন",
    settings: "সেটিংস",
    swap: "সোওয়াপ",
    swapDetails: "সোওয়াপ বিস্তারিত",
    swapHistory: "সোওয়াপ ইতিহাস",
    to: "সোওয়াপ করুন",
    walletConnected: "ওয়ালেট সংযুক্ত"
  },
  CVe = {
    name: "বাংলা",
    title: "ভাষা"
  },
  AVe = {
    enabledBridges: "ব্রিজ সক্রিয়",
    enabledExchanges: "এক্সচেঞ্জ সক্রিয়",
    gasPrice: {
      fast: "দ্রুত",
      normal: "স্বাভাবিক",
      slow: "ধীরে",
      title: "গ্যাসের দাম"
    },
    routePriority: "রুট অগ্রাধিকার",
    showDestinationWallet: "গন্তব্য ওয়ালেট দেখান",
    slippage: "স্লিপেজ"
  },
  TVe = {
    message: {
      autoRefuel: "আপনার {{chainName}} গ্যাস কম। চালিয়ে যাওয়ার মাধ্যমে, আপনি সোওয়াপ সম্পূর্ণ করার জন্য পর্যাপ্ত গ্যাস পাবেন।",
      emptyActiveSwaps: "প্রগতিতে সোওয়াপ এখানে প্রদর্শিত হবে। একবার সম্পূর্ণ হলে, সোওয়াপ ইতিহাসে তাদের খুঁজুন।",
      emptySwapHistory: "সোওয়াপ ইতিহাস শুধুমাত্র স্থানীয়ভাবে সংরক্ষণ করা হয় এবং আপনি যদি আপনার ব্রাউজার ডেটা সাফ করেন তাহলে মুছে ফেলা হবে।",
      emptyTokenList: "আমরা {{chainName}} চেইনে টোকেন খুঁজে পাইনি বা আপনার কাছে নেই। অনুগ্রহ করে আবার অনুসন্ধান করার চেষ্টা করুন বা অন্য একটি চেইন পছন্দ করুন।",
      routeNotFound: "অন্য টোকেন সমন্বয় চেষ্টা করুন।"
    },
    title: {
      autoRefuel: "গ্যাস পান",
      emptyActiveSwaps: "কোনো সক্রিয় সোওয়াপ নেই",
      emptySwapHistory: "কোনো সাম্প্রতিক সোওয়াপ নেই।",
      routeNotFound: "কোন রুট উপলব্ধ"
    }
  },
  kVe = {
    message: {
      swapPartiallySuccessful: "আমরা সোওয়াপ সম্পূর্ণ করার চেষ্টা করেছি, কিন্তু {{tokenSymbol}} টোকেনের জন্য {{tool}} -এর লিকুইডিটি ফুরিয়ে গেছে।",
      swapSuccessful: "এখন {{chainName}} চেইনে {{walletAddress}} ওয়ালেটে {{amount, number(maximumFractionDigits: 9)}} {{tokenSymbol}} আছে।"
    },
    title: {
      gasSwapSuccessful: "গ্যাস সোওয়াপ সফল",
      refundIssued: "রিফান্ড জারি করা হয়েছে",
      swapPartiallySuccessful: "সোওয়াপ আংশিকভাবে সফল",
      swapSuccessful: "সোওয়াপ সফল"
    }
  },
  _Ve = {
    message: {
      deleteActiveSwaps: "সক্রিয় সোওয়াপ শুধুমাত্র স্থানীয়ভাবে সংরক্ষণ করা হয় এবং যদি আপনি সেগুলি মুছে ফেলেন তবে পুনরুদ্ধার করা যাবে না।",
      deleteSwapHistory: "সোওয়াপ ইতিহাস শুধুমাত্র স্থানীয়ভাবে সংরক্ষণ করা হয় এবং আপনি এটি মুছে ফেললে পুনরুদ্ধার করা যাবে না।",
      highValueLoss: "প্রাপ্ত টোকেনগুলির মান সোওয়াপ করা টোকেন এবং লেনদেনের খরচের তুলনায় উল্লেখযোগ্যভাবে কম।",
      insufficientFunds: "সোওয়াপ সম্পূর্ণ করার জন্য আপনার কাছে পর্যাপ্ত তহবিল নেই।",
      insufficientGas: "সোওয়াপ সম্পূর্ণ করার জন্য আপনার কাছে পর্যাপ্ত গ্যাস নেই। আপনাকে অন্তত যোগ করতে হবে:",
      rateChanged: "বিনিময় হার পরিবর্তিত হয়েছে। সোওয়াপ চালিয়ে যাওয়ার মাধ্যমে, আপনি নতুন হার গ্রহণ করবেন।",
      resetSettings: "এটি আপনার রুটের অগ্রাধিকার, স্লিপেজ, গ্যাসের দাম, সক্ষম ব্রিজ এবং এক্সচেঞ্জ রিসেট করবে।"
    },
    title: {
      deleteActiveSwaps: "সমস্ত সক্রিয় সোওয়াপ মুছবেন?",
      deleteSwap: "এই সোওয়াপ মুছে ফেলবেন?",
      deleteSwapHistory: "সোওয়াপ ইতিহাস মুছবেন?",
      highValueLoss: "উচ্চ মূল্য ক্ষতি",
      insufficientGas: "অপর্যাপ্ত গ্যাস",
      rateChanged: "হার পরিবর্তিত হয়েছে",
      resetSettings: "রিসেট সেটিংস?"
    }
  },
  IVe = {
    message: {
      slippageThreshold: "স্লিপেজ সংজ্ঞায়িত থ্রেশহোল্ডের চেয়ে বড়। একটি নতুন উদ্ধৃতি পেতে একটি নতুন রুট অনুরোধ করুন।",
      transactionFailed: "আরও তথ্যের জন্য ব্লক এক্সপ্লোরার চেক করুন।",
      transactionNotSent: "লেনদেন পাঠানো হয়নি। আপনার ওয়ালেটে {{amount, number(maximumFractionDigits: 9)}} {{tokenSymbol}} {{chainName}} থেকে যায়।",
      transactionRejected: "লেনদেন সম্পূর্ণ করতে আপনার স্বাক্ষর প্রয়োজন। আপনার ওয়ালেটে {{amount, number(maximumFractionDigits: 9)}} {{tokenSymbol}} {{chainName}} থেকে যায়।",
      unknown: "অনুগ্রহ করে আবার চেষ্টা করুন বা সাপোর্ট এর সাথে যোগাযোগ করুন।"
    },
    title: {
      balanceIsTooLow: "ব্যালেন্স খুব কম",
      chainSwitch: "চেইন সুইচ প্রয়োজন",
      failed: "সোওয়াপ ব্যর্থ হয়েছে",
      gasLimitIsTooLow: "গ্যাসের সীমা খুব কম",
      slippageNotMet: "স্লিপেজ শর্ত পূরণ করা হয়নি",
      transactionCanceled: "লেনদেন বাতিল করা হয়েছে",
      transactionFailed: "লেনদেন ব্যর্থ হয়েছে",
      transactionRejected: "স্বাক্ষর প্রয়োজন",
      transactionUnderpriced: "লেনদেনের দাম কম",
      transactionUnprepared: "লেনদেন প্রস্তুত করতে অক্ষম",
      unknown: "কিছু ভুল হয়েছে",
      walletAddressInvalid: "ওয়ালেট ঠিকানা অবৈধ।",
      walletAddressRequired: "ওয়ালেট ঠিকানা প্রয়োজন।",
      walletEnsAddressInvalid: "ওয়ালেট ঠিকানা অবৈধ বা নেটওয়ার্ক ইএনএস সমর্থন করে না।"
    }
  },
  PVe = {
    crossStepDetails: "{{tool}} হয়ে {{from}} থেকে {{to}} পর্যন্ত ব্রিজ",
    currentAmount: "বর্তমান পরিমাণ",
    estimatedTime: "{{value}}মি",
    featuredTokens: "বৈশিষ্ট্যযুক্ত টোকেন",
    from: "থেকে",
    fromAmount: "আপনি টাকা পাঠান",
    gasCost: "গ্যাস খরচ",
    gasFeeEstimated: "আনুমানিক গ্যাস ফি",
    gasFeePaid: "গ্যাস ফি প্রদান করা হয়",
    inProgress: "প্রক্রিয়াধীন",
    nftStepDetails: "{{tool}} এর মাধ্যমে এনএফটি কিনুন",
    onChain: "{{chainName}} -এ",
    otherTokens: "অন্যান্য টোকেন",
    ownedBy: "মালিক",
    payWith: "পে দিতে",
    process: {
      crossChain: {
        actionRequired: "দয়াকরে লেনদেন স্বাক্ষর করুন",
        done: "ব্রিজ লেনদেন নিশ্চিত করা হয়েছে",
        pending: "ব্রিজ লেনদেনের জন্য অপেক্ষা করছে",
        started: "ব্রিজ লেনদেনের প্রস্তুতি"
      },
      receivingChain: {
        done: "ব্রিজ সম্পন্ন হয়েছে",
        partial: "ব্রিজ আংশিকভাবে সম্পন্ন হয়েছে",
        pending: "গন্তব্য চেইন এর জন্য অপেক্ষা",
        refunded: "ব্রিজ লেনদেন ফেরত করা হয়েছে"
      },
      swap: {
        actionRequired: "দয়াকরে লেনদেন স্বাক্ষর করুন",
        done: "সোওয়াপ সম্পন্ন হয়েছে",
        pending: "সোওয়াপ লেনদেনের জন্য অপেক্ষা করা হচ্ছে",
        started: "সোয়াপ লেনদেন প্রস্তুত করা হচ্ছে"
      },
      switchChain: {
        actionRequired: "চেইন সুইচ প্রয়োজন",
        done: "চেইন সফলভাবে সুইচ করা হয়েছে"
      },
      tokenAllowance: {
        done: "টোকেন অনুমতি অনুমোদিত",
        pending: "টোকেন অনুমতির অপেক্ষায়",
        started: "টোকেন অনুমতির অপেক্ষায়"
      }
    },
    quotedAmount: "উদ্ধৃত পরিমাণ",
    rateChange: "রেট পরিবর্তন",
    receiving: "রিসিভিং",
    refuelStepDetails: "{{tool}} এর মাধ্যমে গ্যাস পান",
    routes: "আপনি পান",
    selectChain: "চেইন",
    selectChainAndToken: "চেইন এবং টোকেন নির্বাচন করুন",
    selectToken: "টোকেন",
    sendToAddress: "{{address}} এ পাঠান",
    sendToWallet: "অন্য ওয়ালেটে পাঠান",
    sentToAddress: "{{address}} এ পাঠানো হয়েছে",
    stepBridge: "ব্রিজ",
    stepDetails: "লি.ফাই এর মাধ্যমে {{tool}}",
    stepSwap: "সোওয়াপ",
    stepSwapAndBridge: "সোওয়াপ এবং ব্রিজ",
    supportId: "সাপোর্ট আইডি",
    swapStepDetails: "{{tool}} এর মাধ্যমে {{chain}} এ সোওয়াপ করুন",
    swapping: "সোওয়াপ",
    tags: {
      cheapest: "সস্তা",
      fastest: "দ্রুত",
      insurable: "বীমাযোগ্য",
      insurance: "বীমা",
      insured: "বীমাকৃত",
      recommended: "Recommended",
      safest: "নিরাপদ"
    },
    to: "প্রতি",
    tokenOnChain: "{{chainName}} -এ {{tokenSymbol}}",
    tokenOnChainAmount: "{{amount, number(maximumFractionDigits: 9)}} {{tokenSymbol}} {{chainName}} -এ",
    tokenSearch: "আপনার টোকেন অনুসন্ধান করুন",
    valueLoss: "মান ক্ষতি",
    walletAddressOrEns: "ওয়ালেট ঠিকানা বা ইএনএস নাম"
  },
  RVe = {
    bridgeExploits: "ব্রিজের ত্রুটি, হ্যাক বা শোষণ",
    insure: "ট্রানজিটে টোকেনের ১০০% বীমা করুন।",
    insured: "আপনি ট্রানজিটের ১০০% টোকেন বীমা করেছেন:",
    slippageError: "প্রাপ্ত টোকেনগুলির জন্য স্লিপেজে ত্রুটি।"
  },
  OVe = {
    additionalProviderFee: "অতিরিক্ত সেতু, ডেক্স, এবং পরিষেবা ফি।",
    estimatedNetworkFee: "আনুমানিক নেটওয়ার্ক ফি।",
    estimatedTime: "মিনিটের মধ্যে আনুমানিক সোওয়াপ কার্যকর করার সময়।",
    notFound: {
      text: "আমরা এই পৃষ্ঠাটি খুঁজে পাইনি।",
      title: "৪০৪"
    },
    numberOfSteps: "সোওয়াপ পদক্ষেপ একটি সংখ্যা. প্রতিটি ধাপে ১-২ টি লেনদেন থাকতে পারে যার জন্য একটি স্বাক্ষর প্রয়োজন।",
    progressToNextUpdate: "প্রদর্শিত ডেটা {{value}} সেকেন্ড পরে স্বয়ংক্রিয়ভাবে রিফ্রেশ হবে। ম্যানুয়ালি আপডেট করতে এখানে ক্লিক করুন।",
    settingsModified: "সেটিংস (পরিবর্তিত)"
  },
  DVe = {
    extensionNotFound: "এই ওয়ালেটটি বেছে নেওয়ার আগে দয়া করে নিশ্চিত করুন যে শুধুমাত্র {{name}} ব্রাউজার এক্সটেনশন সক্রিয় আছে।"
  },
  NVe = {
    button: xVe,
    format: EVe,
    header: SVe,
    language: CVe,
    settings: AVe,
    info: TVe,
    success: kVe,
    warning: _Ve,
    error: IVe,
    main: PVe,
    insurance: RVe,
    tooltip: OVe,
    wallet: DVe
  },
  MVe = {
    name: "Deutsch",
    title: "Sprache"
  },
  $Ve = {
    currency: "{{value, currency(currency: USD)}}",
    number: "{{value, number(maximumFractionDigits: 4)}}"
  },
  LVe = {
    auto: "Auto",
    bridge: "Bridge",
    buy: "Buy",
    buyNow: "Jetzt kaufen",
    cancel: "Abbrechen",
    connectWallet: "Wallet verbinden",
    contactSupport: "Support kontaktieren",
    continue: "Fortsetzen",
    copyAddress: "Adresse kopieren",
    dark: "Dunkel",
    delete: "Löschen",
    disconnect: "Trennen",
    done: "Fertig",
    exchange: "Exchange",
    getGas: "Gas erhalten",
    hide: "Ausblenden",
    learnMore: "Mehr erfahren",
    lifiCheckout: "LI.FI Checkout",
    lifiExchange: "LI.FI Exchange",
    light: "Hell",
    max: "max",
    ok: "OK",
    removeTransaction: "Transaktion entfernen",
    reset: "Zurücksetzen",
    resetSettings: "Einstellungen zurücksetzen",
    reviewBridge: "Bridge überprüfen",
    reviewPurchase: "Kauf ansehen",
    reviewSwap: "Swap überprüfen",
    seeDetails: "Siehe Einzelheiten",
    showAll: "Alles anzeigen",
    startBridging: "Starte Bridge Protokoll",
    startSwapping: "Swap starten",
    swap: "Swap",
    tryAgain: "Erneut versuchen",
    viewCoverage: "Deckung anzeigen",
    viewOnExplorer: "Im Explorer anzeigen"
  },
  BVe = {
    activeTransactions: "Aktive Transaktion",
    bridge: "Bridge",
    checkout: "Zur Kasse",
    exchange: "Exchange",
    from: "Swap von",
    gas: "Gas",
    payWith: "Zahle mit",
    purchase: "Kauf",
    purchaseDetails: "Kaufdetails",
    selectChain: "Chain auswählen",
    selectWallet: "Wallet wählen",
    settings: "Einstellungen",
    swap: "Swap",
    to: "Swap zu",
    transactionDetails: "Transaktionsdetails",
    transactionHistory: "Transaktionshistorie\u2028",
    walletConnected: "Wallet verbunden",
    youGet: "Sie erhalten"
  },
  FVe = {
    message: {
      autoRefuel: "Sie haben nicht genug Gas auf {{chainName}}. Wenn Sie fortfahren, erhalten Sie zusätzlich genug Gas um den Swap abzuschließen.",
      emptyActiveTransactions: "Laufende Swaps werden hier angezeigt. Sobald Sie fertig sind, finden Sie sie in der Transaktionshistorie.",
      emptyTokenList: "Es wurden keine Tokens auf der Chain {{chainName}} gefunden oder Sie haben keine. Bitte versuchen Sie die Suche erneut mit der Contract-Adresse falls Ihr Token nicht erscheint oder wechseln Sie die Chain.",
      emptyTransactionHistory: "Die Transaktionshistorie wird nur lokal gespeichert und gelöscht, wenn Sie Ihre Browserdaten löschen.",
      routeNotFound: "Gründe dafür könnten lauten: geringe Liquidität, gewählter Betrag ist zu niedrig, die Gaskosten sind zu hoch oder es gibt keine Routen für die ausgewählte Kombination."
    },
    title: {
      autoRefuel: "Gas erhalten",
      emptyActiveTransactions: "Keine aktiven Transaktionen",
      emptyTransactionHistory: "Keine neuen Transaktionen",
      routeNotFound: "Keine Routen verfügbar"
    }
  },
  jVe = {
    message: {
      exchangePartiallySuccessful: "Wir haben versucht, den Swap abzuschließen, aber {{tool}} hat keine Liquidität für {{tokenSymbol}} Token.",
      exchangeSuccessful: "Es sind jetzt {{amount, number(maximumFractionDigits: 9)}} {{tokenSymbol}} in der Wallet {{walletAddress}} auf der {{chainName}}-Chain.",
      purchaseSuccessful: "Sie besitzen jetzt {{assetName}} in der Wallet {{walletAddress}} auf der {{chainName}}-Chain."
    },
    title: {
      bridgePartiallySuccessful: "Bridge teilweise erfolgreich",
      bridgeSuccessful: "Bridge erfolgreich",
      purchaseSuccessful: "Kauf abgeschlossen",
      refundIssued: "Rückerstattung gewährt",
      swapPartiallySuccessful: "Swap teilweise erfolgreich",
      swapSuccessful: "Swap erfolgreich"
    }
  },
  UVe = {
    message: {
      deleteActiveTransactions: "Aktive Swaps werden nur lokal gespeichert und können nicht wiederhergestellt werden, wenn Sie sie löschen.",
      deleteTransactionHistory: "Die Transaktionshistorie wird nur lokal gespeichert und kann nicht wiederhergestellt werden, wenn Sie sie löschen.",
      highValueLoss: "Der Wert der erhaltenen Token ist deutlich niedriger als die getauschten Token und die Transaktionskosten.",
      insufficientFunds: "Sie haben nicht genug Token, um diesen Swap abzuschließen.",
      insufficientGas: "Sie haben nicht genug Gas um diesen Swap abzuschließen. Sie müssen mindestens hinzufügen:",
      rateChanged: "Der Wechselkurs hat sich geändert. Durch Fortsetzen des Swaps akzeptieren Sie den neuen Kurs.",
      resetSettings: "Dies wird Ihre Routenpriorität, Slippage, Gaspreis, aktivierte Brücken und Exchanges zurücksetzen."
    },
    title: {
      deleteActiveTransactions: "Alle aktiven Transaktionen entfernen?",
      deleteTransaction: "Transaktion löschen?",
      deleteTransactionHistory: "Transaktionshistorie entfernen?",
      highValueLoss: "Hoher Wertverlust",
      insufficientGas: "Unzureichendes Gas",
      rateChanged: "Wechselkurs geändert",
      resetSettings: "Einstellungen zurücksetzen?"
    }
  },
  zVe = {
    message: {
      allowanceRequired: "Überweisungsbetrag für {{tokenSymbol}} überschreitet Ihre derzeitige Zulassung. Bitte erhöhen Sie das Limit und versuchen Sie es erneut.",
      insufficientFunds: "Sie haben nicht genug Gas, um die Kosten der Transaktion zu decken.",
      slippageThreshold: "Die Slippage ist größer als der definierte Schwellenwert. Bitte fordern Sie eine neue Route an, um ein neues Angebot zu erhalten.",
      transactionFailed: "Weitere Informationen finden Sie im Block-Explorer.",
      transactionNotSent: "Die Transaktion wurde nicht gesendet, Ihr Geld befindet sich noch in Ihrer Brieftasche ({{amount, number(maximumFractionDigits: 4)}} {{tokenSymbol}} auf {{chainName}}).",
      transactionRejected: "Ihre Signatur ist erforderlich, um die Transaktion abzuschließen. {{amount, number(maximumFractionDigits: 9)}} {{tokenSymbol}} auf {{chainName}} verbleiben in Ihrem Wallet.",
      unknown: "Bitte versuchen Sie es später noch einmal oder kontaktieren Sie den Support."
    },
    title: {
      allowanceRequired: "Unzureichende Erlaubnis",
      balanceIsTooLow: "Ihr Guthaben ist zu gering",
      chainSwitch: "Chainwechsel erforderlich",
      gasLimitIsTooLow: "Das Gaslimit ist zu niedrig",
      insufficientFunds: "Unzureichendes Guthaben",
      slippageNotMet: "Slippagebedingungen nicht erfüllt",
      transactionCanceled: "Transaktion abgebrochen",
      transactionFailed: "Transaktion ist fehlgeschlagen.",
      transactionRejected: "Signatur benötigt.",
      transactionUnderpriced: "Transaktion ist unterbewertet.",
      transactionUnprepared: "Transaktion kann nicht vorbereitet werden.",
      unknown: "Etwas ist schief gelaufen.",
      walletAddressInvalid: "Wallet-Adresse ist ungültig.",
      walletAddressRequired: "Wallet-Adresse ist erforderlich.",
      walletEnsAddressInvalid: "Die Wallet-Adresse ist ungültig oder das Netzwerk unterstützt ENS nicht."
    }
  },
  HVe = {
    additionalProviderFee: "Zusätzliche Bridges, DEXs und Servicegebühren.",
    estimatedNetworkFee: "Geschätzte Netzwerkgebühr.",
    estimatedTime: "Geschätzte Swap-Ausführungszeit in Minuten.",
    notFound: {
      text: "Wir konnten diese Seite nicht finden.",
      title: "404"
    },
    numberOfSteps: "Eine Anzahl von Swap-Schritten. Jeder Schritt kann 2 Transaktionen enthalten, die eine Unterschrift erfordern.",
    progressToNextUpdate: "Angezeigte Daten werden nach {{value}} Sekunden automatisch aktualisiert. Klicken Sie hier, um manuell zu aktualisieren.",
    recommended: "Eine preiswerte Route, die Komplexität und Benutzerfreundlichkeit in Einklang bringt.",
    settingsModified: "Einstellungen (geändert)"
  },
  VVe = {
    crossStepDetails: "Bridgen von {{from}} nach {{to}} über {{tool}}",
    currentAmount: "Aktueller Betrag",
    estimatedTime: "{{value}} m",
    featuredTokens: "Ausgewählte Token",
    from: "Von",
    fromAmount: "Sie bezahlen",
    gasCost: "Gaskosten",
    gasFeeEstimated: "geschätzte Gasgebühr",
    gasFeePaid: "gezahlte Gasgebühr",
    inProgress: "wird ausgeführt",
    nftStepDetails: "NFT über {{tool}} kaufen",
    onChain: "auf {{chainName}}",
    otherTokens: "Andere Token",
    ownedBy: "In Besitz von",
    process: {
      crossChain: {
        actionRequired: "Bitte signieren Sie die Transaktion.",
        done: "Transaktion genehmigt",
        pending: "Warten auf Transaktion",
        started: "Transaktion vorbereiten"
      },
      nft: {
        done: "NFT gekauft"
      },
      receivingChain: {
        done: "Bridge abgeschlossen",
        partial: "Bridge teilweise abgeschlossen",
        pending: "Warten auf Empfänger-Chain.",
        refunded: "Bridge Transaktion zurückerstattet"
      },
      swap: {
        actionRequired: "Bitte signieren Sie die Transaktion.",
        done: "Swap abgeschlossen",
        pending: "Warten auf Transaktion",
        started: "Swap vorbereiten"
      },
      switchChain: {
        actionRequired: "Chainwechsel erforderlich",
        done: "Chain erfolgreich gewechselt."
      },
      tokenAllowance: {
        done: "Token-Zulassung genehmigt.",
        pending: "Warten auf Token-Genehmigung.",
        started: "Token-Freigabe festlegen."
      }
    },
    quotedAmount: "Angebotsbetrag",
    rateChange: "Wechselkurs geändert",
    receiving: "Eingehend",
    refuelStepDetails: "Gas über {{tool}} erhalten",
    selectChain: "Chain",
    selectChainAndToken: "Chain und Token auswählen",
    selectToken: "Token",
    sendToAddress: "An {{address}} senden",
    sendToWallet: "An eine andere Wallet senden",
    sending: "Wird gesendet",
    sentToAddress: "Gesendet an {{address}}",
    stepBridge: "Bridge",
    stepBridgeAndBuy: "Bridge und Kauf",
    stepDetails: "{{tool}} via LI.FI",
    stepSwap: "Swap",
    stepSwapAndBridge: "Tauschen und überbrücken",
    stepSwapAndBuy: "Tauschen und kaufen",
    supportId: "Support-ID",
    swapStepDetails: "Tausche auf {{chain}} über {{tool}}",
    tags: {
      cheapest: "Günstig",
      fastest: "Schnell",
      insurable: "Versicherbar",
      insurance: "Versicherung",
      insured: "Versichert",
      recommended: "Empfohlen",
      safest: "Sicher"
    },
    to: "Zu",
    tokenOnChain: "{{tokenSymbol}} auf {{chainName}}",
    tokenOnChainAmount: "{{amount, number(maximumFractionDigits: 4)}} {{tokenSymbol}} auf {{chainName}}",
    tokenSearch: "Suchen Sie Ihren Token",
    valueLoss: "Wertverlust",
    walletAddressOrEns: "Wallet-Adresse oder ENS-Name"
  },
  WVe = {
    bridgeExploits: "Bridge-Fehlfunktionen, Hacks oder Exploits",
    insure: "Versichere <0>{{amount, number(maximumFractionDigits: 9)}} {{tokenSymbol}}</0> während der Übertragung.",
    insured: "Du hast <0>{{amount, number(maximumFractionDigits: 9)}} {{tokenSymbol}}</0> während der Übertragung versichert:",
    slippageError: "Fehler in Slippage für empfangene Token"
  },
  qVe = {
    enabledBridges: "Aktivierte Bridges",
    enabledExchanges: "Aktivierte Exchanges",
    gasPrice: {
      fast: "Schnell",
      normal: "Normal",
      slow: "Langsam",
      title: "Gaspreis"
    },
    routePriority: "Routenpriorität",
    showDestinationWallet: "Ziel Wallet anzeigen",
    slippage: "Slippage",
    resetSettings: "Sie verwenden benutzerdefinierte Einstellungen, die die Anzahl der verfügbaren Routen begrenzen."
  },
  GVe = {
    extensionNotFound: "Bitte stellen Sie sicher, dass nur die Browsererweiterung {{name}} aktiv ist, bevor Sie dieses Wallet auswählen."
  },
  KVe = {
    language: MVe,
    format: $Ve,
    button: LVe,
    header: BVe,
    info: FVe,
    success: jVe,
    warning: UVe,
    error: zVe,
    tooltip: HVe,
    main: VVe,
    insurance: WVe,
    settings: qVe,
    wallet: GVe
  },
  QVe = {
    name: "English",
    title: "Language"
  },
  YVe = {
    currency: "{{value, currency(currency: USD)}}",
    number: "{{value, number(maximumFractionDigits: 9)}}"
  },
  JVe = {
    auto: "Auto",
    bridge: "Bridge",
    buy: "Buy",
    buyNow: "Buy now",
    cancel: "Cancel",
    close: "Close",
    connectWallet: "Connect wallet",
    contactSupport: "Contact support",
    continue: "Continue",
    copyAddress: "Copy address",
    dark: "Dark",
    delete: "Delete",
    disconnect: "Disconnect",
    done: "Done",
    exchange: "Exchange",
    getGas: "Get gas",
    hide: "Hide",
    learnMore: "Learn more",
    lifiCheckout: "LI.FI Checkout",
    lifiExchange: "LI.FI Exchange",
    light: "Light",
    max: "max",
    ok: "Ok",
    removeTransaction: "Remove transaction",
    reset: "Reset",
    resetSettings: "Reset settings",
    reviewBridge: "Review bridge",
    reviewPurchase: "Review purchase",
    reviewSwap: "Review swap",
    seeDetails: "See details",
    showAll: "Show all",
    startBridging: "Start bridging",
    startSwapping: "Start swapping",
    swap: "Swap",
    tryAgain: "Try again",
    viewCoverage: "View coverage",
    viewOnExplorer: "View on explorer"
  },
  XVe = {
    activeTransactions: "Active transactions",
    bridge: "Bridge",
    checkout: "Checkout",
    exchange: "Exchange",
    from: "Exchange from",
    gas: "Gas",
    payWith: "Pay with",
    purchase: "Purchase",
    purchaseDetails: "Purchase details",
    selectChain: "Select chain",
    selectWallet: "Select your wallet",
    settings: "Settings",
    swap: "Swap",
    to: "Exchange to",
    transactionDetails: "Transaction details",
    transactionHistory: "Transaction history",
    walletConnected: "Wallet connected",
    youGet: "You get"
  },
  ZVe = {
    message: {
      autoRefuel: "You're low on {{chainName}} gas. By continuing, you'll get enough gas to complete the transaction.",
      emptyActiveTransactions: "Transactions in progress will appear here. Once completed, find them in transaction history.",
      emptyTokenList: "We couldn't find tokens on {{chainName}} chain or you don't have any. Please search by contract address if your token doesn't appear or choose another chain.",
      emptyTransactionHistory: "Transaction history is only stored locally and will be deleted if you clear your browser data.",
      routeNotFound: "Reasons for that could be: low liquidity, amount selected is too low, gas costs are too high or there are no routes for the selected combination."
    },
    title: {
      autoRefuel: "Get gas",
      emptyActiveTransactions: "No active transactions",
      emptyTransactionHistory: "No recent transactions",
      routeNotFound: "No routes available"
    }
  },
  eWe = {
    message: {
      exchangePartiallySuccessful: "We've tried to complete the transaction, but {{tool}} ran out of liquidity for {{tokenSymbol}} token.",
      exchangeSuccessful: "There are now {{amount, number(maximumFractionDigits: 9)}} {{tokenSymbol}} in {{walletAddress}} wallet on {{chainName}} chain.",
      purchaseSuccessful: "You now own {{assetName}} in {{walletAddress}} wallet on {{chainName}} chain."
    },
    title: {
      bridgePartiallySuccessful: "Bridge partially successful",
      bridgeSuccessful: "Bridge successful",
      purchaseSuccessful: "Purchase successful",
      refundIssued: "Refund issued",
      swapPartiallySuccessful: "Swap partially successful",
      swapSuccessful: "Swap successful"
    }
  },
  tWe = {
    message: {
      deleteActiveTransactions: "Active transactions are only stored locally and can't be recovered if you delete them.",
      deleteTransactionHistory: "Transaction history is only stored locally and can't be recovered if you delete it.",
      highValueLoss: "The value of the received tokens is significantly lower than the exchanged tokens and transaction cost.",
      insufficientFunds: "You don't have enough funds to complete the transaction.",
      insufficientGas: "You don't have enough gas to complete the transaction. You need to add at least:",
      rateChanged: "The exchange rate has changed. By continuing the transaction, you'll accept the new rate.",
      resetSettings: "This will reset your route priority, slippage, gas price, enabled bridges and exchanges."
    },
    title: {
      deleteActiveTransactions: "Delete all active transactions?",
      deleteTransaction: "Delete this transaction?",
      deleteTransactionHistory: "Delete transaction history?",
      highValueLoss: "High value loss",
      insufficientGas: "Insufficient gas",
      rateChanged: "Rate changed",
      resetSettings: "Reset settings?"
    }
  },
  nWe = {
    message: {
      allowanceRequired: "Transfer amount for {{tokenSymbol}} exceeds your current allowance. Please increase your allowance and try again.",
      insufficientFunds: "You don't have enough gas to cover the cost of the transaction.",
      slippageThreshold: "The slippage is larger than the defined threshold. Please request a new quote.",
      transactionFailed: "Please check the block explorer for more information.",
      transactionNotSent: "Transaction was not sent. {{amount, number(maximumFractionDigits: 9)}} {{tokenSymbol}} on {{chainName}} remain in your wallet.",
      transactionRejected: "Your signature is required to complete the transaction. {{amount, number(maximumFractionDigits: 9)}} {{tokenSymbol}} on {{chainName}} remain in your wallet.",
      unknown: "Please try again or contact support."
    },
    title: {
      allowanceRequired: "Insufficient allowance",
      balanceIsTooLow: "The balance is too low",
      chainSwitch: "Chain switch required",
      gasLimitIsTooLow: "The gas limit is too low",
      insufficientFunds: "Insufficient funds",
      slippageNotMet: "Slippage conditions not met",
      transactionCanceled: "Transaction canceled",
      transactionFailed: "Transaction failed",
      transactionRejected: "Signature required",
      transactionUnderpriced: "Transaction is underpriced",
      transactionUnprepared: "Unable to prepare transaction",
      unknown: "Something went wrong",
      walletAddressInvalid: "Wallet address is invalid.",
      walletAddressRequired: "Wallet address is required.",
      walletEnsAddressInvalid: "Wallet address is invalid or network doesn't support ENS."
    }
  },
  rWe = {
    additionalProviderFee: "Additional bridges, DEXs, and service fees.",
    estimatedNetworkFee: "Estimated network fee.",
    estimatedTime: "Estimated execution time in minutes.",
    notFound: {
      text: "We couldn't find this page.",
      title: "404"
    },
    numberOfSteps: "A number of exchange steps. Each step can contain 1-2 transactions that require a signature.",
    progressToNextUpdate: "Quotes will update in {{value}} seconds. <0/> Click here to update now.",
    recommended: "A cheap route that balances complexity and ease of use.",
    settingsModified: "Settings (modified)"
  },
  iWe = {
    crossStepDetails: "Bridge from {{from}} to {{to}} via {{tool}}",
    currentAmount: "Current amount",
    estimatedTime: "{{value}}m",
    featuredTokens: "Featured tokens",
    from: "From",
    fromAmount: "You pay",
    gasCost: "Gas cost",
    gasFeeEstimated: "estimated gas fee",
    gasFeePaid: "gas fee paid",
    inProgress: "in progress",
    nftStepDetails: "Purchase NFT via {{tool}}",
    onChain: "on {{chainName}}",
    otherTokens: "Other tokens",
    ownedBy: "Owned by",
    process: {
      crossChain: {
        actionRequired: "Please sign the transaction",
        done: "Bridge transaction confirmed",
        pending: "Waiting for bridge transaction",
        started: "Preparing bridge transaction"
      },
      nft: {
        done: "NFT purchased"
      },
      receivingChain: {
        done: "Bridge completed",
        partial: "Bridge partially completed",
        pending: "Waiting for destination chain",
        refunded: "Bridge transaction refunded"
      },
      swap: {
        actionRequired: "Please sign the transaction",
        done: "Swap completed",
        pending: "Waiting for swap transaction",
        started: "Preparing swap transaction"
      },
      switchChain: {
        actionRequired: "Chain switch required",
        done: "Chain switched successfully"
      },
      tokenAllowance: {
        done: "Token allowance approved",
        pending: "Waiting for token allowance",
        started: "Setting token allowance"
      }
    },
    quotedAmount: "Quoted amount",
    rateChange: "Rate change",
    receiving: "Receiving",
    refuelStepDetails: "Get gas via {{tool}}",
    selectChain: "Select chain",
    selectChainAndToken: "Select chain and token",
    selectToken: "Select token",
    sendToAddress: "Send to {{address}}",
    sendToWallet: "Send to a different wallet",
    sending: "Sending",
    sentToAddress: "Sent to {{address}}",
    stepBridge: "Bridge",
    stepBridgeAndBuy: "Bridge and buy",
    stepDetails: "{{tool}} via LI.FI",
    stepSwap: "Swap",
    stepSwapAndBridge: "Swap and bridge",
    stepSwapAndBuy: "Swap and buy",
    supportId: "Support ID",
    swapStepDetails: "Swap on {{chain}} via {{tool}}",
    tags: {
      cheapest: "Cheap",
      fastest: "Fast",
      insurable: "Insurable",
      insurance: "Insurance",
      insured: "Insured",
      recommended: "Recommended",
      safest: "Safe"
    },
    to: "To",
    tokenOnChain: "{{tokenSymbol}} on {{chainName}}",
    tokenOnChainAmount: "{{amount, number(maximumFractionDigits: 9)}} {{tokenSymbol}} on {{chainName}}",
    tokenSearch: "Search by token name or address",
    valueLoss: "Value loss",
    walletAddressOrEns: "Wallet address or ENS name"
  },
  sWe = {
    bridgeExploits: "Bridge malfunctions, hacks or exploits",
    insure: "Insure <0>{{amount, number(maximumFractionDigits: 9)}} {{tokenSymbol}}</0> in transit.",
    insured: "You've insured <0>{{amount, number(maximumFractionDigits: 9)}} {{tokenSymbol}}</0> in transit:",
    slippageError: "Error in slippage for tokens received"
  },
  oWe = {
    enabledBridges: "Enabled bridges",
    enabledExchanges: "Enabled exchanges",
    gasPrice: {
      fast: "Fast",
      normal: "Normal",
      slow: "Slow",
      title: "Gas price"
    },
    routePriority: "Route priority",
    showDestinationWallet: "Show destination wallet",
    slippage: "Slippage",
    resetSettings: "You're using custom setting limiting the number of available routes."
  },
  aWe = {
    extensionNotFound: "Please make sure that only the {{name}} browser extension is active before choosing this wallet."
  },
  cWe = {
    language: QVe,
    format: YVe,
    button: JVe,
    header: XVe,
    info: ZVe,
    success: eWe,
    warning: tWe,
    error: nWe,
    tooltip: rWe,
    main: iWe,
    insurance: sWe,
    settings: oWe,
    wallet: aWe
  },
  lWe = {
    auto: "Auto",
    cancel: "Cancelar",
    connectWallet: "Conectar billetera",
    contactSupport: "Contactar soporte",
    continue: "Continuar",
    copyAddress: "Copiar dirección",
    dark: "Oscuro",
    delete: "Eliminar",
    disconnect: "Desconectar",
    done: "Hecho",
    getGas: "Obtener gas",
    hide: "Esconder",
    lifiSwap: "LI.FI Swap",
    light: "Luz",
    max: "máximo",
    ok: "Ok",
    okay: "Okay",
    removeSwap: "Eliminar swap",
    reset: "Reiniciar",
    resetSettings: "Reiniciar ajustes",
    restartSwap: "Reiniciar swap",
    reviewGasSwap: "Revisar swap de gas",
    reviewSwap: "Revisar swap",
    seeDetails: "Ver detalles",
    showAll: "Mostrar todo",
    startGasSwap: "Iniciar intercambio de gas",
    startSwap: "Iniciar swap",
    swap: "Swap",
    tryAgain: "Intentar otra vez",
    viewOnExplorer: "Ver en explorador"
  },
  uWe = {
    currency: "{{value, currency(currency: USD)}}",
    number: "{{value, number(maximumFractionDigits: 4)}}"
  },
  dWe = {
    activeSwaps: "Swaps activos",
    checkout: "Checkout",
    from: "Intercambiar de",
    gas: "Gas",
    gasSwap: "Swap de gas",
    routes: "Usted obtiene",
    selectChain: "Seleccione la cadena",
    selectWallet: "Seleccione su billetera",
    settings: "Ajustes",
    swap: "Swap",
    swapDetails: "Detalles del swap",
    swapHistory: "Historial de swaps",
    to: "Swap a",
    walletConnected: "Billetera conectada"
  },
  fWe = {
    name: "Español",
    title: "Idioma"
  },
  hWe = {
    enabledBridges: "Puentes habilitados",
    enabledExchanges: "Intercambios habilitados",
    gasPrice: {
      fast: "Rápido",
      normal: "Normal",
      slow: "Lento",
      title: "Precio de gas"
    },
    routePriority: "Prioridad de ruta",
    showDestinationWallet: "Mostrar billetera de destino",
    slippage: "Diferencial"
  },
  pWe = {
    message: {
      emptyActiveSwaps: "Los intercambios en curso aparecerán aquí. Una vez completado, encuéntrelos en el historial de intercambio.",
      emptySwapHistory: "El historial de intercambio solo se almacena localmente y se eliminará si borra los datos de su navegador.",
      emptyTokenList: "No pudimos encontrar tokens en la cadena {{chainName}} o no tienes ninguno. Por favor intente buscar de nuevo o elija otra cadena.",
      routeNotFound: "Pruebe con otra combinación de tokens."
    },
    title: {
      emptyActiveSwaps: "No hay intercambios activos",
      emptySwapHistory: "No hay intercambios recientes",
      routeNotFound: "No hay rutas disponibles"
    }
  },
  mWe = {
    message: {
      swapPartiallySuccessful: "Hemos intentado completar el swap, pero {{tool}} se quedó sin liquidez para el token {{tokenSymbol}}.",
      swapSuccessful: "Ahora hay {{amount, number(maximumFractionDigits: 4)}} {{tokenSymbol}} en la billetera {{walletAddress}} en la cadena {{chainName}}."
    },
    title: {
      gasSwapSuccessful: "Swap de gas exitoso",
      refundIssued: "Reembolso emitido",
      swapPartiallySuccessful: "Swap parcialmente exitoso",
      swapSuccessful: "Intercambio exitoso"
    }
  },
  gWe = {
    message: {
      deleteActiveSwaps: "Los intercambios activos solo se almacenan localmente y no se pueden recuperar si los elimina.",
      deleteSwapHistory: "El historial de intercambio solo se almacena localmente y no se puede recuperar si lo elimina.",
      highValueLoss: "El valor de los tokens recibidos es significativamente menor que los tokens intercambiados y el costo de la transacción.",
      insufficientFunds: "No tiene fondos suficientes para ejecutar el intercambio.",
      insufficientGas: "Debes agregar al menos:",
      rateChanged: "La tasa de cambio ha cambiado. Continuar con el swap implica que estas de acuerdo con la nueva tasa.",
      resetSettings: "Esto restablecerá su prioridad de ruta, deslizamiento, precio de gas, puentes e intercambios habilitados."
    },
    title: {
      deleteActiveSwaps: "¿Eliminar todos los intercambios activos?",
      deleteSwap: "¿Eliminar este intercambio?",
      deleteSwapHistory: "¿Eliminar el historial de intercambio?",
      highValueLoss: "Pérdida de alto valor",
      insufficientGas: "Gas insuficiente",
      rateChanged: "Cambios de precio detectado",
      resetSettings: "¿Reiniciar los ajustes?"
    }
  },
  yWe = {
    message: {
      slippageThreshold: "El slippage es mayor que el umbral definido. Por favor, solicite una nueva ruta para obtener un presupuesto nuevo.",
      transactionFailed: "Por favor consulte el explorador de bloques para obtener mas información",
      transactionNotSent: "La transacción no fue enviada, sus fondos aún están en su billetera ({{amount, number(maximumFractionDigits: 4)}} {{tokenSymbol}} en {{chainName}}).",
      transactionRejected: "Se requiere su firma para completar la transacción. {{amount, number(maximumFractionDigits: 4)}} {{tokenSymbol}} en {{chainName}} permanecen en su billetera.",
      unknown: "Inténtalo de nuevo o ponte en contacto con soporte."
    },
    title: {
      balanceIsTooLow: "El balance es demasiado bajo",
      chainSwitch: "Se requiere cambiar cadena.",
      failed: "Swap ha fallado",
      gasLimitIsTooLow: "Límite de gas es demasiado bajo",
      slippageNotMet: "Condiciones de slippage no cumplidas",
      transactionCanceled: "Transacción cancelada",
      transactionFailed: "La transacción ha fallado.",
      transactionRejected: "Firma requerida.",
      transactionUnderpriced: "La transacción está subvaluada.",
      transactionUnprepared: "No se puede preparar la transacción.",
      unknown: "Algo salió mal.",
      walletAddressInvalid: "La dirección de la billetera no es válida.",
      walletAddressRequired: "Dirección de billetera es requerida.",
      walletEnsAddressInvalid: "La dirección de la billetera no es válida o la red no es compatible con ENS."
    }
  },
  vWe = {
    crossStepDetails: "Mover fondos de {{from}} {{to}} {{tool}}",
    currentAmount: "Cantidad actual",
    estimatedTime: "{{value}}m",
    featuredTokens: "Tokens destacados",
    from: "Desde",
    fromAmount: "Usted paga",
    gasCost: "Costo de gas",
    gasFeeEstimated: "tarifa de gas estimada",
    gasFeePaid: "comisión de gas pagada",
    inProgress: "en progreso",
    nftStepDetails: "Compra NFT a través de {{tool}}",
    onChain: "en {{chainName}}",
    otherTokens: "Otros tokens",
    ownedBy: "Propiedad de",
    payWith: "Pagar con",
    process: {
      crossChain: {
        actionRequired: "Por favor firme la transacción.",
        done: "Transacción aprobada.",
        pending: "Esperando transacción.",
        started: "Preparando transacción."
      },
      receivingChain: {
        done: "Fondos recibidos.",
        partial: "Transacción de bridge parcialmente completada",
        pending: "Esperando cadena de recepción.",
        refunded: "Transacción de bridge reembolsada"
      },
      swap: {
        actionRequired: "Por favor firme la transacción.",
        done: "Swap completado.",
        pending: "Esperando transacción del intercambio",
        started: "Preparando transacción de intercambio"
      },
      switchChain: {
        actionRequired: "Cambiar cadenas es requerido",
        done: "Cadena cambiada con éxito"
      },
      tokenAllowance: {
        done: "Permiso de token aprobado",
        pending: "Esperando permiso de token",
        started: "Configurando permiso de tokens"
      }
    },
    quotedAmount: "Monto citado",
    rateChange: "Cambios de precio detectado",
    receiving: "Recibiendo",
    routes: "Usted obtiene",
    selectChain: "Cadena",
    selectChainAndToken: "Seleccione cadena y token",
    selectToken: "Token",
    sendToAddress: "Enviar a {{address}}",
    sendToWallet: "Enviar a una billetera diferente",
    sentToAddress: "Enviado a {{address}}",
    stepBridge: "Cruzar",
    stepSwap: "Swap",
    stepSwapAndBridge: "Swap y cruzar",
    supportId: "ID de soporte",
    swapStepDetails: "Intercambiar en {{chain}} a través de {{tool}}",
    swapping: "Intercambiando",
    tags: {
      ALTERNATIVE: "ALTERNATIVO",
      CHEAPEST: "BARATO",
      FASTEST: "RÁPIDO",
      RECOMMENDED: "RECOMENDADO",
      SAFEST: "SEGURO"
    },
    to: "A",
    tokenOnChain: "{{tokenSymbol}} en {{chainName}}",
    tokenOnChainAmount: "{{amount, number(maximumFractionDigits: 4)}} {{tokenSymbol}} on {{chainName}}",
    tokenSearch: "Busque su token",
    valueLoss: "Valor perdido",
    walletAddressOrEns: "Dirección de billetera o nombre ENS"
  },
  bWe = {
    estimatedNetworkFee: "Tarifa de red estimada.",
    estimatedTime: "Tiempo estimado de ejecución del swap en minutos.",
    notFound: {
      text: "No pudimos encontrar esta página.",
      title: "404"
    },
    numberOfSteps: "Una serie de pasos de intercambio. Cada paso puede contener 1-2 transacciones que requieren una firma.",
    progressToNextUpdate: "Los datos mostrados se actualizarán automáticamente después de {{value}} segundos. Haga clic aquí para actualizar manualmente.",
    settingsModified: "Ajustes (modificados)"
  },
  wWe = {
    extensionNotFound: "Por favor, asegúrese de que sólo la extensión {{name}} del navegador esta activa antes de elegir esta billetera."
  },
  xWe = {
    button: lWe,
    format: uWe,
    header: dWe,
    language: fWe,
    settings: hWe,
    info: pWe,
    success: mWe,
    warning: gWe,
    error: yWe,
    main: vWe,
    tooltip: bWe,
    wallet: wWe
  },
  EWe = {
    name: "Français",
    title: "Langue"
  },
  SWe = {
    currency: "{{value, currency(currency: USD)}}",
    number: "{{value, number(maximumFractionDigits: 4)}}"
  },
  CWe = {
    auto: "Auto",
    bridge: "Bridge",
    buy: "Acheter",
    buyNow: "Acheter maintenant",
    cancel: "Annuler",
    connectWallet: "Connecter un portefeuille",
    contactSupport: "Contacter le support",
    continue: "Continuer",
    copyAddress: "Copier l’adresse",
    dark: "Sombre",
    delete: "Supprimer",
    disconnect: "Déconnecter",
    done: "Terminé",
    exchange: "Échanger",
    getGas: "Obtenir du gaz",
    hide: "Cacher",
    learnMore: "Plus d'info",
    lifiCheckout: "Paiement LI.FI",
    lifiExchange: "Échange LI.FI",
    light: "Clair",
    max: "max",
    ok: "Ok",
    removeTransaction: "Supprimer la transaction",
    reset: "Réinitialiser",
    resetSettings: "Réinitialiser les paramètres",
    reviewBridge: "Revoir le pont",
    reviewPurchase: "Vérifiez votre achat",
    reviewSwap: "Vérifier l'échange",
    seeDetails: "Voir les détails",
    showAll: "Afficher tout",
    startBridging: "Commencer le pont",
    startSwapping: "Commencer à échanger",
    swap: "Échanger",
    tryAgain: "Réessayer",
    viewCoverage: "Voir la couverture",
    viewOnExplorer: "Voir sur l'explorateur"
  },
  AWe = {
    activeTransactions: "Transactions actives",
    bridge: "Bridge",
    checkout: "Paiement",
    exchange: "Échanger",
    from: "Échanger de",
    gas: "Gaz",
    payWith: "Payer avec",
    purchase: "Acheter",
    purchaseDetails: "Détails de l'achat",
    selectChain: "Sélectionner la chaîne",
    selectWallet: "Sélectionnez votre portefeuille",
    settings: "Paramètres",
    swap: "Échanger",
    to: "Échanger pour",
    transactionDetails: "Détails de la transaction",
    transactionHistory: "Historique de transaction",
    walletConnected: "Portefeuille connecté",
    youGet: "Vous obtenez"
  },
  TWe = {
    message: {
      autoRefuel: "Vous avez peu de gaz sur {{chainName}}. En continuant, vous aurez assez de gaz pour compléter l'échange.",
      emptyActiveTransactions: "Les transactions en cours apparaîtront ici. Une fois terminées, retrouvez-les dans l'historique des transactions.",
      emptyTokenList: "Nous n'avons pas pu trouver de jetons sur la chaîne {{chainName}} ou vous n'en avez pas. Veuillez rechercher par adresse de contrat si votre jeton n'apparaît pas ou choisissez une autre chaîne.",
      emptyTransactionHistory: "L'historique de transaction est uniquement stocké au niveau local et sera supprimé si vous effacez les données de votre navigateur.",
      routeNotFound: "Raisons possibles : faible liquidité, le montant sélectionné est trop faible, les coûts de gaz sont trop élevés ou il n'y a pas de routes pour la combinaison sélectionnée."
    },
    title: {
      autoRefuel: "Obtenir du gaz",
      emptyActiveTransactions: "Pas de transactions actives",
      emptyTransactionHistory: "Pas de transactions récentes",
      routeNotFound: "Aucun itinéraire disponible"
    }
  },
  kWe = {
    message: {
      exchangePartiallySuccessful: "Nous avons essayé de compléter la transaction, mais {{tool}} a manqué de liquidité pour le jeton {{tokenSymbol}}.",
      exchangeSuccessful: "Il y a maintenant {{amount, number(maximumFractionDigits: 4)}} {{tokenSymbol}} dans le portefeuille {{walletAddress}} sur la chaîne {{chainName}}.",
      purchaseSuccessful: "Vous possédez maintenant {{assetName}} dans le portefeuille {{walletAddress}} sur la chaîne {{chainName}}."
    },
    title: {
      bridgePartiallySuccessful: "Pont partiellement réussi",
      bridgeSuccessful: "Pont réussi",
      purchaseSuccessful: "Achat effectué",
      refundIssued: "Remboursement émis",
      swapPartiallySuccessful: "Échange partiellement réussi",
      swapSuccessful: "Échange réussi"
    }
  },
  _We = {
    message: {
      deleteActiveTransactions: "Les transactions actives ne sont stockées que localement et ne peuvent être récupérées si vous les supprimez.",
      deleteTransactionHistory: "L'historique d transaction est uniquement stocké localement et ne peut être récupéré si vous le supprimez.",
      highValueLoss: "La valeur des jetons reçus est nettement inférieure à celle des jetons échangés et au coût de la transaction.",
      insufficientFunds: "Vous n'avez pas assez de fonds pour finaliser l'échange.",
      insufficientGas: "Vous n'avez pas assez de gaz pour finaliser l'échange. Vous devez avoir au moins:",
      rateChanged: "Le taux de change a changé. En continuant l'échange, vous devrez accepter le nouveau taux.",
      resetSettings: "Cela réinitialisera la priorité de votre itinéraire, l'effet de glissement, le prix du gaz, les ponts et les plateformes d'échanges activés."
    },
    title: {
      deleteActiveTransactions: "Supprimer toutes les transactions actives ?",
      deleteTransaction: "Supprimer cette transaction ?",
      deleteTransactionHistory: "Supprimer l'historique de transaction ?",
      highValueLoss: "Perte de valeur élevée",
      insufficientGas: "Gaz insuffisant",
      rateChanged: "Taux modifié",
      resetSettings: "Réinitialiser les paramètres ?"
    }
  },
  IWe = {
    message: {
      allowanceRequired: "Le montant du transfert pour {{tokenSymbol}} dépasse votre allocation actuelle. Veuillez augmenter votre allocation et réessayer.",
      insufficientFunds: "Vous n'avez pas assez de gaz pour couvrir le coût de la transaction.",
      slippageThreshold: "L'effet de glissement est supérieur au seuil défini. Veuillez demander un nouvel itinéraire pour obtenir un nouveau devis.",
      transactionFailed: "Veuillez consulter l'explorateur de blocs pour plus d'informations.",
      transactionNotSent: "La transaction n'a pas été envoyée. {{amount, number(maximumFractionDigits: 9)}} {{tokenSymbol}} sur {{chainName}} restent dans votre portefeuille.",
      transactionRejected: "Votre signature est requise pour compléter la transaction. {{amount, number(maximumFractionDigits: 4)}} {{tokenSymbol}} sur {{chainName}} restent dans votre portefeuille.",
      unknown: "Veuillez réessayer ou contacter le support."
    },
    title: {
      allowanceRequired: "Allocation insuffisante",
      balanceIsTooLow: "Le solde est trop bas.",
      chainSwitch: "Changement de chaîne nécessaire.",
      gasLimitIsTooLow: "La limite de gaz est trop basse.",
      insufficientFunds: "Fonds insuffisants",
      slippageNotMet: "Les conditions de l'effet de glissement ne sont pas remplies.",
      transactionCanceled: "Transaction annulée.",
      transactionFailed: "La transaction a échoué.",
      transactionRejected: "Signature requise.",
      transactionUnderpriced: "La transaction est sous-évaluée.",
      transactionUnprepared: "Impossible de préparer la transaction.",
      unknown: "Il y a eu un problème.",
      walletAddressInvalid: "L'adresse du portefeuille n'est pas valide.",
      walletAddressRequired: "L'adresse du portefeuille est nécessaire.",
      walletEnsAddressInvalid: "L'adresse du portefeuille n'est pas valide ou le réseau ne supporte pas l'ENS."
    }
  },
  PWe = {
    additionalProviderFee: "Ponts additionnels, DEX et frais de service.",
    estimatedNetworkFee: "Frais de réseau estimés.",
    estimatedTime: "Durée d'exécution de l'échange estimé en minutes.",
    notFound: {
      text: "Nous n'avons pas trouvé cette page.",
      title: "404"
    },
    numberOfSteps: "Un certain nombre d'étapes d'échange. Chaque étape peut contenir 1 à 2 transactions nécessitant une signature.",
    progressToNextUpdate: "Les données affichées seront automatiquement actualisées après {{value}} secondes. Cliquez ici pour les mettre à jour manuellement.",
    recommended: "Une voie bon marché qui équilibre complexité et facilité d'utilisation.",
    settingsModified: "Paramètres (modifiés)"
  },
  RWe = {
    crossStepDetails: "Passer de {{from}} à {{to}} via {{tool}}",
    currentAmount: "Montant actuel",
    estimatedTime: "{{value}}m",
    featuredTokens: "Jetons en vedette",
    from: "De",
    fromAmount: "Vous payez",
    gasCost: "Coût du gaz",
    gasFeeEstimated: "frais de gaz estimés",
    gasFeePaid: "frais de gaz payés",
    inProgress: "en cours",
    nftStepDetails: "Acheter un NFT via {{tool}}",
    onChain: "sur {{chainName}}",
    otherTokens: "Autres jetons",
    ownedBy: "Propriétaire",
    process: {
      crossChain: {
        actionRequired: "Veuillez signer la transaction.",
        done: "Transaction Bridge confirmée",
        pending: "En attente de la transaction bridge",
        started: "Préparation de la transaction bridge"
      },
      nft: {
        done: "NFT acheté"
      },
      receivingChain: {
        done: "Bridge complété",
        partial: "Bridge partiellement complété",
        pending: "En attente de la chaîne de destination",
        refunded: "Transaction bridge remboursée"
      },
      swap: {
        actionRequired: "Veuillez signer la transaction.",
        done: "Échange terminé.",
        pending: "En attente de la transaction d'échange",
        started: "Préparation de la transaction d'échange"
      },
      switchChain: {
        actionRequired: "Changement de chaîne requis.",
        done: "Chaîne changée avec succès."
      },
      tokenAllowance: {
        done: "Allocation de jetons approuvée.",
        pending: "En attente de l'allocation de jetons",
        started: "Fixation de l'allocation de jeton."
      }
    },
    quotedAmount: "Montant indiqué",
    rateChange: "Taux de change",
    receiving: "En cours de réception",
    refuelStepDetails: "Obtenir du gaz via {{tool}}",
    selectChain: "Sélectionner la chaîne",
    selectChainAndToken: "Sélectionnez la chaîne et le jeton",
    selectToken: "Choisissez un jeton",
    sendToAddress: "Envoyer à {{address}}",
    sendToWallet: "Envoyer vers un autre portefeuille",
    sending: "Envoi",
    sentToAddress: "Envoyé à {{address}}",
    stepBridge: "Bridge",
    stepBridgeAndBuy: "Bridge et acheter",
    stepDetails: "{{tool}} via LI.FI",
    stepSwap: "Échanger",
    stepSwapAndBridge: "Échange et Bridge",
    stepSwapAndBuy: "Échanger et acheter",
    supportId: "ID de support",
    swapStepDetails: "Échanger sur {{chain}} via {{tool}}",
    tags: {
      cheapest: "Pas cher",
      fastest: "Rapide",
      insurable: "Assurable",
      insurance: "Assurance",
      insured: "Assuré",
      recommended: "Recommandé",
      safest: "Sûr"
    },
    to: "À",
    tokenOnChain: "{{tokenSymbol}} sur {{chainName}}",
    tokenOnChainAmount: "{{amount, number(maximumFractionDigits: 4)}} {{tokenSymbol}} sur {{chainName}}",
    tokenSearch: "Recherche par nom de jeton ou adresse",
    valueLoss: "Perte de valeur",
    walletAddressOrEns: "Adresse du portefeuille ou nom ENS"
  },
  OWe = {
    bridgeExploits: "Des dysfonctionnements de pont, des hacks ou des exploits",
    insure: "Assurer <0>{{amount, number(maximumFractionDigits: 9)}} {{tokenSymbol}}</0> en transit :",
    insured: "Vous avez assuré <0>{{amount, number(maximumFractionDigits: 9)}} {{tokenSymbol}}</0> en transit :",
    slippageError: "Erreur dans le slippage pour les jetons reçus"
  },
  DWe = {
    enabledBridges: "Bridges activés",
    enabledExchanges: "Échanges autorisés",
    gasPrice: {
      fast: "Rapide",
      normal: "Normal",
      slow: "Lent",
      title: "Prix du gaz"
    },
    routePriority: "Priorité de l'itinéraire",
    showDestinationWallet: "Afficher le portefeuille de destination",
    slippage: "Effet de glissement",
    resetSettings: "Vous utilisez des paramètres personnalisés limitant le nombre de routes disponibles."
  },
  NWe = {
    extensionNotFound: "Veuillez vous assurer que seule l'extension de navigateur {{name}} est active avant de choisir ce portefeuille."
  },
  MWe = {
    language: EWe,
    format: SWe,
    button: CWe,
    header: AWe,
    info: TWe,
    success: kWe,
    warning: _We,
    error: IWe,
    tooltip: PWe,
    main: RWe,
    insurance: OWe,
    settings: DWe,
    wallet: NWe
  },
  $We = {
    name: "Indonesian",
    title: "Bahasa"
  },
  LWe = {
    currency: "{{value, currency(currency: USD)}}",
    number: "{{value, number(maximumFractionDigits: 9)}}"
  },
  BWe = {
    auto: "Otomatis",
    bridge: "Bridge",
    buy: "Beli",
    buyNow: "Beli sekarang",
    cancel: "Batal",
    connectWallet: "Hubungkan dompet",
    contactSupport: "Kontak bantuan",
    continue: "Lanjutkan",
    copyAddress: "Salin alamat",
    dark: "Gelap",
    delete: "Hapus",
    disconnect: "Tidak terkoneksi",
    done: "Selesai",
    exchange: "Pertukaran",
    getGas: "Dapatkan gas",
    hide: "Sembunyikan",
    learnMore: "Pelajari lebih lanjut",
    lifiCheckout: "Pembayaran LI.FI",
    lifiExchange: "Pertukaran LI.FI",
    light: "Terang",
    max: "maks",
    ok: "Ya",
    removeTransaction: "Hapus transaksi",
    reset: "Atur ulang",
    resetSettings: "Setel ulang pengaturan",
    reviewBridge: "Peninjauan bridge",
    reviewPurchase: "Tinjau pembelian",
    reviewSwap: "Tinjau swap",
    seeDetails: "Lihat rinciannya",
    showAll: "Tampilkan semua",
    startBridging: "Mulai bridge",
    startSwapping: "Mulai swap",
    swap: "Swap",
    tryAgain: "Coba lagi",
    viewCoverage: "Melihat cakupan",
    viewOnExplorer: "Lihat di explorer"
  },
  FWe = {
    activeTransactions: "Transaksi aktif",
    bridge: "Bridge",
    checkout: "Checkout",
    exchange: "Pertukaran",
    from: "Swap dari",
    gas: "Gas",
    payWith: "Bayar dengan",
    purchase: "Pembelian",
    purchaseDetails: "Detail pembelian",
    selectChain: "Pilih jaringan",
    selectWallet: "Pilih dompet",
    settings: "Pengaturan",
    swap: "Swap",
    to: "Swap ke",
    transactionDetails: "Rincian transaksi",
    transactionHistory: "Riwayat transaksi",
    walletConnected: "Dompet terhubung",
    youGet: "Anda mendapatkan"
  },
  jWe = {
    message: {
      autoRefuel: "Gas anda hampir habis {{chainName}}. Dengan melanjutkan, anda akan mendapatkan cukup gas untuk menyelesaikan penukaran.",
      emptyActiveTransactions: "Transaksi yang sedang berlangsung akan muncul di sini. Setelah selesai, temukan di riwayat transaksi.",
      emptyTokenList: "Kami tidak dapat menemukan token di jaringan {{chainName}} atau Anda tidak memilikinya. Silakan cari berdasarkan alamat kontrak jika token Anda tidak muncul atau pilih jaringan lain.",
      emptyTransactionHistory: "Riwayat transaksi hanya disimpan secara lokal dan akan dihapus jika Anda menghapus data browser.",
      routeNotFound: "Alasannya mungkin: likuiditas rendah, jumlah yang dipilih terlalu rendah, biaya gas terlalu tinggi, atau tidak ada rute untuk kombinasi yang dipilih."
    },
    title: {
      autoRefuel: "Dapatkan gas",
      emptyActiveTransactions: "Tidak ada transaksi yang aktif",
      emptyTransactionHistory: "Tidak ada transaksi terbaru",
      routeNotFound: "Rute tidak tersedia"
    }
  },
  UWe = {
    message: {
      exchangePartiallySuccessful: "Kami telah mencoba menyelesaikan transaksi, tetapi {{tool}} kehabisan likuiditas untuk token {{tokenSymbol}}.",
      exchangeSuccessful: "Sekarang ada {{amount, number(maximumFractionDigits: 9)}} {{tokenSymbol}} di dompet {{walletAddress}} pada jaringan {{chainName}}.",
      purchaseSuccessful: "Anda sekarang memiliki {{assetName}} di dompet {{walletAddress}} di chain {{chainName}}."
    },
    title: {
      bridgePartiallySuccessful: "Bridge sebagian berhasil",
      bridgeSuccessful: "Bridge berhasil",
      purchaseSuccessful: "Pembelian berhasil",
      refundIssued: "Pengembalian dana diterbitkan",
      swapPartiallySuccessful: "Swap sebagian berhasil",
      swapSuccessful: "Swap berhasil"
    }
  },
  zWe = {
    message: {
      deleteActiveTransactions: "Transaksi aktif hanya disimpan secara lokal dan tidak dapat dipulihkan jika Anda menghapusnya.",
      deleteTransactionHistory: "Riwayat transaksi hanya disimpan secara lokal dan tidak dapat dipulihkan jika Anda menghapusnya.",
      highValueLoss: "Nilai token yang diterima jauh lebih rendah daripada token yang ditukar dan biaya transaksi.",
      insufficientFunds: "Anda tidak memiliki cukup dana untuk menyelesaikan penukaran.",
      insufficientGas: "Anda tidak memiliki cukup gas untuk menyelesaikan penukaran. Anda perlu menambahkan setidaknya:",
      rateChanged: "Nilai tukar telah berubah. Dengan melanjutkan penukaran, Anda akan menerima tarif baru.",
      resetSettings: "Ini akan mengatur ulang prioritas rute Anda, slippage, harga gas, jembatan yang diaktifkan, dan pertukaran."
    },
    title: {
      deleteActiveTransactions: "Hapus seluruh transaksi aktif?",
      deleteTransaction: "Hapus transaksi ini?",
      deleteTransactionHistory: "Hapus riwayat transaksi?",
      highValueLoss: "Kehilangan nilai tinggi",
      insufficientGas: "Gas tidak mencukupi",
      rateChanged: "Rate berubah",
      resetSettings: "Setel ulang pengaturan?"
    }
  },
  HWe = {
    message: {
      allowanceRequired: "Jumlah transfer untuk {{tokenSymbol}} melebihi jatah Anda saat ini. Tingkatkan jatah Anda dan coba lagi.",
      insufficientFunds: "Anda tidak memiliki cukup gas untuk menutup biaya transaksi.",
      slippageThreshold: "Slippage lebih besar dari ambang batas yang ditentukan. Silakan minta rute baru untuk mendapatkan penawaran baru.",
      transactionFailed: "Silakan periksa block explorer untuk informasi lebih lanjut.",
      transactionNotSent: "Transaksi tidak terkirim. {{amount, number(maximumFractionDigits: 9)}} {{tokenSymbol}} di {{chainName}} tetap berada di dompet Anda.",
      transactionRejected: "Tanda tangan Anda diperlukan untuk menyelesaikan transaksi. {{amount, number(maximumFractionDigits: 9)}} {{tokenSymbol}} di {{chainName}} tetap berada di dompet Anda.",
      unknown: "Silakan coba lagi atau hubungi bagian dukungan."
    },
    title: {
      allowanceRequired: "Saldo tidak mencukupi",
      balanceIsTooLow: "Saldo Anda terlalu sedikit",
      chainSwitch: "Penggantian jaringan diperlukan",
      gasLimitIsTooLow: "Gas limit terlalu rendah",
      insufficientFunds: "Dana tidak mencukupi",
      slippageNotMet: "Kondisi slippage tidak terpenuhi",
      transactionCanceled: "Transaksi dibatalkan",
      transactionFailed: "Transaksi gagal",
      transactionRejected: "Tanda tangan diperlukan",
      transactionUnderpriced: "Transaksi di bawah harga",
      transactionUnprepared: "Tidak dapat menguraikan transaksi",
      unknown: "Terjadi kesalahan",
      walletAddressInvalid: "Alamat dompet tidak valid.",
      walletAddressRequired: "Alamat dompet diperlukan.",
      walletEnsAddressInvalid: "Alamat dompet tidak valid atau jaringan tidak mendukung ENS."
    }
  },
  VWe = {
    additionalProviderFee: "Jembatan tambahan, DEX, dan biaya layanan.",
    estimatedNetworkFee: "Perkiraan biaya jaringan.",
    estimatedTime: "Perkiraan waktu eksekusi swap dalam hitungan menit.",
    notFound: {
      text: "Kami tidak dapat menemukan halaman ini.",
      title: "404"
    },
    numberOfSteps: "Sejumlah langkah swap. Setiap langkah dapat berisi 1-2 transaksi yang memerlukan tanda tangan.",
    progressToNextUpdate: "Data yang ditampilkan akan disegarkan secara otomatis setelah {{value}} detik. Klik di sini untuk memperbarui secara manual.",
    recommended: "Rute murah yang menyeimbangkan kerumitan dan kemudahan penggunaan.",
    settingsModified: "Pengaturan (diubah)"
  },
  WWe = {
    crossStepDetails: "Bridge dari {{from}} to {{to}} via {{tool}}",
    currentAmount: "Jumlah saat ini",
    estimatedTime: "{{value}}m",
    featuredTokens: "Token unggulan",
    from: "Dari",
    fromAmount: "Anda membayar",
    gasCost: "Biaya Gas",
    gasFeeEstimated: "perkiraan biaya gas",
    gasFeePaid: "biaya gas yang dibayar",
    inProgress: "dalam proses",
    nftStepDetails: "Beli NFT melalui {{tool}}",
    onChain: "di {{chainName}}",
    otherTokens: "Token lainnya",
    ownedBy: "Dimiliki oleh",
    process: {
      crossChain: {
        actionRequired: "Mohon konfirmasi transaksi",
        done: "Bridge dikonfirmasi",
        pending: "Menunggu transaksi bridge",
        started: "Mempersiapkan transaksi bridge"
      },
      nft: {
        done: "NFT dibeli"
      },
      receivingChain: {
        done: "Bridge selesai",
        partial: "Bridge sebagian selesai",
        pending: "Menunggu jaringan tujuan",
        refunded: "Dana transaksi bridge dikembalikan"
      },
      swap: {
        actionRequired: "Mohon konfirmasi transaksi",
        done: "Swap selesai",
        pending: "Menunggu transaksi swap",
        started: "Mempersiapkan transaksi swap"
      },
      switchChain: {
        actionRequired: "Penggantian jaringan diperlukan",
        done: "Penggantian jaringan berhasil"
      },
      tokenAllowance: {
        done: "Izin token disetujui",
        pending: "Menunggu untuk izin token",
        started: "Pengaturan izin token"
      }
    },
    quotedAmount: "Jumlah yang dikutip",
    rateChange: "Perubahan rate",
    receiving: "Menerima",
    refuelStepDetails: "Dapatkan gas melalui {{tool}}",
    selectChain: "Pilih jaringan",
    selectChainAndToken: "Pilih jaringan dan token",
    selectToken: "Pilih token",
    sendToAddress: "Kirim ke {{address}}",
    sendToWallet: "Kirim ke dompet berbeda",
    sending: "Mengirim",
    sentToAddress: "Dikirim ke {{address}}",
    stepBridge: "Bridge",
    stepBridgeAndBuy: "Bridge dan beli",
    stepDetails: "{{tool}} melalui LI.FI",
    stepSwap: "Swap",
    stepSwapAndBridge: "Swap dan bridge",
    stepSwapAndBuy: "Swap dan beli",
    supportId: "ID dukungan",
    swapStepDetails: "Swap di {{chain}} melalui {{tool}}",
    tags: {
      cheapest: "Murah",
      fastest: "Cepat",
      insurable: "Dapat diasuransikan",
      insurance: "Asuransi",
      insured: "Diasuransikan",
      recommended: "Direkomendasikan",
      safest: "Aman"
    },
    to: "Kepada",
    tokenOnChain: "{{tokenSymbol}} di {{chainName}}",
    tokenOnChainAmount: "{{amount, number(maximumFractionDigits: 9)}} {{tokenSymbol}} di {{chainName}}",
    tokenSearch: "Cari berdasarkan nama atau alamat token",
    valueLoss: "Kehilangan nilai",
    walletAddressOrEns: "Alamat dompet atau nama ENS"
  },
  qWe = {
    bridgeExploits: "Malfungsi jembatan, peretasan, atau eksploitasi",
    insure: "Asuransikan <0>{{amount, number(maximumFractionDigits: 9)}} {{tokenSymbol}}</0> dalam perjalanan.",
    insured: "Anda telah mengasuransikan <0>{{amount, number(maximumFractionDigits: 9)}} {{tokenSymbol}}</0> dalam perjalanan:",
    slippageError: "Kesalahan dalam slippage untuk token yang diterima"
  },
  GWe = {
    enabledBridges: "Jembatan diaktifkan",
    enabledExchanges: "Pertukaran diaktifkan",
    gasPrice: {
      fast: "Cepat",
      normal: "Normal",
      slow: "Lambat",
      title: "Harga gas"
    },
    routePriority: "Prioritas rute",
    showDestinationWallet: "Tampilkan Alamat Tujuan",
    slippage: "Slippage"
  },
  KWe = {
    extensionNotFound: "Pastikan hanya ekstensi browser {{name}} yang aktif sebelum memilih dompet ini."
  },
  QWe = {
    language: $We,
    format: LWe,
    button: BWe,
    header: FWe,
    info: jWe,
    success: UWe,
    warning: zWe,
    error: HWe,
    tooltip: VWe,
    main: WWe,
    insurance: qWe,
    settings: GWe,
    wallet: KWe
  },
  YWe = {
    name: "Italiano",
    title: "Lingua"
  },
  JWe = {
    currency: "{{value, currency(currency: USD)}}",
    number: "{{value, number(maximumFractionDigits: 9)}}"
  },
  XWe = {
    auto: "Auto",
    bridge: "Bridge",
    buy: "Acquista",
    buyNow: "Acquista subito",
    cancel: "Annulla",
    connectWallet: "Collega il portafoglio",
    contactSupport: "Contatta l'assistenza",
    continue: "Continua",
    copyAddress: "Copia indirizzo",
    dark: "Scuro",
    delete: "Elimina",
    disconnect: "Disconnetti",
    done: "Fatto",
    exchange: "Scambia",
    getGas: "Ottieni gas",
    hide: "Nascondi",
    learnMore: "Ulteriori informazioni",
    lifiCheckout: "LI.FI Checkout",
    lifiExchange: "LI.FI Exchange",
    light: "Chiaro",
    max: "massimo",
    ok: "Ok",
    removeTransaction: "Rimuovi transazione",
    reset: "Ripristina",
    resetSettings: "Ripristina impostazioni",
    reviewBridge: "Rivedi bridge",
    reviewPurchase: "Rivedi acquisto",
    reviewSwap: "Rivedi lo scambio",
    seeDetails: "Vedi dettagli",
    showAll: "Mostra tutto",
    startBridging: "Inizia il bridge",
    startSwapping: "Avvia lo scambio",
    swap: "Scambio",
    tryAgain: "Riprova",
    viewCoverage: "Vedi copertura",
    viewOnExplorer: "Visualizza sull'Explorer"
  },
  ZWe = {
    activeTransactions: "Transazioni attive",
    bridge: "Bridge",
    checkout: "Checkout",
    exchange: "Exchange",
    from: "Scambia da",
    gas: "Gas",
    payWith: "Paga con",
    purchase: "Acquista",
    purchaseDetails: "Dettagli di acquisto",
    selectChain: "Seleziona la chain",
    selectWallet: "Seleziona il tuo portafoglio",
    settings: "Impostazioni",
    swap: "Scambio",
    to: "Scambia a",
    transactionDetails: "Dettagli transazione",
    transactionHistory: "Storico Transazioni",
    walletConnected: "Portafoglio collegato",
    youGet: "Ricevi"
  },
  eqe = {
    message: {
      autoRefuel: "Livello basso di gas su {{chainName}}. Continuando avrai abbastanza gas per completare lo scambio.",
      emptyActiveTransactions: "Le transazioni in corso appariranno qui. Una volta completate, potrai trovarle nella cronologia delle transazioni.",
      emptyTokenList: "Non siamo riusciti a trovare token sulla chain {{chainName}} o non ne hai. Riprova o scegli un'altra chain.",
      emptyTransactionHistory: "La cronologia delle transazioni è memorizzata solo localmente e verrà eliminata se si cancellano i dati del browser.",
      routeNotFound: "Le ragioni potrebbero essere: bassa liquidità, la quantità selezionata è troppo bassa, i costi del gas sono troppo elevati o non ci sono routes per la combinazione selezionata."
    },
    title: {
      autoRefuel: "Ottieni gas",
      emptyActiveTransactions: "Nessuna transazione attiva",
      emptyTransactionHistory: "Nessuna transazione recente",
      routeNotFound: "Nessuna rotta disponibile"
    }
  },
  tqe = {
    message: {
      exchangePartiallySuccessful: "Abbiamo provato a completare la transazione, ma {{tool}} ha esaurito la liquidità per il token {{tokenSymbol}}.",
      exchangeSuccessful: "Sono presenti ora {{amount, number(maximumFractionDigits: 9)}} {{tokenSymbol}} nel portafoglio {{walletAddress}} sulla chain {{chainName}}.",
      purchaseSuccessful: "Ora possiedi {{assetName}} nel wallet {{walletAddress}} sulla chain {{chainName}}."
    },
    title: {
      bridgePartiallySuccessful: "Bridge parzialmente completato con successo",
      bridgeSuccessful: "Bridge avvenuto con successo",
      purchaseSuccessful: "Acquisto completato",
      refundIssued: "Rimborso inviato",
      swapPartiallySuccessful: "Scambio parzialmente completato con successo",
      swapSuccessful: "Scambio completato con successo"
    }
  },
  nqe = {
    message: {
      deleteActiveTransactions: "Gli scambi attivi vengono memorizzati solo localmente e non possono essere recuperati se vengono cancellati.",
      deleteTransactionHistory: "La cronologia delle transazioni è memorizzata solo localmente e non può essere recuperata se la elimini.",
      highValueLoss: "Il valore dei token ricevuti è significativamente inferiore ai token scambiati più il costo della transazione.",
      insufficientFunds: "Non hai abbastanza fondi per completare lo scambio.",
      insufficientGas: "Non hai abbastanza gas per completare lo scambio. Devi aggiungere almeno:",
      rateChanged: "Il tasso di scambio è cambiato. Se procedi, confermi di accettare il nuovo tasso.",
      resetSettings: "Questo porterà al ripristino della priorità di route, slittamento di prezzo, prezzo del gas, bridge abilitati ed exchanges."
    },
    title: {
      deleteActiveTransactions: "Eliminare tutte le transazioni attive?",
      deleteTransaction: "Eliminare questa transazione?",
      deleteTransactionHistory: "Eliminare la cronologia transazioni?",
      highValueLoss: "Perdita di valore elevato",
      insufficientGas: "Gas insufficiente",
      rateChanged: "Tasso cambiato",
      resetSettings: "Ripristinare le impostazioni?"
    }
  },
  rqe = {
    message: {
      allowanceRequired: "L'importo di {{tokenSymbol}} supera la tua quota massima permessa. Aumenta la quota e riprova.",
      insufficientFunds: "Non hai abbastanza gas per coprire il costo della transazione.",
      slippageThreshold: "Lo slittamento di prezzo è più alto della soglia definita. Si prega di richiedere una nuova route per ottenere una quota aggiornata.",
      transactionFailed: "Per ulteriori informazioni, consultare il block explorer.",
      transactionNotSent: "La transazione non è stata inviata. {{amount, number(maximumFractionDigits: 9)}} {{tokenSymbol}} su {{chainName}} sono ancora presenti nel tuo portafoglio.",
      transactionRejected: "Per completare la transazione è necessaria la tua firma. {{amount, number(maximumFractionDigits: 9)}} {{tokenSymbol}} su {{chainName}} rimangono nel tuo portafoglio.",
      unknown: "Riprova o contatta il nostro supporto."
    },
    title: {
      allowanceRequired: "Quota massima insufficiente",
      balanceIsTooLow: "Il saldo è troppo basso",
      chainSwitch: "È necessario cambiare la chain",
      gasLimitIsTooLow: "Limite di gas troppo basso",
      insufficientFunds: "Fondi insufficienti",
      slippageNotMet: "Condizioni di slittamento di prezzo non rispettate",
      transactionCanceled: "Transazione cancellata",
      transactionFailed: "Transazione fallita",
      transactionRejected: "Firma obbligatoria",
      transactionUnderpriced: "L'operazione è sottostimata",
      transactionUnprepared: "Impossibile preparare la transazione",
      unknown: "Qualcosa è andato storto",
      walletAddressInvalid: "L'indirizzo del portafoglio non è valido.",
      walletAddressRequired: "L'indirizzo è un campo obbligatorio.",
      walletEnsAddressInvalid: "L'indirizzo non è valido o la rete non supporta ENS."
    }
  },
  iqe = {
    additionalProviderFee: "Bridge aggiuntivi, DEX e spese di servizio.",
    estimatedNetworkFee: "Costo di rete stimato.",
    estimatedTime: "Tempo di esecuzione dello scambio stimato in minuti.",
    notFound: {
      text: "Non siamo riusciti a trovare questa pagina.",
      title: "404"
    },
    numberOfSteps: "Una serie di fasi di scambio. Ogni fase può contenere 1-3 transazioni che richiedono una firma.",
    progressToNextUpdate: "I dati visualizzati si aggiorneranno automaticamente dopo {{value}} secondi. Fai click qui per aggiornare manualmente.",
    recommended: "Una rotta economica che equilibra complessità e facilità di utilizzo.",
    settingsModified: "Impostazioni (modificate)"
  },
  sqe = {
    crossStepDetails: "Trasferisci da {{from}} a {{to}} tramite {{tool}}",
    currentAmount: "Quantità corrente",
    estimatedTime: "{{value}}m",
    featuredTokens: "Token in evidenza",
    from: "Da",
    fromAmount: "Paghi",
    gasCost: "Costo del gas",
    gasFeeEstimated: "tassa di gas stimata",
    gasFeePaid: "tassa di gas pagata",
    inProgress: "in corso",
    nftStepDetails: "Acquista NFT tramite {{tool}}",
    onChain: "su {{chainName}}",
    otherTokens: "Altri token",
    ownedBy: "Di proprietà di",
    process: {
      crossChain: {
        actionRequired: "Si prega di firmare la transazione",
        done: "Transazione di bridge approvata",
        pending: "In attesa della transazione di bridge",
        started: "Preparazione della transazione di bridge"
      },
      nft: {
        done: "NFT acquistati"
      },
      receivingChain: {
        done: "Bridge completato",
        partial: "Bridge parzialmente completato",
        pending: "In attesa della chain di destinazione",
        refunded: "Transazione di bridge rimborsata"
      },
      swap: {
        actionRequired: "Si prega di firmare la transazione",
        done: "Scambio completato",
        pending: "In attesa della transazione di scambio",
        started: "Preparazione dello scambio"
      },
      switchChain: {
        actionRequired: "È necessario cambiare la chain",
        done: "La chain è stata cambiata con successo"
      },
      tokenAllowance: {
        done: "Indennità del token approvata",
        pending: "In attesa dell'indennità del token",
        started: "Applicazione dell'indennità di token"
      }
    },
    quotedAmount: "Totale quotato",
    rateChange: "Tasso di scambio",
    receiving: "In ricezione",
    refuelStepDetails: "Ottieni gas tramite {{tool}}",
    selectChain: "Seleziona la chain",
    selectChainAndToken: "Selezionare la chain ed il token",
    selectToken: "Seleziona un token",
    sendToAddress: "Invia a {{address}}",
    sendToWallet: "Invia ad un altro portafoglio",
    sending: "Invio in corso",
    sentToAddress: "Inviati a {{address}}",
    stepBridge: "Bridge",
    stepBridgeAndBuy: "Trasferisci e acquista",
    stepDetails: "{{tool}} tramite LI.FI",
    stepSwap: "Scambio",
    stepSwapAndBridge: "Scambia e bridge",
    stepSwapAndBuy: "Scambia e acquista",
    supportId: "ID supporto",
    swapStepDetails: "Scambio su {{chain}} tramite {{tool}}.",
    tags: {
      cheapest: "Economico",
      fastest: "Veloce",
      insurable: "Assicurabile",
      insurance: "Assicurazione",
      insured: "Assicurato",
      recommended: "Consigliato",
      safest: "Sicuro"
    },
    to: "A",
    tokenOnChain: "{{tokenSymbol}} su {{chainName}}",
    tokenOnChainAmount: "{{amount, number(maximumFractionDigits: 9)}} {{tokenSymbol}} su {{chainName}}",
    tokenSearch: "Cerca per nome token o indirizzo",
    valueLoss: "Perdita di valore",
    walletAddressOrEns: "Indirizzo del portafoglio o nome ENS"
  },
  oqe = {
    bridgeExploits: "Malfunzionamenti, hack o exploit di bridge",
    insure: "Assicura <0>{{amount, number(maximumFractionDigits: 9)}} {{tokenSymbol}}</0> in transito.",
    insured: "Hai assicurato <0>{{amount, number(maximumFractionDigits: 9)}} {{tokenSymbol}}</0> in transito:",
    slippageError: "Errore nello slippage dei token ricevuti"
  },
  aqe = {
    enabledBridges: "Bridge abilitati",
    enabledExchanges: "Exchange abilitati",
    gasPrice: {
      fast: "Veloce",
      normal: "Normale",
      slow: "Lento",
      title: "Prezzo gas"
    },
    routePriority: "Priorità di route",
    showDestinationWallet: "Mostra il portafoglio di destinazione",
    slippage: "Slittamento"
  },
  cqe = {
    extensionNotFound: "Assicurati che solo l'estensione {{name}} del browser sia attiva prima di scegliere questo portafoglio."
  },
  lqe = {
    language: YWe,
    format: JWe,
    button: XWe,
    header: ZWe,
    info: eqe,
    success: tqe,
    warning: nqe,
    error: rqe,
    tooltip: iqe,
    main: sqe,
    insurance: oqe,
    settings: aqe,
    wallet: cqe
  },
  uqe = {
    name: "한국어",
    title: "언어"
  },
  dqe = {
    currency: "{{value, currency(currency: USD)}}",
    number: "{{value, number(maximumFractionDigits: 9)}}"
  },
  fqe = {
    auto: "자동",
    bridge: "브릿지",
    buy: "매수",
    buyNow: "즉시 매수",
    cancel: "취소",
    connectWallet: "지갑 연결",
    contactSupport: "고객 지원",
    continue: "계속",
    copyAddress: "주소 복사",
    dark: "어둡게",
    delete: "삭제",
    disconnect: "연결 해제",
    done: "완료",
    exchange: "교환",
    getGas: "가스 받기",
    hide: "숨기기",
    learnMore: "자세히 알아보기",
    lifiCheckout: "LI.FI 결제",
    lifiExchange: "LI.FI 교환",
    light: "밝게",
    max: "최대",
    ok: "확인",
    removeTransaction: "거래 지우기",
    reset: "초기화",
    resetSettings: "설정 초기화",
    reviewBridge: "브릿지 리뷰",
    reviewPurchase: "매수 검토",
    reviewSwap: "스왑 검토",
    seeDetails: "자세히 보기",
    showAll: "모두 보기",
    startBridging: "브릿지 시작하기",
    startSwapping: "스왑 시작하기",
    swap: "스왑",
    tryAgain: "다시 시도",
    viewCoverage: "보장 범위",
    viewOnExplorer: "탐색기에서 보기"
  },
  hqe = {
    activeTransactions: "활성화된 거래",
    bridge: "브릿지",
    checkout: "주문",
    exchange: "교환",
    from: "다음에서 스왑",
    gas: "가스",
    payWith: "결제 수단",
    purchase: "구입",
    purchaseDetails: "주문 세부사항",
    selectChain: "체인 선택",
    selectWallet: "지갑 선택",
    settings: "설정",
    swap: "스왑",
    to: "다음으로 스왑",
    transactionDetails: "거래 세부사항",
    transactionHistory: "거래 내역",
    walletConnected: "지갑 연결됨",
    youGet: "받는 수량"
  },
  pqe = {
    message: {
      autoRefuel: "현재 {{chainName}} 가스가 부족합니다. 이 기능을 통하여 스왑을 완료할 가스를 보충할 수 있습니다.",
      emptyActiveTransactions: "진행 중인 스왑이 여기에 나타납니다. 완료 후에는 스왑 기록을 참조하십시오",
      emptyTokenList: "{{chainName}} 체인에서 토큰을 찾을 수 없거나 보유 중인 토큰이 아닙니다. 다시 검색하거나 다른 체인을 선택하십시오.",
      emptyTransactionHistory: "스왑 기록은 로컬에만 저장되며 브라우저 데이터를 지우면 삭제됩니다.",
      routeNotFound: "이유: 낮은 유동성, 선택된 수량이 너무 적음, 가스비가 너무 비싸거나 경로가 존재하지 않음"
    },
    title: {
      autoRefuel: "가스 받기",
      emptyActiveTransactions: "활성화된 거래가 없음",
      emptyTransactionHistory: "최근 거래 없음",
      routeNotFound: "가능한 경로가 없음"
    }
  },
  mqe = {
    message: {
      exchangePartiallySuccessful: "스왑을 시도했지만, {{tokenSymbol}} 토큰에 대한 {{tool}}의 유동성이 부족합니다.",
      exchangeSuccessful: "{{walletAddress}} 지갑의 {{chainName}} 체인에 {{amount, number(maximumFractionDigits: 9)}} {{tokenSymbol}}이(가) 있습니다.",
      purchaseSuccessful: "{{walletAddress}} 지갑의 {{chainName}} 체인에 {{assetName}} 을 획득하셨습니다."
    },
    title: {
      bridgePartiallySuccessful: "부분 스왑 성공",
      bridgeSuccessful: "브릿지 성공",
      purchaseSuccessful: "구입 성공",
      refundIssued: "환불되었습니다",
      swapPartiallySuccessful: "부분 스왑 성공",
      swapSuccessful: "스왑 성공"
    }
  },
  gqe = {
    message: {
      deleteActiveTransactions: "활성화된 스왑은 로컬에만 저장되며 삭제시 복구할 수 없습니다.",
      deleteTransactionHistory: "스왑 기록은 로컬에만 저장되며 삭제시 복구할 수 없습니다.",
      highValueLoss: "받은 토큰의 가치가 스왑된 토큰 및 트랜잭션 비용보다 상당히 낮습니다.",
      insufficientFunds: "스왑을 진행할 자금이 부족합니다.",
      insufficientGas: "스왑을 진행할 가스가 부족합니다. 최소 다음과 같은 가스가 필요합니다:",
      rateChanged: "거래 비율이 변경되었습니다. 스왑을 계속하면 새로운 비율이 적용됩니다.",
      resetSettings: "우선 경로, 슬리피지, 가스 비용, 활성화된 브릿지 및 거래소가 재설정됩니다."
    },
    title: {
      deleteActiveTransactions: "모든 활성화된 거래를 삭제합니까?",
      deleteTransaction: "이 거래를 삭제합니까?",
      deleteTransactionHistory: "거래 내역을 삭제합니까?",
      highValueLoss: "높은 가치 손실",
      insufficientGas: "가스 부족",
      rateChanged: "비율 변경됨",
      resetSettings: "설정을 초기화합니까?"
    }
  },
  yqe = {
    message: {
      allowanceRequired: "{{tokenSymbol}} 이체 금액이 한도를 초과했습니다. 한도를 증액한 뒤 다시 시도해주십시오.",
      insufficientFunds: "트랜잭션에 필요한 가스비가 부족합니다.",
      slippageThreshold: "슬리피지가 한계점보다 큽니다. 새로운 견적을 얻기 위해 새 경로를 요청하십시오.",
      transactionFailed: "자세한 정보는 블록 탐색기에서 확인하세요.",
      transactionNotSent: "트랜잭션 전송에 실패했습니다. {{chainName}}의 {{amount, number(maximumFractionDigits: 9)}} {{tokenSymbol}}이 지갑에 남아있습니다.",
      transactionRejected: "트랜잭션 완료를 위해 서명이 필요합니다. {{chainName}}의 {{amount, number(maximumFractionDigits: 9)}} {{tokenSymbol}}이 지갑에 남아있습니다.",
      unknown: "다시 시도하거나 고객 센터에 문의하십시오."
    },
    title: {
      allowanceRequired: "한도 부족",
      balanceIsTooLow: "잔액이 부족합니다.",
      chainSwitch: "체인을 변경하십시오",
      gasLimitIsTooLow: "가스 한도가 너무 낮습니다",
      insufficientFunds: "잔고 부족",
      slippageNotMet: "슬리피지 조건을 충족하지 못했습니다.",
      transactionCanceled: "거래가 취소되었습니다",
      transactionFailed: "거래가 실패하였습니다",
      transactionRejected: "서명이 필요합니다",
      transactionUnderpriced: "거래 가격이 너무 낮습니다",
      transactionUnprepared: "트랜잭션을 진행할 수 없습니다.",
      unknown: "문제가 발생했습니다",
      walletAddressInvalid: "지갑 주소가 유효하지 않습니다.",
      walletAddressRequired: "지갑 주소가 필요합니다.",
      walletEnsAddressInvalid: "지갑 주소가 유효하지 않거나 네트워크가 ENS를 지원하지 않습니다."
    }
  },
  vqe = {
    additionalProviderFee: "추가적인 브릿지, 덱스, 그리고 서비스 수수료",
    estimatedNetworkFee: "예상 네트워크 수수료",
    estimatedTime: "예상 스왑 시간(분)",
    notFound: {
      text: "페이지를 찾을 수 없습니다.",
      title: "404"
    },
    numberOfSteps: "여러 스왑 단계. 각 단계 진행을 위해서는 1-2개의 트랜잭션 서명이 필요할 수 있습니다.",
    progressToNextUpdate: "표시된 데이터가 {{value}} 초 후에 자동 새로고침 됩니다. 수동으로 업데이트 하려면 여기를 클릭하십시오.",
    recommended: "편리성과 복잡성에 균형을 둔 저렴한 루트",
    settingsModified: "설정 (수정됨)"
  },
  bqe = {
    crossStepDetails: "{{tool}}을 통해 {{from}}(으)로부터 {{to}}(으)로 브릿지",
    currentAmount: "현재 수량",
    estimatedTime: "{{value}}분",
    featuredTokens: "주요 토큰",
    from: "[Value] 를",
    fromAmount: "지불 수량",
    gasCost: "가스비",
    gasFeeEstimated: "예상 가스비",
    gasFeePaid: "가스비 지불됨",
    inProgress: "진행 중",
    nftStepDetails: "{{tool}} 를 통해 NFT 구입",
    onChain: "{{chainName}} 에서",
    otherTokens: "다른 토큰",
    ownedBy: "소유자: ",
    process: {
      crossChain: {
        actionRequired: "트랜잭션을 서명하십시오.",
        done: "브릿지 트랜잭션이 확인됨",
        pending: "브릿지 트랜잭션 대기 중",
        started: "브릿지 트랜잭션 준비 중"
      },
      nft: {
        done: "NFT 구입 성공"
      },
      receivingChain: {
        done: "브릿지 완료",
        partial: "브릿지 부분 완료",
        pending: "도착 체인 대기 중",
        refunded: "브릿지 트랜잭션 환불됨"
      },
      swap: {
        actionRequired: "트랜잭션을 서명하십시오",
        done: "스왑 완료",
        pending: "스왑 트랜잭션 대기 중",
        started: "스왑 트랜잭션 준비 중"
      },
      switchChain: {
        actionRequired: "체인 전환 요청됨",
        done: "체인 전환 완료"
      },
      tokenAllowance: {
        done: "토큰 허용 승인됨",
        pending: "토큰 허용 대기 중",
        started: "토큰 허용 설정"
      }
    },
    quotedAmount: "견적",
    rateChange: "비율 변경",
    receiving: "받는 중",
    refuelStepDetails: "{{tool}} 를 통해 가스 얻기",
    selectChain: "체인 선택",
    selectChainAndToken: "체인과 토큰 선택",
    selectToken: "토큰 선택",
    sendToAddress: "{{address}}로 전송",
    sendToWallet: "다른 지갑으로 전송",
    sending: "전송중",
    sentToAddress: "{{address}}로 전송",
    stepBridge: "브릿지",
    stepBridgeAndBuy: "브릿지 그리고 매수",
    stepDetails: "LI.FI 를 통한 {{tool}}",
    stepSwap: "스왑",
    stepSwapAndBridge: "스왑 그리고 브릿지",
    stepSwapAndBuy: "스왑 그리고 매수",
    supportId: "서포트 ID",
    swapStepDetails: "{{tool}}로 {{chain}}에서 스왑",
    tags: {
      cheapest: "저렴한",
      fastest: "빠르게",
      insurable: "보험 적용 가능한",
      insurance: "보험",
      insured: "보험 적용됨",
      recommended: "추천",
      safest: "안전한"
    },
    to: "도착",
    tokenOnChain: "{{chainName}}의 {{tokenSymbol}}",
    tokenOnChainAmount: "{{chainName}}의 {{amount, number(maximumFractionDigits: 9)}} {{tokenSymbol}}",
    tokenSearch: "이름 또는 컨트랙트 주소를 통해 검색",
    valueLoss: "가치 손실",
    walletAddressOrEns: "지갑 주소 또는 ENS"
  },
  wqe = {
    bridgeExploits: "브릿지 오류, 해킹, 취약점 공격",
    insure: "브릿지 중인 <0>{{amount, number(maximumFractionDigits: 9)}} {{tokenSymbol}}</0> 보험 적용",
    insured: "브릿지 중인 <0>{{amount, number(maximumFractionDigits: 9)}} {{tokenSymbol}}</0> 보험 적용 완료",
    slippageError: "받을 토큰의 슬리피지 오류가 발생했습니다."
  },
  xqe = {
    enabledBridges: "활성화된 브릿지",
    enabledExchanges: "지원 거래소",
    gasPrice: {
      fast: "빠르게",
      normal: "표준",
      slow: "느리게",
      title: "가스 가격"
    },
    routePriority: "우선 경로",
    showDestinationWallet: "받는 지갑 보기",
    slippage: "슬리피지"
  },
  Eqe = {
    extensionNotFound: "이 지갑을 선택하기 전 {{name}} 브라우저만 활성화 상태인지 확인하십시오."
  },
  Sqe = {
    language: uqe,
    format: dqe,
    button: fqe,
    header: hqe,
    info: pqe,
    success: mqe,
    warning: gqe,
    error: yqe,
    tooltip: vqe,
    main: bqe,
    insurance: wqe,
    settings: xqe,
    wallet: Eqe
  },
  Cqe = {
    name: "Português",
    title: "Idioma"
  },
  Aqe = {
    currency: "{{value, currency(currency: USD)}}",
    number: "{{value, number(maximumFractionDigits: 9)}}"
  },
  Tqe = {
    auto: "Automático",
    bridge: "Ponte",
    buy: "Comprar",
    buyNow: "Comprar agora",
    cancel: "Cancelar",
    connectWallet: "Conectar carteira",
    contactSupport: "Falar com o suporte",
    continue: "Continuar",
    copyAddress: "Copiar endereço",
    dark: "Escuro",
    delete: "Apagar",
    disconnect: "Desconectar",
    done: "Concluído",
    exchange: "Conversão",
    getGas: "Obter gás",
    hide: "Ocultar",
    learnMore: "Saiba mais",
    lifiCheckout: "Finalizar Compra LI.FI",
    lifiExchange: "Conversão LI.FI",
    light: "Claro",
    max: "máximo",
    ok: "Tudo certo",
    removeTransaction: "Remover transação",
    reset: "Redefinir",
    resetSettings: "Redefinir as configurações",
    reviewBridge: "Revisar ponte",
    reviewPurchase: "Revisar compra",
    reviewSwap: "Rever conversão",
    seeDetails: "Ver detalhes",
    showAll: "Mostrar tudo",
    startBridging: "Iniciar ponte",
    startSwapping: "Iniciar conversão",
    swap: "Conversão",
    tryAgain: "Tente novamente",
    viewCoverage: "Ver cobertura",
    viewOnExplorer: "Ver no explorador"
  },
  kqe = {
    activeTransactions: "Transações ativas",
    bridge: "Ponte",
    checkout: "Finalizar",
    exchange: "Conversão",
    from: "Converter a partir de",
    gas: "Gás",
    payWith: "Pagar com",
    purchase: "Compra",
    purchaseDetails: "Detalhes da compra",
    selectChain: "Selecionar uma rede",
    selectWallet: "Selecionar sua carteira",
    settings: "Configurações",
    swap: "Conversão",
    to: "Converter para",
    transactionDetails: "Detalhes da transação",
    transactionHistory: "Histórico de transações",
    walletConnected: "Carteira conectada",
    youGet: "Você recebe"
  },
  _qe = {
    message: {
      autoRefuel: "Você está com pouco gás na rede {{chainName}}. Ao continuar, você obterá gás suficiente para completar a conversão.",
      emptyActiveTransactions: "As transações em andamento aparecerão aqui. Uma vez concluídas, encontre-as no histórico de transações.",
      emptyTokenList: "Não conseguimos encontrar tokens na rede {{chainName}} ou você não possui nenhum. Por favor, procure pelo endereço de contrato caso o token não apareça ou escolha outra rede.",
      emptyTransactionHistory: "O histórico de transações é armazenado apenas localmente e será excluído se você limpar os dados do seu navegador.",
      routeNotFound: "Razões para isso podem ser: baixa liquidez, valor selecionado é muito baixo, os custos com gás são muito elevados ou não há rotas para a combinação selecionada."
    },
    title: {
      autoRefuel: "Obter gás",
      emptyActiveTransactions: "Nenhuma transação ativa",
      emptyTransactionHistory: "Nenhuma transação recente",
      routeNotFound: "Nenhuma rota disponível"
    }
  },
  Iqe = {
    message: {
      exchangePartiallySuccessful: "Tentamos completar a transação, mas {{tool}} ficou sem liquidez com o token {{tokenSymbol}}.",
      exchangeSuccessful: "Agora há {{amount, number(maximumFractionDigits: 9)}} {{tokenSymbol}} na carteira {{walletAddress}} na rede {{chainName}}.",
      purchaseSuccessful: "Agora você tem {{assetName}} na carteira {{walletAddress}} na cadeia {{chainName}}"
    },
    title: {
      bridgePartiallySuccessful: "Ponte parcialmente concluída",
      bridgeSuccessful: "Ponte bem sucedida",
      purchaseSuccessful: "Compra efetuada com sucesso",
      refundIssued: "Reembolso emitido",
      swapPartiallySuccessful: "Conversão parcialmente bem sucedida",
      swapSuccessful: "Conversão bem sucedida"
    }
  },
  Pqe = {
    message: {
      deleteActiveTransactions: "Transações ativas são armazenadas apenas localmente e não podem ser recuperadas se você excluí-las.",
      deleteTransactionHistory: "O histórico de conversões é armazenado apenas localmente e não pode ser recuperado caso seja excluído.",
      highValueLoss: "A quantidade de tokens a serem recebidos é significativamente menor do que os tokens convertidos e os custos da transação.",
      insufficientFunds: "Você não possui fundos suficientes para completar a conversão.",
      insufficientGas: "Você não tem gás suficiente para completar a conversão. É necessário adicionar pelo menos:",
      rateChanged: "A taxa de câmbio mudou. Ao continuar a conversão, você aceitará a nova taxa.",
      resetSettings: "Isto redefinirá sua prioridade de rota, tolerância a derrapagem, preço de gás, pontes e trocas ativadas."
    },
    title: {
      deleteActiveTransactions: "Excluir todas as transações ativas?",
      deleteTransaction: "Excluir esta transação?",
      deleteTransactionHistory: "Excluir histórico de transação?",
      highValueLoss: "Alta perda de valor",
      insufficientGas: "Gás insuficiente",
      rateChanged: "Taxa alterada",
      resetSettings: "Redefinir as configurações?"
    }
  },
  Rqe = {
    message: {
      allowanceRequired: "A quantidade a ser transferida para {{tokenSymbol}} excede a sua permissão atual. Por favor, aumente a sua permissão e tente novamente.",
      insufficientFunds: "Você não tem gás suficiente para cobrir o custo da transação.",
      slippageThreshold: "A derrapagem é maior do que o limite definido. Solicite uma nova rota para obter uma nova cotação.",
      transactionFailed: "Por favor, verifique o explorador de blocos para mais informações.",
      transactionNotSent: "A transação não foi enviada. {{amount, number(maximumFractionDigits: 9)}} {{tokenSymbol}} na {{chainName}} permanece na sua carteira.",
      transactionRejected: "Sua assinatura é necessária para completar a transação. {{amount, number(maximumFractionDigits: 9)}} {{tokenSymbol}} em {{chainName}} permanece na sua carteira.",
      unknown: "Por favor, tente novamente ou fale com o suporte."
    },
    title: {
      allowanceRequired: "Permissão insuficiente",
      balanceIsTooLow: "O saldo é muito baixo",
      chainSwitch: "Necessário mudança de rede",
      gasLimitIsTooLow: "O limite de gás é muito baixo",
      insufficientFunds: "Saldo insuficiente",
      slippageNotMet: "Condições de tolerância a discrepâncias não foram atendidas",
      transactionCanceled: "Transação cancelada",
      transactionFailed: "Transação falhou",
      transactionRejected: "Necessário assinatura",
      transactionUnderpriced: "Transação está abaixo do valor",
      transactionUnprepared: "Não foi possível preparar a transação",
      unknown: "Algo deu errado",
      walletAddressInvalid: "Endereço da carteira é inválido.",
      walletAddressRequired: "Endereço da carteira é necessário.",
      walletEnsAddressInvalid: "O endereço da carteira é inválido ou a rede não suporta ENS."
    }
  },
  Oqe = {
    additionalProviderFee: "Pontes adicionais, DEXes e taxas de serviço.",
    estimatedNetworkFee: "Taxa de rede estimada.",
    estimatedTime: "Tempo de execução da conversão estimado em minutos.",
    notFound: {
      text: "Não conseguimos encontrar esta página.",
      title: "404"
    },
    numberOfSteps: "Um número de passos para a conversão. Cada etapa pode conter 1-2 transações que requerem uma assinatura.",
    progressToNextUpdate: "Os dados exibidos serão atualizados automaticamente após {{value}} segundos. Clique aqui para atualizar manualmente.",
    recommended: "Uma rota econômica que equilibra complexidade e facilidade de uso.",
    settingsModified: "Configurações (modificado)"
  },
  Dqe = {
    crossStepDetails: "Ponte de {{from}} para {{to}} via {{tool}}",
    currentAmount: "Quantidade atual",
    estimatedTime: "{{value}}min",
    featuredTokens: "Tokens em destaque",
    from: "De",
    fromAmount: "Você paga",
    gasCost: "Custo do gás",
    gasFeeEstimated: "Taxa de gás estimada",
    gasFeePaid: "taxa de gás paga",
    inProgress: "em andamento",
    nftStepDetails: "Comprar NFT via {{tool}}",
    onChain: "em {{chainName}}",
    otherTokens: "Outros tokens",
    ownedBy: "Possuído por",
    process: {
      crossChain: {
        actionRequired: "Por favor, assine a transação",
        done: "Transação da ponte confirmada",
        pending: "Aguardando a transação da ponte",
        started: "Preparando a transação da ponte"
      },
      nft: {
        done: "NFT comprado"
      },
      receivingChain: {
        done: "Ponte concluída",
        partial: "Ponte parcialmente concluída",
        pending: "Aguardando a rede de destino",
        refunded: "Transação de ponte reembolsada"
      },
      swap: {
        actionRequired: "Por favor, assine a transação",
        done: "Conversão concluída",
        pending: "Aguardando a transação de conversão",
        started: "Preparando a transação de conversão"
      },
      switchChain: {
        actionRequired: "Necessário mudança de rede",
        done: "Rede alterada com sucesso"
      },
      tokenAllowance: {
        done: "Permissão de token aprovada",
        pending: "Aguardando a permissão do token",
        started: "Configurando a permissão do token"
      }
    },
    quotedAmount: "Valor da cotação",
    rateChange: "Alterar taxa",
    receiving: "Recebendo",
    refuelStepDetails: "Obter gás via {{tool}}",
    selectChain: "Selecione a rede",
    selectChainAndToken: "Selecione a rede e o token",
    selectToken: "Selecione o Token",
    sendToAddress: "Enviar para",
    sendToWallet: "Enviar para uma carteira diferente",
    sending: "Enviando",
    sentToAddress: "Enviar para",
    stepBridge: "Ponte",
    stepBridgeAndBuy: "Transfira e compre",
    stepDetails: "{{tool}} via LI.FI",
    stepSwap: "Conversão",
    stepSwapAndBridge: "Converter e enviar pela ponte",
    stepSwapAndBuy: "Converta e compre",
    supportId: "ID de suporte",
    swapStepDetails: "Converter na {{chain}} via {{tool}}",
    tags: {
      cheapest: "Barato",
      fastest: "Rápido",
      insurable: "Assegurável",
      insurance: "Seguro",
      insured: "Segurado",
      recommended: "Recomendado",
      safest: "Seguro"
    },
    to: "Para",
    tokenOnChain: "{{tokenSymbol}} na {{chainName}}",
    tokenOnChainAmount: "{{amount, number(maximumFractionDigits: 9)}} {{tokenSymbol}} na {{chainName}}",
    tokenSearch: "Pesquisar pelo nome do token ou endereço",
    valueLoss: "Perda de Valor",
    walletAddressOrEns: "Endereço da carteira ou nome ENS"
  },
  Nqe = {
    bridgeExploits: "Mau funcionamento da ponte, hacks ou exploits",
    insure: "Contratar seguro para <0>{{amount, number(maximumFractionDigits: 9)}} {{tokenSymbol}}</0> em trânsito.",
    insured: "Você contratou seguro para <0>{{amount, number(maximumFractionDigits: 9)}} {{tokenSymbol}}</0> em trânsito:",
    slippageError: "Erro na discrepância para tokens recebidos"
  },
  Mqe = {
    enabledBridges: "Pontes habilitadas",
    enabledExchanges: "Corretoras habilitadas",
    gasPrice: {
      fast: "Rápido",
      normal: "Normal",
      slow: "Lento",
      title: "Preço do gás"
    },
    routePriority: "Prioridade de rota / caminho",
    showDestinationWallet: "Mostrar carteira de destino",
    slippage: "Derrapagem",
    resetSettings: "Você está usando a configuração personalizada que limita a quantidade de rotas disponíveis."
  },
  $qe = {
    extensionNotFound: "Por favor, certifique-se de que apenas a extensão do navegador da {{name}} está ativa antes de escolher esta carteira."
  },
  Lqe = {
    language: Cqe,
    format: Aqe,
    button: Tqe,
    header: kqe,
    info: _qe,
    success: Iqe,
    warning: Pqe,
    error: Rqe,
    tooltip: Oqe,
    main: Dqe,
    insurance: Nqe,
    settings: Mqe,
    wallet: $qe
  },
  Bqe = {
    name: "ภาษาไทย",
    title: "ภาษา"
  },
  Fqe = {
    currency: "{{value, currency(currency: USD)}}",
    number: "{{value, number(maximumFractionDigits: 9)}}"
  },
  jqe = {
    auto: "อัตโนมัติ",
    bridge: "บริดจ์",
    buy: "ซื้อ",
    buyNow: "ซื้อตอนนี้",
    cancel: "ยกเลิก",
    connectWallet: "เชื่อมต่อ กระเป๋า",
    contactSupport: "ติดต่อฝ่ายสนับสนุน",
    continue: "ดำเนินการต่อ",
    copyAddress: "คัดลอกที่อยู่",
    dark: "มืด",
    delete: "ลบ",
    disconnect: "ยกเลิกการเชื่อมต่อ",
    done: "เสร็จสิ้น",
    exchange: "แลกเปลี่ยน",
    getGas: "รับแก็ส",
    hide: "ซ่อน",
    learnMore: "เรียนรู้เพิ่มเติม",
    lifiCheckout: "Li.Fi. ตรวจสอบ",
    lifiExchange: "LI.FI Exchange",
    light: "สว่าง",
    max: "สูงสุด",
    ok: "ตกลง",
    removeTransaction: "นำรายการออก",
    reset: "ล้างข้อมูล",
    resetSettings: "รีเซ็ตการตั้งค่า",
    reviewBridge: "ตรวจสอบบริดจ์",
    reviewPurchase: "ตรวจสอบการสั่งซื้อ",
    reviewSwap: "ตรวจสอบการแลกเปลี่ยน",
    seeDetails: "ดูรายละเอียด",
    showAll: "แสดงทั้งหมด",
    startBridging: "เริ่มต้นการบริดจ์",
    startSwapping: "เริ่มต้นการแลกเปลี่ยน",
    swap: "การแลกเปลี่ยน",
    tryAgain: "ลองใหม่",
    viewCoverage: "ดูความคุ้มครอง",
    viewOnExplorer: "ดูในการสำรวจ"
  },
  Uqe = {
    activeTransactions: "ธุรกรรมมีผล",
    bridge: "บริดจ์",
    checkout: "เช็คเอาท์",
    exchange: "แลกเปลี่ยน",
    from: "แลกเปลี่ยนจาก",
    gas: "แก็ส",
    payWith: "ชำระด้วย",
    purchase: "ซื้อ",
    purchaseDetails: "รายละเอียดการซื้อ",
    selectChain: "เลือกเชน",
    selectWallet: "เลือกกระเป๋าของคุณ",
    settings: "ตั้งค่า",
    swap: "แลกเปลี่ยน",
    to: "แลกเปลี่ยนเป็น",
    transactionDetails: "รายละเอียดของธุรกรรม",
    transactionHistory: "ประวัติการซื้อขาย",
    walletConnected: "กระเป๋าถูกเชื่อมต่อแล้ว",
    youGet: "คุณได้รับ"
  },
  zqe = {
    message: {
      autoRefuel: "คุณใช้แก็ส {{chainName}} เหลือน้อย เมื่อดำเนินการต่อ คุณจะได้รับแก็สเพียงพอสำหรับการแลกเปลี่ยนให้เสร็จสมบูรณ์",
      emptyActiveTransactions: "การแลกเปลี่ยนที่กำลังดำเนินการจะปรากฏที่นี่. เมื่อเสร็จสิ้น, จะพบประวัติการแลกเปลี่ยน.",
      emptyTokenList: "เราไม่พบโทเค็นใน {{chainName}} เชนหรือคุณไม่มีโทเค็น. โปรดลองอีกครั้งหรือเลือกเชนอื่น.",
      emptyTransactionHistory: "ประวัติการแลกเปลี่ยนจะถูกเก็บไว้ในเครื่องเท่านั้นและจะถูกลบหากคุณล้างข้อมูลเบราว์เซอร์ของคุณ.",
      routeNotFound: "เหตุผลที่อาจเกิดขึ้น : สภาพคล่องต่ำ , จำนวนที่เลือกน้อยเกินไป , ต้นทุนแก็สสูงหรือไม่มีเส้นทางที่ใช้งานได้"
    },
    title: {
      autoRefuel: "รับแก็ส",
      emptyActiveTransactions: "ไม่มีธุรกรรมที่มีผล",
      emptyTransactionHistory: "ไม่มีธุรกรรมล่าสุด",
      routeNotFound: "ไม่พบเส้นทาง"
    }
  },
  Hqe = {
    message: {
      exchangePartiallySuccessful: "เราได้พยายามดำเนินการแลกเปลี่ยนให้เสร็จสมบูรณ์แต่ {{tool}} ขาดสภาพคล่องสำหรับโทเค็น {{tokenSymbol}}",
      exchangeSuccessful: "ตอนนี้มี {{amount, number(maximumFractionDigits: 9)}}{{tokenSymbol}} ใน {{walletAddress}} กระเป๋าบน {{chainName}} เชน.",
      purchaseSuccessful: "คุณมี {{assetName}} ใน{{walletAddress}} กระเป๋า บน{{chainName}} เครือข่าย"
    },
    title: {
      bridgePartiallySuccessful: "แลกเปลี่ยนสำเร็จบางส่วน",
      bridgeSuccessful: "บริดจ์สำเร็จ",
      purchaseSuccessful: "การซื้อเสร็จสมบูรณ์",
      refundIssued: "คืนเงินแล้ว",
      swapPartiallySuccessful: "แลกเปลี่ยนสำเร็จบางส่วน",
      swapSuccessful: "แลกเปลี่ยนสำเร็จ"
    }
  },
  Vqe = {
    message: {
      deleteActiveTransactions: "การแลกเปลี่ยนที่ใช้งานอยู่จะถูกจัดเก็บไว้ในเครื่องเท่านั้นและไม่สามารถกู้คืนได้หากคุณลบออก.",
      deleteTransactionHistory: "ประวัติการแลกเปลี่ยนจะถูกจัดเก็บไว้ในเครื่องเท่านั้นและไม่สามารถกู้คืนได้หากคุณลบออก",
      highValueLoss: "มูลค่าของโทเค็นที่ได้รับนั้นต่ำกว่าโทเค็นที่แลกเปลี่ยนและต้นทุนการทำธุรกรรมอย่างมาก.",
      insufficientFunds: "คุณมีเงินไม่เพียงพอที่จะดำเนินการแลกเปลี่ยน.",
      insufficientGas: "คุณมีแก๊สไม่เพียงพอที่จะแลกเปลี่ยนให้เสร็จสมบูรณ์ คุณต้องเพิ่มอย่างน้อย:",
      rateChanged: "อัตราแลกเปลี่ยนมีการเปลี่ยนแปลง คุณจะยอมรับอัตราใหม่.",
      resetSettings: "การดำเนินการนี้จะรีเซ็ตลำดับความสำคัญของเส้นทาง การคลาดเลื่อน ค่าแก็ส บริดจ์ที่เปิดใช้งานและการแลกเปลี่ยน"
    },
    title: {
      deleteActiveTransactions: "ลบ​รายการธุรกรรม​ทั้งหมด?",
      deleteTransaction: "ต้องการลบธุรกรรมนี้?",
      deleteTransactionHistory: "ต้องการลบประวัติการทำธุรกรรม?",
      highValueLoss: "สูญเสียมูลค่าสูง",
      insufficientGas: "ค่าแก็สไม่พอ",
      rateChanged: "อัตราการแลกเปลี่ยนถูกเปลี่ยน",
      resetSettings: "รีเซ็ทการตั้งค่า?"
    }
  },
  Wqe = {
    message: {
      allowanceRequired: "โอนด้วยจำนวน {{tokenSymbol}} ตามการอนุญาตของคุณ.ได้โปรดเพิ่มการอนุญาตของคุณอีกครั้ง",
      insufficientFunds: "คุณมีแก็สไม่พอสำหรับการธุรกรรมนี้",
      slippageThreshold: "การคลาดเคลื่อนมีขนาดใหญ่กว่าเกณฑ์ที่กำหนด โปรดขอเส้นทางใหม่เพื่อได้รับการเสนอราคาใหม่.",
      transactionFailed: "โปรดตรวจสอบบล็อกการสำรวจสำหรับข้อมูลเพิ่มเติม.",
      transactionNotSent: "ไม่ได้ส่งธุรกรรม. {{amount, number(maximumFractionDigits: 9)}} {{tokenSymbol}} บน {{chainName}} ยังคงอยู่ในกระเป๋าเงินของคุณ.",
      transactionRejected: "จำเป็นต้องมีลายเซ็นของคุณเพื่อทำธุรกรมให้เสร็จสมบูรณ์. {{amount, number(maximumFractionDigits: 9)}} {{tokenSymbol}} บน {{chainName}} ยังคงอยู่ในกระเป๋าเงินของคุณ.",
      unknown: "โปรดลองอีกครั้งหรือติดต่อฝ่ายสนับสนุน."
    },
    title: {
      allowanceRequired: "การอนุญาตไม่เพียงพอ",
      balanceIsTooLow: "ยอดคงเหลือต่ำเกินไป",
      chainSwitch: "จำเป็นต้องเปลี่ยนเชน",
      gasLimitIsTooLow: "แก๊สคงเหลือต่ำเกินไป",
      insufficientFunds: "ยอดคงเหลือไม่เพียงพอ",
      slippageNotMet: "ความคลาดเคลื่อนของราคาไม่เป็นไปตามเงื่อนไข.",
      transactionCanceled: "ธุรกรรมถูกยกเลิกแล้ว",
      transactionFailed: "การทำธุรกรรมล้มเหลว",
      transactionRejected: "ต้องมีลายเซ็น",
      transactionUnderpriced: "ราคาธุรกรรมต่ำเกินไป",
      transactionUnprepared: "ไม่สามารถจัดทำธุรกรรมได้",
      unknown: "มีบางอย่างผิดพลาด",
      walletAddressInvalid: "ที่อยู่กระเป๋าเงินไม่ถูกต้อง.",
      walletAddressRequired: "กรุณากรอกที่อยู่กระเป๋าเงิน.",
      walletEnsAddressInvalid: "ที่อยู่กระเป๋าเงินไม่ถูกต้องหรือเครือข่ายไม่รองรับ ENS."
    }
  },
  qqe = {
    additionalProviderFee: "บริดจ์เพิ่มเติม DEX และค่าบริการ",
    estimatedNetworkFee: "ค่าธรรรมเนียมโดยประมาณของเครือข่าย",
    estimatedTime: "เวลาดำเนินการแลกเปลี่ยนโดยประมาณเป็นนาที.",
    notFound: {
      text: "เราไม่พบหน้านี้.",
      title: "404"
    },
    numberOfSteps: "ขั้นตอนการแลกเปลี่ยนหลายขั้นตอน แต่ละขั้นตอนสามารถมี 1-2 รายการที่ต้องใช้ลายเซ็น.",
    progressToNextUpdate: "ข้อมูลที่แสดงจะรีเฟรชอัตโนมัติหลังจาก {{value}} วินาที คลิกที่นี่เพื่ออัปเดตด้วยตนเอง",
    recommended: "เส้นทางที่ถูกมียอดคงเหลือที่เพียงพอและง่ายต่องการใช้งาน",
    settingsModified: "การตั้งค่า (แก้ไข)"
  },
  Gqe = {
    crossStepDetails: "บริดจ์จาก{{from}} to {{to}} โดย {{tool}}",
    currentAmount: "จำนวนเงินปัจจุบัน",
    estimatedTime: "{{value}} นาที",
    featuredTokens: "จุดเด่นของเหรียญ",
    from: "จาก",
    fromAmount: "คุณจ่าย",
    gasCost: "ค่าแก๊ส",
    gasFeeEstimated: "ค่าแก๊สโดยประมาณ",
    gasFeePaid: "จ่ายค่าทำเนียมแล้ว",
    inProgress: "กำลังดำเนินการ",
    nftStepDetails: "ซื้อ NFT ผ่าน {{tool}}",
    onChain: "บน {{chainName}}",
    otherTokens: "โทเค็นอื่น",
    ownedBy: "เป็นเจ้าของโดย",
    process: {
      crossChain: {
        actionRequired: "กรุณาเซ็นชื่อในการทำธุรกรรม",
        done: "ธุรกรรมข้ามเชนได้รับการยืนยันแล้ว",
        pending: "รอสำหรับการทำรายการบริดจ์",
        started: "เตรียมการทำรายการบริดจ์"
      },
      nft: {
        done: "ซื้อ NFT แล้ว"
      },
      receivingChain: {
        done: "ข้ามเชนเสร็จสมบูรณ์",
        partial: "การข้ามเชนเสร็จสมบูรณ์บางส่วน",
        pending: "กำลังรอเชนปลายทาง",
        refunded: "คืนเงินการทำธุรกรรมข้ามเชนแล้ว"
      },
      swap: {
        actionRequired: "กรุณาเซ็นชื่อในการทำธุรกรรม",
        done: "การแลกเปลี่ยนเสร็จสมบูรณ์",
        pending: "กำลังรอการแลกเปลี่ยนธุรกรรม",
        started: "กำลังเตรียมการแลกเปลี่ยนธุรกรรม"
      },
      switchChain: {
        actionRequired: "จำเป็นต้องเปลี่ยนเชน",
        done: "สลับเชนสำเร็จแล้ว"
      },
      tokenAllowance: {
        done: "โทเค็นได้รับการอนุญาตแล้ว",
        pending: "รอการอนุญาตของโทเค็น",
        started: "การตั้งค่าการอนุญาตโทเค็น"
      }
    },
    quotedAmount: "จำนวนทั้งหมดที่เสนอ",
    rateChange: "อัตราแลกเปลี่ยน",
    receiving: "ได้รับ",
    refuelStepDetails: "รับแก๊สผ่าน {{tool}}",
    selectChain: "เลือกเชน",
    selectChainAndToken: "เลือกเชนและโทเค็น",
    selectToken: "เลือกโทเคน",
    sendToAddress: "ส่งไปยัง {{address}}",
    sendToWallet: "ส่งไปยังกระเป๋าเงินอื่น",
    sending: "กำลังส่ง",
    sentToAddress: "ส่งไปยัง {{address}}",
    stepBridge: "บริดจ์",
    stepBridgeAndBuy: "บริดจ์และซื้อ",
    stepDetails: "{{tool}} โดย LI.FI",
    stepSwap: "แลกเปลี่ยน",
    stepSwapAndBridge: "แลกเปลี่ยนและบริดจ์",
    stepSwapAndBuy: "แลกเปลี่ยน และ ซื้อ",
    supportId: "หมายเลขที่สนับสนุน",
    swapStepDetails: "แลกเปลี่ยนบน {{chain}} ผ่าน {{tool}}",
    tags: {
      cheapest: "ราคาถูก",
      fastest: "รวดเร็ว",
      insurable: "การประกัน",
      insurance: "การประกัน",
      insured: "ประกัน",
      recommended: "แนะนำ",
      safest: "ปลอดภัย"
    },
    to: "ถึง",
    tokenOnChain: "{{tokenSymbol}} บน {{chainName}}",
    tokenOnChainAmount: "{{amount, number(maximumFractionDigits: 9)}}{{tokenSymbol}} บน {{chainName}}",
    tokenSearch: "ค้นหาชื่อของเหรียญ หรือ ที่อยู่",
    valueLoss: "มูลค่าที่สูญเสีย",
    walletAddressOrEns: "ที่อยู่กระเป๋าหรือชื่อENS"
  },
  Kqe = {
    bridgeExploits: "การบริดจ์ทำงานผิดปกติ แฮ็กหรือหาผลประโยชน์",
    insure: "ประกัน<0>{{amount, number(maximumFractionDigits: 9)}}{{tokenSymbol}}</0> ในการขนส่ง",
    insured: "คุณได้ประกัน<0>{{amount, number(maximumFractionDigits: 9)}}{{tokenSymbol}}</0> ในการขนส่ง",
    slippageError: "เกิดข้อผิดพลาดในการคลาดเคลื่อนของโทเค็นที่ได้รับ"
  },
  Qqe = {
    enabledBridges: "เปิดการใช้งานบริดจ์",
    enabledExchanges: "เปิดการใช้งาน การแลกเปลี่ยน",
    gasPrice: {
      fast: "รวดเร็ว",
      normal: "ปกติ",
      slow: "ช้า",
      title: "ค่าแก็ส"
    },
    routePriority: "ลำดับสำคัญของเส้นทาง",
    showDestinationWallet: "แสดงกระเป๋าปลายทาง",
    slippage: "ความคลาดเคลื่อน"
  },
  Yqe = {
    extensionNotFound: "โปรดตรวจสอบว่ามีเพียงส่วนขยายของเบราว์เซอร์ {{name}} เท่านั้นที่ใช้งานได้ก่อนที่จะเลือกกระเป๋าเงินนี้."
  },
  Jqe = {
    language: Bqe,
    format: Fqe,
    button: jqe,
    header: Uqe,
    info: zqe,
    success: Hqe,
    warning: Vqe,
    error: Wqe,
    tooltip: qqe,
    main: Gqe,
    insurance: Kqe,
    settings: Qqe,
    wallet: Yqe
  },
  Xqe = {
    name: "Türkçe",
    title: "Dil"
  },
  Zqe = {
    currency: "{{value, currency(currency: USD)}}",
    number: "{{value, number(maximumFractionDigits: 9)}}"
  },
  eGe = {
    auto: "Otomatik",
    bridge: "Gönder",
    buy: "Satın al",
    buyNow: "Hemen satın al",
    cancel: "İptal",
    connectWallet: "Cüzdanı Bağla",
    contactSupport: "Destek Ekibine Ulaş",
    continue: "Devam et",
    copyAddress: "Adresi Kopyala",
    dark: "Koyu",
    delete: "Sil",
    disconnect: "Bağlantıyı Kes",
    done: "Tamamlandı",
    exchange: "Al-Sat",
    getGas: "Gaz al",
    hide: "Gizle",
    learnMore: "Daha fazla bilgi edinin",
    lifiCheckout: "İşlem sonucu",
    lifiExchange: "LI-FI Al-Sat",
    light: "Açık",
    max: "maksimum",
    ok: "Tamam",
    removeTransaction: "İşlemi kaldır",
    reset: "Sıfırla",
    resetSettings: "Ayarları Sıfırla",
    reviewBridge: "Köprüleri İncele",
    reviewPurchase: "Satın almayı gözden geçir",
    reviewSwap: "Takas işlemini incele",
    seeDetails: "Detayları Gör",
    showAll: "Tümünü Göster",
    startBridging: "Başla",
    startSwapping: "Takas işlemini başlat",
    swap: "Takas et",
    tryAgain: "Tekrar Deneyin",
    viewCoverage: "Kapsamaya bak",
    viewOnExplorer: "Tarayıcıda Görüntüle"
  },
  tGe = {
    activeTransactions: "Aktif işlemler",
    bridge: "Gönder",
    checkout: "Ödeme yap",
    exchange: "Al-Sat",
    from: "Şundan takas et",
    gas: "Gaz",
    payWith: "Şununla öde",
    purchase: "Satın al",
    purchaseDetails: "Satın Alma Detayları",
    selectChain: "Zincir Seç",
    selectWallet: "Bir Cüzdan Seçin",
    settings: "Ayarlar",
    swap: "Takas",
    to: "Şuna takas et",
    transactionDetails: "İşlem ayrıntıları",
    transactionHistory: "İşlem geçmişi",
    walletConnected: "Cüzdan Bağlandı",
    youGet: "Alacağınız"
  },
  nGe = {
    message: {
      autoRefuel: "{{chainName}} ağında gaz yetersiz. Devam ederek, işlem için gereken miktarda gaz alacaksınız.",
      emptyActiveTransactions: "Devam eden işlemler burada görünecek. Tamamlandığında, işlem geçmişinden bulabilirsiniz.",
      emptyTokenList: "{{chainName}} ağında token bulamadık veya sizde hiç token yok. Lütfen tekrar aramayı deneyin veya başka bir ağ seçin.",
      emptyTransactionHistory: "İşlem geçmişi yalnızca yerel olarak saklanır ve tarayıcı verilerinizi temizlerseniz silinir.",
      routeNotFound: "Muhtemel sebepler şunlar olabilir: Düşük likidite, seçilen miktarın çok düşük olması, gaz masrafının çok olması ya da seçilen kombinasyon için rota olmaması."
    },
    title: {
      autoRefuel: "Gaz al",
      emptyActiveTransactions: "Aktif işlem bulunmamaktadır",
      emptyTransactionHistory: "Yakın zamanda bir işlem yok",
      routeNotFound: "Kullanılabilir bir yol bulunamadı"
    }
  },
  rGe = {
    message: {
      exchangePartiallySuccessful: "İşlemi tamamlamaya çalıştık, ancak {{tool}} üzerinde, {{tokenSymbol}} için likidite bulunmuyor.",
      exchangeSuccessful: "Şu anda {{chainName}} ağındaki {{walletAddress}} adresinde {{amount, number(maximumFractionDigits: 9)}} adet {{tokenSymbol}} bulunmaktadır.",
      purchaseSuccessful: "Şu anda {{chainName}} ağı {{walletAddress}} adresinde {{assetName}} bulunmaktadır."
    },
    title: {
      bridgePartiallySuccessful: "Köprü işlemi kısmen başarılı",
      bridgeSuccessful: "İşlem başarılı",
      purchaseSuccessful: "İşlem başarılı",
      refundIssued: "Geri ödeme yapıldı",
      swapPartiallySuccessful: "Takas işlemi kısmen başarılı",
      swapSuccessful: "Takas başarılı"
    }
  },
  iGe = {
    message: {
      deleteActiveTransactions: "Aktif işlemler yalnızca yerel olarak depolanır ve silerseniz kurtarılamaz.",
      deleteTransactionHistory: "İşlem geçmişi yalnızca yerel olarak depolanır ve silerseniz kurtarılamaz.",
      highValueLoss: "Elde edilecek varlıkların değeri, takas edilen varlıklardan ve işlem maliyetinden önemli ölçüde düşüktür.",
      insufficientFunds: "Takas işlemini gerçekleştirmek için yeterli bakiyeniz bulunmamaktadır.",
      insufficientGas: "En azından şunları eklemelisiniz:",
      rateChanged: "Takas oranı değişti. İşleme devam ederek yeni oranı kabul etmiş olursunuz.",
      resetSettings: "Bu, rota önceliğinizi, slipajı, gaz fiyatını, etkin köprüleri ve takasları sıfırlayacaktır."
    },
    title: {
      deleteActiveTransactions: "Tüm aktif işlemleri sil?",
      deleteTransaction: "Bu işlem silinsin mi?",
      deleteTransactionHistory: "İşlem geçmişi silinsin mi?",
      highValueLoss: "Yüksek değer kaybı",
      insufficientGas: "Yetersiz gaz",
      rateChanged: "Oran değişti",
      resetSettings: "Ayarları sıfırla?"
    }
  },
  sGe = {
    message: {
      allowanceRequired: "{{tokenSymbol}} için verilen izinden fazla miktarda transfer yapılamaz. Token izinlerini arttırıp tekrar deneyiniz.",
      insufficientFunds: "Bu işlemi gerçekleştirmek için yeterli gaz bulunmamaktadır.",
      slippageThreshold: "Slipaj, tanımlanan eşikten daha büyük. Yeni bir fiyat teklifi almak için lütfen yeni bir rota isteyin.",
      transactionFailed: "Daha fazla bilgi için ağ tarayıcısını kontrol edin.",
      transactionNotSent: "İşlem gönderilmedi. {{chainName}} üzerinde {{amount, number(maximumFractionDigits: 9)}} {{tokenSymbol}} cüzdanınızda bulunmaktadır.",
      transactionRejected: "İşlemi tamamlamak için imzanız gerekiyor. {{chainName}} üzerinde {{amount, number(maximumFractionDigits: 9)}} {{tokenSymbol}} cüzdanınızda bulunmaktadır.",
      unknown: "Lütfen tekrar deneyin veya desteğe başvurun."
    },
    title: {
      allowanceRequired: "İzin miktarı yetersiz",
      balanceIsTooLow: "Bakiye çok düşük",
      chainSwitch: "Lütfen ağı değiştirin",
      gasLimitIsTooLow: "Gaz limiti çok düşük",
      insufficientFunds: "Yetersiz bakiye",
      slippageNotMet: "Slipaj koşulları karşılanmadı",
      transactionCanceled: "İşlem iptal edildi",
      transactionFailed: "İşlem başarısız",
      transactionRejected: "İmza gerekiyor",
      transactionUnderpriced: "İşlemin değeri düşük",
      transactionUnprepared: "İşlem başlatılamıyor",
      unknown: "Bir sorun oluştu",
      walletAddressInvalid: "Cüzdan adresi geçersizdir.",
      walletAddressRequired: "Cüzdan adresi gereklidir.",
      walletEnsAddressInvalid: "Cüzdan adresi geçerli değil veya ağ ENS desteklemiyor."
    }
  },
  oGe = {
    additionalProviderFee: "Ek köprü, DEX'ler ve hizmet ücretleri.",
    estimatedNetworkFee: "Tahmini ağ ücreti.",
    estimatedTime: "Dakika cinsinden tahmini işlem süresi.",
    notFound: {
      text: "Aradığınız sayfayı bulamadık.",
      title: "404"
    },
    numberOfSteps: "İşlem birkaç adımdan oluşmaktadır. Her adım, imza gerektiren 1-2 işlem içerebilir.",
    progressToNextUpdate: "Görüntülenen veriler, {{value}} saniye sonra otomatik olarak yenilenecektir. Manuel olarak güncellemek için burayı tıklayın.",
    recommended: "Karmaşıklığı ve kullanım kolaylığını dengeleyen ucuz bir rota.",
    settingsModified: "Ayarlar (değiştirilen)"
  },
  aGe = {
    crossStepDetails: "{{from}} ile {{to}} ağları arasında {{tool}} ile gönderim sağlayın",
    currentAmount: "Geçerli miktar",
    estimatedTime: "{{value}} dakika",
    featuredTokens: "Öne çıkan jetonlar",
    from: "Gönderen",
    fromAmount: "Ödediğiniz",
    gasCost: "Gaz Bedeli",
    gasFeeEstimated: "Tahmini Gaz Ücreti",
    gasFeePaid: "Ödenen Gaz ücreti",
    inProgress: "işlem devam ediyor",
    nftStepDetails: "{{tool}} aracılığıyla NFT satın alın",
    onChain: "{{chainName}} üzerinde",
    otherTokens: "Diğer jetonlar",
    ownedBy: "Tarafından sahip olunan",
    process: {
      crossChain: {
        actionRequired: "Lütfen işlemi onaylayın",
        done: "Köprü işlemi teyit edildi",
        pending: "Köprü işlemi bekleniyor",
        started: "Köprü işlemi hazırlanıyor"
      },
      nft: {
        done: "NFT satın alındı"
      },
      receivingChain: {
        done: "Köprü işlemi tamamlandı",
        partial: "Köprü işlemi kısmen tamamlandı",
        pending: "Hedef zincir bekleniyor",
        refunded: "Köprü işlemi iade edildi"
      },
      swap: {
        actionRequired: "Lütfen işlemi onaylayın",
        done: "Takas işlemi tamamlandı",
        pending: "Takas işlemi bekleniyor",
        started: "Takas işlemi hazırlanıyor"
      },
      switchChain: {
        actionRequired: "Lütfen ağı değiştirin",
        done: "Ağ başarıyla değiştirildi"
      },
      tokenAllowance: {
        done: "Jeton izni onaylandı",
        pending: "Jeton izni bekleniyor",
        started: "Jeton izni ayarlanıyor"
      }
    },
    quotedAmount: "Teklif edilen tutar",
    rateChange: "Değişiklik oranı",
    receiving: "Alınıyor",
    refuelStepDetails: "{{tool}} aracılığıyla gaz al",
    selectChain: "Zincir",
    selectChainAndToken: "Ağı ve jetonu seçin",
    selectToken: "Jeton",
    sendToAddress: "Bu adrese gönder: {{address}}",
    sendToWallet: "Farklı bir cüzdana gönder",
    sending: "Gönderiliyor",
    sentToAddress: "Bu adrese gönderildi: {{address}}",
    stepBridge: "Köprüle",
    stepBridgeAndBuy: "Köprüle ve satın al",
    stepDetails: "LI.FI aracılığıyla {{tool}}",
    stepSwap: "Takas et",
    stepSwapAndBridge: "Takas et ve Köprüle",
    stepSwapAndBuy: "Takasla ve satın al",
    supportId: "Destek",
    swapStepDetails: "{{chain}} üzerinde {{tool}} aracılığıyla takas et",
    tags: {
      cheapest: "Ucuz",
      fastest: "Hızlı",
      insurable: "Sigortalanabilir",
      insurance: "Sigorta",
      insured: "Sigortalı",
      recommended: "Önerilen",
      safest: "Güvenli"
    },
    to: "Şuna",
    tokenOnChain: "{{chainName}} üzerindeki {{tokenSymbol}}",
    tokenOnChainAmount: "{{chainName}} üzerindeki {{amount, number(maximumFractionDigits: 9)}}{{tokenSymbol}}",
    tokenSearch: "Tokenlerinizi adres ve ya isim aracılığıyla arayın",
    valueLoss: "Değer kaybı",
    walletAddressOrEns: "Cüzdan adresi veya ENS alan adı"
  },
  cGe = {
    bridgeExploits: "Köprü arızaları, hack veya istismarlar",
    insure: "<0>{{amount, number(maximumFractionDigits: 9)}} adet {{tokenSymbol}}</0>. Tek seferde sigortala.",
    insured: "<0>{{amount, number(maximumFractionDigits: 9)}} adet {{tokenSymbol}}</0> sigortalandı:",
    slippageError: "Alınan tokenlar için slipaj hatası"
  },
  lGe = {
    enabledBridges: "Etkin Köprüler",
    enabledExchanges: "Etkin platformlar",
    gasPrice: {
      fast: "Hızlı",
      normal: "Standard",
      slow: "Yavaş",
      title: "Gaz ücreti"
    },
    routePriority: "Rota önceliği",
    showDestinationWallet: "Hedef Adresi Göster",
    slippage: "Sapma toleransı",
    resetSettings: "Kullanılabilir rotaların sayısını sınırlayan özel bir ayar kullanıyorsunuz."
  },
  uGe = {
    extensionNotFound: "Lütfen bu cüzdanı seçmeden önce yalnızca {{name}} tarayıcı uzantısının etkin olduğundan emin olun."
  },
  dGe = {
    language: Xqe,
    format: Zqe,
    button: eGe,
    header: tGe,
    info: nGe,
    success: rGe,
    warning: iGe,
    error: sGe,
    tooltip: oGe,
    main: aGe,
    insurance: cGe,
    settings: lGe,
    wallet: uGe
  },
  fGe = {
    name: "Українська",
    title: "Мова"
  },
  hGe = {
    currency: "{{value, currency(currency: USD)}}",
    number: "{{value, number(maximumFractionDigits: 9)}}"
  },
  pGe = {
    auto: "Авто",
    bridge: "Бридж",
    buy: "Придбати",
    buyNow: "Придбати",
    cancel: "Скасувати",
    connectWallet: "Під'єднати гаманець",
    contactSupport: "Служба підтримки",
    continue: "Продовжити",
    copyAddress: "Скопіювати адресу",
    dark: "Темна",
    delete: "Видалити",
    disconnect: "Від'єднатись",
    done: "Готово",
    exchange: "Обмін",
    getGas: "Отримати газ",
    hide: "Сховати",
    learnMore: "Докладніше",
    lifiCheckout: "LI.FI Checkout",
    lifiExchange: "LI.FI Обмін",
    light: "Світла",
    max: "макс",
    ok: "Ок",
    removeTransaction: "Видалити транзакцію",
    reset: "Скинути",
    resetSettings: "Скинути налаштування",
    reviewBridge: "Переглянути бридж",
    reviewPurchase: "Перегляд покупки",
    reviewSwap: "Переглянути своп",
    seeDetails: "Детальніше",
    showAll: "Показати всі",
    startBridging: "Почати бридж",
    startSwapping: "Почати своп",
    swap: "Своп",
    tryAgain: "Спробувати ще раз",
    viewCoverage: "Переглянути покриття",
    viewOnExplorer: "Переглянути в оглядачі"
  },
  mGe = {
    activeTransactions: "Активні транзакції",
    bridge: "Бридж",
    checkout: "Розрахунок",
    exchange: "Обмін",
    from: "Своп з",
    gas: "Газ",
    payWith: "Сплатити за допомогою",
    purchase: "Купівля",
    purchaseDetails: "Деталі покупки",
    selectChain: "Виберіть чейн",
    selectWallet: "Виберіть свій гаманець",
    settings: "Налаштування",
    swap: "Своп",
    to: "Своп на",
    transactionDetails: "Деталі транзакції",
    transactionHistory: "Історія транзакцій",
    walletConnected: "Гаманець підʼєднано",
    youGet: "Ви отримаєте"
  },
  gGe = {
    message: {
      autoRefuel: "У вас замало {{chainName}} газу. Продовжуючи, ви отримаєте достатньо газу, щоб завершити обмін.",
      emptyActiveTransactions: "Тут показуються незавершені транзакції. Після завершення ви можете знайти їх в історії транзакцій.",
      emptyTokenList: "Нам не вдалося знайти токени на {{chainName}}, або у вас їх немає. Будь ласка, спробуйте пошук за адресою контракту або виберіть інший чейн.",
      emptyTransactionHistory: "Історія транзакцій зберігається лише локально та буде видалена, якщо ви очистите дані браузера.",
      routeNotFound: "Причинами цього можуть бути: низька ліквідність, вибрана надто низька сума, занадто високі витрати на газ або відсутність маршрутів для вибраної комбінації."
    },
    title: {
      autoRefuel: "Отримати газ",
      emptyActiveTransactions: "Немає активних транзакцій",
      emptyTransactionHistory: "Немає останніх транзакцій",
      routeNotFound: "Немає доступних маршрутів"
    }
  },
  yGe = {
    message: {
      exchangePartiallySuccessful: "Ми намагалися завершити транзакцію, але {{tool}} не вистачило ліквідності токену {{tokenSymbol}}.",
      exchangeSuccessful: "Зараз є {{amount, number(maximumFractionDigits: 9)}} {{tokenSymbol}} у гаманці {{walletAddress}} на чейні {{chainName}}.",
      purchaseSuccessful: "Тепер ви маєте {{assetName}} в {{walletAddress}} гаманці на ланцюжку {{chainName}}."
    },
    title: {
      bridgePartiallySuccessful: "Бридж частково успішний",
      bridgeSuccessful: "Бридж успішний",
      purchaseSuccessful: "Покупка успішна",
      refundIssued: "Здійснено повернення коштів",
      swapPartiallySuccessful: "Своп частково успішний",
      swapSuccessful: "Своп успішний"
    }
  },
  vGe = {
    message: {
      deleteActiveTransactions: "Активні транзакції зберігаються лише локально й не можуть бути відновлені, якщо ви їх видалите.",
      deleteTransactionHistory: "Історія транзакцій зберігається лише локально й не може бути відновлена, якщо ви їх видалите.",
      highValueLoss: "Вартість отриманих токенів значно нижча, ніж обмінені токени та вартість транзакції.",
      insufficientFunds: "У вас недостатньо коштів для здійснення свопу.",
      insufficientGas: "Для завершення свопа у вас недостатньо газу. Вам необхідно додати хоча б:",
      rateChanged: "Курс обміну змінився. Продовжуючи своп, ви приймете новий курс.",
      resetSettings: "Це скине пріоритет вашого маршруту, прослизання, ціну газу, увімкнені бриджі та обмінники."
    },
    title: {
      deleteActiveTransactions: "Видалити всі активні транзакції?",
      deleteTransaction: "Видалити цю транзакцію?",
      deleteTransactionHistory: "Видалити історію транзакцій?",
      highValueLoss: "Висока втрата вартості",
      insufficientGas: "Недостатня кількість газу",
      rateChanged: "Курс змінився",
      resetSettings: "Скинути налаштування?"
    }
  },
  bGe = {
    message: {
      allowanceRequired: "Сума переказу для {{tokenSymbol}} перевищує поточну межу. Збільшіть доступну кількість у гаманці та спробуйте ще раз.",
      insufficientFunds: "Не вистачає газу для покриття вартості транзакції.",
      slippageThreshold: "Прослизання перевищує визначений поріг. Будь ласка, зробіть запит на новий маршрут, щоб отримати нову пропозицію.",
      transactionFailed: "Будь ласка, перевірте провідник блоків для отримання додаткової інформації.",
      transactionNotSent: "Транзакція не була відправлена. {{amount, number(maximumFractionDigits: 9)}} {{tokenSymbol}} на {{chainName}} все ще знаходяться у вашому гаманці.",
      transactionRejected: "Для завершення транзакції потрібен ваш підпис. {{amount, number(maximumFractionDigits: 9)}} {{tokenSymbol}} на {{chainName}} залишаються у вашому гаманці.",
      unknown: "Будь ласка, спробуйте ще раз або зверніться до служби підтримки."
    },
    title: {
      allowanceRequired: "Недостатня дозволена кількість",
      balanceIsTooLow: "Баланс занадто низький",
      chainSwitch: "Потрібно переключити чейн.",
      gasLimitIsTooLow: "Занадто низький ліміт газу",
      insufficientFunds: "Недостатньо коштів",
      slippageNotMet: "Не виконані умови прослизання",
      transactionCanceled: "Транзакцію скасовано",
      transactionFailed: "Транзакція не вдалася.",
      transactionRejected: "Підпис обов'язковий.",
      transactionUnderpriced: "Транзакція є заниженою.",
      transactionUnprepared: "Не вдалося підготувати транзакцію.",
      unknown: "Щось пішло не так.",
      walletAddressInvalid: "Адреса гаманця недійсна.",
      walletAddressRequired: "Необхідно вказати адресу гаманця.",
      walletEnsAddressInvalid: "Адреса гаманця недійсна або мережа не підтримує ENS."
    }
  },
  wGe = {
    additionalProviderFee: "Додаткові комісії бриджів, обмінників та послуг.",
    estimatedNetworkFee: "Орієнтовна мережева плата.",
    estimatedTime: "Орієнтовний час виконання свопу в хвилинах.",
    notFound: {
      text: "Ми не змогли знайти цю сторінку.",
      title: "404"
    },
    numberOfSteps: "Кількість кроків свопу. Кожен крок може містити 1-3 транзакції, які потребують підпису.",
    progressToNextUpdate: "Зображені дані автоматично оновляться через {{value}} секунд. Натисніть тут, щоб оновити вручну.",
    recommended: "Дешевий маршрут, який балансує складність і легкість використання.",
    settingsModified: "Налаштування (змінено)"
  },
  xGe = {
    crossStepDetails: "Бридж з {{from}} до {{to}} через {{tool}}",
    currentAmount: "Поточна сума",
    estimatedTime: "{{value}}х",
    featuredTokens: "Рекомендовані токени",
    from: "З",
    fromAmount: "Ви платите",
    gasCost: "Вартість газу",
    gasFeeEstimated: "орієнтована комісія за газ",
    gasFeePaid: "оплата за газ",
    inProgress: "в процесі",
    nftStepDetails: "Придбати NFT через {{tool}}",
    onChain: "на {{chainName}}",
    otherTokens: "Інші токени",
    ownedBy: "Власник",
    process: {
      crossChain: {
        actionRequired: "Будь ласка, підпишіть транзакцію",
        done: "Бридж транзакцію схвалено",
        pending: "Очікування бридж транзакції",
        started: "Підготовка бридж транзакції"
      },
      nft: {
        done: "Придбано NFT"
      },
      receivingChain: {
        done: "Бридж завершено",
        partial: "Бридж частково завершено",
        pending: "В очікуванні чейна що приймає",
        refunded: "Бридж транзакція відшкодована"
      },
      swap: {
        actionRequired: "Будь ласка, підпишіть транзакцію",
        done: "Своп завершено",
        pending: "Очікування своп транзакції",
        started: "Підготовка своп транзакції"
      },
      switchChain: {
        actionRequired: "Потрібно перемикнути чейн",
        done: "Чейн успішно перемикнувся"
      },
      tokenAllowance: {
        done: "Токени схвалено",
        pending: "Очікування схвалення токенів",
        started: "Схвалення токенів"
      }
    },
    quotedAmount: "Запропонована сума",
    rateChange: "Зміна курсу",
    receiving: "Отримання",
    refuelStepDetails: "Отримати газ через {{tool}}",
    selectChain: "Виберіть чейн",
    selectChainAndToken: "Виберіть чейн і токен",
    selectToken: "Виберіть токен",
    sendToAddress: "Відправити на {{address}}",
    sendToWallet: "Надіслати на інший гаманець",
    sending: "Відправлення",
    sentToAddress: "Відправлено на {{address}}",
    stepBridge: "Бридж",
    stepBridgeAndBuy: "Бридж та покупка",
    stepDetails: "{{tool}} через LI.FI",
    stepSwap: "Своп",
    stepSwapAndBridge: "Своп та бридж",
    stepSwapAndBuy: "Своп та покупка",
    supportId: "Ідентифікатор підтримки",
    swapStepDetails: "Своп на {{chain}} через {{tool}}",
    tags: {
      cheapest: "Дешевий",
      fastest: "Швидкий",
      insurable: "Страховка",
      insurance: "Страхування",
      insured: "Застрахований",
      recommended: "Рекомендований",
      safest: "Безпечний"
    },
    to: "До",
    tokenOnChain: "{{tokenSymbol}} на {{chainName}}",
    tokenOnChainAmount: "{{amount, number(maximumFractionDigits: 9)}} {{tokenSymbol}} на {{chainName}}",
    tokenSearch: "Шукати за ім'ям або адресою",
    valueLoss: "Втрата вартості",
    walletAddressOrEns: "Адреса гаманця або ім’я ENS"
  },
  EGe = {
    bridgeExploits: "Збої в роботі бриджу, зломи чи експлойти",
    insure: "Застрахуйте <0>{{amount, number(maximumFractionDigits: 9)}} {{tokenSymbol}}</0> токенів транзакції.",
    insured: "Ви застрахували <0>{{amount, number(maximumFractionDigits: 9)}} {{tokenSymbol}}</0> токенів транзакції:",
    slippageError: "Помилка в прослизанні для отриманих токенів"
  },
  SGe = {
    enabledBridges: "Увімкнені бриджі",
    enabledExchanges: "Увімкнені обмінники",
    gasPrice: {
      fast: "Швидко",
      normal: "Нормально",
      slow: "Повільно",
      title: "Ціна на газ"
    },
    routePriority: "Пріоритет маршруту",
    showDestinationWallet: "Показати цільовий гаманець",
    slippage: "Прослизання",
    resetSettings: "Ви використовуєте налаштування які можуть обмежувати кількість доступних маршрутів."
  },
  CGe = {
    extensionNotFound: "Перш ніж вибрати цей гаманець, переконайтеся, що в браузері активне лише розширення {{name}}."
  },
  AGe = {
    language: fGe,
    format: hGe,
    button: pGe,
    header: mGe,
    info: gGe,
    success: yGe,
    warning: vGe,
    error: bGe,
    tooltip: wGe,
    main: xGe,
    insurance: EGe,
    settings: SGe,
    wallet: CGe
  },
  TGe = {
    name: "Tiếng Việt",
    title: "Ngôn ngữ"
  },
  kGe = {
    currency: "{{value, currency(currency: USD)}}",
    number: "{{value, number(maximumFractionDigits: 9)}}"
  },
  _Ge = {
    auto: "Tự động",
    bridge: "Cầu",
    buy: "Mua",
    buyNow: "Mua ngay bây giờ",
    cancel: "Huỷ bỏ",
    connectWallet: "Kết nối ví",
    contactSupport: "Liên hệ hỗ trợ",
    continue: "Tiếp tục",
    copyAddress: "Sao chép địa chỉ",
    dark: "Tối",
    delete: "Xóa",
    disconnect: "Ngắt kết nối",
    done: "Hoàn thành",
    exchange: "Hoán đổi",
    getGas: "Thiết lập gas",
    hide: "Ẩn",
    learnMore: "Xem thêm",
    lifiCheckout: "LI.FI Checkout",
    lifiExchange: "LI.FI Exchange",
    light: "Sáng",
    max: "Tối đa",
    ok: "Ok",
    removeTransaction: "Xoá giao dịch",
    reset: "Đặt lại",
    resetSettings: "Đặt lại cài đặt",
    reviewBridge: "Xem xét cầu",
    reviewPurchase: "Đánh giá thanh toán",
    reviewSwap: "Xem lại Swap",
    seeDetails: "Xem chi tiết",
    showAll: "Hiển thị tất cả",
    startBridging: "Bắt đầu đi cầu",
    startSwapping: "Bắt đầu Swap",
    swap: "Swap",
    tryAgain: "Thử lại",
    viewCoverage: "Xem phạm vi bảo hiểm",
    viewOnExplorer: "Xem tại Explorer"
  },
  IGe = {
    activeTransactions: "Các giao dịch hiện tại",
    bridge: "Cầu",
    checkout: "Thanh toán",
    exchange: "Hoán đổi",
    from: "Swap từ",
    gas: "Gas",
    payWith: "Thanh toán bằng",
    purchase: "Thanh toán",
    purchaseDetails: "Thông tin chi tiết",
    selectChain: "Chọn chain",
    selectWallet: "Chọn ví",
    settings: "Cài đặt",
    swap: "Swap",
    to: "Swap từ",
    transactionDetails: "Chi tiết giao dịch",
    transactionHistory: "Lịch sử giao dịch",
    walletConnected: "Wallet connected",
    youGet: "Bạn nhận"
  },
  PGe = {
    message: {
      autoRefuel: "Gas trên {{chainName}} chain của bạn đang thấp. Để tiếp tục, bạn nên có thêm gas để hoàn thành việc swap.",
      emptyActiveTransactions: "Các lệnh swap đang xử lý sẽ được hiện ở đây. Khi nào lệnh hoàn tất, bạn có thể kiểm tra lại tại mục lịch sử swap.",
      emptyTokenList: "Chúng tôi không thể tìm được token ở {{chainName}} hoặc số dư của bạn không có. Vui lòng thử tìm kiếm lại hoặc chọn một chain khác.",
      emptyTransactionHistory: "Lịch sử Swap chỉ được lưu trữ cục bộ và sẽ bị xóa nếu bạn xóa dữ liệu trình duyệt của mình.",
      routeNotFound: "Lý do cho điều đó có thể là: tính thanh khoản thấp, số tiền được chọn quá thấp, chi phí gas quá cao hoặc không có lộ trình cho cặp giao dịch đã chọn."
    },
    title: {
      autoRefuel: "Thiết lập Gas",
      emptyActiveTransactions: "Không có thông tin giao dịch hiện tại",
      emptyTransactionHistory: "Chưa có giao dịch",
      routeNotFound: "Không có đường đi"
    }
  },
  RGe = {
    message: {
      exchangePartiallySuccessful: "Chúng tôi đã cố gắng hoàn thành việc hoán đổi, nhưng {{tool}} đã cạn thanh khoản cho token {{tokenSymbol}}.",
      exchangeSuccessful: "Hiện tại {{amount, number(maximumFractionDigits: 9)}} {{tokenSymbol}} trong ví {{walletAddress}} tại {{chainName}} chain.",
      purchaseSuccessful: "Hiện tại bạn đang nắm giữ {{assetName}} tại ví {{walletAddress}} trên chain {{chainName}}."
    },
    title: {
      bridgePartiallySuccessful: "Swap thành công một phần",
      bridgeSuccessful: "Bridge thành công",
      purchaseSuccessful: "Mua thành công",
      refundIssued: "Đã Refund",
      swapPartiallySuccessful: "Swap thành công một phần",
      swapSuccessful: "Swap thành công"
    }
  },
  OGe = {
    message: {
      deleteActiveTransactions: "Các giao dịch đang hoạt động chỉ được lưu trữ cục bộ và không thể phục hồi nếu bạn xóa chúng.",
      deleteTransactionHistory: "Lịch sử Swap chỉ lưu trữ cục bộ và không thể phục hồi khi bạn xoá chúng.",
      highValueLoss: "Giá trị của token nhận được đang thấp hơn rất nhiều so với token được swap và chi phí giao dịch.",
      insufficientFunds: "Bạn không có đủ tiền để thực hiện tác vụ này.",
      insufficientGas: "Bạn không đủ gas để thực hiện swap. Bạn cần thêm ít nhất:",
      rateChanged: "Tỉ lệ hoán đổi đã thay đổi. Để tiếp tục Swap, bạn sẽ chấp nhận tỉ lệ mới.",
      resetSettings: "Thao tác này sẽ đặt lại mức độ ưu tiên của tuyến đường, độ trượt giá, giá gas, bridge và sàn giao dịch."
    },
    title: {
      deleteActiveTransactions: "Xóa tất cả giao dịch đang thực hiện?",
      deleteTransaction: "Xóa giao dịch này?",
      deleteTransactionHistory: "Xoá lịch sử giao dịch?",
      highValueLoss: "Tổn thất lớn",
      insufficientGas: "Không đủ gas",
      rateChanged: "Tỉ giá đã thay đổi",
      resetSettings: "Đặt lại cài đặt?"
    }
  },
  DGe = {
    message: {
      allowanceRequired: "Chuyển số lượng {{tokenSymbol}} vượt quá mức cho phép hiện tại của bạn. Vui lòng tăng mức độ cho phép sử dụng token và thử lại.",
      insufficientFunds: "Bạn không có đủ gas để chi trả cho chi phí giao dịch.",
      slippageThreshold: "Độ trượt giá lớn hơn ngưỡng xác định. Vui lòng yêu cầu một tuyến đường mới để nhận báo giá mới.",
      transactionFailed: "Vui lòng kiểm tra block explorer để biết thêm thông tin.",
      transactionNotSent: "Giao dịch chưa được gửi. {{amount, number(maximumFractionDigits: 9)}} {{tokenSymbol}} tại {{chainName}} vẫn còn trong ví của bạn.",
      transactionRejected: "Cần có chữ ký để hoàn tất giao dịch. {{amount, number(maximumFractionDigits: 9)}} {{tokenSymbol}} tại {{chainName}} vẫn còn trong ví của bạn.",
      unknown: "Vui lòng thử lại hoặc liên hệ hỗ trợ."
    },
    title: {
      allowanceRequired: "Sự cho phép không đủ",
      balanceIsTooLow: "Số dư quá thấp",
      chainSwitch: "Yêu cầu đổi chain",
      gasLimitIsTooLow: "Giới hạn gas quá thấp",
      insufficientFunds: "Không đủ tài sản",
      slippageNotMet: "Điều kiện trượt giá không được đáp ứng",
      transactionCanceled: "Giao dịch bị huỷ",
      transactionFailed: "Giao dịch không thành công",
      transactionRejected: "Yêu cầu chữ ký",
      transactionUnderpriced: "Giao dịch bị định giá thấp",
      transactionUnprepared: "Không thể tải giao dịch",
      unknown: "Xảy ra lỗi",
      walletAddressInvalid: "Địa chỉ ví không hợp lệ.",
      walletAddressRequired: "Yêu cầu địa chỉ ví.",
      walletEnsAddressInvalid: "Địa chỉ ví không hợp lệ hoặc mạng lưới không hỗ trợ ENS."
    }
  },
  NGe = {
    additionalProviderFee: "Cầu bổ sung, DEX và phí dịch vụ.",
    estimatedNetworkFee: "Phí mạng ước tính.",
    estimatedTime: "Thời gian thực hiện lệnh swap (phút).",
    notFound: {
      text: "Chúng tôi không thể tìm thấy trang này.",
      title: "404"
    },
    numberOfSteps: "Một số bước swap. Mỗi bước có thể chứa 1-2 giao dịch yêu cầu chữ ký.",
    progressToNextUpdate: "Thông tin hiển thị sẽ tự động làm mới sau {{value}} giây. Bấm vào đây để cập nhật thủ công.",
    recommended: "Một tuyến đường giá rẻ cân bằng giữa sự phức tạp và dễ sử dụng.",
    settingsModified: "Thiết lập (Đã điều chỉnh)"
  },
  MGe = {
    crossStepDetails: "Chuyển từ {{from}} đến {{to}} thông qua {{tool}}",
    currentAmount: "Số lượng hiện tại",
    estimatedTime: "{{value}}m",
    featuredTokens: "Featured tokens",
    from: "Từ",
    fromAmount: "Yêu cầu",
    gasCost: "Phí Gas",
    gasFeeEstimated: "phí Gas ước tính",
    gasFeePaid: "phí Gas đã trả",
    inProgress: "đang xử lý",
    nftStepDetails: "Mua NFT thông qua {{tool}}",
    onChain: "tại {{chainName}}",
    otherTokens: "Token khác",
    ownedBy: "Được sở hữu bởi",
    process: {
      crossChain: {
        actionRequired: "Vui lòng ký hoàn thành giao dịch",
        done: "Giao dịch bridge đã được xác nhận",
        pending: "Chờ giao dịch Bridge",
        started: "Chuẩn bị giao dịch Bridge"
      },
      nft: {
        done: "NFT đã mua"
      },
      receivingChain: {
        done: "Bridge thành công",
        partial: "Bridge thành công 1 phần",
        pending: "Đạng chain đến",
        refunded: "Giao dịch Bridge đã được hoàn trả"
      },
      swap: {
        actionRequired: "Vui lòng ký hoàn thành giao dịch",
        done: "Lệnh swap đã hoàn tất",
        pending: "Chờ giao dịch Swap",
        started: "Đang chuẩn bị giao dịch Swap"
      },
      switchChain: {
        actionRequired: "Yêu cầu đổi chain",
        done: "Chuyển đổi chain thành công"
      },
      tokenAllowance: {
        done: "Mã token đã được phê duyệt",
        pending: "Chờ phê duyệt quyền sử dụng token",
        started: "Thiết lập quyền sử dụng token"
      }
    },
    quotedAmount: "Số tiền trích dẫn",
    rateChange: "Thay đổi tỉ giá",
    receiving: "Đang nhận",
    refuelStepDetails: "Lấy gas thông qua {{tool}}",
    selectChain: "Chọn chain",
    selectChainAndToken: "Chọn chain và token",
    selectToken: "Chọn Token",
    sendToAddress: "Gửi đến {{address}}",
    sendToWallet: "Gửi đến địa chỉ khác",
    sending: "Đang gửi",
    sentToAddress: "Gửi đến {{address}}",
    stepBridge: "Cầu",
    stepBridgeAndBuy: "Chuyển và mua",
    stepDetails: "{{tool}} thông qua LI.FI",
    stepSwap: "Swap",
    stepSwapAndBridge: "Swap và Bridge",
    stepSwapAndBuy: "Hoán đổi và mua",
    supportId: "Mã ID yêu cầu hỗ trợ",
    swapStepDetails: "Swap tại {{chain}} thông qua {{tool}}",
    tags: {
      cheapest: "Rẻ",
      fastest: "Nhanh",
      insurable: "Bảo hiểm",
      insurance: "Bảo hiểm",
      insured: "An toàn",
      recommended: "Khuyến nghị",
      safest: "An toàn"
    },
    to: "Đến",
    tokenOnChain: "{{tokenSymbol}} tại {{chainName}}",
    tokenOnChainAmount: "{{amount, number(maximumFractionDigits: 9)}} {{tokenSymbol}} tại {{chainName}}",
    tokenSearch: "Tìm kiếm bằng tên token hoặc địa chỉ",
    valueLoss: "Bạn sẽ mất",
    walletAddressOrEns: "Địa chỉ hoặc tên miền ENS"
  },
  $Ge = {
    bridgeExploits: "Cầu trục trặc, bị hack hoặc bị khai thác",
    insure: "Bảo hiểm <0>{{amount, number(maximumFractionDigits: 9)}}{{tokenSymbol}}</0> trong quá trình vận chuyển.",
    insured: "Bạn đã bảo hiểm <0>{{amount, number(maximumFractionDigits: 9)}} {{tokenSymbol}}</0> trong quá trình vận chuyển:",
    slippageError: "Lỗi trượt giá đối với token nhận được"
  },
  LGe = {
    enabledBridges: "Số lượng cầu khả dụng",
    enabledExchanges: "Số lượng sàn giao dịch khả dụng",
    gasPrice: {
      fast: "Nhanh",
      normal: "Bình thường",
      slow: "Chậm",
      title: "Giá gas"
    },
    routePriority: "Tuyền đường ưu tiên",
    showDestinationWallet: "Hiển thị địa chỉ ví nhận",
    slippage: "Trượt giá"
  },
  BGe = {
    extensionNotFound: "Chắc chắn rằng tiện ích trên trình duyệt {{name}} đã được kích hoạt tước khi chọn ví này."
  },
  FGe = {
    language: TGe,
    format: kGe,
    button: _Ge,
    header: IGe,
    info: PGe,
    success: RGe,
    warning: OGe,
    error: DGe,
    tooltip: NGe,
    main: MGe,
    insurance: $Ge,
    settings: LGe,
    wallet: BGe
  },
  jGe = {
    name: "中文",
    title: "语言"
  },
  UGe = {
    currency: "{{value, currency(currency: USD)}}",
    number: "{{value, number(maximumFractionDigits: 9)}}"
  },
  zGe = {
    auto: "自动",
    bridge: "跨链",
    buy: "购买",
    buyNow: "立即购买",
    cancel: "取消",
    connectWallet: "关联钱包",
    contactSupport: "联系技术支持",
    continue: "继续",
    copyAddress: "复制地址",
    dark: "深色主题",
    delete: "删除",
    disconnect: "断开连接",
    done: "已完成",
    exchange: "兑换",
    getGas: "开始兑换燃气费",
    hide: "隐藏",
    learnMore: "了解更多",
    lifiCheckout: "LI.FI 结算",
    lifiExchange: "LI.FI 兑换",
    light: "浅色主题",
    max: "最大",
    ok: "确认",
    removeTransaction: "删除交易",
    reset: "重置",
    resetSettings: "恢复默认设置",
    reviewBridge: "查看跨链详情",
    reviewPurchase: "查看购买详情",
    reviewSwap: "查看该兑换",
    seeDetails: "查看详情",
    showAll: "显示所有",
    startBridging: "开始跨链",
    startSwapping: "开始兑换",
    swap: "兑换",
    tryAgain: "重试",
    viewCoverage: "查看我们的覆盖范围",
    viewOnExplorer: "在区块链浏览器上查看"
  },
  HGe = {
    activeTransactions: "进行中的交易",
    bridge: "跨链",
    checkout: "支付",
    exchange: "兑换",
    from: "兑换自",
    gas: "燃气费",
    payWith: "支付方式",
    purchase: "购买",
    purchaseDetails: "交易明细",
    selectChain: "选择网络",
    selectWallet: "选择你的钱包",
    settings: "设置",
    swap: "兑换",
    to: "兑换为",
    transactionDetails: "交易详情",
    transactionHistory: "交易记录",
    walletConnected: "连接钱包",
    youGet: "您获得"
  },
  VGe = {
    message: {
      autoRefuel: "您在 {{chainName}} 链上的燃气费很低。如果启用该选项，您将获得足够的燃气费完成此次兑换。",
      emptyActiveTransactions: "正在进行的兑换将在这里显示。一旦完成，你可在兑换记录中找到它们。",
      emptyTokenList: "我们无法在 {{chainName}} 链上找到这些代币，或者你的钱包内没有这些代币。请再次搜索或者选择其他链再试一次。",
      emptyTransactionHistory: "交易记录只存储在本地，如果您清除浏览器数据，交易记录将被删除。",
      routeNotFound: "导致其的原因可能是：流动性低，所选定代币的数额太低，燃气费过高，或者当前没有合适的交易路径。"
    },
    title: {
      autoRefuel: "获得燃气费",
      emptyActiveTransactions: "没有正在进行的交易",
      emptyTransactionHistory: "近期无交易",
      routeNotFound: "没有可用的路由"
    }
  },
  WGe = {
    message: {
      exchangePartiallySuccessful: "我们尝试完成本次交易，但是 {{tool}} 的 {{tokenSymbol}} 代币流动性不足。",
      exchangeSuccessful: "{{walletAddress}} 钱包在 {{chainName}} 链上收到 {{amount, number(maximumFractionDigits: 9)}} {{tokenSymbol}}",
      purchaseSuccessful: "您的 {{walletAddress}} 钱包在 {{chainName}} 链上拥有该 {{assetName}} 财产"
    },
    title: {
      bridgePartiallySuccessful: "跨链部分成功",
      bridgeSuccessful: "跨链成功",
      purchaseSuccessful: "购买成功",
      refundIssued: "退款已受理",
      swapPartiallySuccessful: "兑换部分完成",
      swapSuccessful: "兑换成功"
    }
  },
  qGe = {
    message: {
      deleteActiveTransactions: "正在进行的交易记录只存储在本地，如果删除它们，我们将无法恢复这些记录。",
      deleteTransactionHistory: "交易记录只存储在本地，如果你删除它，我们将无法恢复这些记录。",
      highValueLoss: "收到的代币的价值明显低于要被兑换的代币和交易成本。",
      insufficientFunds: "你没有足够的资金来完成这笔交易。",
      insufficientGas: "您没有足够的燃气费来完成此次交易。您至少需要添加：",
      rateChanged: "兑换比例已经改变，如果继续兑换，您将接受新的兑换比例。",
      resetSettings: "这将重置您的路由优先级，滑点，燃气费，选中的跨链桥和链上交易所。"
    },
    title: {
      deleteActiveTransactions: "确定要删除所有正在进行的交易吗？",
      deleteTransaction: "确定要删除该交易吗？",
      deleteTransactionHistory: "确定要清空交易记录吗?",
      highValueLoss: "大额资金损失",
      insufficientGas: "燃气费不足",
      rateChanged: "兑换比例变动",
      resetSettings: "确定要恢复默认设置吗?"
    }
  },
  GGe = {
    message: {
      allowanceRequired: "{{tokenSymbol}} 的转账金额超过了您设置的支出上限。请提高该代币的支出上限，然后重试。",
      insufficientFunds: "您没有足够的燃气费支付该交易。",
      slippageThreshold: "滑点大于预设值，请选择其他路由并获取新的价格。",
      transactionFailed: "请查看区块浏览器以了解更多信息。",
      transactionNotSent: "交易未发送，不用担心，{{chainName}} 链上{{amount, number(maximumFractionDigits: 9)}} 个{{tokenSymbol}} 仍在您的钱包里。",
      transactionRejected: "需要您签名来完成此次交易，资金是安全的，{{chainName}} 链上{{amount, number(maximumFractionDigits: 9)}} 个{{tokenSymbol}} 仍在您的钱包里。",
      unknown: "请再试一次或者联系支持。"
    },
    title: {
      allowanceRequired: "余额不足",
      balanceIsTooLow: "余额太低",
      chainSwitch: "请切换当前网络",
      gasLimitIsTooLow: "燃气费设置过低",
      insufficientFunds: "资金不足",
      slippageNotMet: "滑点未满足",
      transactionCanceled: "交易取消",
      transactionFailed: "交易失败",
      transactionRejected: "交易需要签名",
      transactionUnderpriced: "交易定价过低",
      transactionUnprepared: "无法开始该交易",
      unknown: "未知错误",
      walletAddressInvalid: "钱包地址无效。",
      walletAddressRequired: "请输入钱包地址。",
      walletEnsAddressInvalid: "钱包地址无效或者当前网络不支持ENS。"
    }
  },
  KGe = {
    additionalProviderFee: "跨链和交易所的手续费。",
    estimatedNetworkFee: "预估网络手续费。",
    estimatedTime: "预计兑换的执行时间（分钟）。",
    notFound: {
      text: "我们找不到这个页面。",
      title: "404"
    },
    numberOfSteps: "一系列的兑换步骤，每个步骤可能包含1-2个需要签名的交易。",
    progressToNextUpdate: "数据将在{{value}} 秒后自动刷新，点击这里可以手动更新。",
    recommended: "一个价格低廉但是兼顾复杂性和易用性的路由方案。",
    settingsModified: "设置(已修改)"
  },
  QGe = {
    crossStepDetails: "通过{{tool}}把资产从{{from}}链跨到{{to}}链上",
    currentAmount: "当前余额",
    estimatedTime: "{{value}}分钟",
    featuredTokens: "精选代币",
    from: "从",
    fromAmount: "需要支付",
    gasCost: "燃气费消耗",
    gasFeeEstimated: "预估燃气费",
    gasFeePaid: "已支付燃气费",
    inProgress: "进行中",
    nftStepDetails: "通过 {{tool}} 购买 NFT",
    onChain: "在{{chainName}} 上",
    otherTokens: "其他代币",
    ownedBy: "属于",
    process: {
      crossChain: {
        actionRequired: "请签署此交易",
        done: "跨链交易已确认",
        pending: "跨链交易进行中",
        started: "准备执行跨链交易"
      },
      nft: {
        done: "NFT 已购买"
      },
      receivingChain: {
        done: "跨链完成",
        partial: "跨链部分完成",
        pending: "等待接收链回应",
        refunded: "跨链交易资产已退还"
      },
      swap: {
        actionRequired: "请签署此交易",
        done: "兑换完成",
        pending: "代币兑换中",
        started: "准备兑换"
      },
      switchChain: {
        actionRequired: "请切换当前网络",
        done: "网络切换成功"
      },
      tokenAllowance: {
        done: "已批准代币限额",
        pending: "代币限额批准进行中",
        started: "设置代币限额"
      }
    },
    quotedAmount: "报价金额",
    rateChange: "波动率",
    receiving: "接收",
    refuelStepDetails: "通过 {{tool}} 获取燃气费",
    selectChain: "选择网络",
    selectChainAndToken: "选择链和代币",
    selectToken: "选择代币",
    sendToAddress: "发送到{{address}}",
    sendToWallet: "发送到另外的钱包",
    sending: "发送中",
    sentToAddress: "发送到{{address}}",
    stepBridge: "跨链",
    stepBridgeAndBuy: "跨链并购买",
    stepDetails: "通过 LI.FI {{tool}}",
    stepSwap: "兑换",
    stepSwapAndBridge: "兑换和跨链",
    stepSwapAndBuy: "兑换并购买",
    supportId: "支持ID",
    swapStepDetails: "通过{{tool}}在{{chain}}链上兑换代币",
    tags: {
      cheapest: "便宜的",
      fastest: "快速的",
      insurable: "可投保",
      insurance: "保险",
      insured: "受保中",
      recommended: "建议的",
      safest: "最佳/安全"
    },
    to: "到",
    tokenOnChain: "{{chainName}}链上的{{tokenSymbol}}",
    tokenOnChainAmount: "{{chainName}} 链上{{amount, number(maximumFractionDigits: 9)}} 个{{tokenSymbol}}",
    tokenSearch: "按代币名称或者地址搜索",
    valueLoss: "资金损失",
    walletAddressOrEns: "钱包地址或ENS名称"
  },
  YGe = {
    bridgeExploits: "跨链桥故障、被黑或者被利用漏洞",
    insure: "在跨链期间为<0>{{amount, number(maximumFractionDigits: 9)}} {{tokenSymbol}}</0> 投保。",
    insured: "在跨链期间为<0>{{amount, number(maximumFractionDigits: 9)}} {{tokenSymbol}}</0> 投保。",
    slippageError: "目标链代币的滑点错误"
  },
  JGe = {
    enabledBridges: "已选中的跨链桥",
    enabledExchanges: "已选中的交易所",
    gasPrice: {
      fast: "快速",
      normal: "正常",
      slow: "缓慢",
      title: "燃气费"
    },
    routePriority: "路由优先级",
    showDestinationWallet: "显示收款钱包",
    slippage: "滑点",
    resetSettings: "您正在使用自定义设置过滤可用路由。"
  },
  XGe = {
    extensionNotFound: "在选择钱包之前，请确保只有{{name}} 浏览器的扩展应用处于激活状态。"
  },
  ZGe = {
    language: jGe,
    format: UGe,
    button: zGe,
    header: HGe,
    info: VGe,
    success: WGe,
    warning: qGe,
    error: GGe,
    tooltip: KGe,
    main: QGe,
    insurance: YGe,
    settings: JGe,
    wallet: XGe
  },
  F8 = Object.freeze(Object.defineProperty({
    __proto__: null,
    bn: NVe,
    de: KVe,
    en: cWe,
    es: xWe,
    fr: MWe,
    id: QWe,
    it: lqe,
    ko: Sqe,
    pt: Lqe,
    th: Jqe,
    tr: dGe,
    uk: AGe,
    vi: FGe,
    zh: ZGe
  }, Symbol.toStringTag, {
    value: "Module"
  })),
  eKe = ({
    children: e
  }) => {
    const {
      languageResources: t,
      languages: n,
      disableLanguageDetector: r
    } = Wt(), {
      language: i
    } = kc(["language"]), s = j.useMemo(() => {
      var c, l;
      let o = Object.keys(F8).filter(u => Np(u, n)).reduce((u, f) => (u[f] = {
        translation: t != null && t[f] ? aq(F8[f], t[f]) : F8[f]
      }, u), {});
      t && (o = Object.keys(t).reduce((u, f) => (u[f] || (u[f] = {
        translation: t[f]
      }), u), o));
      let a = hs.createInstance({
        lng: (n == null ? void 0 : n.default) || i,
        fallbackLng: o.en ? "en" : (n == null ? void 0 : n.default) || ((c = n == null ? void 0 : n.allow) == null ? void 0 : c[0]) || ((l = Object.keys(o)) == null ? void 0 : l[0]),
        lowerCaseLng: !0,
        interpolation: {
          escapeValue: !1
        },
        resources: o,
        detection: {
          caches: []
        }
      });
      return !i && !(n != null && n.default) && !r && (a = a.use(CJ)), a.use(Gwe).init(), a
    }, [r, i, t, n]);
    return C.jsx(Ywe, {
      i18n: s,
      children: e
    })
  };
let Vb;
const AJ = j.createContext(null),
  ku = () => j.useContext(AJ),
  tKe = ({
    children: e
  }) => {
    const {
      sdkConfig: t,
      integrator: n,
      apiKey: r,
      fee: i,
      referrer: s,
      routePriority: o,
      slippage: a
    } = Wt(), c = j.useMemo(() => {
      const l = {
        ...t,
        apiKey: r,
        integrator: n ?? window.location.hostname,
        defaultRouteOptions: {
          integrator: n ?? window.location.hostname,
          fee: i,
          referrer: s,
          order: o,
          slippage: a,
          ...t == null ? void 0 : t.defaultRouteOptions
        }
      };
      return Vb || (Vb = new Q8e({
        disableVersionCheck: !0,
        widgetVersion: $k,
        ...l
      })), Vb.setConfig(l), Vb
    }, [r, i, n, s, o, t, a]);
    return C.jsx(AJ.Provider, {
      value: c,
      children: e
    })
  };

function nKe(e) {
  return mt("MuiLoadingButton", e)
}
const rKe = gt("MuiLoadingButton", ["root", "loading", "loadingIndicator", "loadingIndicatorCenter", "loadingIndicatorStart", "loadingIndicatorEnd", "endIconLoadingEnd", "startIconLoadingStart"]),
  _o = rKe,
  iKe = ["children", "disabled", "id", "loading", "loadingIndicator", "loadingPosition", "variant"],
  sKe = e => {
    const {
      loading: t,
      loadingPosition: n,
      classes: r
    } = e, i = {
      root: ["root", t && "loading"],
      startIcon: [t && `startIconLoading${qe(n)}`],
      endIcon: [t && `endIconLoading${qe(n)}`],
      loadingIndicator: ["loadingIndicator", t && `loadingIndicator${qe(n)}`]
    }, s = pt(i, nKe, r);
    return K({}, r, s)
  },
  oKe = e => e !== "ownerState" && e !== "theme" && e !== "sx" && e !== "as" && e !== "classes",
  aKe = me(ur, {
    shouldForwardProp: e => oKe(e) || e === "classes",
    name: "MuiLoadingButton",
    slot: "Root",
    overridesResolver: (e, t) => [t.root, t.startIconLoadingStart && {
      [`& .${_o.startIconLoadingStart}`]: t.startIconLoadingStart
    }, t.endIconLoadingEnd && {
      [`& .${_o.endIconLoadingEnd}`]: t.endIconLoadingEnd
    }]
  })(({
    ownerState: e,
    theme: t
  }) => K({
    [`& .${_o.startIconLoadingStart}, & .${_o.endIconLoadingEnd}`]: {
      transition: t.transitions.create(["opacity"], {
        duration: t.transitions.duration.short
      }),
      opacity: 0
    }
  }, e.loadingPosition === "center" && {
    transition: t.transitions.create(["background-color", "box-shadow", "border-color"], {
      duration: t.transitions.duration.short
    }),
    [`&.${_o.loading}`]: {
      color: "transparent"
    }
  }, e.loadingPosition === "start" && e.fullWidth && {
    [`& .${_o.startIconLoadingStart}, & .${_o.endIconLoadingEnd}`]: {
      transition: t.transitions.create(["opacity"], {
        duration: t.transitions.duration.short
      }),
      opacity: 0,
      marginRight: -8
    }
  }, e.loadingPosition === "end" && e.fullWidth && {
    [`& .${_o.startIconLoadingStart}, & .${_o.endIconLoadingEnd}`]: {
      transition: t.transitions.create(["opacity"], {
        duration: t.transitions.duration.short
      }),
      opacity: 0,
      marginLeft: -8
    }
  })),
  cKe = me("span", {
    name: "MuiLoadingButton",
    slot: "LoadingIndicator",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.loadingIndicator, t[`loadingIndicator${qe(n.loadingPosition)}`]]
    }
  })(({
    theme: e,
    ownerState: t
  }) => K({
    position: "absolute",
    visibility: "visible",
    display: "flex"
  }, t.loadingPosition === "start" && (t.variant === "outlined" || t.variant === "contained") && {
    left: t.size === "small" ? 10 : 14
  }, t.loadingPosition === "start" && t.variant === "text" && {
    left: 6
  }, t.loadingPosition === "center" && {
    left: "50%",
    transform: "translate(-50%)",
    color: (e.vars || e).palette.action.disabled
  }, t.loadingPosition === "end" && (t.variant === "outlined" || t.variant === "contained") && {
    right: t.size === "small" ? 10 : 14
  }, t.loadingPosition === "end" && t.variant === "text" && {
    right: 6
  }, t.loadingPosition === "start" && t.fullWidth && {
    position: "relative",
    left: -10
  }, t.loadingPosition === "end" && t.fullWidth && {
    position: "relative",
    right: -10
  })),
  lKe = j.forwardRef(function (t, n) {
    const r = j.useContext(iH),
      i = N2(r, t),
      s = xt({
        props: i,
        name: "MuiLoadingButton"
      }),
      {
        children: o,
        disabled: a = !1,
        id: c,
        loading: l = !1,
        loadingIndicator: u,
        loadingPosition: f = "center",
        variant: h = "text"
      } = s,
      g = Ve(s, iKe),
      y = O2(c),
      x = u ?? C.jsx(u3, {
        "aria-labelledby": y,
        color: "inherit",
        size: 16
      }),
      k = K({}, s, {
        disabled: a,
        loading: l,
        loadingIndicator: x,
        loadingPosition: f,
        variant: h
      }),
      _ = sKe(k),
      p = l ? C.jsx(cKe, {
        className: _.loadingIndicator,
        ownerState: k,
        children: x
      }) : null;
    return C.jsxs(aKe, K({
      disabled: a || l,
      id: y,
      ref: n
    }, g, {
      variant: h,
      classes: _,
      ownerState: k,
      children: [k.loadingPosition === "end" ? o : p, k.loadingPosition === "end" ? p : o]
    }))
  }),
  uKe = lKe,
  bf = {
    primary: {
      main: "#3F49E1",
      light: xd("#3F49E1", .5),
      dark: lu("#3F49E1", .2)
    },
    secondary: {
      main: "#F5B5FF",
      light: xd("#F5B5FF", .5),
      dark: lu("#F5B5FF", .2)
    },
    success: {
      main: "#0AA65B"
    },
    warning: {
      main: "#FFCC00"
    },
    error: {
      main: "#E5452F"
    },
    info: {
      main: "#297EFF"
    }
  },
  dKe = {
    text: {
      primary: "#000000",
      secondary: "#747474"
    }
  },
  fKe = {
    background: {
      paper: "#212121"
    }
  },
  zB = {
    borderRadius: 12,
    borderRadiusSecondary: 8
  },
  hKe = yl `
  0% {
    transform: scale(0);
    opacity: 0.05;
  }
  100% {
    transform: scale(1);
    opacity: 0.1;
  }
`,
  pKe = (e, t = {}) => {
    var a, c, l, u, f, h, g, y, x, k, _, p, v, S;
    const n = ((c = (a = t.palette) == null ? void 0 : a.primary) == null ? void 0 : c.main) ?? bf.primary.main,
      r = xd(((u = (l = t.palette) == null ? void 0 : l.primary) == null ? void 0 : u.main) ?? bf.primary.main, .5),
      i = lu(((h = (f = t.palette) == null ? void 0 : f.primary) == null ? void 0 : h.main) ?? bf.primary.main, .2),
      s = gD(Po.white, n) >= 3 ? Po.white : Po.black,
      o = gD(Po.white, Vt(n, .08)) >= 3 ? Po.white : Po.black;
    return OT({
      typography: {
        fontFamily: "Inter var, Inter, sans-serif",
        ...t.typography
      },
      palette: {
        mode: e,
        ...bf,
        ...e === "light" ? dKe : fKe,
        ...t.palette,
        primary: {
          main: n,
          light: r,
          dark: i
        },
        secondary: {
          main: ((y = (g = t.palette) == null ? void 0 : g.secondary) == null ? void 0 : y.main) ?? bf.secondary.main,
          light: xd(((k = (x = t.palette) == null ? void 0 : x.secondary) == null ? void 0 : k.main) ?? bf.secondary.main, .5),
          dark: lu(((p = (_ = t.palette) == null ? void 0 : _.secondary) == null ? void 0 : p.main) ?? bf.secondary.main, .2)
        }
      },
      shape: {
        ...zB,
        ...t.shape
      },
      breakpoints: {
        values: {
          xs: 0,
          sm: 392,
          md: 900,
          lg: 1200,
          xl: 1536
        }
      },
      components: {
        MuiScopedCssBaseline: {
          styleOverrides: {
            root: {
              fontFamily: "Inter, sans-serif",
              ...t.typography,
              "@supports (font-variation-settings: normal)": {
                fontFamily: "Inter var, sans-serif",
                ...t.typography
              }
            }
          }
        },
        MuiButtonBase: {
          styleOverrides: {
            root: th `
            &
              .${Zs.ripple}.${Zs.rippleVisible} {
              opacity: 0.1;
              animation-name: ${hKe};
            }
          `
          }
        },
        MuiButton: {
          defaultProps: {
            disableElevation: !0
          },
          styleOverrides: {
            root: {
              borderRadius: ((v = t.shape) == null ? void 0 : v.borderRadiusSecondary) ?? zB.borderRadiusSecondary,
              textTransform: "none",
              fontSize: "1rem",
              "&.Mui-disabled, &.Mui-disabled:hover": {
                color: Vt(e === "light" ? Po.black : Po.white, .56),
                cursor: "not-allowed",
                pointerEvents: "auto"
              },
              [`&.${_o.loading}.Mui-disabled`]: {
                backgroundColor: n,
                color: s,
                cursor: "auto",
                pointerEvents: "auto"
              },
              [`.${_o.loadingIndicator}`]: {
                color: s
              },
              [`&.${_o.root}.${_o.loading}`]: {
                color: "transparent"
              }
            },
            text: {
              backgroundColor: e === "light" ? Vt(n, .08) : Vt(n, .42),
              "&:hover": {
                backgroundColor: e === "light" ? Vt(n, .12) : Vt(n, .56)
              },
              color: e === "light" ? n : o
            },
            contained: {
              "&:hover": {
                color: s
              }
            },
            sizeMedium: {
              padding: "10px 14px",
              [`.${Nge.root} &`]: {
                padding: "6px 12px"
              }
            }
          }
        },
        MuiIconButton: {
          styleOverrides: {
            root: {
              color: "inherit",
              "&:hover": {
                color: "inherit"
              }
            }
          }
        },
        MuiAvatar: {
          styleOverrides: {
            root: {
              height: 32,
              width: 32
            }
          },
          ...(S = t.components) == null ? void 0 : S.MuiAvatar
        },
        MuiListItemAvatar: {
          styleOverrides: {
            root: {
              minWidth: 48
            }
          }
        },
        MuiListItemText: {
          styleOverrides: {
            primary: ({
              theme: I
            }) => ({
              fontWeight: "500",
              fontSize: "1.125rem",
              lineHeight: "1.2778",
              color: I.palette.text.primary
            }),
            secondary: ({
              theme: I
            }) => ({
              fontWeight: "400",
              fontSize: "0.75rem",
              color: I.palette.text.secondary
            })
          }
        },
        MuiTooltip: {
          styleOverrides: {
            tooltip: ({
              theme: I
            }) => ({
              backgroundColor: "rgb(0 0 0 / 64%)",
              backdropFilter: "blur(3px)",
              fontSize: "0.75rem",
              padding: I.spacing(1, 1.5)
            }),
            arrow: {
              color: "rgb(0 0 0 / 64%)"
            }
          }
        }
      }
    })
  },
  mKe = ({
    children: e
  }) => {
    const {
      appearance: t,
      theme: n
    } = Wt(), r = x5("(prefers-color-scheme: dark)"), [i, s] = Oq(), [o, a] = j.useState(t ?? i === "auto" ? r ? "dark" : "light" : i);
    j.useEffect(() => {
      a(i === "auto" ? r ? "dark" : "light" : i)
    }, [i, r]), j.useEffect(() => {
      t && s(t)
    }, [t]);
    const c = j.useMemo(() => pKe(o, n), [o, n]);
    return C.jsx(Sfe, {
      theme: c,
      children: e
    })
  },
  TJ = ({
    children: e,
    config: t
  }) => C.jsx(I3e, {
    client: Mxe,
    children: C.jsx(aAe, {
      config: t,
      children: C.jsx(tKe, {
        children: C.jsx(mKe, {
          children: C.jsx(eKe, {
            children: C.jsx(wJ, {
              children: C.jsx(MHe, {
                children: C.jsx(sAe, {
                  config: t,
                  children: C.jsx(gKe, {
                    children: e
                  })
                })
              })
            })
          })
        })
      })
    })
  }),
  gKe = ({
    children: e
  }) => {
    const {
      buildUrl: t
    } = Wt(), r = X2() ? j.Fragment : Oxe;
    return C.jsxs(r, {
      children: [e, t ? C.jsx($He, {}) : null]
    })
  },
  yKe = j.forwardRef(({
    elementRef: e,
    open: t,
    onClose: n,
    integrator: r,
    config: i
  }, s) => {
    var y, x, k, _;
    const o = j.useRef(!!t),
      [a, c] = j.useState(!!t),
      l = j.useCallback(() => {
        c(p => (o.current = !p, o.current)), o.current || n == null || n()
      }, [n]),
      u = j.useCallback(() => {
        c(!0), o.current = !0
      }, []),
      f = j.useCallback(() => {
        c(!1), o.current = !1, n == null || n()
      }, [n]);
    j.useImperativeHandle(s, () => ({
      isOpen: () => o.current,
      toggleDrawer: l,
      openDrawer: u,
      closeDrawer: f
    }), [f, u, l]);
    const h = j.useMemo(() => ({
        ...i,
        integrator: r,
        containerStyle: {
          ...i == null ? void 0 : i.containerStyle,
          height: "100%"
        }
      }), [i, r]),
      g = j.useMemo(() => ({
        closeDrawer: f
      }), [f]);
    return C.jsx(LH.Provider, {
      value: g,
      children: C.jsxs(TJ, {
        config: h,
        children: [(y = h.hiddenUI) != null && y.includes(Ui.DrawerButton) ? null : C.jsxs(Xwe, {
          variant: "contained",
          onClick: l,
          open: a,
          drawerProps: i == null ? void 0 : i.containerStyle,
          children: [a ? C.jsx(Tz, {}) : C.jsx(Az, {}), C.jsx(vKe, {
            open: a,
            subvariant: i == null ? void 0 : i.subvariant
          })]
        }), C.jsx(uH, {
          ref: e,
          anchor: "right",
          open: a,
          onClose: f,
          BackdropProps: {
            sx: {
              backgroundColor: "rgb(0 0 0 / 48%)",
              backdropFilter: "blur(3px)"
            }
          },
          PaperProps: {
            sx: {
              width: ((x = i == null ? void 0 : i.containerStyle) == null ? void 0 : x.width) ?? "100%",
              minWidth: ((k = i == null ? void 0 : i.containerStyle) == null ? void 0 : k.minWidth) ?? 360,
              maxWidth: ((_ = i == null ? void 0 : i.containerStyle) == null ? void 0 : _.maxWidth) ?? 392
            }
          },
          keepMounted: !0,
          children: C.jsx(TX, {})
        })]
      })
    })
  }),
  vKe = ({
    open: e,
    subvariant: t
  }) => {
    const {
      t: n
    } = ft();
    return C.jsx(Zwe, {
      children: n(e ? "button.hide" : t === "nft" ? "button.lifiCheckout" : "button.lifiExchange")
    })
  };
var P_ = {},
  bKe = Zt;
Object.defineProperty(P_, "__esModule", {
  value: !0
});
var kJ = P_.default = void 0,
  wKe = bKe(an()),
  xKe = C;
kJ = P_.default = (0, wKe.default)((0, xKe.jsx)("path", {
  d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2M4 12c0-4.42 3.58-8 8-8 1.85 0 3.55.63 4.9 1.69L5.69 16.9C4.63 15.55 4 13.85 4 12m8 8c-1.85 0-3.55-.63-4.9-1.69L18.31 7.1C19.37 8.45 20 10.15 20 12c0 4.42-3.58 8-8 8"
}), "Block");
const EKe = () => {
  const {
    t: e
  } = ft();
  return C.jsxs(Pe, {
    sx: {
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      flexDirection: "column",
      flex: 1,
      padding: 3
    },
    children: [C.jsx(Ue, {
      fontSize: 48,
      children: C.jsx(kJ, {
        fontSize: "inherit"
      })
    }), C.jsx(Ue, {
      fontSize: 18,
      fontWeight: 700,
      children: e("tooltip.notFound.title")
    }), C.jsx(Ue, {
      fontSize: 14,
      color: "text.secondary",
      textAlign: "center",
      mt: 2,
      children: e("tooltip.notFound.text")
    })]
  })
};
var R_ = {},
  SKe = Zt;
Object.defineProperty(R_, "__esModule", {
  value: !0
});
var mE = R_.default = void 0,
  CKe = SKe(an()),
  AKe = C;
mE = R_.default = (0, CKe.default)((0, AKe.jsx)("path", {
  d: "M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6zM8 9h8v10H8zm7.5-5-1-1h-5l-1 1H5v2h14V4z"
}), "DeleteOutline");
var O_ = {},
  TKe = Zt;
Object.defineProperty(O_, "__esModule", {
  value: !0
});
var D_ = O_.default = void 0,
  kKe = TKe(an()),
  _Ke = C;
D_ = O_.default = (0, kKe.default)((0, _Ke.jsx)("path", {
  d: "m12 4-1.41 1.41L16.17 11H4v2h12.17l-5.58 5.59L12 20l8-8z"
}), "ArrowForward");
var N_ = {},
  IKe = Zt;
Object.defineProperty(N_, "__esModule", {
  value: !0
});
var gE = N_.default = void 0,
  PKe = IKe(an()),
  RKe = C;
gE = N_.default = (0, PKe.default)((0, RKe.jsx)("path", {
  d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2m0 11c-.55 0-1-.45-1-1V8c0-.55.45-1 1-1s1 .45 1 1v4c0 .55-.45 1-1 1m1 4h-2v-2h2z"
}), "ErrorRounded");
var M_ = {},
  OKe = Zt;
Object.defineProperty(M_, "__esModule", {
  value: !0
});
var yE = M_.default = void 0,
  DKe = OKe(an()),
  NKe = C;
yE = M_.default = (0, DKe.default)((0, NKe.jsx)("path", {
  d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2m0 15c-.55 0-1-.45-1-1v-4c0-.55.45-1 1-1s1 .45 1 1v4c0 .55-.45 1-1 1m1-8h-2V7h2z"
}), "InfoRounded");
var _J = {
  exports: {}
};
(function (e, t) {
  (function (n, r) {
    e.exports = r(j)
  })(typeof self < "u" ? self : rn, n => (() => {
    var r = {
        156: a => {
          a.exports = n
        }
      },
      i = {};

    function s(a) {
      var c = i[a];
      if (c !== void 0) return c.exports;
      var l = i[a] = {
        exports: {}
      };
      return r[a](l, l.exports, s), l.exports
    }
    s.d = (a, c) => {
      for (var l in c) s.o(c, l) && !s.o(a, l) && Object.defineProperty(a, l, {
        enumerable: !0,
        get: c[l]
      })
    }, s.o = (a, c) => Object.prototype.hasOwnProperty.call(a, c), s.r = a => {
      typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(a, Symbol.toStringTag, {
        value: "Module"
      }), Object.defineProperty(a, "__esModule", {
        value: !0
      })
    };
    var o = {};
    return (() => {
      s.r(o), s.d(o, {
        default: () => k,
        useStopwatch: () => y,
        useTime: () => x,
        useTimer: () => g
      });
      var a = s(156);
      class c {
        static expiryTimestamp(p) {
          const v = new Date(p).getTime() > 0;
          return v || console.warn("react-timer-hook: { useTimer } Invalid expiryTimestamp settings", p), v
        }
        static onExpire(p) {
          const v = p && typeof p == "function";
          return p && !v && console.warn("react-timer-hook: { useTimer } Invalid onExpire settings function", p), v
        }
      }
      class l {
        static getTimeFromSeconds(p) {
          const v = Math.ceil(p),
            S = Math.floor(v / 86400),
            I = Math.floor(v % 86400 / 3600),
            A = Math.floor(v % 3600 / 60);
          return {
            totalSeconds: v,
            seconds: Math.floor(v % 60),
            minutes: A,
            hours: I,
            days: S
          }
        }
        static getSecondsFromExpiry(p, v) {
          const S = p - new Date().getTime();
          if (S > 0) {
            const I = S / 1e3;
            return v ? Math.round(I) : I
          }
          return 0
        }
        static getSecondsFromPrevTime(p, v) {
          const S = new Date().getTime() - p;
          if (S > 0) {
            const I = S / 1e3;
            return v ? Math.round(I) : I
          }
          return 0
        }
        static getSecondsFromTimeNow() {
          const p = new Date;
          return p.getTime() / 1e3 - 60 * p.getTimezoneOffset()
        }
        static getFormattedTimeFromSeconds(p, v) {
          const {
            seconds: S,
            minutes: I,
            hours: A
          } = l.getTimeFromSeconds(p);
          let w = "",
            E = A;
          return v === "12-hour" && (w = A >= 12 ? "pm" : "am", E = A % 12), {
            seconds: S,
            minutes: I,
            hours: E,
            ampm: w
          }
        }
      }

      function u(_, p) {
        const v = (0, a.useRef)();
        (0, a.useEffect)(() => {
          v.current = _
        }), (0, a.useEffect)(() => {
          if (!p) return () => {};
          const S = setInterval(() => {
            v.current && v.current()
          }, p);
          return () => clearInterval(S)
        }, [p])
      }
      const f = 1e3;

      function h(_) {
        if (!c.expiryTimestamp(_)) return null;
        const p = l.getSecondsFromExpiry(_),
          v = Math.floor(1e3 * (p - Math.floor(p)));
        return v > 0 ? v : f
      }

      function g() {
        let {
          expiryTimestamp: _,
          onExpire: p,
          autoStart: v = !0
        } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        const [S, I] = (0, a.useState)(_), [A, w] = (0, a.useState)(l.getSecondsFromExpiry(S)), [E, D] = (0, a.useState)(v), [$, V] = (0, a.useState)(v), [G, L] = (0, a.useState)(h(S)), b = (0, a.useCallback)(() => {
          c.onExpire(p) && p(), D(!1), L(null)
        }, [p]), T = (0, a.useCallback)(() => {
          D(!1)
        }, []), R = (0, a.useCallback)(function (U) {
          let q = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1];
          L(h(U)), V(q), D(q), I(U), w(l.getSecondsFromExpiry(U))
        }, []), N = (0, a.useCallback)(() => {
          const U = new Date;
          U.setMilliseconds(U.getMilliseconds() + 1e3 * A), R(U)
        }, [A, R]), O = (0, a.useCallback)(() => {
          $ ? (w(l.getSecondsFromExpiry(S)), D(!0)) : N()
        }, [S, $, N]);
        return u(() => {
          G !== f && L(f);
          const U = l.getSecondsFromExpiry(S);
          w(U), U <= 0 && b()
        }, E ? G : null), {
          ...l.getTimeFromSeconds(A),
          start: O,
          pause: T,
          resume: N,
          restart: R,
          isRunning: E
        }
      }

      function y() {
        let {
          autoStart: _,
          offsetTimestamp: p
        } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        const [v, S] = (0, a.useState)(l.getSecondsFromExpiry(p, !0) || 0), [I, A] = (0, a.useState)(new Date), [w, E] = (0, a.useState)(v + l.getSecondsFromPrevTime(I || 0, !0)), [D, $] = (0, a.useState)(_);
        u(() => {
          E(v + l.getSecondsFromPrevTime(I, !0))
        }, D ? 1e3 : null);
        const V = (0, a.useCallback)(() => {
            const b = new Date;
            A(b), $(!0), E(v + l.getSecondsFromPrevTime(b, !0))
          }, [v]),
          G = (0, a.useCallback)(() => {
            S(w), $(!1)
          }, [w]),
          L = (0, a.useCallback)(function () {
            let b = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0,
              T = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1];
            const R = l.getSecondsFromExpiry(b, !0) || 0,
              N = new Date;
            A(N), S(R), $(T), E(R + l.getSecondsFromPrevTime(N, !0))
          }, []);
        return {
          ...l.getTimeFromSeconds(w),
          start: V,
          pause: G,
          reset: L,
          isRunning: D
        }
      }

      function x() {
        let {
          format: _
        } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        const [p, v] = (0, a.useState)(l.getSecondsFromTimeNow());
        return u(() => {
          v(l.getSecondsFromTimeNow())
        }, 1e3), {
          ...l.getFormattedTimeFromSeconds(p, _)
        }
      }

      function k(_) {
        if ((0, a.useEffect)(() => {
            console.warn("react-timer-hook: default export useTimer is deprecated, use named exports { useTimer, useStopwatch, useTime } instead")
          }, []), _.expiryTimestamp) {
          const v = g(_);
          return {
            ...v,
            startTimer: v.start,
            stopTimer: v.pause,
            resetTimer: () => {}
          }
        }
        const p = y(_);
        return {
          ...p,
          startTimer: p.start,
          stopTimer: p.pause,
          resetTimer: p.reset
        }
      }
    })(), o
  })())
})(_J);
var MKe = _J.exports;
const HB = e => {
    var t, n;
    return new Date((((n = (t = e.execution) == null ? void 0 : t.process[0]) == null ? void 0 : n.startedAt) ?? Date.now()) + e.estimate.executionDuration * 1e3)
  },
  IJ = ({
    step: e,
    hideInProgress: t
  }) => {
    var x, k;
    const {
      t: n
    } = ft(), [r, i] = j.useState(!1), [s, o] = j.useState(!!e.execution), [a] = j.useState(() => HB(e)), {
      seconds: c,
      minutes: l,
      isRunning: u,
      pause: f,
      resume: h,
      restart: g
    } = MKe.useTimer({
      autoStart: !1,
      expiryTimestamp: a,
      onExpire: () => i(!0)
    });
    if (j.useEffect(() => {
        if (r || !e.execution) return;
        s || (o(!0), g(HB(e)));
        const _ = e.execution.process.some(p => p.status === "ACTION_REQUIRED" || p.status === "FAILED");
        u && _ ? f() : !u && !_ && h()
      }, [a, s, r, u, f, g, h, e]), !s) return C.jsx(C.Fragment, {
      children: n("main.estimatedTime", {
        value: Math.ceil(e.estimate.executionDuration / 60)
      })
    });
    const y = r || !l && !c;
    return ((x = e.execution) == null ? void 0 : x.status) === "DONE" || ((k = e.execution) == null ? void 0 : k.status) === "FAILED" || y && t ? null : y ? C.jsx(C.Fragment, {
      children: n("main.inProgress")
    }) : C.jsx(C.Fragment, {
      children: `${l}:${c<10?`0${c}`:c}`
    })
  },
  vE = me(bl)(({
    theme: e
  }) => ({
    background: e.palette.background.paper,
    width: 16,
    height: 16,
    border: `2px solid ${e.palette.background.paper}`
  })),
  $Ke = me(gr)(({
    theme: e
  }) => ({
    border: `2px solid ${e.palette.background.paper}`,
    width: 16,
    height: 16
  })),
  LKe = me(Pe)(({
    theme: e
  }) => ({
    background: e.palette.background.paper,
    borderRadius: "50%"
  })),
  BKe = () => C.jsx(LKe, {
    children: C.jsx($Ke, {
      variant: "circular"
    })
  }),
  FKe = me(ame)(({
    theme: e
  }) => ({
    [`& .${rc.badge}:last-child .${tH.root}`]: {
      marginLeft: e.spacing(-1),
      boxSizing: "border-box"
    },
    [`& .${rc.root}:last-child`]: {
      marginLeft: e.spacing(1)
    }
  })),
  jKe = me(Pe)(({
    theme: e
  }) => ({
    background: e.palette.mode === "light" ? e.palette.grey[300] : e.palette.grey[800],
    borderRadius: "50%"
  })),
  UKe = me(Pe)(({
    theme: e
  }) => ({
    background: e.palette.mode === "light" ? e.palette.grey[300] : e.palette.grey[800],
    border: `2px solid ${e.palette.background.paper}`,
    borderRadius: "50%"
  })),
  zKe = ({
    token: e,
    isLoading: t,
    sx: n
  }) => {
    const {
      chain: r
    } = _m(e == null ? void 0 : e.chainId), {
      token: i,
      isLoading: s
    } = hh(e == null ? void 0 : e.chainId, e == null ? void 0 : e.address);
    return C.jsx(PJ, {
      token: i ?? e,
      isLoading: t || s,
      chain: r,
      sx: n
    })
  },
  PJ = ({
    token: e,
    chain: t,
    isLoading: n,
    sx: r
  }) => {
    var i;
    return C.jsx(KT, {
      overlap: "circular",
      anchorOrigin: {
        vertical: "bottom",
        horizontal: "right"
      },
      badgeContent: t && !n ? C.jsx(vE, {
        src: t.logoURI,
        alt: t.name,
        children: t.name[0]
      }) : C.jsx(BKe, {}),
      sx: r,
      children: n ? C.jsx(gr, {
        width: 32,
        height: 32,
        variant: "circular"
      }) : C.jsx(bl, {
        src: e == null ? void 0 : e.logoURI,
        alt: e == null ? void 0 : e.symbol,
        children: (i = e == null ? void 0 : e.symbol) == null ? void 0 : i[0]
      })
    })
  },
  A2 = ({
    token: e,
    chain: t,
    isLoading: n,
    sx: r
  }) => !t || !(e != null && e.logoURI) ? C.jsx(zKe, {
    token: e,
    isLoading: n,
    sx: r
  }) : C.jsx(PJ, {
    token: e,
    chain: t,
    isLoading: n,
    sx: r
  }),
  RJ = ({
    sx: e
  }) => C.jsx(KT, {
    overlap: "circular",
    anchorOrigin: {
      vertical: "bottom",
      horizontal: "right"
    },
    badgeContent: C.jsx(UKe, {
      width: 16,
      height: 16
    }),
    sx: e,
    children: C.jsx(jKe, {
      width: 32,
      height: 32
    })
  }),
  HKe = me(gH)(({
    theme: e
  }) => ({
    borderRadius: e.shape.borderRadius,
    paddingLeft: e.spacing(1.5),
    paddingRight: e.spacing(1.5),
    height: 64,
    "&:hover": {
      backgroundColor: j3(e.palette.mode, "4%")
    }
  })),
  VKe = me(bH, {
    shouldForwardProp: e => e !== "disableRipple"
  })(({
    theme: e
  }) => ({
    padding: e.spacing(0, 1.5),
    [`.${yH.root}`]: {
      right: e.spacing(3)
    },
    "&:hover": {
      cursor: "pointer"
    }
  })),
  WKe = me(ur)(({
    theme: e
  }) => ({
    background: "none",
    "&:hover": {
      background: "none"
    },
    padding: e.spacing(.75, 2),
    fontSize: "0.875rem"
  })),
  OJ = ({
    routeId: e,
    dense: t
  }) => {
    var f;
    const n = Ba(),
      {
        route: r,
        status: i
      } = Sq({
        routeId: e,
        executeInBackground: !0
      }),
      s = r == null ? void 0 : r.steps.slice().reverse().find(h => h.execution),
      o = (f = s == null ? void 0 : s.execution) == null ? void 0 : f.process.at(-1),
      {
        title: a
      } = xq(s, o);
    if (!r || !s) return null;
    const c = () => {
        n(Je.transactionExecution, {
          state: {
            routeId: e
          }
        })
      },
      l = () => {
        switch (o == null ? void 0 : o.status) {
          case "ACTION_REQUIRED":
            return C.jsx(yE, {
              color: "info",
              fontSize: "small"
            });
          case "FAILED":
            return C.jsx(gE, {
              color: "error",
              fontSize: "small"
            });
          default:
            return C.jsx(Ue, {
              fontSize: 14,
              fontWeight: 500,
              children: C.jsx(IJ, {
                step: s,
                hideInProgress: !0
              })
            })
        }
      },
      u = t ? VKe : HKe;
    return C.jsxs(u, {
      onClick: c,
      dense: !0,
      disableRipple: t,
      children: [C.jsx(ym, {
        children: C.jsxs(FKe, {
          total: 2,
          children: [C.jsx(A2, {
            token: r.fromToken
          }), C.jsx(A2, {
            token: r.toToken
          })]
        })
      }), C.jsx(Q2, {
        sx: {
          margin: 0
        },
        disableTypography: !0,
        primary: C.jsxs(Ue, {
          fontWeight: 500,
          lineHeight: 1,
          sx: {
            display: "flex",
            alignItems: "center",
            marginLeft: 2,
            height: 16
          },
          children: [r.fromToken.symbol, C.jsx(D_, {
            sx: {
              paddingX: .5
            }
          }), r.toToken.symbol]
        }),
        secondary: i !== ot.Done ? C.jsx(Ue, {
          fontWeight: 400,
          fontSize: 12,
          color: "text.secondary",
          lineHeight: 1,
          mt: .75,
          ml: 2,
          children: a
        }) : null
      }), l()]
    })
  },
  qKe = (e, t, n) => t === "selected" ? n === "primary" ? e.palette.mode === "light" ? Vt(e.palette.primary.main, .04) : Vt(e.palette.primary.main, .42) : Vt(e.palette.secondary.main, e.palette.mode === "light" ? .08 : .12) : e.palette.background.paper,
  Oi = me(Pe, {
    shouldForwardProp: e => !["variant", "indented", "selectionColor", "pointerEvents"].includes(e)
  })(({
    theme: e,
    variant: t,
    selectionColor: n = "primary",
    indented: r,
    pointerEvents: i,
    onClick: s
  }) => {
    const o = qKe(e, t, n),
      a = s ? e.palette.mode === "light" ? lu(o, .02) : xd(o, .02) : o;
    return {
      backgroundColor: o,
      border: "1px solid",
      borderColor: t === "error" ? e.palette.error.main : t === "selected" ? n === "primary" ? e.palette.primary.main : Vt(e.palette.secondary.main, .48) : e.palette.mode === "light" ? e.palette.grey[300] : e.palette.grey[800],
      borderRadius: e.shape.borderRadius,
      overflow: "hidden",
      position: "relative",
      padding: r ? e.spacing(2) : 0,
      boxSizing: "border-box",
      "&:hover": {
        cursor: s ? "pointer" : "default",
        backgroundColor: a
      },
      [`&:hover .${rc.badge} > div`]: {
        borderColor: a
      },
      transition: e.transitions.create(["background-color"], {
        duration: e.transitions.duration.enteringScreen,
        easing: e.transitions.easing.easeOut
      }),
      pointerEvents: i
    }
  }),
  GKe = me(Kme)(({
    theme: e
  }) => ({
    [`.${Hf.action}`]: {
      marginTop: -2,
      alignSelf: "center"
    },
    [`.${Hf.title}`]: {
      fontWeight: "500",
      fontSize: "1.125rem",
      lineHeight: "1.2778",
      color: e.palette.text.primary
    },
    [`.${Hf.subheader}`]: {
      fontWeight: "400",
      fontSize: "0.75rem",
      color: e.palette.text.secondary
    }
  })),
  $_ = me(_s)(({
    theme: e
  }) => {
    const t = e.palette.mode === "light" ? e.palette.common.black : e.palette.common.white;
    return {
      padding: e.spacing(.5),
      backgroundColor: Vt(t, .04),
      "&:hover": {
        backgroundColor: Vt(t, .08)
      }
    }
  }),
  f9 = me(Pe, {
    shouldForwardProp: e => e !== "type"
  })(({
    theme: e,
    type: t
  }) => ({
    backgroundColor: t === "active" ? e.palette.mode === "light" ? e.palette.secondary.main : Vt(e.palette.secondary.main, .32) : t != null && t.includes("insurance") ? Vt(e.palette.success.main, e.palette.mode === "light" ? .12 : .24) : e.palette.mode === "light" ? Vt(e.palette.common.black, .12) : Vt(e.palette.common.white, .16),
    borderRadius: e.shape.borderRadius,
    color: t != null && t.includes("insurance") ? xd(e.palette.success.main, e.palette.mode === "light" ? 0 : .24) : e.palette.text.primary,
    padding: t === "insurance" ? e.spacing(0, 1.5) : 0,
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    height: 24,
    minWidth: 24,
    userSelect: "none",
    fontSize: "1rem",
    marginRight: e.spacing(1)
  })),
  h9 = me(Ue, {
    shouldForwardProp: e => e !== "type"
  })(({
    theme: e,
    type: t
  }) => ({
    padding: t === "icon" ? e.spacing(.75, 0, .75, .75) : e.spacing(.75, 1.5),
    fontSize: 12,
    lineHeight: 1,
    fontWeight: "600",
    textTransform: "lowercase",
    "&::first-letter": {
      textTransform: "uppercase"
    }
  })),
  Ma = me(Ue, {
    shouldForwardProp: e => !["required"].includes(e)
  })(({
    theme: e,
    required: t
  }) => ({
    fontSize: "0.875rem",
    lineHeight: "1.286",
    letterSpacing: "0.01071em",
    fontWeight: 700,
    padding: e.spacing(1.75, 2, 0, 2),
    "&:after": {
      content: t ? '" *"' : "none",
      color: e.palette.error.main
    }
  })),
  KKe = e => {
    const {
      t
    } = ft(), n = Ba(), {
      account: r
    } = Ri(), i = Pq(r.address);
    if (!(i != null && i.length)) return null;
    const s = () => {
        n(Je.activeTransactions)
      },
      o = (i == null ? void 0 : i.length) > 2;
    return C.jsxs(Oi, {
      variant: "selected",
      selectionColor: "secondary",
      ...e,
      children: [C.jsx(Ma, {
        children: t("header.activeTransactions")
      }), C.jsx(N5, {
        spacing: 1.5,
        pt: 1.5,
        pb: o ? 0 : 2,
        children: i.slice(0, 2).map(a => C.jsx(OJ, {
          routeId: a,
          dense: !0
        }, a))
      }), o ? C.jsx(WKe, {
        disableRipple: !0,
        fullWidth: !0,
        onClick: s,
        children: t("button.showAll")
      }) : null]
    })
  },
  DJ = {
    sx: {
      position: "absolute",
      overflow: "hidden"
    }
  },
  NJ = {
    sx: e => ({
      position: "absolute",
      backgroundImage: "none",
      borderTopLeftRadius: e.shape.borderRadius,
      borderTopRightRadius: e.shape.borderRadius
    })
  },
  MJ = {
    sx: {
      position: "absolute",
      backgroundColor: "rgb(0 0 0 / 32%)",
      backdropFilter: "blur(3px)"
    }
  },
  Dy = ({
    children: e,
    open: t,
    onClose: n
  }) => {
    const r = uq();
    return C.jsx(Rge, {
      container: r,
      open: t,
      onClose: n,
      sx: DJ.sx,
      PaperProps: NJ,
      BackdropProps: MJ,
      children: e
    })
  };
var L_ = {},
  QKe = Zt;
Object.defineProperty(L_, "__esModule", {
  value: !0
});
var B_ = L_.default = void 0,
  YKe = QKe(an()),
  JKe = C;
B_ = L_.default = (0, YKe.default)((0, JKe.jsx)("path", {
  d: "M6.99 11 3 15l3.99 4v-3H14v-2H6.99zM21 9l-3.99-4v3H10v2h7.01v3z"
}), "SwapHoriz");
const XKe = () => {
    const {
      t: e
    } = ft();
    return C.jsxs(yo, {
      sx: {
        display: "flex",
        flex: 1,
        flexDirection: "column",
        alignItems: "center",
        justifyContent: "center",
        paddingY: 12
      },
      children: [C.jsx(Ue, {
        fontSize: 48,
        children: C.jsx(B_, {
          fontSize: "inherit"
        })
      }), C.jsx(Ue, {
        fontSize: 18,
        fontWeight: 700,
        children: e("info.title.emptyActiveTransactions")
      }), C.jsx(Ue, {
        fontSize: 14,
        color: "text.secondary",
        textAlign: "center",
        mt: 2,
        children: e("info.message.emptyActiveTransactions")
      })]
    })
  },
  ZKe = () => {
    const {
      t: e
    } = ft(), {
      account: t
    } = Ri(), n = Pq(t.address), r = gl(c => c.deleteRoutes), i = Om(), [s, o] = j.useState(!1), a = j.useCallback(() => {
      o(c => !c)
    }, []);
    return j.useEffect(() => {
      if (n.length) return i.getState().setAction(C.jsx(_s, {
        size: "medium",
        edge: "end",
        onClick: a,
        children: C.jsx(mE, {})
      }))
    }, [n.length, i, a]), n.length ? C.jsxs(yo, {
      disableGutters: !0,
      children: [C.jsx(sh, {
        sx: {
          paddingLeft: 1.5,
          paddingRight: 1.5
        },
        children: n.map(c => C.jsx(OJ, {
          routeId: c
        }, c))
      }), C.jsxs(Dy, {
        open: s,
        onClose: a,
        children: [C.jsx(D5, {
          children: e("warning.title.deleteActiveTransactions")
        }), C.jsx(q2, {
          children: C.jsx(G2, {
            children: e("warning.message.deleteActiveTransactions")
          })
        }), C.jsxs(W2, {
          children: [C.jsx(ur, {
            onClick: a,
            children: e("button.cancel")
          }), C.jsx(ur, {
            variant: "contained",
            onClick: () => r("active"),
            autoFocus: !0,
            children: e("button.delete")
          })]
        })]
      })]
    }) : C.jsx(XKe, {})
  },
  eQe = 24,
  tQe = 14,
  nQe = me(Sh)(({
    theme: e
  }) => ({
    padding: e.spacing(1.5, 2, 1.5, 0)
  })),
  rQe = me(gm)(({
    theme: e
  }) => ({
    fontSize: 24,
    fontWeight: 700,
    boxShadow: "none",
    [`.${as.input}`]: {
      height: 32,
      padding: e.spacing(0, 0, 0, 2)
    },
    '& input[type="number"]::-webkit-outer-spin-button, & input[type="number"]::-webkit-inner-spin-button': {
      WebkitAppearance: "none",
      margin: 0
    },
    '& input[type="number"]': {
      MozAppearance: "textfield"
    },
    [`&.${as.disabled}`]: {
      color: "inherit"
    },
    [`.${as.input}.${as.disabled}`]: {
      WebkitTextFillColor: "unset"
    }
  })),
  iQe = me(ur)(({
    theme: e
  }) => ({
    padding: e.spacing(.5, 1, .625, 1),
    lineHeight: 1.0715,
    fontSize: "0.875rem",
    minWidth: "unset"
  })),
  sQe = ({
    formType: e
  }) => {
    const {
      t
    } = ft(), {
      setValue: n
    } = Ls(), {
      getChainById: r
    } = vo(), [i, s] = ds({
      name: [sr.getChainKey(e), sr.getTokenKey(e)]
    }), {
      data: o
    } = vq(i), {
      token: a,
      isLoading: c
    } = Nk(i, s), l = () => {
      const u = r(i);
      let f = a == null ? void 0 : a.amount;
      if ((u == null ? void 0 : u.nativeToken.address) === s && (o != null && o.available) && (o != null && o.recommended)) {
        const h = Dn((a == null ? void 0 : a.amount) ?? 0),
          g = Dn(o.recommended.amount).div(10 ** o.recommended.token.decimals).div(2);
        h.gt(g) && (f = Ei(h.minus(g).toString()))
      }
      n(sr.getAmountKey(e), f || "", {
        shouldTouch: !0
      })
    };
    return C.jsx(YT, {
      position: "end",
      children: c && s ? C.jsx(gr, {
        variant: "rectangular",
        width: 46,
        height: 24,
        sx: {
          borderRadius: .5
        }
      }) : e === "from" && (a != null && a.amount) ? C.jsx(iQe, {
        onClick: l,
        children: t("button.max")
      }) : null
    })
  },
  oQe = ({
    formType: e
  }) => {
    const [t, n] = ds({
      name: [sr.getChainKey(e), sr.getTokenKey(e)]
    }), {
      chain: r
    } = _m(t), {
      token: i
    } = hh(t, n);
    return !!(r && i) ? C.jsx(A2, {
      token: i,
      chain: r,
      sx: {
        marginLeft: 2
      }
    }) : C.jsx(RJ, {
      sx: {
        marginLeft: 2
      }
    })
  },
  aQe = ({
    formType: e
  }) => {
    const [t, n] = ds({
      name: [sr.getChainKey(e), sr.getTokenKey(e)]
    }), {
      token: r,
      isLoading: i
    } = Nk(t, n);
    return C.jsx(cQe, {
      formType: e,
      isLoading: i,
      tokenAddress: n,
      token: r
    })
  },
  cQe = ({
    formType: e,
    isLoading: t,
    tokenAddress: n,
    token: r
  }) => {
    const {
      t: i
    } = ft(), s = ds({
      name: sr.getAmountKey(e)
    }), o = Rk(s, r == null ? void 0 : r.priceUSD);
    return C.jsxs(fH, {
      component: "div",
      sx: {
        display: "flex",
        justifyContent: "space-between",
        margin: 0
      },
      children: [C.jsx(Ue, {
        color: o ? "text.secondary" : "grey.600",
        fontWeight: 400,
        fontSize: 12,
        marginLeft: 8,
        lineHeight: 1.3334,
        flex: 1,
        sx: {
          wordBreak: "break-word",
          overflowWrap: "break-word"
        },
        children: i("format.currency", {
          value: o
        })
      }), t && n ? C.jsx(gr, {
        variant: "text",
        width: 48,
        height: 16,
        sx: {
          borderRadius: .25
        }
      }) : r != null && r.amount ? C.jsx(Ue, {
        fontWeight: 400,
        fontSize: 12,
        color: "text.secondary",
        lineHeight: 1.3334,
        pl: .25,
        children: `/ ${i("format.number",{value:Ei(r==null?void 0:r.amount)})}`
      }) : null]
    })
  },
  lQe = ({
    formType: e,
    ...t
  }) => {
    const {
      disabledUI: n
    } = Wt(), [r, i] = ds({
      name: [sr.getChainKey(e), sr.getTokenKey(e)]
    }), {
      token: s
    } = hh(r, i), o = n == null ? void 0 : n.includes(wh.FromAmount);
    return C.jsx(uQe, {
      formType: e,
      token: s,
      startAdornment: C.jsx(oQe, {
        formType: e
      }),
      endAdornment: o ? void 0 : C.jsx(sQe, {
        formType: e
      }),
      bottomAdornment: C.jsx(aQe, {
        formType: e
      }),
      disabled: o,
      ...t
    })
  },
  uQe = ({
    formType: e,
    token: t,
    startAdornment: n,
    endAdornment: r,
    bottomAdornment: i,
    disabled: s,
    ...o
  }) => {
    const {
      t: a
    } = ft(), c = sr.getAmountKey(e), {
      field: {
        onChange: l,
        onBlur: u,
        value: f
      }
    } = F5({
      name: c
    }), h = j.useRef(null), g = x => {
      const {
        value: k
      } = x.target, _ = EA(k, t == null ? void 0 : t.decimals, !0);
      l(_)
    }, y = x => {
      const {
        value: k
      } = x.target, _ = EA(k, t == null ? void 0 : t.decimals);
      l(_), u()
    };
    return j.useLayoutEffect(() => {
      h.current && iCe(eQe, tQe, h.current)
    }, [f, h]), C.jsxs(Oi, {
      ...o,
      children: [C.jsx(Ma, {
        children: a("main.fromAmount")
      }), C.jsxs(nQe, {
        fullWidth: !0,
        children: [C.jsx(rQe, {
          inputRef: h,
          size: "small",
          autoComplete: "off",
          placeholder: "0",
          startAdornment: n,
          endAdornment: r,
          inputProps: {
            inputMode: "decimal"
          },
          onChange: g,
          onBlur: y,
          value: f,
          name: c,
          disabled: s,
          required: !0
        }), i]
      })]
    })
  },
  F_ = ({
    children: e,
    ...t
  }) => e ? C.jsx(Oi, {
    ...t,
    children: e
  }) : null;
var j_ = {},
  dQe = Zt;
Object.defineProperty(j_, "__esModule", {
  value: !0
});
var Gm = j_.default = void 0,
  fQe = dQe(an()),
  hQe = C;
Gm = j_.default = (0, fQe.default)((0, hQe.jsx)("path", {
  d: "M4.47 21h15.06c1.54 0 2.5-1.67 1.73-3L13.73 4.99c-.77-1.33-2.69-1.33-3.46 0L2.74 18c-.77 1.33.19 3 1.73 3M12 14c-.55 0-1-.45-1-1v-2c0-.55.45-1 1-1s1 .45 1 1v2c0 .55-.45 1-1 1m1 4h-2v-2h2z"
}), "WarningRounded");
const U_ = me(Rbe)(({
    theme: e
  }) => ({
    width: 42,
    height: 24,
    padding: 0,
    [`.${jn.switchBase}`]: {
      padding: 0,
      margin: e.spacing(.25),
      transitionDuration: e.transitions.duration.standard,
      [`&.${jn.checked}`]: {
        transform: "translateX(18px)",
        color: e.palette.common.white,
        [`& + .${jn.track}`]: {
          backgroundColor: e.palette.primary.main,
          opacity: 1,
          border: 0
        },
        [`&.${jn.disabled} + .${jn.track}`]: {
          opacity: .5
        }
      },
      [`&.Mui-focusVisible .${jn.thumb}`]: {
        color: e.palette.primary.main,
        border: "6px solid",
        borderColor: e.palette.common.white
      },
      [`&.${jn.disabled} .${jn.thumb}`]: {
        color: e.palette.mode === "light" ? Vt(e.palette.common.black, .12) : Vt(e.palette.common.white, .12)
      },
      [`&.${jn.disabled} + .${jn.track}`]: {
        opacity: e.palette.mode === "light" ? .7 : .3
      }
    },
    [`.${jn.thumb}`]: {
      boxSizing: "border-box",
      width: 20,
      height: 20
    },
    [`.${jn.track}`]: {
      borderRadius: 24 / 2,
      backgroundColor: e.palette.mode === "light" ? Vt(e.palette.common.black, .16) : Vt(e.palette.common.white, .16),
      opacity: 1,
      transition: e.transitions.create(["background-color"], {
        duration: e.transitions.duration.standard
      })
    }
  })),
  $J = me(Pe)(({
    theme: e
  }) => ({
    borderRadius: e.shape.borderRadius,
    position: "relative",
    whiteSpace: "pre-line"
  })),
  LJ = me($J)(({
    theme: e
  }) => ({
    backgroundColor: e.palette.mode === "light" ? Vt(e.palette.warning.main, .32) : Vt(e.palette.warning.main, .16)
  })),
  BJ = me(Pe)(({
    theme: e
  }) => ({
    color: e.palette.mode === "light" ? lu(e.palette.warning.main, .36) : Vt(e.palette.warning.main, 1)
  })),
  pQe = me($J)(({
    theme: e
  }) => ({
    backgroundColor: e.palette.mode === "light" ? Vt(e.palette.info.main, .12) : Vt(e.palette.info.main, .16)
  })),
  mQe = me(Pe)(({
    theme: e
  }) => ({
    color: e.palette.mode === "light" ? e.palette.info.main : xd(e.palette.info.main, .24)
  })),
  gQe = me(U_)(({
    theme: e
  }) => ({
    [`.${jn.switchBase}`]: {
      [`&.${jn.checked}`]: {
        [`& + .${jn.track}`]: {
          backgroundColor: e.palette.mode === "light" ? e.palette.info.main : Vt(e.palette.info.main, .84)
        }
      },
      [`&.Mui-focusVisible .${jn.thumb}`]: {
        color: e.palette.mode === "light" ? e.palette.info.main : Vt(e.palette.info.main, .84)
      }
    }
  })),
  yQe = () => {
    const {
      t: e
    } = ft();
    return C.jsxs(LJ, {
      display: "flex",
      children: [C.jsx(BJ, {
        children: C.jsx(Gm, {
          sx: {
            marginTop: 2,
            marginLeft: 2
          }
        })
      }), C.jsx(Ue, {
        variant: "body2",
        px: 2,
        pb: 2,
        pt: 2,
        children: e("warning.message.insufficientFunds")
      })]
    })
  };
var z_ = {},
  vQe = Zt;
Object.defineProperty(z_, "__esModule", {
  value: !0
});
var Ny = z_.default = void 0,
  bQe = vQe(an()),
  wQe = C;
Ny = z_.default = (0, bQe.default)((0, wQe.jsx)("path", {
  d: "m19.77 7.23.01-.01-3.72-3.72L15 4.56l2.11 2.11c-.94.36-1.61 1.26-1.61 2.33 0 1.38 1.12 2.5 2.5 2.5.36 0 .69-.08 1-.21v7.21c0 .55-.45 1-1 1s-1-.45-1-1V14c0-1.1-.9-2-2-2h-1V5c0-1.1-.9-2-2-2H6c-1.1 0-2 .9-2 2v16h10v-7.5h1.5v5c0 1.38 1.12 2.5 2.5 2.5s2.5-1.12 2.5-2.5V9c0-.69-.28-1.32-.73-1.77M18 10c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1M8 18v-4.5H6L10 6v5h2z"
}), "EvStation");
const xQe = ({
    insufficientGas: e
  }) => {
    const {
      t
    } = ft();
    return C.jsxs(LJ, {
      children: [C.jsxs(BJ, {
        display: "flex",
        alignItems: "center",
        px: 2,
        pt: 2,
        children: [C.jsx(Ny, {
          sx: {
            marginRight: 1
          }
        }), C.jsx(Ue, {
          variant: "body2",
          fontWeight: 700,
          children: t("warning.title.insufficientGas")
        })]
      }), C.jsx(Ue, {
        variant: "body2",
        px: 2,
        pt: 1,
        children: t("warning.message.insufficientGas")
      }), e == null ? void 0 : e.map((n, r) => {
        var i, s;
        return C.jsx(Ue, {
          variant: "body2",
          px: 2,
          pb: (e == null ? void 0 : e.length) - 1 === r ? 2 : 0,
          pt: .5,
          children: t("main.tokenOnChainAmount", {
            amount: (i = n.insufficientAmount) == null ? void 0 : i.toString(),
            tokenSymbol: n.token.symbol,
            chainName: (s = n.chain) == null ? void 0 : s.name
          })
        }, r)
      })]
    })
  },
  FJ = ({
    route: e,
    ...t
  }) => {
    const {
      insufficientGas: n
    } = wq(e), {
      insufficientFromToken: r
    } = yq(e), i = n == null ? void 0 : n.length;
    return C.jsx(fo, {
      timeout: 225,
      in: !!(r || i),
      unmountOnExit: !0,
      mountOnEnter: !0,
      children: C.jsx(Pe, {
        ...t,
        children: r ? C.jsx(yQe, {}) : i ? C.jsx(xQe, {
          insufficientGas: n
        }) : null
      })
    })
  },
  EQe = e => {
    const {
      t
    } = ft(), n = po(l => l.setValue), {
      enabledAutoRefuel: r
    } = kc(["enabledAutoRefuel"]), {
      enabled: i,
      chain: s,
      isLoading: o
    } = Mk(), a = (l, u) => {
      n("enabledAutoRefuel", u)
    }, c = s && i && !o;
    return C.jsx(fo, {
      timeout: 225,
      in: c,
      unmountOnExit: !0,
      mountOnEnter: !0,
      children: C.jsxs(pQe, {
        ...e,
        children: [C.jsxs(mQe, {
          display: "flex",
          alignItems: "center",
          justifyContent: "space-between",
          p: 2,
          children: [C.jsxs(Pe, {
            display: "flex",
            alignItems: "center",
            children: [C.jsx(Ny, {
              sx: {
                marginRight: 1
              }
            }), C.jsx(Ue, {
              variant: "body2",
              fontWeight: 700,
              children: t("info.title.autoRefuel")
            })]
          }), C.jsx(gQe, {
            checked: r,
            onChange: a
          })]
        }), C.jsx(fo, {
          timeout: 225,
          in: r,
          unmountOnExit: !0,
          mountOnEnter: !0,
          children: C.jsx(Ue, {
            variant: "body2",
            px: 2,
            pb: 2,
            children: t("info.message.autoRefuel", {
              chainName: s == null ? void 0 : s.name
            })
          })
        })]
      })
    })
  },
  j8 = (e, t) => e ? Math.min(100, (Date.now() - e) / t * 100) : 0,
  SQe = (e, t) => Math.max(Math.round((t - (Date.now() - e)) / 1e3), 0),
  H_ = ({
    updatedAt: e,
    timeToUpdate: t,
    isLoading: n,
    onClick: r,
    ...i
  }) => {
    const [s, o] = j.useState(() => j8(e, t));
    return j.useEffect(() => {
      o(j8(e, t));
      const a = setInterval(() => {
        const c = j8(e, t);
        o(c), c >= 100 && clearInterval(a)
      }, 1e3);
      return () => clearInterval(a)
    }, [t, e]), j.useEffect(() => {
      n && o(0)
    }, [n]), C.jsx(_s, {
      onClick: r,
      disabled: n,
      ...i,
      children: C.jsx(ro, {
        title: C.jsx(tk, {
          i18nKey: "tooltip.progressToNextUpdate",
          values: {
            value: SQe(e, t)
          },
          components: [C.jsx("br", {})]
        }),
        placement: "top",
        enterDelay: 400,
        arrow: !0,
        children: C.jsxs(Pe, {
          sx: {
            display: "grid",
            position: "relative",
            placeItems: "center",
            width: 24,
            height: 24
          },
          children: [C.jsx(u3, {
            variant: "determinate",
            size: 24,
            value: 100,
            sx: a => ({
              position: "absolute",
              color: a.palette.mode === "light" ? a.palette.grey[300] : a.palette.grey[800]
            })
          }), C.jsx(u3, {
            variant: n ? "indeterminate" : "determinate",
            size: 24,
            value: s,
            sx: a => ({
              opacity: s === 100 && !n ? .5 : 1,
              color: a.palette.mode === "light" ? a.palette.primary.main : a.palette.primary.light
            })
          })]
        })
      })
    })
  };
var V_ = {},
  CQe = Zt;
Object.defineProperty(V_, "__esModule", {
  value: !0
});
var bE = V_.default = void 0,
  AQe = CQe(an()),
  TQe = C;
bE = V_.default = (0, AQe.default)((0, TQe.jsx)("path", {
  d: "m12 8-6 6 1.41 1.41L12 10.83l4.59 4.58L18 14z"
}), "ExpandLess");
var W_ = {},
  kQe = Zt;
Object.defineProperty(W_, "__esModule", {
  value: !0
});
var My = W_.default = void 0,
  _Qe = kQe(an()),
  IQe = C;
My = W_.default = (0, _Qe.default)((0, IQe.jsx)("path", {
  d: "M16.59 8.59 12 13.17 7.41 8.59 6 10l6 6 6-6z"
}), "ExpandMore");
var q_ = {},
  PQe = Zt;
Object.defineProperty(q_, "__esModule", {
  value: !0
});
var G_ = q_.default = void 0,
  RQe = PQe(an()),
  OQe = C;
G_ = q_.default = (0, RQe.default)((0, OQe.jsx)("path", {
  d: "M12 1 3 5v6c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V5zm-2 16-4-4 1.41-1.41L10 14.17l6.59-6.59L18 9z"
}), "VerifiedUser");
const DQe = e => {
    const t = vl(),
      n = t.palette.mode === "light" ? "#1C4332" : t.palette.common.white;
    return C.jsxs("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      width: "58",
      height: "20",
      fill: "none",
      ...e,
      children: [C.jsx("path", {
        fill: n,
        fillRule: "evenodd",
        d: "M42.887 3.894a2.104 2.104 0 0 0-1.304.405 1.259 1.259 0 0 0-.544 1.046c0 .683.509 1.15 1.527 1.401.483.12.817.236 1 .345.184.11.276.234.276.373a.36.36 0 0 1-.227.331 1.25 1.25 0 0 1-.568.115c-.66 0-1.292-.25-1.896-.753V8.23c.473.418 1.082.637 1.826.656h.055c.46.01.912-.12 1.297-.37a1.19 1.19 0 0 0 .558-1.053c0-.734-.51-1.229-1.527-1.485a.532.532 0 0 1-.084-.02l-.097-.022a5.483 5.483 0 0 1-.826-.258c-.18-.079-.269-.192-.269-.341a.38.38 0 0 1 .23-.341c.178-.09.374-.133.572-.126.303.006.602.061.886.164a4 4 0 0 1 .906.443V4.41a3.55 3.55 0 0 0-1.791-.516Zm-11.621.056h1.052v4.88h-1.052V3.95Zm5.014 0 1.638 3.876V3.95h1.025v4.88h-1.625l-1.687-4.002V8.83h-1.025V3.95h1.674Zm10.56.007h1.053v2.9c-.007.28.102.55.3.746a.972.972 0 0 0 .711.3.982.982 0 0 0 .715-.3c.2-.196.31-.466.303-.746v-2.9h1.046v2.9c.013.543-.2 1.067-.59 1.447a2.158 2.158 0 0 1-2.941.007 1.934 1.934 0 0 1-.596-1.454v-2.9Zm9.283 1.653a.714.714 0 0 1-.718.71h-1.179V4.891h1.178a.7.7 0 0 1 .51.206.68.68 0 0 1 .209.505v.008ZM53.18 3.95v4.88h1.045V7.226h.823l.969 1.604h1.185l-1.046-1.736c.29-.114.538-.316.708-.578.176-.26.27-.565.268-.879a1.617 1.617 0 0 0-.505-1.185 1.673 1.673 0 0 0-1.224-.502h-2.223Z",
        clipRule: "evenodd"
      }), C.jsx("path", {
        fill: "#28DA98",
        fillRule: "evenodd",
        d: "M32.366 13.05a1.27 1.27 0 0 0 .37.914c.238.252.57.391.917.383a1.317 1.317 0 0 0 1.296-1.296 1.267 1.267 0 0 0-.383-.913 1.233 1.233 0 0 0-.913-.393 1.216 1.216 0 0 0-.918.388c-.24.245-.373.575-.37.918Zm-.53-1.78a2.274 2.274 0 0 1 1.69-.721c.49-.01.966.166 1.332.493v-.411h1.324v4.838h-1.324v-.401c-.37.318-.845.488-1.333.475a2.252 2.252 0 0 1-1.684-.74 2.45 2.45 0 0 1-.708-1.752 2.471 2.471 0 0 1 .704-1.78v-.001Zm7.093 0c.461-.47 1.095-.73 1.753-.721.5-.006.99.148 1.397.438.408.284.72.685.895 1.15l-1.205.347a1.274 1.274 0 0 0-.434-.543 1.095 1.095 0 0 0-.652-.206 1.174 1.174 0 0 0-.895.393 1.31 1.31 0 0 0-.365.922c-.005.342.127.672.365.918.228.252.554.393.895.388.235.004.466-.068.657-.206a1.3 1.3 0 0 0 .429-.534l1.205.347c-.176.46-.486.858-.89 1.141a2.36 2.36 0 0 1-1.401.439 2.388 2.388 0 0 1-1.767-.736 2.501 2.501 0 0 1 .014-3.537Zm9.495 1.269h-2.346a1.16 1.16 0 0 1 .425-.585c.217-.16.482-.244.753-.237a1.195 1.195 0 0 1 1.168.822Zm.411-1.424a2.477 2.477 0 0 0-3.323.155 2.501 2.501 0 0 0-.013 3.537c.46.48 1.1.747 1.766.735a2.89 2.89 0 0 0 1.351-.342 2.08 2.08 0 0 0 .94-.908l-1.15-.33c-.313.28-.722.428-1.141.412a1.327 1.327 0 0 1-.758-.215 1.043 1.043 0 0 1-.429-.616h3.633c.037-.156.056-.315.055-.475a2.338 2.338 0 0 0-.064-.53 2.467 2.467 0 0 0-.867-1.423Z",
        clipRule: "evenodd"
      }), C.jsx("path", {
        fill: "#28DA98",
        d: "M16.951 10a2.139 2.139 0 0 0-2.139-2.139l1.908-1.907c0 1.18.958 2.139 2.139 2.139L16.95 10ZM12.905 5.954a2.139 2.139 0 0 0-2.14-2.139l1.908-1.907c0 1.18.958 2.138 2.139 2.138l-1.907 1.908Z"
      }), C.jsx("path", {
        fill: n,
        d: "M16.951 18.093a2.139 2.139 0 0 0-2.138-2.14l1.907-1.907c0 1.181.958 2.139 2.139 2.139l-1.908 1.908ZM12.905 14.046a2.139 2.139 0 0 0-2.14-2.138L12.674 10c0 1.181.958 2.139 2.139 2.139l-1.907 1.907ZM16.938 2.147c.008-.078.013-.158.013-.24l-.014.24Z"
      }), C.jsx("path", {
        fill: "#28DA98",
        d: "M20.207 8.651a1.907 1.907 0 0 0-2.698 0 1.901 1.901 0 0 0-.558 1.35c-.001 1.181-.958 2.138-2.14 2.138h.001c-.488 0-.976.186-1.349.559a1.9 1.9 0 0 0-.558 1.35c-.001 1.18-.957 2.135-2.136 2.137h-.004a2.139 2.139 0 0 1-2.138-2.138c0-.489-.186-.977-.559-1.35a1.901 1.901 0 0 0-1.349-.558 2.139 2.139 0 0 1-2.138-2.137v-.004c0-1.18.957-2.136 2.137-2.137.488 0 .977-.185 1.35-.558.373-.373.559-.861.559-1.35 0-1.18.958-2.138 2.139-2.138a1.907 1.907 0 1 0-1.907-1.907A2.139 2.139 0 0 1 6.72 4.046c-.488 0-.977.186-1.35.56-.372.372-.558.86-.558 1.348a2.139 2.139 0 0 1-2.138 2.139 1.907 1.907 0 1 0 .001 3.815 2.139 2.139 0 0 1 2.137 2.136c0 .489.185.978.559 1.351a1.9 1.9 0 0 0 1.354.559 2.139 2.139 0 0 1 2.133 2.139 1.908 1.908 0 0 0 3.815 0c0-1.182.958-2.14 2.139-2.14.488 0 .976-.185 1.349-.558.374-.374.56-.864.558-1.354a2.139 2.139 0 0 1 2.137-2.133 1.908 1.908 0 0 0 1.35-3.256Z"
      }), C.jsx("path", {
        fill: n,
        d: "M28.3 8.651a1.901 1.901 0 0 0-1.348-.558 2.139 2.139 0 0 1-2.139-2.139 1.9 1.9 0 0 0-.559-1.349 1.901 1.901 0 0 0-1.349-.559 2.139 2.139 0 0 1-2.138-2.135 1.907 1.907 0 1 0-3.815-.003c0 .082-.005.164-.014.244v-.005a2.13 2.13 0 0 1-.999 1.579l-.002.001a2.112 2.112 0 0 1-.16.09l-.012.006a2.11 2.11 0 0 1-.163.072l-.018.008c-.055.02-.11.04-.167.056l-.02.006c-.057.016-.115.03-.174.042l-.02.003c-.06.011-.12.02-.182.026l-.013.001c-.064.006-.129.01-.194.01-.06 0-.118.002-.176.008h-.007a1.909 1.909 0 0 0-.526.128l-.01.003a1.92 1.92 0 0 0-.166.077l-.003.002c-.046.024-.09.051-.135.08l-.027.016c-.045.029-.087.061-.13.095-.008.006-.017.011-.025.018a1.912 1.912 0 0 0-.39.43l-.046.08c-.016.027-.034.054-.05.083-.011.023-.02.047-.032.07-.015.033-.032.066-.046.1-.01.025-.018.053-.028.08-.01.03-.023.062-.033.094-.01.036-.018.073-.027.11-.005.023-.012.046-.016.068a1.9 1.9 0 0 0-.02.137l-.007.045a1.935 1.935 0 0 0-.007.154l-.001.029a2.139 2.139 0 0 1-2.138 2.139A1.907 1.907 0 1 0 12.675 10c0-1.18.956-2.138 2.136-2.139.243 0 .485-.045.713-.137l.006-.002c.052-.02.102-.045.152-.07l.018-.009c.045-.023.089-.05.132-.078l.03-.018c.042-.027.083-.058.123-.09l.032-.023a1.953 1.953 0 0 0 .276-.277c.01-.01.017-.023.026-.034.03-.04.06-.08.088-.12l.017-.03c.028-.044.055-.088.079-.133l.009-.02c.025-.049.049-.1.07-.15l.003-.01c.09-.227.136-.468.136-.71l.013-.236a2.139 2.139 0 0 1 4.264.237c0 .49.186.978.559 1.352.373.373.862.559 1.35.558a2.139 2.139 0 0 1-.001 4.278c-.488 0-.977.186-1.35.559-.372.373-.558.862-.558 1.35a2.139 2.139 0 0 1-2.136 2.137 1.908 1.908 0 0 0-1.352 3.256 1.908 1.908 0 0 0 3.257-1.349c0-1.18.958-2.138 2.139-2.138.488 0 .976-.186 1.349-.559.372-.372.558-.86.558-1.35 0-1.18.957-2.136 2.137-2.137a1.907 1.907 0 0 0 1.35-3.256Z"
      })]
    })
  },
  NQe = e => C.jsxs("svg", {
    width: "32",
    height: "32",
    viewBox: "0 0 32 32",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    ...e,
    children: [C.jsx("circle", {
      cx: "16",
      cy: "16",
      r: "16",
      fill: "#F5B5FF"
    }), C.jsx("path", {
      d: "M15.5031 19.2031L10.1691 20.4379C9.97453 20.4867 9.82861 20.6816 9.82861 20.8766V24.5486C9.82861 24.8573 10.0718 25.0523 10.3798 24.9873L17.8215 23.265C18.1296 23.2 18.2593 22.9076 18.1296 22.6314L16.7839 19.853C16.5731 19.4143 16.7839 18.9594 17.2541 18.8619L22.1179 17.692C22.4584 17.6108 22.7502 17.2534 22.7502 16.8959V13.5001C22.7502 13.1914 22.507 12.9802 22.199 13.0614L15.1788 14.735C14.7411 14.8324 14.5465 15.2549 14.7411 15.6611L15.9733 18.212C16.184 18.6507 15.9733 19.0893 15.5031 19.2031Z",
      fill: "black"
    }), C.jsx("path", {
      d: "M11.985 10.0233L13.3793 12.8829C13.5577 13.2566 13.3793 13.6466 12.974 13.7278L10.3962 14.329C10.0719 14.4102 9.8125 14.7352 9.8125 15.0601V18.1309C9.8125 18.6509 10.234 18.9758 10.7366 18.8621L13.1361 18.3097C13.4604 18.2447 13.7198 17.9035 13.7198 17.5785L13.736 14.4265C13.736 13.9878 14.0927 13.5491 14.5142 13.4516L22.3774 11.5669C22.572 11.5181 22.7179 11.3231 22.7179 11.1282V7.45618C22.7179 7.14747 22.4747 6.93625 22.1666 7.01749L12.2931 9.38966C11.985 9.45465 11.8553 9.74711 11.985 10.0233Z",
      fill: "black"
    })]
  });
me("span", {
  shouldForwardProp: e => !["active", "completed", "error"].includes(e)
})(({
  theme: e
}) => ({
  width: 12,
  height: 12,
  borderRadius: "50%",
  border: `2px solid ${e.palette.mode==="light"?e.palette.grey[300]:e.palette.grey[800]}`
}));
const MQe = me(IH, {
    shouldForwardProp: e => !["active", "completed", "error"].includes(e)
  })(({
    theme: e
  }) => ({
    marginLeft: e.spacing(1.875),
    [`.${Zve.line}`]: {
      minHeight: 8,
      borderLeftWidth: 2,
      borderColor: e.palette.mode === "light" ? e.palette.grey[300] : e.palette.grey[800]
    }
  })),
  $Qe = me(Yve, {
    shouldForwardProp: e => !["active", "completed", "error", "disabled"].includes(e)
  })(({
    theme: e
  }) => ({
    padding: 0,
    [`.${Yc.iconContainer}`]: {
      paddingLeft: e.spacing(.75),
      paddingRight: e.spacing(2.75)
    },
    [`&.${Yc.disabled}`]: {
      cursor: "inherit"
    }
  })),
  LQe = me(hbe, {
    shouldForwardProp: e => !["active", "completed", "error"].includes(e)
  })(({
    theme: e
  }) => ({
    borderLeft: `2px solid ${e.palette.mode==="light"?e.palette.grey[300]:e.palette.grey[800]}`,
    marginLeft: e.spacing(1.875),
    paddingLeft: e.spacing(3.875),
    [`&.${abe.last}`]: {
      borderLeft: "none",
      paddingLeft: e.spacing(4.1875)
    }
  })),
  BQe = me(bl)(({
    theme: e,
    variant: t
  }) => ({
    color: e.palette.text.primary,
    backgroundColor: "transparent"
  })),
  jJ = ({
    step: e,
    dense: t,
    ...n
  }) => {
    var u, f;
    const {
      t: r
    } = ft(), {
      subvariant: i
    } = Wt(), [s, o] = j.useState(!1), a = h => {
      h.stopPropagation(), o(g => !g)
    }, c = t && ((u = e.includedSteps) == null ? void 0 : u.length) > 1, l = i === "nft" && ((f = e.includedSteps.find(h => h.tool === "custom" && h.toolDetails.key !== "custom")) == null ? void 0 : f.toolDetails) || e.toolDetails;
    return C.jsxs(Pe, {
      ...n,
      children: [C.jsxs(Pe, {
        display: "flex",
        alignItems: "center",
        children: [C.jsx(KT, {
          overlap: "circular",
          anchorOrigin: {
            vertical: "bottom",
            horizontal: "right"
          },
          badgeContent: C.jsx(vE, {
            children: C.jsx(NQe, {})
          }),
          children: C.jsx(BQe, {
            variant: "circular",
            src: l.logoURI,
            alt: l.name,
            children: l.name[0]
          })
        }), C.jsx(Ue, {
          ml: 2,
          fontSize: 18,
          fontWeight: "500",
          flex: 1,
          children: r("main.stepDetails", {
            tool: l.name
          })
        }), c ? C.jsx($_, {
          onClick: a,
          size: "small",
          children: s ? C.jsx(bE, {}) : C.jsx(My, {})
        }) : null]
      }), c ? C.jsx(fo, {
        timeout: 225,
        in: s,
        mountOnEnter: !0,
        unmountOnExit: !0,
        children: C.jsx(VB, {
          step: e,
          subvariant: i
        })
      }) : C.jsx(VB, {
        step: e,
        subvariant: i
      })]
    })
  },
  VB = ({
    step: e,
    subvariant: t
  }) => {
    const n = ({
        icon: i
      }) => {
        var o;
        const s = (o = e.includedSteps) == null ? void 0 : o[Number(i) - 1];
        return s ? C.jsx(vE, {
          src: s.toolDetails.logoURI,
          alt: s.toolDetails.name,
          sx: {
            boxSizing: "content-box"
          },
          children: s.toolDetails.name[0]
        }) : null
      },
      r = e.tool === "custom" && t === "nft" ? qB : e.type === "lifi" && e.includedSteps.some(i => i.type === "cross") ? GB : KB;
    return e.includedSteps.length > 1 ? C.jsx(Pe, {
      mt: 1.5,
      children: C.jsx(wbe, {
        orientation: "vertical",
        connector: C.jsx(MQe, {}),
        activeStep: -1,
        children: e.includedSteps.map((i, s) => C.jsxs(Ove, {
          expanded: !0,
          children: [C.jsx($Qe, {
            StepIconComponent: n,
            children: i.type === "custom" && t === "nft" ? C.jsx(qB, {
              step: i,
              subvariant: t
            }) : i.type === "cross" ? C.jsx(GB, {
              step: i
            }) : i.type === "protocol" ? C.jsx(FQe, {
              step: i
            }) : C.jsx(KB, {
              step: i
            })
          }), C.jsx(LQe, {
            children: C.jsx(WB, {
              step: i,
              subvariant: t
            })
          })]
        }, i.id))
      })
    }) : C.jsxs(Pe, {
      ml: 6,
      children: [C.jsx(r, {
        step: e,
        subvariant: t === "nft" ? t : void 0
      }), C.jsx(WB, {
        step: e,
        subvariant: t
      })]
    })
  },
  WB = ({
    step: e,
    subvariant: t
  }) => {
    var o, a, c, l, u;
    const {
      t: n
    } = ft(), r = e.action.fromToken.chainId === e.action.toToken.chainId && e.action.fromToken.address === e.action.toToken.address;
    let i;
    if (r) {
      const f = Dn(e.estimate.fromAmount).div(10 ** e.action.fromToken.decimals).minus(Dn(e.estimate.toAmount).div(10 ** e.action.toToken.decimals));
      i = f.gt(0) ? f.toString() : Dn(e.estimate.fromAmount).div(10 ** e.action.fromToken.decimals).toString()
    } else i = Ei(e.estimate.fromAmount, e.action.fromToken.decimals);
    const s = e.type !== "custom" && e.tool !== "custom" && !r;
    return C.jsxs(Ue, {
      fontSize: 12,
      fontWeight: "500",
      color: "text.secondary",
      alignItems: "center",
      display: "flex",
      children: [n("format.number", {
        value: i
      }), " ", e.action.fromToken.symbol, s ? C.jsxs(C.Fragment, {
        children: [C.jsx(D_, {
          sx: {
            fontSize: 18,
            paddingX: .5
          }
        }), n("format.number", {
          value: Ei(((o = e.execution) == null ? void 0 : o.toAmount) ?? e.estimate.toAmount, ((c = (a = e.execution) == null ? void 0 : a.toToken) == null ? void 0 : c.decimals) ?? e.action.toToken.decimals)
        }), " ", ((u = (l = e.execution) == null ? void 0 : l.toToken) == null ? void 0 : u.symbol) ?? e.action.toToken.symbol]
      }) : null]
    })
  },
  qB = ({
    step: e,
    subvariant: t
  }) => {
    var i, s;
    const {
      t: n
    } = ft();
    if (!t) return null;
    const r = t === "nft" && ((i = e.includedSteps) == null ? void 0 : i.length) > 0 && ((s = e.includedSteps.find(o => o.tool === "custom" && o.toolDetails.key !== "custom")) == null ? void 0 : s.toolDetails) || e.toolDetails;
    return C.jsx(Ue, {
      fontSize: 12,
      fontWeight: "500",
      color: "text.secondary",
      children: n(`main.${t}StepDetails`, {
        tool: r.name
      })
    })
  },
  GB = ({
    step: e
  }) => {
    var r, i;
    const {
      t
    } = ft(), {
      getChainById: n
    } = vo();
    return C.jsx(Ue, {
      fontSize: 12,
      fontWeight: "500",
      color: "text.secondary",
      children: t("main.crossStepDetails", {
        from: (r = n(e.action.fromChainId)) == null ? void 0 : r.name,
        to: (i = n(e.action.toChainId)) == null ? void 0 : i.name,
        tool: e.toolDetails.name
      })
    })
  },
  KB = ({
    step: e
  }) => {
    var r;
    const {
      t
    } = ft(), {
      getChainById: n
    } = vo();
    return C.jsx(Ue, {
      fontSize: 12,
      fontWeight: "500",
      color: "text.secondary",
      children: t("main.swapStepDetails", {
        chain: (r = n(e.action.fromChainId)) == null ? void 0 : r.name,
        tool: e.toolDetails.name
      })
    })
  },
  FQe = ({
    step: e
  }) => {
    const {
      t
    } = ft();
    return C.jsx(Ue, {
      fontSize: 12,
      fontWeight: "500",
      color: "text.secondary",
      children: e.toolDetails.key === "lifuelProtocol" ? t("main.refuelStepDetails", {
        tool: e.toolDetails.name
      }) : e.toolDetails.name
    })
  };
var p9 = new Map,
  Wb = new WeakMap,
  QB = 0,
  jQe = void 0;

function UQe(e) {
  return e ? (Wb.has(e) || (QB += 1, Wb.set(e, QB.toString())), Wb.get(e)) : "0"
}

function zQe(e) {
  return Object.keys(e).sort().filter(t => e[t] !== void 0).map(t => `${t}_${t==="root"?UQe(e.root):e[t]}`).toString()
}

function HQe(e) {
  const t = zQe(e);
  let n = p9.get(t);
  if (!n) {
    const r = new Map;
    let i;
    const s = new IntersectionObserver(o => {
      o.forEach(a => {
        var c;
        const l = a.isIntersecting && i.some(u => a.intersectionRatio >= u);
        e.trackVisibility && typeof a.isVisible > "u" && (a.isVisible = l), (c = r.get(a.target)) == null || c.forEach(u => {
          u(l, a)
        })
      })
    }, e);
    i = s.thresholds || (Array.isArray(e.threshold) ? e.threshold : [e.threshold || 0]), n = {
      id: t,
      observer: s,
      elements: r
    }, p9.set(t, n)
  }
  return n
}

function VQe(e, t, n = {}, r = jQe) {
  if (typeof window.IntersectionObserver > "u" && r !== void 0) {
    const c = e.getBoundingClientRect();
    return t(r, {
      isIntersecting: r,
      target: e,
      intersectionRatio: typeof n.threshold == "number" ? n.threshold : 0,
      time: 0,
      boundingClientRect: c,
      intersectionRect: c,
      rootBounds: c
    }), () => {}
  }
  const {
    id: i,
    observer: s,
    elements: o
  } = HQe(n), a = o.get(e) || [];
  return o.has(e) || o.set(e, a), a.push(t), s.observe(e),
    function () {
      a.splice(a.indexOf(t), 1), a.length === 0 && (o.delete(e), s.unobserve(e)), o.size === 0 && (s.disconnect(), p9.delete(i))
    }
}

function WQe({
  threshold: e,
  delay: t,
  trackVisibility: n,
  rootMargin: r,
  root: i,
  triggerOnce: s,
  skip: o,
  initialInView: a,
  fallbackInView: c,
  onChange: l
} = {}) {
  var u;
  const [f, h] = j.useState(null), g = j.useRef(), [y, x] = j.useState({
    inView: !!a,
    entry: void 0
  });
  g.current = l, j.useEffect(() => {
    if (o || !f) return;
    let v;
    return v = VQe(f, (S, I) => {
      x({
        inView: S,
        entry: I
      }), g.current && g.current(S, I), I.isIntersecting && s && v && (v(), v = void 0)
    }, {
      root: i,
      rootMargin: r,
      threshold: e,
      trackVisibility: n,
      delay: t
    }, c), () => {
      v && v()
    }
  }, [Array.isArray(e) ? e.toString() : e, f, i, r, s, o, n, c, t]);
  const k = (u = y.entry) == null ? void 0 : u.target,
    _ = j.useRef();
  !f && k && !s && !o && _.current !== k && (_.current = k, x({
    inView: !!a,
    entry: void 0
  }));
  const p = [h, y.inView, y.entry];
  return p.ref = p[0], p.inView = p[1], p.entry = p[2], p
}
const qQe = {
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  GQe = ({
    children: e,
    width: t = "100%",
    height: n,
    maxHeight: r,
    preserveAspectRatio: i = "xMinYMid meet",
    textStyle: s,
    svgStyle: o,
    cropTop: a,
    cropBottom: c,
    onFit: l
  }) => {
    const u = vl(),
      f = j.useRef(null),
      [h, g] = j.useState(qQe),
      [y] = WQe({
        onChange(k) {
          k && x()
        }
      }),
      x = j.useCallback(() => {
        if (!f.current) return;
        const k = f.current.getBBox();
        a && (k.y += k.height * a, k.height -= k.height * a), c && (k.height -= k.height * c), g(k), l == null || l()
      }, [c, a, l]);
    return j.useLayoutEffect(() => {
      x()
    }, [x, e]), j.useLayoutEffect(() => {
      document.fonts && document.fonts.ready.then(() => {
        x()
      })
    }, [x]), C.jsx("svg", {
      style: o,
      viewBox: `${h.x} ${h.y} ${h.width} ${h.height}`,
      width: t,
      height: n,
      preserveAspectRatio: i,
      fill: u.palette.text.primary,
      ref: y,
      children: C.jsx("text", {
        x: 0,
        y: 0,
        style: s,
        ref: f,
        children: e
      })
    })
  },
  KQe = me(Pe, {
    shouldForwardProp: e => e !== "connected"
  })(({
    theme: e,
    connected: t
  }) => ({
    borderLeftWidth: t ? 2 : 0,
    borderLeftStyle: "solid",
    borderColor: e.palette.mode === "light" ? e.palette.grey[300] : e.palette.grey[800],
    margin: t ? e.spacing(.5, 0, 0, 1.875) : e.spacing(0, 0, 0, 6),
    padding: t ? e.spacing(0, 0, 0, 3.875) : e.spacing(0, 0, 0, 0),
    display: "flex",
    alignItems: "flex-start",
    flexWrap: "wrap"
  })),
  qb = me(Ue, {
    shouldForwardProp: e => !["connected", "dot"].includes(e)
  })(({
    theme: e,
    connected: t,
    dot: n
  }) => ({
    fontSize: 12,
    lineHeight: 1,
    fontWeight: 500,
    color: n ? Vt(e.palette.text.secondary, .56) : e.palette.text.secondary,
    marginTop: t ? 0 : e.spacing(.5)
  })),
  QQe = me(Pe)(({
    theme: e
  }) => ({
    height: 12,
    borderLeftWidth: 2,
    borderLeftStyle: "solid",
    borderColor: e.palette.mode === "light" ? e.palette.grey[300] : e.palette.grey[800],
    margin: e.spacing(0, 0, 0, 3.875),
    padding: e.spacing(0, 0, 0, 3.875)
  })),
  om = ({
    token: e,
    ...t
  }) => !(e != null && e.priceUSD) || !e.logoURI ? C.jsx(YQe, {
    token: e,
    ...t
  }) : C.jsx(UJ, {
    token: e,
    ...t
  }),
  YQe = ({
    token: e,
    isLoading: t,
    ...n
  }) => {
    const {
      token: r,
      isLoading: i
    } = hh(e == null ? void 0 : e.chainId, e == null ? void 0 : e.address);
    return C.jsx(UJ, {
      token: {
        ...e,
        ...r
      },
      isLoading: t || i,
      ...n
    })
  },
  UJ = ({
    token: e,
    connected: t,
    step: n,
    disableDescription: r,
    isLoading: i,
    ...s
  }) => {
    const {
      t: o
    } = ft(), {
      chain: a
    } = _m(e == null ? void 0 : e.chainId), c = Ei(e == null ? void 0 : e.amount, e == null ? void 0 : e.decimals), l = Rk(c, e == null ? void 0 : e.priceUSD);
    return C.jsxs(Pe, {
      flex: 1,
      ...s,
      children: [C.jsxs(Pe, {
        display: "flex",
        flex: 1,
        alignItems: "center",
        children: [C.jsx(A2, {
          token: e,
          chain: a,
          isLoading: i,
          sx: {
            marginRight: 2
          }
        }), i ? C.jsx(gr, {
          width: 112,
          height: 32,
          variant: "text"
        }) : C.jsx(GQe, {
          height: 30,
          textStyle: {
            fontWeight: 700
          },
          children: o("format.number", {
            value: c
          })
        })]
      }), C.jsxs(KQe, {
        connected: t,
        component: "span",
        children: [i ? C.jsx(gr, {
          width: 48,
          height: 12,
          variant: "rounded",
          sx: {
            marginTop: .5
          }
        }) : C.jsx(qb, {
          connected: t,
          children: o("format.currency", {
            value: l
          })
        }), r ? null : C.jsx(qb, {
          connected: t,
          px: .5,
          dot: !0,
          children: "•"
        }), !n && !r ? i ? C.jsx(gr, {
          width: 96,
          height: 12,
          variant: "rounded",
          sx: {
            marginTop: .5
          }
        }) : C.jsx(qb, {
          connected: t,
          children: o("main.tokenOnChain", {
            tokenSymbol: e == null ? void 0 : e.symbol,
            chainName: a == null ? void 0 : a.name
          })
        }) : null, n ? C.jsxs(Pe, {
          display: "flex",
          alignItems: "flex-end",
          height: 12,
          mt: .5,
          children: [C.jsx(Pe, {
            pr: .75,
            children: C.jsx(vE, {
              src: n.toolDetails.logoURI,
              alt: n.toolDetails.name,
              sx: {
                border: 0,
                marginBottom: -.25
              },
              children: n.toolDetails.name[0]
            })
          }), C.jsx(qb, {
            connected: !0,
            children: n.toolDetails.name
          })]
        }) : null]
      })]
    })
  };
var K_ = {},
  JQe = Zt;
Object.defineProperty(K_, "__esModule", {
  value: !0
});
var zJ = K_.default = void 0,
  XQe = JQe(an()),
  ZQe = C;
zJ = K_.default = (0, XQe.default)((0, ZQe.jsx)("path", {
  d: "M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2m3.3 14.71L11 12.41V7h2v4.59l3.71 3.71z"
}), "AccessTimeFilled");
var Q_ = {},
  eYe = Zt;
Object.defineProperty(Q_, "__esModule", {
  value: !0
});
var HJ = Q_.default = void 0,
  tYe = eYe(an()),
  nYe = C;
HJ = Q_.default = (0, tYe.default)((0, nYe.jsx)("path", {
  d: "m11.99 18.54-7.37-5.73L3 14.07l9 7 9-7-1.63-1.27zM12 16l7.36-5.73L21 9l-9-7-9 7 1.63 1.27z"
}), "Layers");
var Y_ = {},
  rYe = Zt;
Object.defineProperty(Y_, "__esModule", {
  value: !0
});
var VJ = Y_.default = void 0,
  iYe = rYe(an()),
  sYe = C;
VJ = Y_.default = (0, iYe.default)((0, sYe.jsx)("path", {
  d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2m1.41 16.09V20h-2.67v-1.93c-1.71-.36-3.16-1.46-3.27-3.4h1.96c.1 1.05.82 1.87 2.65 1.87 1.96 0 2.4-.98 2.4-1.59 0-.83-.44-1.61-2.67-2.14-2.48-.6-4.18-1.62-4.18-3.67 0-1.72 1.39-2.84 3.11-3.21V4h2.67v1.95c1.86.45 2.79 1.86 2.85 3.39H14.3c-.05-1.11-.64-1.87-2.22-1.87-1.5 0-2.4.68-2.4 1.64 0 .84.65 1.39 2.67 1.91s4.18 1.39 4.18 3.91c-.01 1.83-1.38 2.83-3.12 3.16"
}), "MonetizationOn");
const Gb = me(Ue)(({
    theme: e
  }) => ({
    color: e.palette.mode === "light" ? Vt(e.palette.common.black, .24) : Vt(e.palette.common.white, .32),
    lineHeight: 0,
    marginRight: e.spacing(.5)
  })),
  oYe = e => Object.values(e.steps.reduce((t, n) => {
    var r;
    if ((r = n.estimate.gasCosts) != null && r.length) {
      const {
        token: i
      } = n.estimate.gasCosts[0], s = n.estimate.gasCosts.reduce((u, f) => u.plus(Dn(f.amount || 0)), Dn(0)).div(10 ** i.decimals), o = n.estimate.gasCosts.reduce((u, f) => u + parseFloat(f.amountUSD || "0"), 0), a = t[i.chainId], c = a ? a.amount.plus(s) : s, l = a ? a.amountUSD + o : o;
      return t[i.chainId] = {
        amount: c,
        amountUSD: l,
        token: i
      }, t
    }
    return t
  }, {})),
  aYe = (e, t) => Object.values(e.steps.reduce((n, r) => {
    let i = r.estimate.feeCosts;
    if (typeof t == "boolean" && (i = i == null ? void 0 : i.filter(s => s.included === t)), i != null && i.length) {
      const {
        token: s
      } = i[0], o = i.reduce((f, h) => f.plus(Dn(h.amount || 0)), Dn(0)).div(10 ** s.decimals), a = i.reduce((f, h) => f + parseFloat(h.amountUSD || "0"), 0), c = n[s.chainId], l = c ? c.amount.plus(o) : o, u = c ? c.amountUSD + a : a;
      return n[s.chainId] = {
        amount: l,
        amountUSD: u,
        token: s
      }, n
    }
    return n
  }, {})),
  cYe = ({
    route: e,
    dense: t
  }) => {
    const {
      t: n
    } = ft(), r = Math.ceil(e.steps.map(a => a.estimate.executionDuration).reduce((a, c) => a + c, 0) / 60), i = parseFloat(e.gasCostUSD ?? "") || .01, s = oYe(e), o = aYe(e, !1);
    return C.jsxs(Pe, {
      display: "flex",
      justifyContent: "space-between",
      flex: 1,
      mt: 2,
      children: [C.jsx(ro, {
        title: C.jsxs(Pe, {
          component: "span",
          children: [n("tooltip.estimatedNetworkFee"), s.map((a, c) => {
            var l;
            return C.jsxs(Ue, {
              fontSize: 12,
              fontWeight: "500",
              children: [(l = a.amount) == null ? void 0 : l.toFixed(9), " ", a.token.symbol, " (", n("format.currency", {
                value: a.amountUSD
              }), ")"]
            }, `${a.token.address}${c}`)
          })]
        }),
        placement: "top",
        enterDelay: 400,
        arrow: !0,
        children: C.jsxs(Pe, {
          display: "flex",
          alignItems: "center",
          mr: t ? 0 : 2,
          children: [C.jsx(Gb, {
            children: C.jsx(Ny, {
              fontSize: "small"
            })
          }), C.jsx(Ue, {
            fontSize: 14,
            color: "text.primary",
            fontWeight: "500",
            lineHeight: 1,
            children: n("format.currency", {
              value: i
            })
          })]
        })
      }), C.jsx(ro, {
        title: C.jsxs(Pe, {
          component: "span",
          children: [n("tooltip.additionalProviderFee"), o.map((a, c) => {
            var l;
            return C.jsxs(Ue, {
              fontSize: 12,
              fontWeight: "500",
              children: [(l = a.amount) == null ? void 0 : l.toFixed(9), " ", a.token.symbol, " (", n("format.currency", {
                value: a.amountUSD
              }), ")"]
            }, `${a.token.address}${c}`)
          })]
        }),
        placement: "top",
        enterDelay: 400,
        arrow: !0,
        children: C.jsxs(Pe, {
          display: "flex",
          alignItems: "center",
          mr: t ? 0 : 2,
          children: [C.jsx(Gb, {
            children: C.jsx(VJ, {
              fontSize: "small"
            })
          }), C.jsx(Ue, {
            fontSize: 14,
            color: "text.primary",
            fontWeight: "500",
            lineHeight: 1,
            children: n("format.currency", {
              value: o.reduce((a, c) => a + c.amountUSD, 0)
            })
          })]
        })
      }), C.jsx(ro, {
        title: n("tooltip.estimatedTime"),
        placement: "top",
        enterDelay: 400,
        arrow: !0,
        children: C.jsxs(Pe, {
          display: "flex",
          alignItems: "center",
          mr: t ? 0 : 2,
          children: [C.jsx(Gb, {
            children: C.jsx(zJ, {
              fontSize: "small"
            })
          }), C.jsx(Ue, {
            fontSize: 14,
            color: "text.primary",
            fontWeight: "500",
            lineHeight: 1,
            children: n("main.estimatedTime", {
              value: r
            })
          })]
        })
      }), C.jsx(ro, {
        title: n("tooltip.numberOfSteps"),
        placement: "top",
        enterDelay: 400,
        arrow: !0,
        children: C.jsxs(Pe, {
          display: "flex",
          alignItems: "center",
          children: [C.jsx(Gb, {
            children: C.jsx(HJ, {
              fontSize: "small"
            })
          }), C.jsx(Ue, {
            fontSize: 14,
            color: "text.primary",
            fontWeight: "500",
            lineHeight: 1,
            children: e.steps.length
          })]
        })
      })]
    })
  },
  J_ = ({
    route: e,
    active: t,
    variant: n = "default",
    expanded: r,
    ...i
  }) => {
    var y, x, k, _, p, v;
    const {
      t: s
    } = ft(), {
      subvariant: o
    } = Wt(), [a, c] = j.useState(r), l = ((y = e.insurance) == null ? void 0 : y.state) === "INSURABLE", u = S => {
      S.stopPropagation(), c(I => !I)
    }, f = o === "nft" ? {
      ...e.fromToken,
      amount: e.fromAmount
    } : {
      ...e.toToken,
      amount: e.toAmount
    }, h = ((x = e.tags) == null ? void 0 : x[0]) === "RECOMMENDED" ? uYe : j.Fragment, g = C.jsxs(Pe, {
      flex: 1,
      children: [o !== "refuel" && (l || (k = e.tags) != null && k.length) ? C.jsxs(Pe, {
        display: "flex",
        alignItems: "center",
        mb: 2,
        children: [l ? C.jsx(lYe, {
          insuredAmount: Ei(e.toAmountMin, e.toToken.decimals),
          insuredTokenSymbol: e.toToken.symbol,
          children: C.jsxs(f9, {
            type: (_ = e.tags) != null && _.length && !a ? "insurance-icon" : "insurance",
            children: [C.jsx(G_, {
              fontSize: "inherit"
            }), a || !((p = e.tags) != null && p.length) ? C.jsx(h9, {
              type: "icon",
              children: s("main.tags.insurable")
            }) : null]
          })
        }) : null, (v = e.tags) != null && v.length ? C.jsx(h, {
          children: C.jsx(f9, {
            type: t ? "active" : void 0,
            children: C.jsx(h9, {
              children: s(`main.tags.${e.tags[0].toLowerCase()}`)
            })
          })
        }) : null]
      }) : null, C.jsxs(Pe, {
        display: "flex",
        justifyContent: "space-between",
        alignItems: "start",
        children: [C.jsx(om, {
          token: f,
          step: a ? void 0 : e.steps[0]
        }), r ? null : C.jsx($_, {
          onClick: u,
          size: "small",
          children: a ? C.jsx(bE, {}) : C.jsx(My, {})
        })]
      }), C.jsx(fo, {
        timeout: 225,
        in: a,
        mountOnEnter: !0,
        unmountOnExit: !0,
        children: e.steps.map(S => C.jsx(jJ, {
          step: S,
          mt: 2
        }, S.id))
      }), C.jsx(cYe, {
        route: e
      })]
    });
    return o === "refuel" || n === "cardless" ? g : C.jsx(Oi, {
      variant: t ? "selected" : "default",
      selectionColor: "secondary",
      indented: !0,
      ...i,
      children: g
    })
  },
  lYe = ({
    insuredAmount: e,
    insuredTokenSymbol: t,
    children: n
  }) => {
    const {
      t: r
    } = ft();
    return C.jsx(ro, {
      title: C.jsxs(Pe, {
        component: "span",
        children: [C.jsx(Ue, {
          fontSize: 12,
          fontWeight: "500",
          children: C.jsx(tk, {
            i18nKey: "insurance.insure",
            values: {
              amount: e,
              tokenSymbol: t
            },
            components: [C.jsx("strong", {})]
          })
        }), C.jsxs(Pe, {
          sx: {
            listStyleType: "disc",
            pl: 2
          },
          children: [C.jsx(Ue, {
            fontSize: 12,
            fontWeight: "500",
            display: "list-item",
            children: r("insurance.bridgeExploits")
          }), C.jsx(Ue, {
            fontSize: 12,
            fontWeight: "500",
            display: "list-item",
            children: r("insurance.slippageError")
          })]
        })]
      }),
      placement: "top",
      enterDelay: 400,
      arrow: !0,
      children: n
    })
  },
  uYe = ({
    children: e
  }) => {
    const {
      t
    } = ft();
    return C.jsx(ro, {
      title: t("tooltip.recommended"),
      placement: "top",
      enterDelay: 400,
      arrow: !0,
      children: e
    })
  },
  X_ = ({
    variant: e,
    ...t
  }) => {
    const {
      subvariant: n
    } = Wt(), r = C.jsxs(Pe, {
      flex: 1,
      children: [n !== "refuel" && n !== "nft" ? C.jsx(Pe, {
        display: "flex",
        alignItems: "center",
        mb: 2,
        children: C.jsx(gr, {
          variant: "rectangular",
          width: 112,
          height: 24,
          sx: i => ({
            borderRadius: `${i.shape.borderRadius}px`
          })
        })
      }) : null, C.jsxs(Pe, {
        children: [C.jsxs(Pe, {
          display: "flex",
          alignItems: "center",
          children: [C.jsx(Pe, {
            mr: 2,
            children: C.jsx(gr, {
              variant: "circular",
              width: 32,
              height: 32
            })
          }), C.jsx(gr, {
            variant: "text",
            width: 96,
            height: 32
          })]
        }), C.jsxs(Pe, {
          ml: 6,
          display: "flex",
          alignItems: "center",
          children: [C.jsx(gr, {
            variant: "text",
            width: 102,
            height: 16
          }), C.jsx(gr, {
            variant: "text",
            width: 72,
            height: 16,
            sx: {
              marginLeft: 1
            }
          })]
        })]
      }), C.jsxs(Pe, {
        mt: 2,
        display: "flex",
        justifyContent: "space-between",
        children: [C.jsx(gr, {
          variant: "text",
          width: 64,
          height: 20
        }), C.jsx(gr, {
          variant: "text",
          width: 64,
          height: 20
        }), C.jsx(gr, {
          variant: "text",
          width: 48,
          height: 20
        }), C.jsx(gr, {
          variant: "text",
          width: 32,
          height: 20
        })]
      })]
    });
    return n === "refuel" || e === "cardless" ? r : C.jsx(Oi, {
      indented: !0,
      ...t,
      children: r
    })
  };
var Z_ = {},
  dYe = Zt;
Object.defineProperty(Z_, "__esModule", {
  value: !0
});
var WJ = Z_.default = void 0,
  fYe = dYe(an()),
  hYe = C;
WJ = Z_.default = (0, fYe.default)((0, hYe.jsx)("path", {
  d: "M19 15.18V7c0-2.21-1.79-4-4-4s-4 1.79-4 4v10c0 1.1-.9 2-2 2s-2-.9-2-2V8.82C8.16 8.4 9 7.3 9 6c0-1.66-1.34-3-3-3S3 4.34 3 6c0 1.3.84 2.4 2 2.82V17c0 2.21 1.79 4 4 4s4-1.79 4-4V7c0-1.1.9-2 2-2s2 .9 2 2v8.18c-1.16.41-2 1.51-2 2.82 0 1.66 1.34 3 3 3s3-1.34 3-3c0-1.3-.84-2.4-2-2.82"
}), "Route");
const eI = () => {
    const {
      t: e
    } = ft();
    return C.jsxs(Pe, {
      sx: {
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        flexDirection: "column",
        flex: 1
      },
      py: 1.625,
      children: [C.jsx(Ue, {
        fontSize: 48,
        children: C.jsx(WJ, {
          fontSize: "inherit"
        })
      }), C.jsx(Ue, {
        fontSize: 18,
        fontWeight: 700,
        children: e("info.title.routeNotFound")
      }), C.jsx(Ue, {
        fontSize: 14,
        color: "text.secondary",
        textAlign: "center",
        mt: 2,
        children: e("info.message.routeNotFound")
      })]
    })
  },
  pYe = e => {
    const {
      t
    } = ft(), n = Ba(), {
      subvariant: r,
      useRecommendedRoute: i
    } = Wt(), {
      isValid: s,
      isValidating: o
    } = xm(), {
      routes: a,
      isLoading: c,
      isFetching: l,
      isFetched: u,
      dataUpdatedAt: f,
      refetchTime: h,
      refetch: g
    } = Ih(), y = a == null ? void 0 : a[0];
    if (!y && !c && !l && !u) return null;
    const x = () => {
        n(Je.routes)
      },
      p = !(r === "refuel" || i) && !(!y && !c && !l) && ((a == null ? void 0 : a.length) ?? 0) > 1;
    return C.jsxs(Oi, {
      ...e,
      children: [C.jsx(Ma, {
        children: t(r === "nft" ? "main.fromAmount" : "header.youGet")
      }), C.jsx(H_, {
        updatedAt: f || new Date().getTime(),
        timeToUpdate: h,
        isLoading: l,
        onClick: () => g(),
        sx: {
          position: "absolute",
          top: 8,
          right: 8
        }
      }), C.jsxs(Pe, {
        p: 2,
        children: [c ? C.jsx(X_, {
          variant: "cardless"
        }) : y ? C.jsx(J_, {
          route: y,
          variant: "cardless",
          active: !0
        }) : C.jsx(eI, {}), C.jsx(fo, {
          timeout: 225,
          in: p,
          unmountOnExit: !0,
          mountOnEnter: !0,
          appear: !0,
          children: C.jsx(Pe, {
            mt: 2,
            children: C.jsx(ur, {
              onClick: x,
              disabled: o || !s,
              fullWidth: !0,
              children: t("button.showAll")
            })
          })
        })]
      })]
    })
  },
  $y = 680,
  mYe = me(Pe, {
    shouldForwardProp: e => e !== "variant"
  })(({
    variant: e
  }) => ({
    display: "flex",
    justifyContent: "center",
    alignItems: "start",
    flex: 1,
    height: e === "drawer" ? "none" : $y
  })),
  gYe = me(Pe, {
    shouldForwardProp: e => e !== "variant"
  })(({
    theme: e,
    variant: t
  }) => ({
    position: "relative",
    boxSizing: "content-box",
    width: "100%",
    minWidth: 360,
    maxWidth: 392,
    maxHeight: t === "drawer" ? "none" : $y,
    background: e.palette.background.default,
    overflow: "auto",
    flex: 1,
    zIndex: 0
  })),
  yYe = me(TH, {
    shouldForwardProp: e => e !== "variant"
  })(({
    variant: e
  }) => ({
    display: "flex",
    flex: 1,
    flexDirection: "column",
    overflowX: "clip",
    margin: 0,
    width: "100%",
    maxHeight: e === "drawer" ? "none" : $y,
    overflowY: "auto",
    height: "100%"
  })),
  qJ = me(yo)({
    display: "flex",
    flexDirection: "column",
    flex: 1
  }),
  vYe = ({
    children: e
  }) => {
    const {
      containerStyle: t,
      variant: n,
      elementId: r
    } = Wt();
    return C.jsx(gYe, {
      sx: t,
      variant: n,
      id: dh(pc.RelativeContainer, r),
      children: C.jsx(yYe, {
        id: dh(pc.ScrollableContainer, r),
        variant: n,
        enableColorScheme: !0,
        children: C.jsx(qJ, {
          disableGutters: !0,
          children: e
        })
      })
    })
  },
  bYe = me(Pe)(({
    theme: e
  }) => ({
    height: $y,
    zIndex: 0
  })),
  wYe = me(Pe)({
    overflowY: "auto",
    height: "100%",
    width: "100%",
    flex: 1,
    display: "flex",
    flexDirection: "column"
  }),
  xYe = me(TH)(({
    theme: e
  }) => ({
    backgroundColor: e.palette.background.default,
    overflow: "auto",
    width: 436,
    maxHeight: $y,
    marginLeft: e.spacing(3),
    display: "flex",
    flexDirection: "column"
  })),
  EYe = me(Pe)(({
    theme: e
  }) => ({
    backgroundColor: e.palette.background.default,
    backdropFilter: "blur(12px)",
    display: "flex",
    justifyContent: "space-between",
    alignItems: "center",
    padding: e.spacing(1.5, 3),
    position: "sticky",
    top: 0,
    zIndex: 1200
  })),
  Cx = {
    enter: 225,
    exit: 225,
    appear: 0
  },
  SYe = [{
    path: "/",
    element: !0
  }],
  CYe = () => {
    const e = ak(SYe);
    return C.jsx(bYe, {
      children: C.jsx(fo, {
        timeout: Cx,
        in: !!e,
        orientation: "horizontal",
        children: C.jsx(t2, {
          timeout: Cx,
          in: !!e,
          mountOnEnter: !0,
          unmountOnExit: !0,
          children: C.jsx("div", {
            children: C.jsx(AYe, {})
          })
        })
      })
    })
  },
  AYe = () => {
    const {
      t: e
    } = ft(), t = Ba(), n = r6(), {
      subvariant: r,
      containerStyle: i
    } = Wt(), {
      isValid: s,
      isValidating: o
    } = xm(), {
      routes: a,
      isLoading: c,
      isFetching: l,
      isFetched: u,
      dataUpdatedAt: f,
      refetchTime: h,
      refetch: g
    } = Ih(), y = p => {
      s && !o && (n(p), t(Je.transactionExecution, {
        state: {
          routeId: p.id
        }
      }))
    }, x = a == null ? void 0 : a[0], k = !!(x || c || l || u), _ = !x && !c && !l && k;
    return C.jsx(fo, {
      timeout: Cx.enter,
      in: k,
      orientation: "horizontal",
      children: C.jsx(t2, {
        timeout: Cx.enter,
        in: k,
        mountOnEnter: !0,
        unmountOnExit: !0,
        children: C.jsx(xYe, {
          sx: i,
          enableColorScheme: !0,
          children: C.jsxs(wYe, {
            children: [C.jsxs(EYe, {
              children: [C.jsx(Ue, {
                fontSize: 18,
                fontWeight: "700",
                flex: 1,
                noWrap: !0,
                children: e(r === "nft" ? "main.fromAmount" : "header.youGet")
              }), C.jsx(H_, {
                updatedAt: f || new Date().getTime(),
                timeToUpdate: h,
                isLoading: l,
                onClick: () => g(),
                sx: {
                  marginRight: -1
                }
              })]
            }), C.jsx(N5, {
              direction: "column",
              spacing: 2,
              flex: 1,
              paddingX: 3,
              paddingBottom: 3,
              children: _ ? C.jsx(eI, {}) : c || l && !(a != null && a.length) ? Array.from({
                length: 3
              }).map((p, v) => C.jsx(X_, {}, v)) : a == null ? void 0 : a.map((p, v) => C.jsx(J_, {
                route: p,
                onClick: () => y(p),
                active: v === 0,
                expanded: (a == null ? void 0 : a.length) <= 2
              }, p.id))
            })]
          })
        })
      })
    })
  };
var tI = {},
  TYe = Zt;
Object.defineProperty(tI, "__esModule", {
  value: !0
});
var GJ = tI.default = void 0,
  kYe = TYe(an()),
  _Ye = C;
GJ = tI.default = (0, kYe.default)((0, _Ye.jsx)("path", {
  d: "M16 17.01V10h-2v7.01h-3L15 21l4-3.99zM9 3 5 6.99h3V14h2V6.99h3z"
}), "SwapVert");
const IYe = me(_s)(({
    theme: e
  }) => ({
    backgroundColor: e.palette.background.paper,
    border: "1px solid",
    borderColor: e.palette.mode === "light" ? e.palette.grey[300] : e.palette.grey[800],
    zIndex: 1100,
    padding: e.spacing(.5),
    "&:hover": {
      backgroundColor: e.palette.mode === "light" ? lu(e.palette.background.paper, .02) : xd(e.palette.background.paper, .02)
    }
  })),
  PYe = ({
    vertical: e
  }) => {
    const {
      setValue: t,
      getValues: n
    } = Ls(), r = () => {
      const [i, s, o, a] = n([Qe.FromChain, Qe.FromToken, Qe.ToChain, Qe.ToToken]);
      t(Qe.FromAmount, "", {
        shouldTouch: !0
      }), t(Qe.FromChain, o, {
        shouldTouch: !0
      }), t(Qe.FromToken, a, {
        shouldTouch: !0
      }), t(Qe.ToChain, i, {
        shouldTouch: !0
      }), t(Qe.ToToken, s, {
        shouldTouch: !0
      })
    };
    return C.jsx(IYe, {
      onClick: r,
      size: "small",
      children: e ? C.jsx(GJ, {}) : C.jsx(B_, {})
    })
  },
  YB = me(GKe, {
    shouldForwardProp: e => !["selected", "compact"].includes(e)
  })(({
    theme: e,
    selected: t,
    compact: n
  }) => ({
    height: 64,
    [`.${Hf.title}`]: {
      color: t ? e.palette.text.primary : e.palette.text.secondary,
      textOverflow: "ellipsis",
      whiteSpace: "nowrap",
      overflow: "hidden",
      width: n ? 92 : 256,
      fontWeight: t ? 500 : 400,
      fontSize: n && !t ? "1rem" : "1.125rem",
      [e.breakpoints.down(392)]: {
        width: n ? 92 : 224
      }
    },
    [`.${Hf.subheader}`]: {
      textOverflow: "ellipsis",
      whiteSpace: "nowrap",
      overflow: "hidden",
      width: n ? 92 : 256,
      [e.breakpoints.down(392)]: {
        width: n ? 92 : 224
      }
    }
  })),
  JB = ({
    formType: e,
    compact: t
  }) => {
    const {
      t: n
    } = ft(), r = Ba(), {
      disabledUI: i,
      subvariant: s
    } = Wt(), o = t6(), a = sr.getTokenKey(e), [c, l] = ds({
      name: [sr.getChainKey(e), a]
    }), {
      chain: u,
      isLoading: f
    } = _m(c), {
      token: h,
      isLoading: g
    } = hh(c, l), y = () => {
      r(e === "from" ? Je.fromToken : s === "refuel" ? Je.toTokenNative : Je.toToken)
    }, x = !!(u && h), k = i != null && i.includes(a) ? void 0 : y, _ = n(e === "to" && s === "refuel" ? "main.selectChain" : e === "to" && o ? "main.selectToken" : "main.selectChainAndToken"), p = n(e === "from" && s === "nft" ? "header.payWith" : `main.${e}`);
    return C.jsxs(Oi, {
      flex: 1,
      onClick: k,
      children: [C.jsx(Ma, {
        children: p
      }), c && l && (f || g) ? C.jsx(YB, {
        avatar: C.jsx(gr, {
          variant: "circular",
          width: 32,
          height: 32
        }),
        title: C.jsx(gr, {
          variant: "text",
          width: 64,
          height: 24
        }),
        subheader: C.jsx(gr, {
          variant: "text",
          width: 64,
          height: 16
        }),
        compact: t
      }) : C.jsx(YB, {
        avatar: x ? C.jsx(A2, {
          token: h,
          chain: u
        }) : C.jsx(RJ, {}),
        title: x ? h.symbol : _,
        subheader: x ? n("main.onChain", {
          chainName: u.name
        }) : null,
        selected: x,
        compact: t
      })]
    })
  },
  RYe = e => {
    const t = x5(h => h.breakpoints.down("sm")),
      {
        disabledUI: n,
        hiddenUI: r,
        subvariant: i
      } = Wt(),
      [s, o, a, c] = ds({
        name: [Qe.FromChain, Qe.ToChain, Qe.FromToken, Qe.ToToken]
      }),
      l = i === "refuel" || (n == null ? void 0 : n.includes(wh.FromToken)) || (n == null ? void 0 : n.includes(wh.ToToken)) || (r == null ? void 0 : r.includes(Ui.ToToken)),
      u = i === "nft" || (r == null ? void 0 : r.includes(Ui.ToToken)),
      f = s && o && a && c && !t && !u;
    return C.jsxs(Pe, {
      sx: {
        display: "flex",
        flexDirection: f ? "row" : "column"
      },
      ...e,
      children: [C.jsx(JB, {
        formType: "from",
        compact: f
      }), u ? null : C.jsx(Pe, {
        sx: {
          display: "flex",
          justifyContent: "center",
          alignItems: "center"
        },
        m: l ? 1 : -1.125,
        children: l ? null : C.jsx(PYe, {
          vertical: !f
        })
      }), u ? null : C.jsx(JB, {
        formType: "to",
        compact: f
      })]
    })
  },
  OYe = me(Sh)(({
    theme: e
  }) => ({
    padding: e.spacing(1.5, 2, 1.5, 0)
  })),
  DYe = me(gm)(({
    theme: e
  }) => ({
    [`.${as.input}`]: {
      height: 32,
      padding: e.spacing(0, 0, 0, 2)
    },
    [`&.${as.disabled}`]: {
      color: "inherit"
    },
    [`.${as.input}.${as.disabled}`]: {
      WebkitTextFillColor: "unset"
    }
  })),
  NYe = j.forwardRef((e, t) => {
    const {
      t: n
    } = ft(), {
      trigger: r,
      getValues: i,
      setValue: s,
      clearErrors: o
    } = Ls(), {
      account: a
    } = Ri(), {
      disabledUI: c,
      hiddenUI: l,
      requiredUI: u,
      toAddress: f
    } = Wt(), {
      showSendToWallet: h,
      showSendToWalletDirty: g,
      setSendToWallet: y
    } = z3(), {
      showDestinationWallet: x
    } = kc(["showDestinationWallet"]), k = l == null ? void 0 : l.includes(Ui.ToAddress), _ = c == null ? void 0 : c.includes(wh.ToAddress), p = u == null ? void 0 : u.includes(bx.ToAddress), v = j.useRef(p), {
      field: {
        onChange: S,
        onBlur: I,
        name: A,
        value: w
      }
    } = F5({
      name: Qe.ToAddress,
      rules: {
        required: p && n("error.title.walletAddressRequired"),
        onChange: D => {
          s(Qe.ToAddress, D.target.value.trim())
        },
        validate: async D => {
          var $, V;
          try {
            if (!D) return !0;
            const G = await ((V = ($ = a.signer) == null ? void 0 : $.provider) == null ? void 0 : V.resolveName(D));
            return k3(G || D) || n("error.title.walletAddressInvalid")
          } catch {
            return n("error.title.walletEnsAddressInvalid")
          }
        },
        onBlur: () => r(Qe.ToAddress)
      }
    }), E = !!(!g && x && f && !k) || p;
    return j.useEffect(() => {
      E && y(!0)
    }, [E, y]), j.useEffect(() => {
      i(Qe.ToAddress) ? r(Qe.ToAddress) : v.current !== p && (v.current = p, r(Qe.ToAddress).then(() => o(Qe.ToAddress)))
    }, [a.chainId, o, i, p, r]), k ? null : C.jsx(fo, {
      timeout: E ? 0 : 225,
      in: h || E,
      mountOnEnter: !0,
      unmountOnExit: !0,
      children: C.jsxs(Oi, {
        ...e,
        ref: t,
        children: [C.jsx(Ma, {
          required: p,
          children: n("main.sendToWallet")
        }), C.jsxs(OYe, {
          fullWidth: !0,
          sx: {
            paddingTop: "6px",
            paddingBottom: "5px"
          },
          children: [C.jsx(DYe, {
            size: "small",
            autoComplete: "off",
            autoCorrect: "off",
            autoCapitalize: "off",
            spellCheck: "false",
            onChange: S,
            onBlur: I,
            name: A,
            value: w,
            placeholder: n("main.walletAddressOrEns"),
            disabled: !!(f && _)
          }), C.jsx(MYe, {})]
        })]
      })
    })
  }),
  MYe = () => {
    var t;
    const {
      errors: e
    } = xm();
    return C.jsx(fH, {
      error: !!e.toAddress,
      children: (t = e.toAddress) == null ? void 0 : t.message
    })
  };
var nI = {},
  $Ye = Zt;
Object.defineProperty(nI, "__esModule", {
  value: !0
});
var T2 = nI.default = void 0,
  LYe = $Ye(an()),
  BYe = C;
T2 = nI.default = (0, LYe.default)((0, BYe.jsx)("path", {
  d: "M18 4H6C3.79 4 2 5.79 2 8v8c0 2.21 1.79 4 4 4h12c2.21 0 4-1.79 4-4V8c0-2.21-1.79-4-4-4m-1.86 9.77c-.24.2-.57.28-.88.2L4.15 11.25C4.45 10.52 5.16 10 6 10h12c.67 0 1.26.34 1.63.84zM6 6h12c1.1 0 2 .9 2 2v.55c-.59-.34-1.27-.55-2-.55H6c-.73 0-1.41.21-2 .55V8c0-1.1.9-2 2-2"
}), "Wallet");
const FYe = () => {
    const {
      t: e
    } = ft(), {
      setValue: t
    } = Ls(), n = Pm(), {
      disabledUI: r,
      hiddenUI: i,
      requiredUI: s
    } = Wt(), {
      showSendToWallet: o,
      toggleSendToWallet: a
    } = z3(), {
      showDestinationWallet: c
    } = kc(["showDestinationWallet"]);
    if (!c || i != null && i.includes(Ui.ToAddress) || s != null && s.includes(bx.ToAddress)) return null;
    const l = () => {
      o && !(r != null && r.includes(wh.ToAddress)) && t(Qe.ToAddress, "", {
        shouldTouch: !0
      }), a(), n.emit(Cs.SendToWalletToggled, z3.getState().showSendToWallet)
    };
    return C.jsx(ro, {
      title: e("main.sendToWallet"),
      placement: "bottom-end",
      enterDelay: 400,
      arrow: !0,
      children: C.jsx(ur, {
        variant: o ? "contained" : "text",
        onClick: l,
        sx: {
          minWidth: 48,
          marginLeft: 1
        },
        children: C.jsx(T2, {})
      })
    })
  },
  jYe = e => {
    const {
      routes: t
    } = Ih(), n = t == null ? void 0 : t[0];
    return C.jsx(FJ, {
      route: n,
      ...e
    })
  },
  UYe = me(yo)({
    display: "flex",
    flexDirection: "column",
    flexGrow: 1,
    position: "relative"
  }),
  KJ = ({
    onClick: e,
    text: t,
    disabled: n,
    loading: r
  }) => {
    const {
      t: i
    } = ft(), s = Ba(), {
      walletManagement: o
    } = Wt(), {
      account: a,
      connect: c
    } = Ri(), l = async () => {
      a.isActive ? e == null || e() : o ? await c() : s(Je.selectWallet)
    }, u = () => a.isActive && t ? t : i("button.connectWallet");
    return C.jsx(uKe, {
      variant: "contained",
      color: "primary",
      onClick: l,
      disabled: n,
      loading: r,
      loadingPosition: "center",
      fullWidth: !0,
      children: u()
    })
  },
  zYe = () => {
    const {
      t: e
    } = ft(), t = Ba(), {
      isValid: n,
      isValidating: r
    } = xm(), i = r6(), {
      subvariant: s
    } = Wt(), o = Hk(f => f.state), {
      routes: a
    } = Ih(), c = a == null ? void 0 : a[0], l = async () => {
      c && (i(c), t(Je.transactionExecution, {
        state: {
          routeId: c.id
        }
      }))
    }, u = () => {
      if (c) switch (s) {
        case "nft":
          return e("button.reviewPurchase");
        case "refuel":
          return e("button.reviewBridge");
        default:
          const f = c.fromChainId === c.toChainId ? "Swap" : "Bridge";
          return e(`button.review${f}`)
      } else switch (s) {
        case "nft":
          return e("button.buy");
        case "refuel":
          return e("button.getGas");
        case "split":
          return e(o ? `button.${o}` : "button.exchange");
        default:
          return e("button.exchange")
      }
    };
    return C.jsx(KJ, {
      text: u(),
      onClick: l,
      disabled: c && (r || !n)
    })
  },
  HYe = () => {
    const e = hq(),
      {
        subvariant: t,
        contractComponent: n
      } = Wt(),
      r = t === "nft";
    return C.jsxs(UYe, {
      disableGutters: !0,
      children: [C.jsx(KKe, {
        mx: 3,
        mt: 1,
        mb: 1
      }), r ? C.jsx(F_, {
        mx: 3,
        mt: 1,
        mb: 1,
        children: n
      }) : null, C.jsx(RYe, {
        mt: 1,
        mx: 3,
        mb: 2
      }), r ? null : C.jsx(lQe, {
        formType: "from",
        mx: 3,
        mb: 2
      }), e ? null : C.jsx(pYe, {
        mx: 3,
        mb: 2
      }), C.jsx(NYe, {
        mx: 3,
        mb: 2
      }), C.jsx(EQe, {
        mx: 3,
        mb: 2
      }), C.jsx(jYe, {
        mx: 3,
        mb: 2
      }), C.jsxs(Pe, {
        display: "flex",
        mx: 3,
        mb: 1,
        children: [C.jsx(zYe, {}), C.jsx(FYe, {})]
      })]
    })
  },
  VYe = me(N5)(({
    theme: e
  }) => ({
    position: "relative",
    padding: e.spacing(1, 3)
  })),
  WYe = () => {
    const {
      navigateBack: e,
      navigate: t
    } = Ud(), {
      routes: n,
      isLoading: r,
      isFetching: i,
      dataUpdatedAt: s,
      refetchTime: o,
      refetch: a
    } = Ih(), c = r6(), l = Om(), u = h => {
      c(h), t(Je.transactionExecution, {
        state: {
          routeId: h.id
        }
      })
    };
    j.useEffect(() => {
      !(n != null && n.length) && !r && !i && e()
    }, []), j.useEffect(() => l.getState().setAction(C.jsx(H_, {
      updatedAt: s || new Date().getTime(),
      timeToUpdate: o,
      isLoading: i,
      onClick: () => a(),
      sx: {
        marginRight: -1
      },
      size: "medium",
      edge: "end"
    })), [s, l, i, a, o]);
    const f = !(n != null && n.length) && !r && !i;
    return C.jsx(VYe, {
      direction: "column",
      spacing: 2,
      flex: 1,
      children: f ? C.jsx(eI, {}) : r ? Array.from({
        length: 3
      }).map((h, g) => C.jsx(X_, {}, g)) : n == null ? void 0 : n.map((h, g) => C.jsx(J_, {
        route: h,
        onClick: () => u(h),
        active: g === 0,
        expanded: (n == null ? void 0 : n.length) <= 2
      }, h.id))
    })
  },
  XB = me(Oi)({
    display: "grid",
    placeItems: "center",
    minWidth: 52,
    height: 56
  }),
  qYe = me(Pe)(({
    theme: e
  }) => ({
    display: "grid",
    gridTemplateColumns: "repeat(auto-fit, minmax(52px, 1fr))",
    gridAutoRows: "56px",
    justifyContent: "space-between",
    gap: e.spacing(1.5)
  })),
  QJ = e => {
    const t = sr.getChainKey(e),
      {
        field: {
          onChange: n,
          onBlur: r
        }
      } = F5({
        name: t
      }),
      {
        setValue: i
      } = Ls(),
      {
        chains: s,
        isLoading: o
      } = vo(),
      [a, c] = qCe(),
      l = t6();
    return {
      chainOrder: a,
      chains: s,
      getChains: () => s ? a.map(g => s.find(y => y.id === g)).filter(Boolean) : [],
      isLoading: o,
      setChainOrder: c,
      setCurrentChain: h => {
        n(h), r(), l && i(sr.getChainKey("to"), h, {
          shouldTouch: !0
        }), i(sr.getTokenKey(e), ""), i(sr.getAmountKey(e), ""), i(Qe.TokenSearchFilter, ""), c(h)
      }
    }
  },
  GYe = ({
    formType: e
  }) => {
    const t = Ba(),
      {
        chainOrder: n,
        chains: r,
        getChains: i,
        isLoading: s,
        setChainOrder: o,
        setCurrentChain: a
      } = QJ(e),
      [c] = ds({
        name: [sr.getChainKey(e)]
      });
    n.includes(c) || o(c);
    const u = () => {
        t(Je[`${e}Chain`])
      },
      f = ((r == null ? void 0 : r.length) ?? 0) - A1;
    return C.jsxs(qYe, {
      children: [s ? Array.from({
        length: A1 + 1
      }).map((h, g) => C.jsx(gr, {
        variant: "rectangular",
        width: 56,
        height: 56,
        sx: {
          borderRadius: 1
        }
      }, g)) : i().map(h => C.jsx(ro, {
        title: h.name,
        placement: "top",
        enterDelay: 400,
        arrow: !0,
        children: C.jsx(XB, {
          onClick: () => a(h.id),
          variant: c === h.id ? "selected" : "default",
          children: C.jsx(bl, {
            src: h.logoURI,
            alt: h.key,
            sx: {
              width: 40,
              height: 40
            },
            children: h.name[0]
          })
        })
      }, h.id)), f > 0 ? C.jsx(XB, {
        onClick: u,
        children: C.jsx(Pe, {
          sx: {
            width: 40,
            height: 40,
            display: "grid",
            placeItems: "center"
          },
          children: C.jsxs(Ue, {
            fontWeight: 500,
            children: ["+", f]
          })
        })
      }) : null]
    })
  },
  Ly = me(gH)(({
    theme: e
  }) => ({
    borderRadius: e.shape.borderRadius,
    paddingLeft: e.spacing(1.5),
    height: 56,
    "&:hover": {
      backgroundColor: j3(e.palette.mode, "4%")
    }
  })),
  rI = me(Q2)(({
    theme: e
  }) => ({
    [`.${ru.primary}`]: {
      fontWeight: 400
    }
  }));
var iI = {},
  KYe = Zt;
Object.defineProperty(iI, "__esModule", {
  value: !0
});
var YJ = iI.default = void 0,
  QYe = KYe(an()),
  ZB = C;
YJ = iI.default = (0, QYe.default)([(0, ZB.jsx)("path", {
  d: "M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3 6.08 3 3.28 5.64 3.03 9h2.02C5.3 6.75 7.18 5 9.5 5 11.99 5 14 7.01 14 9.5S11.99 14 9.5 14c-.17 0-.33-.03-.5-.05v2.02c.17.02.33.03.5.03 1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19z"
}, "0"), (0, ZB.jsx)("path", {
  d: "M6.47 10.82 4 13.29l-2.47-2.47-.71.71L3.29 14 .82 16.47l.71.71L4 14.71l2.47 2.47.71-.71L4.71 14l2.47-2.47z"
}, "1")], "SearchOff");
const YYe = ({
  formType: e
}) => {
  var i;
  const {
    t
  } = ft(), [n] = ds({
    name: [sr.getChainKey(e)]
  }), {
    getChainById: r
  } = vo();
  return C.jsxs(Pe, {
    sx: {
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      flexDirection: "column",
      flex: 1,
      padding: 3
    },
    children: [C.jsx(Ue, {
      fontSize: 48,
      lineHeight: 1,
      children: C.jsx(YJ, {
        fontSize: "inherit"
      })
    }), C.jsx(Ue, {
      fontSize: 14,
      color: "text.secondary",
      textAlign: "center",
      mt: 2,
      px: 2,
      children: t("info.message.emptyTokenList", {
        chainName: (i = r(n)) == null ? void 0 : i.name
      })
    })]
  })
};

function x0(e, t, n) {
  let r = n.initialDeps ?? [],
    i;
  return () => {
    var s, o, a, c;
    let l;
    n.key && ((s = n.debug) != null && s.call(n)) && (l = Date.now());
    const u = e();
    if (!(u.length !== r.length || u.some((g, y) => r[y] !== g))) return i;
    r = u;
    let h;
    if (n.key && ((o = n.debug) != null && o.call(n)) && (h = Date.now()), i = t(...u), n.key && ((a = n.debug) != null && a.call(n))) {
      const g = Math.round((Date.now() - l) * 100) / 100,
        y = Math.round((Date.now() - h) * 100) / 100,
        x = y / 16,
        k = (_, p) => {
          for (_ = String(_); _.length < p;) _ = " " + _;
          return _
        };
      console.info(`%c⏱ ${k(y,5)} /${k(g,5)} ms`, `
            font-size: .6rem;
            font-weight: bold;
            color: hsl(${Math.max(0,Math.min(120-120*x,120))}deg 100% 31%);`, n == null ? void 0 : n.key)
    }
    return (c = n == null ? void 0 : n.onChange) == null || c.call(n, i), i
  }
}

function U8(e, t) {
  if (e === void 0) throw new Error(`Unexpected undefined${t?`: ${t}`:""}`);
  return e
}
const JYe = (e, t) => Math.abs(e - t) < 1,
  XYe = e => e,
  ZYe = e => {
    const t = Math.max(e.startIndex - e.overscan, 0),
      n = Math.min(e.endIndex + e.overscan, e.count - 1),
      r = [];
    for (let i = t; i <= n; i++) r.push(i);
    return r
  },
  eJe = (e, t) => {
    const n = e.scrollElement;
    if (!n) return;
    const r = s => {
      const {
        width: o,
        height: a
      } = s;
      t({
        width: Math.round(o),
        height: Math.round(a)
      })
    };
    if (r(n.getBoundingClientRect()), typeof ResizeObserver > "u") return () => {};
    const i = new ResizeObserver(s => {
      const o = s[0];
      if (o != null && o.borderBoxSize) {
        const a = o.borderBoxSize[0];
        if (a) {
          r({
            width: a.inlineSize,
            height: a.blockSize
          });
          return
        }
      }
      r(n.getBoundingClientRect())
    });
    return i.observe(n, {
      box: "border-box"
    }), () => {
      i.unobserve(n)
    }
  },
  tJe = (e, t) => {
    const n = e.scrollElement;
    if (!n) return;
    const r = () => {
      t(n[e.options.horizontal ? "scrollLeft" : "scrollTop"])
    };
    return r(), n.addEventListener("scroll", r, {
      passive: !0
    }), () => {
      n.removeEventListener("scroll", r)
    }
  },
  nJe = (e, t, n) => {
    if (t != null && t.borderBoxSize) {
      const r = t.borderBoxSize[0];
      if (r) return Math.round(r[n.options.horizontal ? "inlineSize" : "blockSize"])
    }
    return Math.round(e.getBoundingClientRect()[n.options.horizontal ? "width" : "height"])
  },
  rJe = (e, {
    adjustments: t = 0,
    behavior: n
  }, r) => {
    var i, s;
    const o = e + t;
    (s = (i = r.scrollElement) == null ? void 0 : i.scrollTo) == null || s.call(i, {
      [r.options.horizontal ? "left" : "top"]: o,
      behavior: n
    })
  };
class iJe {
  constructor(t) {
    this.unsubs = [], this.scrollElement = null, this.isScrolling = !1, this.isScrollingTimeoutId = null, this.scrollToIndexTimeoutId = null, this.measurementsCache = [], this.itemSizeCache = new Map, this.pendingMeasuredCacheIndexes = [], this.scrollDirection = null, this.scrollAdjustments = 0, this.measureElementCache = new Map, this.observer = (() => {
      let n = null;
      const r = () => n || (typeof ResizeObserver < "u" ? n = new ResizeObserver(i => {
        i.forEach(s => {
          this._measureElement(s.target, s)
        })
      }) : null);
      return {
        disconnect: () => {
          var i;
          return (i = r()) == null ? void 0 : i.disconnect()
        },
        observe: i => {
          var s;
          return (s = r()) == null ? void 0 : s.observe(i, {
            box: "border-box"
          })
        },
        unobserve: i => {
          var s;
          return (s = r()) == null ? void 0 : s.unobserve(i)
        }
      }
    })(), this.range = null, this.setOptions = n => {
      Object.entries(n).forEach(([r, i]) => {
        typeof i > "u" && delete n[r]
      }), this.options = {
        debug: !1,
        initialOffset: 0,
        overscan: 1,
        paddingStart: 0,
        paddingEnd: 0,
        scrollPaddingStart: 0,
        scrollPaddingEnd: 0,
        horizontal: !1,
        getItemKey: XYe,
        rangeExtractor: ZYe,
        onChange: () => {},
        measureElement: nJe,
        initialRect: {
          width: 0,
          height: 0
        },
        scrollMargin: 0,
        gap: 0,
        scrollingDelay: 150,
        indexAttribute: "data-index",
        initialMeasurementsCache: [],
        lanes: 1,
        ...n
      }
    }, this.notify = n => {
      var r, i;
      (i = (r = this.options).onChange) == null || i.call(r, this, n)
    }, this.maybeNotify = x0(() => (this.calculateRange(), [this.isScrolling, this.range ? this.range.startIndex : null, this.range ? this.range.endIndex : null]), n => {
      this.notify(n)
    }, {
      key: !1,
      debug: () => this.options.debug,
      initialDeps: [this.isScrolling, this.range ? this.range.startIndex : null, this.range ? this.range.endIndex : null]
    }), this.cleanup = () => {
      this.unsubs.filter(Boolean).forEach(n => n()), this.unsubs = [], this.scrollElement = null
    }, this._didMount = () => (this.measureElementCache.forEach(this.observer.observe), () => {
      this.observer.disconnect(), this.cleanup()
    }), this._willUpdate = () => {
      const n = this.options.getScrollElement();
      this.scrollElement !== n && (this.cleanup(), this.scrollElement = n, this._scrollToOffset(this.scrollOffset, {
        adjustments: void 0,
        behavior: void 0
      }), this.unsubs.push(this.options.observeElementRect(this, r => {
        this.scrollRect = r, this.maybeNotify()
      })), this.unsubs.push(this.options.observeElementOffset(this, r => {
        this.scrollAdjustments = 0, this.scrollOffset !== r && (this.isScrollingTimeoutId !== null && (clearTimeout(this.isScrollingTimeoutId), this.isScrollingTimeoutId = null), this.isScrolling = !0, this.scrollDirection = this.scrollOffset < r ? "forward" : "backward", this.scrollOffset = r, this.maybeNotify(), this.isScrollingTimeoutId = setTimeout(() => {
          this.isScrollingTimeoutId = null, this.isScrolling = !1, this.scrollDirection = null, this.maybeNotify()
        }, this.options.scrollingDelay))
      })))
    }, this.getSize = () => this.scrollRect[this.options.horizontal ? "width" : "height"], this.memoOptions = x0(() => [this.options.count, this.options.paddingStart, this.options.scrollMargin, this.options.getItemKey], (n, r, i, s) => (this.pendingMeasuredCacheIndexes = [], {
      count: n,
      paddingStart: r,
      scrollMargin: i,
      getItemKey: s
    }), {
      key: !1
    }), this.getFurthestMeasurement = (n, r) => {
      const i = new Map,
        s = new Map;
      for (let o = r - 1; o >= 0; o--) {
        const a = n[o];
        if (i.has(a.lane)) continue;
        const c = s.get(a.lane);
        if (c == null || a.end > c.end ? s.set(a.lane, a) : a.end < c.end && i.set(a.lane, !0), i.size === this.options.lanes) break
      }
      return s.size === this.options.lanes ? Array.from(s.values()).sort((o, a) => o.end === a.end ? o.index - a.index : o.end - a.end)[0] : void 0
    }, this.getMeasurements = x0(() => [this.memoOptions(), this.itemSizeCache], ({
      count: n,
      paddingStart: r,
      scrollMargin: i,
      getItemKey: s
    }, o) => {
      const a = this.pendingMeasuredCacheIndexes.length > 0 ? Math.min(...this.pendingMeasuredCacheIndexes) : 0;
      this.pendingMeasuredCacheIndexes = [];
      const c = this.measurementsCache.slice(0, a);
      for (let l = a; l < n; l++) {
        const u = s(l),
          f = this.options.lanes === 1 ? c[l - 1] : this.getFurthestMeasurement(c, l),
          h = f ? f.end + this.options.gap : r + i,
          g = o.get(u),
          y = typeof g == "number" ? g : this.options.estimateSize(l),
          x = h + y,
          k = f ? f.lane : l % this.options.lanes;
        c[l] = {
          index: l,
          start: h,
          size: y,
          end: x,
          key: u,
          lane: k
        }
      }
      return this.measurementsCache = c, c
    }, {
      key: !1,
      debug: () => this.options.debug
    }), this.calculateRange = x0(() => [this.getMeasurements(), this.getSize(), this.scrollOffset], (n, r, i) => this.range = n.length > 0 && r > 0 ? sJe({
      measurements: n,
      outerSize: r,
      scrollOffset: i
    }) : null, {
      key: !1,
      debug: () => this.options.debug
    }), this.getIndexes = x0(() => [this.options.rangeExtractor, this.calculateRange(), this.options.overscan, this.options.count], (n, r, i, s) => r === null ? [] : n({
      ...r,
      overscan: i,
      count: s
    }), {
      key: !1,
      debug: () => this.options.debug
    }), this.indexFromElement = n => {
      const r = this.options.indexAttribute,
        i = n.getAttribute(r);
      return i ? parseInt(i, 10) : (console.warn(`Missing attribute name '${r}={index}' on measured element.`), -1)
    }, this._measureElement = (n, r) => {
      const i = this.measurementsCache[this.indexFromElement(n)];
      if (!i || !n.isConnected) {
        this.measureElementCache.forEach((a, c) => {
          a === n && (this.observer.unobserve(n), this.measureElementCache.delete(c))
        });
        return
      }
      const s = this.measureElementCache.get(i.key);
      s !== n && (s && this.observer.unobserve(s), this.observer.observe(n), this.measureElementCache.set(i.key, n));
      const o = this.options.measureElement(n, r, this);
      this.resizeItem(i, o)
    }, this.resizeItem = (n, r) => {
      const i = this.itemSizeCache.get(n.key) ?? n.size,
        s = r - i;
      s !== 0 && (n.start < this.scrollOffset + this.scrollAdjustments && this._scrollToOffset(this.scrollOffset, {
        adjustments: this.scrollAdjustments += s,
        behavior: void 0
      }), this.pendingMeasuredCacheIndexes.push(n.index), this.itemSizeCache = new Map(this.itemSizeCache.set(n.key, r)), this.notify(!1))
    }, this.measureElement = n => {
      n && this._measureElement(n, void 0)
    }, this.getVirtualItems = x0(() => [this.getIndexes(), this.getMeasurements()], (n, r) => {
      const i = [];
      for (let s = 0, o = n.length; s < o; s++) {
        const a = n[s],
          c = r[a];
        i.push(c)
      }
      return i
    }, {
      key: !1,
      debug: () => this.options.debug
    }), this.getVirtualItemForOffset = n => {
      const r = this.getMeasurements();
      return U8(r[JJ(0, r.length - 1, i => U8(r[i]).start, n)])
    }, this.getOffsetForAlignment = (n, r) => {
      const i = this.getSize();
      r === "auto" && (n <= this.scrollOffset ? r = "start" : n >= this.scrollOffset + i ? r = "end" : r = "start"), r === "start" ? n = n : r === "end" ? n = n - i : r === "center" && (n = n - i / 2);
      const s = this.options.horizontal ? "scrollWidth" : "scrollHeight",
        a = (this.scrollElement ? "document" in this.scrollElement ? this.scrollElement.document.documentElement[s] : this.scrollElement[s] : 0) - this.getSize();
      return Math.max(Math.min(a, n), 0)
    }, this.getOffsetForIndex = (n, r = "auto") => {
      n = Math.max(0, Math.min(n, this.options.count - 1));
      const i = U8(this.getMeasurements()[n]);
      if (r === "auto")
        if (i.end >= this.scrollOffset + this.getSize() - this.options.scrollPaddingEnd) r = "end";
        else if (i.start <= this.scrollOffset + this.options.scrollPaddingStart) r = "start";
      else return [this.scrollOffset, r];
      const s = r === "end" ? i.end + this.options.scrollPaddingEnd : i.start - this.options.scrollPaddingStart;
      return [this.getOffsetForAlignment(s, r), r]
    }, this.isDynamicMode = () => this.measureElementCache.size > 0, this.cancelScrollToIndex = () => {
      this.scrollToIndexTimeoutId !== null && (clearTimeout(this.scrollToIndexTimeoutId), this.scrollToIndexTimeoutId = null)
    }, this.scrollToOffset = (n, {
      align: r = "start",
      behavior: i
    } = {}) => {
      this.cancelScrollToIndex(), i === "smooth" && this.isDynamicMode() && console.warn("The `smooth` scroll behavior is not fully supported with dynamic size."), this._scrollToOffset(this.getOffsetForAlignment(n, r), {
        adjustments: void 0,
        behavior: i
      })
    }, this.scrollToIndex = (n, {
      align: r = "auto",
      behavior: i
    } = {}) => {
      n = Math.max(0, Math.min(n, this.options.count - 1)), this.cancelScrollToIndex(), i === "smooth" && this.isDynamicMode() && console.warn("The `smooth` scroll behavior is not fully supported with dynamic size.");
      const [s, o] = this.getOffsetForIndex(n, r);
      this._scrollToOffset(s, {
        adjustments: void 0,
        behavior: i
      }), i !== "smooth" && this.isDynamicMode() && (this.scrollToIndexTimeoutId = setTimeout(() => {
        if (this.scrollToIndexTimeoutId = null, this.measureElementCache.has(this.options.getItemKey(n))) {
          const [c] = this.getOffsetForIndex(n, o);
          JYe(c, this.scrollOffset) || this.scrollToIndex(n, {
            align: o,
            behavior: i
          })
        } else this.scrollToIndex(n, {
          align: o,
          behavior: i
        })
      }))
    }, this.scrollBy = (n, {
      behavior: r
    } = {}) => {
      this.cancelScrollToIndex(), r === "smooth" && this.isDynamicMode() && console.warn("The `smooth` scroll behavior is not fully supported with dynamic size."), this._scrollToOffset(this.scrollOffset + n, {
        adjustments: void 0,
        behavior: r
      })
    }, this.getTotalSize = () => {
      var n;
      const r = this.getMeasurements();
      let i;
      return r.length === 0 ? i = this.options.paddingStart : i = this.options.lanes === 1 ? ((n = r[r.length - 1]) == null ? void 0 : n.end) ?? 0 : Math.max(...r.slice(-this.options.lanes).map(s => s.end)), i - this.options.scrollMargin + this.options.paddingEnd
    }, this._scrollToOffset = (n, {
      adjustments: r,
      behavior: i
    }) => {
      this.options.scrollToFn(n, {
        behavior: i,
        adjustments: r
      }, this)
    }, this.measure = () => {
      this.itemSizeCache = new Map, this.notify(!1)
    }, this.setOptions(t), this.scrollRect = this.options.initialRect, this.scrollOffset = this.options.initialOffset, this.measurementsCache = this.options.initialMeasurementsCache, this.measurementsCache.forEach(n => {
      this.itemSizeCache.set(n.key, n.size)
    }), this.maybeNotify()
  }
}
const JJ = (e, t, n, r) => {
  for (; e <= t;) {
    const i = (e + t) / 2 | 0,
      s = n(i);
    if (s < r) e = i + 1;
    else if (s > r) t = i - 1;
    else return i
  }
  return e > 0 ? e - 1 : 0
};

function sJe({
  measurements: e,
  outerSize: t,
  scrollOffset: n
}) {
  const r = e.length - 1,
    s = JJ(0, r, a => e[a].start, n);
  let o = s;
  for (; o < r && e[o].end < n + t;) o++;
  return {
    startIndex: s,
    endIndex: o
  }
}
const oJe = typeof document < "u" ? j.useLayoutEffect : j.useEffect;

function aJe(e) {
  const t = j.useReducer(() => ({}), {})[1],
    n = {
      ...e,
      onChange: (i, s) => {
        var o;
        s ? Ux.flushSync(t) : t(), (o = e.onChange) == null || o.call(e, i, s)
      }
    },
    [r] = j.useState(() => new iJe(n));
  return r.setOptions(n), j.useEffect(() => r._didMount(), []), oJe(() => r._willUpdate()), r
}

function cJe(e) {
  return aJe({
    observeElementRect: eJe,
    observeElementOffset: tJe,
    scrollToFn: rJe,
    ...e
  })
}
var sI = {},
  lJe = Zt;
Object.defineProperty(sI, "__esModule", {
  value: !0
});
var oI = sI.default = void 0,
  uJe = lJe(an()),
  dJe = C;
oI = sI.default = (0, uJe.default)((0, dJe.jsx)("path", {
  d: "M18 19H6c-.55 0-1-.45-1-1V6c0-.55.45-1 1-1h5c.55 0 1-.45 1-1s-.45-1-1-1H5c-1.11 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2v-6c0-.55-.45-1-1-1s-1 .45-1 1v5c0 .55-.45 1-1 1M14 4c0 .55.45 1 1 1h2.59l-9.13 9.13c-.39.39-.39 1.02 0 1.41.39.39 1.02.39 1.41 0L19 6.41V9c0 .55.45 1 1 1s1-.45 1-1V4c0-.55-.45-1-1-1h-5c-.55 0-1 .45-1 1"
}), "OpenInNewRounded");
const fJe = me(Ly)(({
    theme: e
  }) => ({
    paddingLeft: e.spacing(1.5),
    paddingRight: e.spacing(1.5),
    height: 64,
    width: "100%"
  })),
  XJ = me(bH)(({
    theme: e
  }) => ({
    position: "absolute",
    top: 0,
    left: 0,
    height: 64,
    flexDirection: "column",
    alignItems: "flex-start",
    padding: e.spacing(0, 1.5),
    [`.${yH.root}`]: {
      right: e.spacing(3)
    },
    [`& .${ru.primary}`]: {
      height: 22
    },
    [`& .${ru.primary}, & .${ru.secondary}`]: {
      textOverflow: "ellipsis",
      overflow: "hidden",
      whiteSpace: "nowrap"
    }
  })),
  hJe = me(_s)(({
    theme: e
  }) => ({
    lineHeight: 1,
    fontSize: "0.75rem",
    fontWeight: 400,
    padding: e.spacing(.375, .375),
    marginLeft: e.spacing(.25),
    color: "inherit",
    backgroundColor: "unset",
    minWidth: "unset",
    borderRadius: "50%",
    "&:hover": {
      backgroundColor: e.palette.mode === "light" ? Vt(e.palette.common.black, .04) : Vt(e.palette.common.white, .08)
    },
    svg: {
      fontSize: "0.875rem"
    }
  })),
  pJe = j.memo(({
    onClick: e,
    size: t,
    start: n,
    token: r,
    chain: i,
    showBalance: s,
    isBalanceLoading: o,
    startAdornment: a,
    endAdornment: c
  }) => {
    const l = () => e == null ? void 0 : e(r.address);
    return C.jsxs(XJ, {
      disablePadding: !0,
      style: {
        height: `${t}px`,
        transform: `translateY(${n}px)`
      },
      children: [a, C.jsx(mJe, {
        token: r,
        chain: i,
        showBalance: s,
        isBalanceLoading: o,
        onClick: l
      }), c]
    })
  }),
  mJe = ({
    onClick: e,
    token: t,
    chain: n,
    showBalance: r,
    isBalanceLoading: i
  }) => {
    var g;
    const {
      t: s
    } = ft(), o = Rk(t.amount, t.priceUSD), a = j.useRef(null), c = j.useRef(), [l, u] = j.useState(!1), f = () => {
      c.current = setTimeout(() => u(!0), 350)
    }, h = () => {
      clearTimeout(c.current), l && u(!1)
    };
    return C.jsxs(fJe, {
      onClick: e,
      onMouseEnter: f,
      onMouseLeave: h,
      dense: !0,
      children: [C.jsx(ym, {
        children: C.jsx(bl, {
          src: t.logoURI,
          alt: t.symbol,
          children: (g = t.symbol) == null ? void 0 : g[0]
        })
      }), C.jsx(Q2, {
        primary: t.symbol,
        secondaryTypographyProps: {
          component: "div"
        },
        secondary: C.jsxs(Pe, {
          position: "relative",
          height: 20,
          ref: a,
          children: [C.jsx(YC, {
            direction: "down",
            in: !l,
            container: a.current,
            style: {
              position: "absolute"
            },
            appear: !1,
            children: C.jsx(Pe, {
              pt: .25,
              children: t.name
            })
          }), C.jsx(YC, {
            direction: "up",
            in: l,
            container: a.current,
            style: {
              position: "absolute"
            },
            appear: !1,
            mountOnEnter: !0,
            children: C.jsxs(Pe, {
              display: "flex",
              children: [C.jsx(Pe, {
                display: "flex",
                alignItems: "center",
                pt: .125,
                children: pp(t.address)
              }), C.jsx(hJe, {
                size: "small",
                LinkComponent: K2,
                href: `${n==null?void 0:n.metamask.blockExplorerUrls[0]}address/${t.address}`,
                target: "_blank",
                rel: "nofollow noreferrer",
                onClick: y => y.stopPropagation(),
                children: C.jsx(oI, {})
              })]
            })
          })]
        })
      }), r ? i ? C.jsx(ZJ, {}) : C.jsxs(Pe, {
        sx: {
          textAlign: "right"
        },
        children: [Number(t.amount) ? C.jsx(Ue, {
          variant: "body1",
          noWrap: !0,
          children: s("format.number", {
            value: Ei(t.amount)
          })
        }) : null, o ? C.jsx(Ue, {
          fontWeight: 400,
          fontSize: 12,
          color: "text.secondary",
          "data-price": t.priceUSD,
          children: s("format.currency", {
            value: o
          })
        }) : null]
      }) : null]
    })
  },
  gJe = () => C.jsxs(XJ, {
    secondaryAction: C.jsx(ZJ, {}),
    disablePadding: !0,
    sx: {
      position: "relative",
      flexDirection: "row",
      alignItems: "center"
    },
    children: [C.jsx(ym, {
      children: C.jsx(gr, {
        variant: "circular",
        width: 32,
        height: 32,
        sx: {
          marginLeft: 1.5,
          marginRight: 2
        }
      })
    }), C.jsx(Q2, {
      primary: C.jsx(gr, {
        variant: "text",
        width: 48,
        height: 20
      }),
      secondary: C.jsx(gr, {
        variant: "text",
        width: 96,
        height: 20
      })
    })]
  }),
  ZJ = () => C.jsxs(Pe, {
    sx: {
      display: "flex",
      flexDirection: "column",
      alignItems: "flex-end"
    },
    children: [C.jsx(gr, {
      variant: "text",
      width: 56,
      height: 24
    }), C.jsx(gr, {
      variant: "text",
      width: 48,
      height: 18
    })]
  }),
  yJe = ({
    tokens: e,
    featuredTokensLength: t,
    scrollElementRef: n,
    chainId: r,
    chain: i,
    isLoading: s,
    isBalanceLoading: o,
    showBalance: a,
    showFeatured: c,
    onClick: l
  }) => {
    const {
      t: u
    } = ft(), f = !!t && c, h = (t ?? 0) - 1, g = e.length - 1, {
      getVirtualItems: y,
      getTotalSize: x,
      scrollToIndex: k
    } = cJe({
      count: e.length,
      getScrollElement: () => n.current,
      overscan: 10,
      paddingEnd: 12,
      estimateSize: _ => {
        var v, S;
        let p = 64;
        return f && (_ === 0 && ((v = e[_]) != null && v.featured) && (p += 24), _ === h && _ !== g && ((S = e[_]) != null && S.featured) && (p += 32)), p
      },
      getItemKey: _ => `${e[_].address}-${_}`
    });
    return j.useEffect(() => {
      y().length && k(0, {
        align: "start"
      })
    }, [k, r, y]), s ? C.jsx(sh, {
      disablePadding: !0,
      children: Array.from({
        length: 3
      }).map((_, p) => C.jsx(gJe, {}, p))
    }) : C.jsx(sh, {
      style: {
        height: x()
      },
      disablePadding: !0,
      children: y().map(_ => {
        const p = e[_.index];
        return C.jsx(pJe, {
          onClick: l,
          size: _.size,
          start: _.start,
          token: p,
          chain: i,
          isBalanceLoading: o,
          showBalance: a,
          startAdornment: f && p.featured && _.index === 0 ? C.jsx(Ue, {
            fontSize: 14,
            fontWeight: 600,
            lineHeight: 1,
            px: 2,
            pb: 1.25,
            children: u("main.featuredTokens")
          }) : null,
          endAdornment: f && p.featured && _.index === h && _.index !== g ? C.jsx(Ue, {
            fontSize: 14,
            fontWeight: 600,
            lineHeight: 1,
            px: 2,
            py: 1.25,
            children: u("main.otherTokens")
          }) : null
        }, _.key)
      })
    })
  },
  eX = (e, t) => {
    const n = sr.getTokenKey(e),
      {
        field: {
          onChange: r,
          onBlur: i
        }
      } = F5({
        name: n
      }),
      {
        setValue: s,
        getValues: o
      } = Ls(),
      {
        subvariant: a
      } = Wt(),
      c = Pm();
    return j.useCallback((l, u) => {
      r(l), i();
      const f = u ?? o(sr.getChainKey(e));
      s(sr.getChainKey(e), f, {
        shouldDirty: !0,
        shouldTouch: !0
      }), s(sr.getAmountKey(e), "");
      const h = e === "from" ? "to" : "from",
        [g, y] = o([sr.getTokenKey(h), sr.getChainKey(h)]);
      g === l && y === f && a !== "nft" && s(sr.getTokenKey(h), "", {
        shouldDirty: !0,
        shouldTouch: !0
      });
      const x = e === "from" ? Cs.SourceChainTokenSelected : Cs.DestinationChainTokenSelected;
      c.emit(x, {
        chainId: f,
        tokenAddress: l
      }), t == null || t()
    }, [c, e, o, i, r, t, s, a])
  },
  vJe = ({
    formType: e,
    height: t,
    onClick: n
  }) => {
    var A;
    const r = j.useRef(null),
      {
        account: i
      } = Ri(),
      [s] = ds({
        name: [sr.getChainKey(e)]
      }),
      [o] = fq([Qe.TokenSearchFilter], 320),
      {
        chain: a,
        isLoading: c
      } = _m(s),
      {
        tokens: l,
        tokensWithBalance: u,
        isLoading: f,
        isBalanceLoading: h,
        featuredTokens: g
      } = gq(s);
    let y = u ?? l ?? [];
    const x = ((A = o == null ? void 0 : o.replaceAll("$", "")) == null ? void 0 : A.toUpperCase()) ?? "";
    y = o ? y.filter(w => w.name.toUpperCase().includes(x) || w.symbol.toUpperCase().includes(x) || w.address.toUpperCase().includes(x)) : y;
    const k = !f && !y.length && !!o && !!s,
      {
        token: _,
        isLoading: p
      } = Cq(s, o, k),
      v = f || c || k && p,
      S = y.length ? y : _ ? [_] : y,
      I = eX(e, n);
    return C.jsxs(Pe, {
      ref: r,
      style: {
        height: t,
        overflow: "auto"
      },
      children: [!S.length && !v ? C.jsx(YYe, {
        formType: e
      }) : null, C.jsx(yJe, {
        tokens: S,
        featuredTokensLength: g == null ? void 0 : g.length,
        scrollElementRef: r,
        chainId: s,
        chain: a,
        isLoading: v,
        isBalanceLoading: h,
        showBalance: i.isActive,
        showFeatured: !o,
        onClick: I
      })]
    })
  },
  z8 = ({
    formType: e,
    selectNativeToken: t
  }) => {
    const {
      navigateBack: n
    } = Ud(), {
      chains: r,
      setCurrentChain: i
    } = QJ(e), s = eX(e, n), o = async a => {
      t ? s(a.nativeToken.address, a.id) : (i(a.id), n())
    };
    return C.jsx(yo, {
      disableGutters: !0,
      children: C.jsx(sh, {
        sx: {
          paddingLeft: 1.5,
          paddingRight: 1.5
        },
        children: r == null ? void 0 : r.map(a => C.jsxs(Ly, {
          onClick: () => o(a),
          children: [C.jsx(ym, {
            children: C.jsx(bl, {
              src: a.logoURI,
              alt: a.name,
              children: a.name[0]
            })
          }), C.jsx(rI, {
            primary: a.name
          })]
        }, a.id))
      })
    })
  };
var aI = {},
  bJe = Zt;
Object.defineProperty(aI, "__esModule", {
  value: !0
});
var tX = aI.default = void 0,
  wJe = bJe(an()),
  xJe = C;
tX = aI.default = (0, wJe.default)((0, xJe.jsx)("path", {
  d: "M19 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.11 0 2-.9 2-2V5c0-1.1-.89-2-2-2m-9 14-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8z"
}), "CheckBox");
var cI = {},
  EJe = Zt;
Object.defineProperty(cI, "__esModule", {
  value: !0
});
var m9 = cI.default = void 0,
  SJe = EJe(an()),
  CJe = C;
m9 = cI.default = (0, SJe.default)((0, CJe.jsx)("path", {
  d: "M19 5v14H5V5zm0-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2"
}), "CheckBoxOutlineBlankOutlined");
var lI = {},
  AJe = Zt;
Object.defineProperty(lI, "__esModule", {
  value: !0
});
var nX = lI.default = void 0,
  TJe = AJe(an()),
  kJe = C;
nX = lI.default = (0, TJe.default)((0, kJe.jsx)("path", {
  d: "M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2m0 16H5V5h14zM17.99 9l-1.41-1.42-6.59 6.59-2.58-2.57-1.42 1.41 4 3.99z"
}), "CheckBoxOutlined");
var uI = {},
  _Je = Zt;
Object.defineProperty(uI, "__esModule", {
  value: !0
});
var rX = uI.default = void 0,
  IJe = _Je(an()),
  PJe = C;
rX = uI.default = (0, IJe.default)((0, PJe.jsx)("path", {
  d: "M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2m0 16H5V5h14zM7 11h10v2H7z"
}), "IndeterminateCheckBoxOutlined");
const RJe = me(Ly)(({
    theme: e
  }) => ({
    paddingRight: e.spacing(1)
  })),
  eF = ({
    type: e
  }) => {
    const t = e.toLowerCase(),
      {
        tools: n
      } = Lk(),
      [r, i] = po(a => [a[`enabled${e}`], a.setTools], El),
      s = Om(),
      o = a => {
        if (!n) return;
        const c = n[t].map(l => l.key);
        r != null && r.includes(a) ? i(e, r.filter(l => l !== a), c) : i(e, [...r, a], c)
      };
    return j.useEffect(() => {
      const a = (n == null ? void 0 : n[t].length) === r.length,
        c = () => {
          if (!n) return;
          const l = n[t].map(u => u.key);
          a ? i(e, [], l) : i(e, l, l)
        };
      return s.getState().setAction(C.jsx(_s, {
        size: "medium",
        edge: "end",
        onClick: c,
        children: a ? C.jsx(nX, {}) : r.length ? C.jsx(rX, {}) : C.jsx(m9, {})
      }))
    }, [r.length, s, i, n, e, t]), C.jsx(yo, {
      disableGutters: !0,
      children: C.jsx(sh, {
        sx: {
          paddingLeft: 1.5,
          paddingRight: 1.5
        },
        children: n == null ? void 0 : n[t].map(a => C.jsxs(RJe, {
          onClick: () => o(a.key),
          children: [C.jsx(ym, {
            children: C.jsx(bl, {
              src: a.logoURI,
              alt: a.name,
              children: a.name[0]
            })
          }), C.jsx(rI, {
            primary: a.name
          }), r != null && r.includes(a.key) ? C.jsx(tX, {
            color: "primary"
          }) : C.jsx(m9, {})]
        }, a.name))
      })
    })
  };
var dI = {},
  OJe = Zt;
Object.defineProperty(dI, "__esModule", {
  value: !0
});
var iX = dI.default = void 0,
  DJe = OJe(an()),
  NJe = C;
iX = dI.default = (0, DJe.default)((0, NJe.jsx)("path", {
  d: "M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14"
}), "Search");
const sX = me(gm)(({
    theme: e
  }) => ({
    backgroundColor: e.palette.mode === "light" ? e.palette.common.white : e.palette.background.paper,
    paddingRight: e.spacing(2),
    [`.${as.input}`]: {
      padding: e.spacing(1.5, 1, 1.5, 2),
      height: "2.875em",
      boxSizing: "inherit"
    }
  })),
  MJe = me(sX)(({
    theme: e
  }) => ({
    paddingRight: e.spacing(1.5)
  })),
  $Je = () => {
    const {
      t: e
    } = ft(), {
      register: t,
      setValue: n
    } = Ls();
    return j.useEffect(() => () => {
      n(Qe.TokenSearchFilter, "")
    }, [n]), C.jsx(Oi, {
      children: C.jsx(Sh, {
        fullWidth: !0,
        children: C.jsx(MJe, {
          size: "small",
          placeholder: e("main.tokenSearch"),
          defaultValue: "",
          endAdornment: C.jsx(YT, {
            position: "end",
            children: C.jsx(iX, {})
          }),
          inputProps: {
            inputMode: "search",
            ...t(Qe.TokenSearchFilter)
          },
          autoComplete: "off"
        })
      })
    })
  },
  LJe = 360,
  tF = ({
    formType: e
  }) => {
    cCe();
    const {
      navigateBack: t
    } = Ud(), n = j.useRef(null), r = uCe(), [i, s] = j.useState(0), o = t6();
    j.useLayoutEffect(() => {
      var c;
      s(Math.max(r - (((c = n.current) == null ? void 0 : c.offsetHeight) ?? 0), LJe))
    }, [r]);
    const a = o && e === "to";
    return C.jsxs(yo, {
      disableGutters: !0,
      children: [C.jsxs(Pe, {
        pt: 1,
        pb: 2,
        px: 3,
        ref: n,
        children: [a ? null : C.jsx(GYe, {
          formType: e
        }), C.jsx(Pe, {
          mt: a ? 0 : 2,
          children: C.jsx($Je, {})
        })]
      }), C.jsx(vJe, {
        height: i,
        onClick: t,
        formType: e
      })]
    })
  },
  BJe = () => {
    var u;
    const {
      t: e
    } = ft(), {
      navigateBack: t
    } = Ud(), {
      connect: n
    } = Ri(), [r, i] = j.useState({
      show: !1
    }), [s, o] = j.useState(), a = x5(f => f.breakpoints.up("sm")), c = () => {
      i(f => ({
        ...f,
        show: !1
      }))
    }, l = j.useCallback(async f => {
      if (!await f.installed()) {
        i({
          show: !0,
          wallet: f
        });
        return
      }
      t(), await n(f)
    }, [n, t]);
    return j.useEffect(() => {
      Promise.all(Pw.map(f => f.installed())).then(f => {
        const h = Pw.filter((x, k) => f[k]),
          g = Pw.filter((x, k) => !f[k] && x.name !== "Default Wallet"),
          y = [...h];
        a && y.push(...g), o(y)
      })
    }, []), C.jsxs(yo, {
      disableGutters: !0,
      children: [C.jsx(sh, {
        sx: {
          paddingLeft: 1.5,
          paddingRight: 1.5
        },
        children: s == null ? void 0 : s.map(f => C.jsxs(Ly, {
          onClick: () => l(f),
          children: [C.jsx(ym, {
            children: C.jsx(bl, {
              src: f.icon.src || f.icon,
              alt: f.name,
              children: f.name[0]
            })
          }), C.jsx(rI, {
            primary: f.name
          })]
        }, f.name))
      }), C.jsxs(Dy, {
        open: r.show,
        onClose: c,
        children: [C.jsx(q2, {
          children: C.jsx(G2, {
            children: e("wallet.extensionNotFound", {
              name: (u = r.wallet) == null ? void 0 : u.name
            })
          })
        }), C.jsx(W2, {
          children: C.jsx(ur, {
            variant: "contained",
            onClick: c,
            autoFocus: !0,
            children: e("button.ok")
          })
        })]
      })]
    })
  };
var fI = {},
  FJe = Zt;
Object.defineProperty(fI, "__esModule", {
  value: !0
});
var oX = fI.default = void 0,
  jJe = FJe(an()),
  UJe = C;
oX = fI.default = (0, jJe.default)((0, UJe.jsx)("path", {
  d: "M20 8.69V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12zM12 18c-.89 0-1.74-.2-2.5-.55C11.56 16.5 13 14.42 13 12s-1.44-4.5-3.5-5.45C10.26 6.2 11.11 6 12 6c3.31 0 6 2.69 6 6s-2.69 6-6 6"
}), "Brightness4");
var hI = {},
  zJe = Zt;
Object.defineProperty(hI, "__esModule", {
  value: !0
});
var aX = hI.default = void 0,
  HJe = zJe(an()),
  VJe = C;
aX = hI.default = (0, HJe.default)((0, VJe.jsx)("path", {
  d: "M12 3c-4.97 0-9 4.03-9 9s4.03 9 9 9 9-4.03 9-9c0-.46-.04-.92-.1-1.36-.98 1.37-2.58 2.26-4.4 2.26-2.98 0-5.4-2.42-5.4-5.4 0-1.81.89-3.42 2.26-4.4-.44-.06-.9-.1-1.36-.1"
}), "DarkMode");
var pI = {},
  WJe = Zt;
Object.defineProperty(pI, "__esModule", {
  value: !0
});
var cX = pI.default = void 0,
  qJe = WJe(an()),
  GJe = C;
cX = pI.default = (0, qJe.default)((0, GJe.jsx)("path", {
  d: "M12 7c-2.76 0-5 2.24-5 5s2.24 5 5 5 5-2.24 5-5-2.24-5-5-5M2 13h2c.55 0 1-.45 1-1s-.45-1-1-1H2c-.55 0-1 .45-1 1s.45 1 1 1m18 0h2c.55 0 1-.45 1-1s-.45-1-1-1h-2c-.55 0-1 .45-1 1s.45 1 1 1M11 2v2c0 .55.45 1 1 1s1-.45 1-1V2c0-.55-.45-1-1-1s-1 .45-1 1m0 18v2c0 .55.45 1 1 1s1-.45 1-1v-2c0-.55-.45-1-1-1s-1 .45-1 1M5.99 4.58c-.39-.39-1.03-.39-1.41 0-.39.39-.39 1.03 0 1.41l1.06 1.06c.39.39 1.03.39 1.41 0s.39-1.03 0-1.41zm12.37 12.37c-.39-.39-1.03-.39-1.41 0-.39.39-.39 1.03 0 1.41l1.06 1.06c.39.39 1.03.39 1.41 0 .39-.39.39-1.03 0-1.41zm1.06-10.96c.39-.39.39-1.03 0-1.41-.39-.39-1.03-.39-1.41 0l-1.06 1.06c-.39.39-.39 1.03 0 1.41s1.03.39 1.41 0zM7.05 18.36c.39-.39.39-1.03 0-1.41-.39-.39-1.03-.39-1.41 0l-1.06 1.06c-.39.39-.39 1.03 0 1.41s1.03.39 1.41 0z"
}), "LightMode");
const H8 = me(wwe)(({
    theme: e
  }) => ({
    textTransform: "none",
    borderRadius: e.shape.borderRadius,
    borderColor: e.palette.mode === "light" ? e.palette.grey[300] : e.palette.grey[800],
    [`&.${Of.selected}`]: {
      color: e.palette.mode === "light" ? e.palette.primary.main : e.palette.primary.light,
      borderColor: "currentColor !important"
    }
  })),
  KJe = () => {
    const {
      t: e
    } = ft(), {
      hiddenUI: t
    } = Wt(), [n, r] = Oq();
    return t != null && t.includes(Ui.Appearance) ? null : C.jsx(Pe, {
      pb: 2,
      children: C.jsxs(kwe, {
        color: "primary",
        value: n,
        onChange: (i, s) => {
          s && r(s)
        },
        exclusive: !0,
        fullWidth: !0,
        children: [C.jsxs(H8, {
          value: "light",
          children: [C.jsx(cX, {
            sx: {
              marginRight: 1
            }
          }), e("button.light")]
        }), C.jsxs(H8, {
          value: "dark",
          children: [C.jsx(aX, {
            sx: {
              marginRight: 1
            }
          }), e("button.dark")]
        }), C.jsxs(H8, {
          value: "auto",
          children: [C.jsx(oX, {
            sx: {
              marginRight: 1
            }
          }), e("button.auto")]
        })]
      })
    })
  };
var mI = {},
  QJe = Zt;
Object.defineProperty(mI, "__esModule", {
  value: !0
});
var lX = mI.default = void 0,
  YJe = QJe(an()),
  JJe = C;
lX = mI.default = (0, YJe.default)((0, JJe.jsx)("path", {
  d: "M10 6 8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"
}), "ChevronRight");
const XJe = me(Ly)(({
    theme: e
  }) => ({
    height: 48,
    paddingRight: e.spacing(.5)
  })),
  nF = me(Q2)({
    [`.${ru.primary}`]: {
      fontWeight: 400,
      fontSize: "1rem"
    }
  }),
  rF = ({
    type: e
  }) => {
    const {
      t
    } = ft(), n = Ba(), [r, i] = po(o => {
      const a = Object.values(o[`_enabled${e}`] ?? {});
      return [a.filter(Boolean).length, a.length]
    }, El), s = () => {
      n(Je[e.toLowerCase()])
    };
    return C.jsxs(XJe, {
      onClick: s,
      children: [C.jsx(nF, {
        primary: t(`settings.enabled${e}`)
      }), C.jsxs(Pe, {
        display: "flex",
        alignItems: "center",
        children: [C.jsx(nF, {
          primary: `${r}/${i}`
        }), C.jsx(lX, {})]
      })]
    })
  };
var gI = {},
  ZJe = Zt;
Object.defineProperty(gI, "__esModule", {
  value: !0
});
var wE = gI.default = void 0,
  eXe = ZJe(an()),
  tXe = C;
wE = gI.default = (0, eXe.default)((0, tXe.jsx)("path", {
  d: "M7.41 8.59 12 13.17l4.59-4.58L18 10l-6 6-6-6z"
}), "KeyboardArrowDown");
const yI = me(cve, {
    shouldForwardProp: e => e !== "dense"
  })(({
    theme: e,
    dense: t
  }) => ({
    backgroundColor: e.palette.mode === "light" ? e.palette.common.white : e.palette.background.paper,
    [`.${as.input}`]: {
      padding: t ? e.spacing(1.625, 2, 1.5, 2) : e.spacing(2),
      display: "flex",
      alignItems: "center"
    },
    [`.${T0.icon}`]: {
      right: 10,
      color: e.palette.text.primary
    },
    [`.${XC.root}`]: {
      minWidth: 38
    },
    [`.${Hl.notchedOutline}`]: {
      display: "none"
    }
  })),
  nXe = () => {
    const {
      t: e
    } = ft(), t = po(r => r.setValue), {
      gasPrice: n
    } = kc(["gasPrice"]);
    return C.jsxs(Oi, {
      flex: 1,
      children: [C.jsx(Ma, {
        children: e("settings.gasPrice.title")
      }), C.jsx(Sh, {
        fullWidth: !0,
        children: C.jsxs(yI, {
          MenuProps: {
            elevation: 2
          },
          value: n,
          onChange: r => t("gasPrice", r.target.value),
          IconComponent: wE,
          dense: !0,
          children: [C.jsx(Vf, {
            value: "slow",
            children: e("settings.gasPrice.slow")
          }), C.jsx(Vf, {
            value: "normal",
            children: e("settings.gasPrice.normal")
          }), C.jsx(Vf, {
            value: "fast",
            children: e("settings.gasPrice.fast")
          })]
        })
      })]
    })
  },
  rXe = () => {
    var l;
    const {
      t: e,
      i18n: t
    } = ft(), {
      languages: n,
      hiddenUI: r
    } = Wt(), i = po(u => u.setValue), {
      language: s
    } = kc(["language"]);
    if (r != null && r.includes(Ui.Language)) return null;
    const o = u => {
        const f = u.target.value;
        i("language", f), t.changeLanguage(f)
      },
      a = Object.keys(t.store.data).sort();
    if (a.length <= 1) return null;
    const c = a.includes(s || t.resolvedLanguage || "") ? s || t.resolvedLanguage : (n == null ? void 0 : n.default) || ((l = n == null ? void 0 : n.allow) == null ? void 0 : l[0]);
    return C.jsxs(Oi, {
      mb: 2,
      children: [C.jsx(Ma, {
        children: e("language.title")
      }), C.jsx(Sh, {
        fullWidth: !0,
        children: C.jsx(yI, {
          MenuProps: {
            elevation: 2
          },
          value: c,
          onChange: o,
          IconComponent: wE,
          dense: !0,
          children: a.map(u => C.jsx(Vf, {
            value: u,
            children: e("language.name", {
              lng: u
            })
          }, u))
        })
      })]
    })
  },
  iXe = me(Pe)(({
    theme: e
  }) => ({
    background: j3(e.palette.mode, "4%"),
    borderRadius: "16px",
    padding: "16px",
    svg: {
      fill: j3(e.palette.mode, "40%")
    }
  })),
  sXe = Bd(C.jsx("path", {
    d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2m0 15c-.55 0-1-.45-1-1v-4c0-.55.45-1 1-1s1 .45 1 1v4c0 .55-.45 1-1 1m1-8h-2V7h2z"
  }), "InfoRounded"),
  oXe = () => {
    var _, p;
    const [e, t, n, r, i] = po(v => [v.enabledBridges, v.enabledExchanges, v.routePriority, v.slippage, v.gasPrice], El), {
      t: s
    } = ft(), {
      tools: o
    } = Lk(), a = Wt(), c = po(v => v.reset), [l, u] = j.useState(!1), f = j.useCallback(() => {
      u(v => !v)
    }, []), h = () => {
      o && (c(a, o.bridges.map(v => v.key), o.exchanges.map(v => v.key)), Rq(a)), f()
    }, g = a.slippage ? Number(r) !== a.slippage * 100 : r !== ga.slippage, y = a.routePriority ? n !== a.routePriority : n !== ga.routePriority, x = i !== ga.gasPrice;
    return ((_ = o == null ? void 0 : o.bridges) == null ? void 0 : _.length) !== (e == null ? void 0 : e.length) || ((p = o == null ? void 0 : o.exchanges) == null ? void 0 : p.length) !== (t == null ? void 0 : t.length) || g || y || x ? C.jsx(Pe, {
      px: 3,
      mt: 1.5,
      mb: 1,
      children: C.jsxs(iXe, {
        children: [C.jsxs(Pe, {
          display: "flex",
          marginBottom: "12px",
          children: [C.jsx(sXe, {
            sx: {
              marginRight: "8px"
            }
          }), C.jsx(Pe, {
            fontSize: 14,
            children: s("settings.resetSettings")
          })]
        }), C.jsx(ur, {
          onClick: f,
          fullWidth: !0,
          children: s("button.resetSettings")
        }), C.jsxs(Dy, {
          open: l,
          onClose: f,
          children: [C.jsx(D5, {
            children: s("warning.title.resetSettings")
          }), C.jsx(q2, {
            children: C.jsx(G2, {
              children: s("warning.message.resetSettings")
            })
          }), C.jsxs(W2, {
            children: [C.jsx(ur, {
              onClick: f,
              children: s("button.cancel")
            }), C.jsx(ur, {
              variant: "contained",
              onClick: h,
              autoFocus: !0,
              children: s("button.reset")
            })]
          })]
        })]
      })
    }) : null
  },
  aXe = () => {
    const {
      t: e
    } = ft(), t = po(i => i.setValue), {
      routePriority: n
    } = kc(["routePriority"]), r = n ?? "";
    return C.jsxs(Oi, {
      children: [C.jsx(Ma, {
        children: e("settings.routePriority")
      }), C.jsx(Sh, {
        fullWidth: !0,
        children: C.jsx(yI, {
          MenuProps: {
            elevation: 2
          },
          value: r,
          onChange: i => t("routePriority", i.target.value),
          IconComponent: wE,
          dense: !0,
          children: kSe.map(i => {
            const s = e(`main.tags.${i.toLowerCase()}`),
              o = `${s[0]}${s.slice(1).toLowerCase()}`;
            return C.jsx(Vf, {
              value: i,
              children: o
            }, i)
          })
        })
      })]
    })
  },
  cXe = () => {
    const {
      t: e
    } = ft(), {
      hiddenUI: t
    } = Wt(), n = z3(o => o.setSendToWallet), r = po(o => o.setValue), {
      showDestinationWallet: i
    } = kc(["showDestinationWallet"]);
    if (t != null && t.includes(Ui.ToAddress)) return null;
    const s = (o, a) => {
      r("showDestinationWallet", a), n(!1)
    };
    return C.jsx(Pe, {
      px: 3,
      pt: 2,
      pb: 1.5,
      children: C.jsxs(Pe, {
        sx: {
          display: "flex",
          justifyContent: "space-between",
          alignItems: "center"
        },
        children: [C.jsx(Pe, {
          sx: {
            display: "flex",
            alignItems: "center"
          },
          children: C.jsx(Ue, {
            variant: "subtitle1",
            color: "text.primary",
            lineHeight: "normal",
            children: e("settings.showDestinationWallet")
          })
        }), C.jsx(U_, {
          checked: i,
          onChange: s
        })]
      })
    })
  },
  lXe = () => {
    const {
      t: e
    } = ft(), {
      slippage: t
    } = kc(["slippage"]), n = po(a => a.setValue), r = j.useRef(t), i = a => {
      const {
        value: c
      } = a.target;
      n("slippage", e$(c, r.current, !0))
    }, s = a => {
      const {
        value: c
      } = a.target;
      n("slippage", e$(c, r.current))
    }, o = t ?? "";
    return C.jsxs(Oi, {
      children: [C.jsx(Ma, {
        children: e("settings.slippage")
      }), C.jsx(Sh, {
        fullWidth: !0,
        children: C.jsx(sX, {
          size: "small",
          placeholder: e("settings.slippage"),
          endAdornment: C.jsx(YT, {
            position: "end",
            children: "%"
          }),
          autoComplete: "off",
          inputProps: {
            inputMode: "decimal"
          },
          onChange: i,
          onBlur: s,
          value: o
        })
      })]
    })
  },
  uXe = () => C.jsxs(yo, {
    disableGutters: !0,
    children: [C.jsxs(Pe, {
      px: 3,
      pt: 1,
      children: [C.jsx(KJe, {}), C.jsx(rXe, {}), C.jsx(aXe, {}), C.jsxs(Pe, {
        sx: {
          display: "flex",
          alignItems: "center"
        },
        mt: 2,
        children: [C.jsx(Pe, {
          pr: 2,
          flex: 1,
          children: C.jsx(lXe, {})
        }), C.jsx(nXe, {})]
      })]
    }), C.jsx(cXe, {}), C.jsxs(Pe, {
      px: 1.5,
      children: [C.jsx(rF, {
        type: "Bridges"
      }), C.jsx(rF, {
        type: "Exchanges"
      })]
    }), C.jsx(oXe, {})]
  });
var vI = {},
  dXe = Zt;
Object.defineProperty(vI, "__esModule", {
  value: !0
});
var bI = vI.default = void 0,
  fXe = dXe(an()),
  hXe = C;
bI = vI.default = (0, fXe.default)((0, hXe.jsx)("path", {
  d: "M15 20H5V7c0-.55-.45-1-1-1s-1 .45-1 1v13c0 1.1.9 2 2 2h10c.55 0 1-.45 1-1s-.45-1-1-1m5-4V4c0-1.1-.9-2-2-2H9c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h9c1.1 0 2-.9 2-2m-2 0H9V4h9z"
}), "ContentCopyRounded");
const uX = ({
    status: e,
    feeAmountUsd: t,
    insuredAmount: n,
    insuredTokenSymbol: r,
    insuranceCoverageId: i,
    onChange: s,
    ...o
  }) => {
    const {
      t: a
    } = ft(), [c, l] = j.useState(!1), [u, f] = j.useState(e === ot.Idle), h = y => {
      y.stopPropagation(), f(x => !x)
    }, g = (y, x) => {
      l(x), s == null || s(x)
    };
    return C.jsxs(Oi, {
      selectionColor: "secondary",
      indented: !0,
      ...o,
      children: [C.jsxs(Pe, {
        display: "flex",
        alignItems: "center",
        justifyContent: "space-between",
        children: [C.jsxs(f9, {
          type: "insurance",
          children: [C.jsx(G_, {
            fontSize: "inherit"
          }), C.jsx(h9, {
            type: "icon",
            children: e === ot.Idle ? a("main.tags.insurance") : a("main.tags.insured")
          })]
        }), e === ot.Idle ? C.jsx(U_, {
          onChange: g,
          value: c
        }) : C.jsx(Pe, {
          my: -.5,
          children: C.jsx($_, {
            onClick: h,
            size: "small",
            children: u ? C.jsx(bE, {}) : C.jsx(My, {})
          })
        })]
      }), C.jsx(fo, {
        timeout: 225,
        in: u,
        mountOnEnter: !0,
        unmountOnExit: !0,
        children: C.jsxs(Pe, {
          mt: 2,
          children: [C.jsxs(Pe, {
            display: "flex",
            alignItems: "center",
            justifyContent: "space-between",
            mb: 2,
            children: [C.jsx(Ue, {
              fontSize: 24,
              fontWeight: 700,
              lineHeight: 1,
              children: a("format.currency", {
                value: t
              })
            }), C.jsx(DQe, {})]
          }), C.jsxs(Pe, {
            children: [C.jsx(Ue, {
              fontSize: 14,
              children: C.jsx(tk, {
                i18nKey: e === ot.Idle ? "insurance.insure" : "insurance.insured",
                values: {
                  amount: n,
                  tokenSymbol: r
                },
                components: [C.jsx("strong", {})]
              })
            }), C.jsx(fo, {
              timeout: 225,
              in: c || e !== ot.Idle,
              mountOnEnter: !0,
              unmountOnExit: !0,
              children: C.jsxs(Pe, {
                sx: {
                  listStyleType: "disc",
                  pl: 2
                },
                children: [C.jsx(Ue, {
                  fontSize: 14,
                  display: "list-item",
                  children: a("insurance.bridgeExploits")
                }), C.jsx(Ue, {
                  fontSize: 14,
                  display: "list-item",
                  children: a("insurance.slippageError")
                })]
              })
            }), C.jsx(K2, {
              href: e === ot.Idle ? "https://docs.insurace.io/landing-page/documentation/cover-products/bridge-cover/li.fi" : `https://app.insurace.io/bridge-cover?search=${i}`,
              target: "_blank",
              underline: "none",
              color: "text.primary",
              children: C.jsx(Ue, {
                pt: .5,
                color: "primary",
                fontSize: 14,
                fontWeight: 600,
                children: e === ot.Idle ? a("button.learnMore") : a("button.viewCoverage")
              })
            })]
          })]
        })
      })]
    })
  },
  pXe = ({
    status: e,
    insurableRouteId: t,
    onChange: n,
    ...r
  }) => {
    const i = r6(),
      s = gl(l => l.routes[t]),
      {
        routes: o
      } = Ih({
        insurableRoute: s == null ? void 0 : s.route
      }),
      a = o == null ? void 0 : o[0],
      c = l => {
        a && (l && i(a, t), n == null || n(l ? a.id : t))
      };
    return a ? C.jsx(fo, {
      timeout: 225,
      in: a.insurance.state === "INSURED",
      unmountOnExit: !0,
      mountOnEnter: !0,
      appear: e === ot.Idle,
      children: C.jsx(uX, {
        ...r,
        status: e,
        insuredAmount: Ei(a.toAmountMin, a.toToken.decimals),
        insuredTokenSymbol: a.toToken.symbol,
        onChange: c
      })
    }) : null
  },
  dX = ({
    status: e,
    insurableRouteId: t,
    onChange: n,
    ...r
  }) => e === ot.Idle ? C.jsx(pXe, {
    status: e,
    insurableRouteId: t,
    onChange: n,
    ...r
  }) : C.jsx(uX, {
    status: e,
    ...r
  });
var wI = {},
  mXe = Zt;
Object.defineProperty(wI, "__esModule", {
  value: !0
});
var xI = wI.default = void 0,
  gXe = mXe(an()),
  yXe = C;
xI = wI.default = (0, gXe.default)((0, yXe.jsx)("path", {
  d: "M17 7h-3c-.55 0-1 .45-1 1s.45 1 1 1h3c1.65 0 3 1.35 3 3s-1.35 3-3 3h-3c-.55 0-1 .45-1 1s.45 1 1 1h3c2.76 0 5-2.24 5-5s-2.24-5-5-5m-9 5c0 .55.45 1 1 1h6c.55 0 1-.45 1-1s-.45-1-1-1H9c-.55 0-1 .45-1 1m2 3H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h3c.55 0 1-.45 1-1s-.45-1-1-1H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h3c.55 0 1-.45 1-1s-.45-1-1-1"
}), "LinkRounded");
const iF = (e, t, n) => {
    switch (t) {
      case "ACTION_REQUIRED":
        return Vt(e.palette.info.main, .12);
      case "DONE":
        return n === "PARTIAL" || n === "REFUNDED" ? Vt(e.palette.warning.main, .48) : Vt(e.palette.success.main, .12);
      case "FAILED":
        return Vt(e.palette.error.main, .12);
      default:
        return e.palette.grey[e.palette.mode === "light" ? 300 : 800]
    }
  },
  EI = me(Pe, {
    shouldForwardProp: e => !["status", "substatus"].includes(e)
  })(({
    theme: e,
    status: t,
    substatus: n
  }) => ({
    backgroundColor: ["ACTION_REQUIRED", "DONE", "FAILED"].includes(t) ? iF(e, t, n) : e.palette.background.paper,
    borderStyle: "solid",
    borderColor: iF(e, t, n),
    borderWidth: ["ACTION_REQUIRED", "DONE", "FAILED"].includes(t) ? 0 : 2,
    display: "grid",
    position: "relative",
    placeItems: "center",
    width: 32,
    height: 32,
    borderRadius: "50%"
  })),
  vXe = yl `
  0% {
    stroke-dashoffset: 129;
    transform: rotate(0);
  }
  50% {
    stroke-dashoffset: 56;
    transform: rotate(45deg);
  };
  100% {
    stroke-dashoffset: 129;
    transform: rotate(360deg);
  }
`,
  bXe = me(u3)
`
  color: ${({theme:e})=>e.palette.mode==="light"?e.palette.primary.main:e.palette.primary.light};
  animation-duration: 3s;
  position: absolute;
  left: -2px;
  .${rge.circle} {
    animation-duration: 2s;
    animation-timing-function: linear;
    animation-name: ${vXe};
    stroke-dasharray: 129;
    stroke-dashoffset: 129;
    stroke-linecap: round;
    transform-origin: 100% 100%;
  }
`, fX = me(_s)(({
  theme: e
}) => ({
  padding: e.spacing(.5)
})), wXe = ({
  step: e,
  toAddress: t,
  toAddressLink: n
}) => {
  var s;
  const {
    t: r
  } = ft(), i = ((s = e.execution) == null ? void 0 : s.status) === "DONE";
  return C.jsx(Pe, {
    px: 2,
    py: 1,
    children: C.jsxs(Pe, {
      sx: {
        display: "flex",
        alignItems: "center"
      },
      children: [C.jsx(EI, {
        status: i ? "DONE" : "NOT_STARTED",
        children: C.jsx(T2, {
          color: i ? "success" : "inherit",
          sx: {
            position: "absolute",
            fontSize: "1rem"
          }
        })
      }), C.jsx(Ue, {
        mx: 2,
        flex: 1,
        fontSize: 14,
        fontWeight: 400,
        children: i ? r("main.sentToAddress", {
          address: t
        }) : r("main.sendToAddress", {
          address: t
        })
      }), C.jsx(fX, {
        size: "small",
        edge: "end",
        LinkComponent: K2,
        href: n,
        target: "_blank",
        rel: "nofollow noreferrer",
        children: C.jsx(xI, {})
      })]
    })
  })
}, xXe = ({
  step: e
}) => {
  var r, i, s;
  const {
    t
  } = ft(), n = ((r = e.execution) == null ? void 0 : r.status) === "DONE";
  return C.jsx(Pe, {
    px: 2,
    py: 1,
    children: C.jsxs(Pe, {
      sx: {
        display: "flex",
        alignItems: "center"
      },
      children: [C.jsx(EI, {
        status: n ? "DONE" : "NOT_STARTED",
        children: C.jsx(Ny, {
          color: n ? "success" : "inherit",
          sx: {
            position: "absolute",
            fontSize: "1rem"
          }
        })
      }), C.jsxs(Ue, {
        ml: 2,
        flex: 1,
        fontSize: 14,
        fontWeight: 400,
        children: [t("format.currency", {
          value: (((i = e.execution) == null ? void 0 : i.gasAmountUSD) || ((s = e.estimate.gasCosts) == null ? void 0 : s.reduce((o, a) => o + parseFloat(a.amountUSD || "0"), 0))) ?? 0
        }), " ", t(n ? "main.gasFeePaid" : "main.gasFeeEstimated")]
      })]
    })
  })
};
var SI = {},
  EXe = Zt;
Object.defineProperty(SI, "__esModule", {
  value: !0
});
var CI = SI.default = void 0,
  SXe = EXe(an()),
  CXe = C;
CI = SI.default = (0, SXe.default)((0, CXe.jsx)("path", {
  d: "M9 16.2 4.8 12l-1.4 1.4L9 19 21 7l-1.4-1.4z"
}), "Done");

function AXe({
  process: e
}) {
  return C.jsxs(EI, {
    status: e.status,
    substatus: e.substatus,
    children: [e.status === "STARTED" || e.status === "PENDING" ? C.jsx(bXe, {
      size: 32,
      thickness: 3
    }) : null, e.status === "ACTION_REQUIRED" ? C.jsx(yE, {
      color: "info",
      sx: {
        position: "absolute",
        fontSize: "1rem"
      }
    }) : null, e.status === "DONE" && (e.substatus === "PARTIAL" || e.substatus === "REFUNDED") ? C.jsx(Gm, {
      sx: t => ({
        position: "absolute",
        fontSize: "1rem",
        color: lu(t.palette.warning.main, .32)
      })
    }) : e.status === "DONE" ? C.jsx(CI, {
      color: "success",
      sx: {
        position: "absolute",
        fontSize: "1rem"
      }
    }) : null, e.status === "FAILED" ? C.jsx(gE, {
      color: "error",
      sx: {
        position: "absolute",
        fontSize: "1rem"
      }
    }) : null]
  })
}
const TXe = ({
    step: e,
    process: t
  }) => {
    const {
      title: n,
      message: r
    } = xq(e, t);
    return C.jsxs(Pe, {
      px: 2,
      py: 1,
      children: [C.jsxs(Pe, {
        sx: {
          display: "flex",
          alignItems: "center"
        },
        children: [C.jsx(AXe, {
          process: t
        }), C.jsx(Ue, {
          mx: 2,
          flex: 1,
          fontSize: 14,
          fontWeight: t.error ? 600 : 400,
          children: n
        }), t.txLink ? C.jsx(fX, {
          size: "small",
          edge: "end",
          LinkComponent: K2,
          href: t.txLink,
          target: "_blank",
          rel: "nofollow noreferrer",
          children: C.jsx(xI, {})
        }) : null]
      }), r ? C.jsx(Ue, {
        ml: 6,
        fontSize: 14,
        fontWeight: 500,
        color: "text.secondary",
        children: r
      }) : null]
    })
  },
  kXe = ({
    step: e,
    fromToken: t,
    toToken: n,
    toAddress: r
  }) => {
    var f, h, g;
    const {
      t: i
    } = ft(), {
      getChainById: s
    } = vo(), {
      subvariant: o
    } = Wt(), a = (f = e.execution) == null ? void 0 : f.process.some(y => y.status === "FAILED"), c = () => {
      switch (e.type) {
        case "lifi":
          const y = e.includedSteps.some(k => k.type === "cross"),
            x = e.includedSteps.some(k => k.type === "swap");
          return i(y && x ? o === "nft" ? "main.stepBridgeAndBuy" : "main.stepSwapAndBridge" : y ? o === "nft" ? "main.stepBridgeAndBuy" : "main.stepBridge" : o === "nft" ? "main.stepSwapAndBuy" : "main.stepSwap");
        default:
          return i(o === "nft" ? "main.stepSwapAndBuy" : "main.stepSwap")
      }
    }, l = pp(r), u = r ? `${(h=s(e.action.toChainId))==null?void 0:h.metamask.blockExplorerUrls[0]}address/${r}` : void 0;
    return C.jsxs(Oi, {
      variant: a ? "error" : "default",
      children: [C.jsxs(Pe, {
        sx: {
          display: "flex",
          flex: 1
        },
        children: [C.jsx(Ma, {
          flex: 1,
          children: c()
        }), C.jsx(Ma, {
          sx: {
            fontWeight: 500
          },
          children: C.jsx(IJ, {
            step: e
          })
        })]
      }), C.jsxs(Pe, {
        py: 1,
        children: [t ? C.jsx(om, {
          token: t,
          px: 2,
          py: 1
        }) : null, C.jsx(jJ, {
          step: e,
          px: 2,
          py: 1,
          dense: !0
        }), (g = e.execution) == null ? void 0 : g.process.map((y, x) => C.jsx(TXe, {
          step: e,
          process: y
        }, x)), C.jsx(xXe, {
          step: e
        }), l && u ? C.jsx(wXe, {
          step: e,
          toAddress: l,
          toAddressLink: u
        }) : null, n ? C.jsx(om, {
          token: n,
          px: 2,
          py: 1
        }) : null]
      })]
    })
  },
  _Xe = me(yo)(({
    theme: e
  }) => ({
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    height: e.spacing(2)
  })),
  IXe = () => C.jsx(_Xe, {
    children: C.jsx(c1e, {
      orientation: "vertical",
      flexItem: !0
    })
  }),
  hX = (e, t) => e == null ? void 0 : e.steps.map((n, r, i) => {
    var l, u, f;
    const s = i.length - 1,
      o = r === 0 ? {
        ...n.action.fromToken,
        amount: n.action.fromAmount
      } : void 0,
      a = r === s ? {
        ...((l = n.execution) == null ? void 0 : l.toToken) ?? ((u = n.action) == null ? void 0 : u.toToken),
        amount : (f = n.execution) != null && f.toAmount ? n.execution.toAmount : t === "nft" ? e.toAmount : n.estimate.toAmount
      } : void 0,
      c = r === s && e.fromAddress !== e.toAddress ? e.toAddress : void 0;
    return C.jsxs(j.Fragment, {
      children: [C.jsx(kXe, {
        step: n,
        fromToken: o,
        toToken: a,
        toAddress: c
      }), i.length > 1 && r !== i.length - 1 ? C.jsx(IXe, {}) : null]
    }, n.id)
  }),
  PXe = ({
    supportId: e
  }) => {
    const {
      t
    } = ft(), n = Pm(), r = () => {
      n.all.has(Cs.RouteContactSupport) ? n.emit(Cs.RouteContactSupport, {
        supportId: e
      }) : window.open("https://discord.gg/lifi", "_blank", "nofollow noreferrer")
    };
    return C.jsx(ur, {
      onClick: r,
      fullWidth: !0,
      children: t("button.contactSupport")
    })
  },
  RXe = me(yo)(({
    theme: e
  }) => ({
    padding: e.spacing(1, 3)
  })),
  OXe = () => {
    var v, S, I, A, w;
    const {
      t: e,
      i18n: t
    } = ft(), {
      navigateBack: n
    } = Ud(), {
      subvariant: r,
      contractComponent: i,
      contractSecondaryComponent: s
    } = Wt(), {
      state: o
    } = yu(), [a, c] = gl(E => [E.routes[o == null ? void 0 : o.routeId], E.deleteRoute], El), l = Om(), [u, f] = j.useState(!1), h = j.useCallback(() => {
      f(E => !E)
    }, []), g = () => {
      n(), a && c(a.route.id)
    }, y = (S = (v = a == null ? void 0 : a.route.steps[0].execution) == null ? void 0 : v.process.filter(E => E.type !== "TOKEN_ALLOWANCE").find(E => E.txHash)) == null ? void 0 : S.txHash, x = y ?? (a == null ? void 0 : a.route.fromAddress);
    let k = y ?? (a == null ? void 0 : a.route.id) ?? "";
    const _ = async () => {
      await navigator.clipboard.writeText(k)
    };
    j.useEffect(() => l.getState().setAction(C.jsx(_s, {
      size: "medium",
      edge: "end",
      onClick: h,
      children: C.jsx(mE, {})
    })), [l, h]);
    const p = new Date(((I = a == null ? void 0 : a.route.steps[0].execution) == null ? void 0 : I.process[0].startedAt) ?? 0);
    return C.jsxs(RXe, {
      children: [C.jsxs(Pe, {
        sx: {
          display: "flex",
          flex: 1,
          justifyContent: "space-between"
        },
        pb: 1,
        children: [C.jsx(Ue, {
          fontSize: 12,
          children: new Intl.DateTimeFormat(t.language, {
            dateStyle: "long"
          }).format(p)
        }), C.jsx(Ue, {
          fontSize: 12,
          children: new Intl.DateTimeFormat(t.language, {
            timeStyle: "short"
          }).format(p)
        })]
      }), hX(a == null ? void 0 : a.route, r), r === "nft" ? C.jsx(F_, {
        mt: 2,
        children: s || i
      }) : null, ((w = (A = a == null ? void 0 : a.route) == null ? void 0 : A.insurance) == null ? void 0 : w.state) === "INSURED" ? C.jsx(dX, {
        mt: 2,
        status: a.status,
        feeAmountUsd: a.route.insurance.feeAmountUsd,
        insuredAmount: Ei(a.route.toAmountMin, a.route.toToken.decimals),
        insuredTokenSymbol: a.route.toToken.symbol,
        insurableRouteId: a.route.id,
        insuranceCoverageId: x
      }) : null, C.jsxs(Oi, {
        mt: 2,
        children: [C.jsxs(Pe, {
          sx: {
            display: "flex",
            flex: 1
          },
          children: [C.jsx(Ma, {
            flex: 1,
            children: e("main.supportId")
          }), C.jsx(Pe, {
            mr: 1,
            mt: 1,
            children: C.jsx(_s, {
              size: "medium",
              onClick: _,
              children: C.jsx(bI, {
                fontSize: "small"
              })
            })
          })]
        }), C.jsx(Ue, {
          variant: "body2",
          pt: 1,
          pb: 2,
          px: 2,
          sx: {
            wordBreak: "break-all"
          },
          children: k
        })]
      }), C.jsx(Pe, {
        mt: 2,
        children: C.jsx(PXe, {
          supportId: k
        })
      }), C.jsxs(Dy, {
        open: u,
        onClose: h,
        children: [C.jsx(D5, {
          children: e("warning.title.deleteTransaction")
        }), C.jsx(q2, {
          children: C.jsx(G2, {
            children: e("warning.message.deleteTransactionHistory")
          })
        }), C.jsxs(W2, {
          children: [C.jsx(ur, {
            onClick: h,
            children: e("button.cancel")
          }), C.jsx(ur, {
            variant: "contained",
            onClick: g,
            autoFocus: !0,
            children: e("button.delete")
          })]
        })]
      })]
    })
  };
var AI = {},
  DXe = Zt;
Object.defineProperty(AI, "__esModule", {
  value: !0
});
var pX = AI.default = void 0,
  NXe = DXe(an()),
  Kb = C;
pX = AI.default = (0, NXe.default)([(0, Kb.jsx)("path", {
  d: "M14 9h-4c-.55 0-1-.45-1-1s.45-1 1-1h4c.55 0 1 .45 1 1s-.45 1-1 1m0 3h-4c-.55 0-1-.45-1-1s.45-1 1-1h4c.55 0 1 .45 1 1s-.45 1-1 1"
}, "0"), (0, Kb.jsx)("path", {
  d: "M19.5 3.5 18 2l-1.5 1.5L15 2l-1.5 1.5L12 2l-1.5 1.5L9 2 7.5 3.5 6 2v14H4c-.55 0-1 .45-1 1v2c0 1.66 1.34 3 3 3h12c1.66 0 3-1.34 3-3V2zM15 20H6c-.55 0-1-.45-1-1v-1h10zm4-1c0 .55-.45 1-1 1s-1-.45-1-1v-2c0-.55-.45-1-1-1H8V5h11z"
}, "1"), (0, Kb.jsx)("circle", {
  cx: "17",
  cy: "8",
  r: "1"
}, "2"), (0, Kb.jsx)("circle", {
  cx: "17",
  cy: "11",
  r: "1"
}, "3")], "ReceiptLongRounded");
const sF = () => {
    const {
      t: e
    } = ft();
    return C.jsxs(yo, {
      sx: {
        display: "flex",
        flex: 1,
        flexDirection: "column",
        alignItems: "center",
        justifyContent: "center",
        paddingY: 12
      },
      children: [C.jsx(Ue, {
        fontSize: 48,
        children: C.jsx(pX, {
          fontSize: "inherit"
        })
      }), C.jsx(Ue, {
        fontSize: 18,
        fontWeight: 700,
        children: e("info.title.emptyTransactionHistory")
      }), C.jsx(Ue, {
        fontSize: 14,
        color: "text.secondary",
        textAlign: "center",
        mt: 2,
        children: e("info.message.emptyTransactionHistory")
      })]
    })
  },
  MXe = ({
    route: e
  }) => {
    var a, c, l, u, f;
    const {
      i18n: t
    } = ft(), n = Ba(), r = () => {
      n(Je.transactionDetails, {
        state: {
          routeId: e.id
        }
      })
    }, i = new Date(((a = e.steps[0].execution) == null ? void 0 : a.process[0].startedAt) ?? 0), s = {
      ...e.fromToken,
      amount: e.fromAmount
    }, o = {
      ...((l = (c = e.steps.at(-1)) == null ? void 0 : c.execution) == null ? void 0 : l.toToken) ?? e.toToken,
      amount : ((f = (u = e.steps.at(-1)) == null ? void 0 : u.execution) == null ? void 0 : f.toAmount) ?? e.toAmount
    };
    return C.jsxs(Oi, {
      onClick: r,
      children: [C.jsxs(Pe, {
        sx: {
          display: "flex",
          flex: 1,
          justifyContent: "space-between"
        },
        pt: 1.75,
        px: 2,
        children: [C.jsx(Ue, {
          fontSize: 12,
          children: new Intl.DateTimeFormat(t.language, {
            dateStyle: "long"
          }).format(i)
        }), C.jsx(Ue, {
          fontSize: 12,
          children: new Intl.DateTimeFormat(t.language, {
            timeStyle: "short"
          }).format(i)
        })]
      }), C.jsxs(Pe, {
        py: 1,
        children: [C.jsx(om, {
          token: s,
          px: 2,
          pt: 1,
          connected: !0
        }), C.jsx(QQe, {}), C.jsx(om, {
          token: o,
          px: 2,
          pt: .5,
          pb: 1
        })]
      })]
    })
  },
  $Xe = () => {
    const {
      t: e
    } = ft(), {
      account: t
    } = Ri(), n = tAe(t.address), r = Om(), i = gl(c => c.deleteRoutes), [s, o] = j.useState(!1), a = j.useCallback(() => {
      o(c => !c)
    }, []);
    return j.useEffect(() => {
      if (n.length) return r.getState().setAction(C.jsx(_s, {
        size: "medium",
        edge: "end",
        onClick: a,
        children: C.jsx(mE, {})
      }))
    }, [n.length, a, r]), n.length ? C.jsxs(yo, {
      children: [C.jsx(N5, {
        spacing: 2,
        mt: 1,
        children: n.length ? n.map(({
          route: c
        }) => C.jsx(MXe, {
          route: c
        }, c.id)) : C.jsx(sF, {})
      }), C.jsxs(Dy, {
        open: s,
        onClose: a,
        children: [C.jsx(D5, {
          children: e("warning.title.deleteTransactionHistory")
        }), C.jsx(q2, {
          children: C.jsx(G2, {
            children: e("warning.message.deleteTransactionHistory")
          })
        }), C.jsxs(W2, {
          children: [C.jsx(ur, {
            onClick: a,
            children: e("button.cancel")
          }), C.jsx(ur, {
            variant: "contained",
            onClick: () => i("completed"),
            autoFocus: !0,
            children: e("button.delete")
          })]
        })]
      })]
    }) : C.jsx(sF, {})
  };
var TI = {},
  LXe = Zt;
Object.defineProperty(TI, "__esModule", {
  value: !0
});
var mX = TI.default = void 0,
  BXe = LXe(an()),
  FXe = C;
mX = TI.default = (0, BXe.default)((0, FXe.jsx)("path", {
  d: "M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6zM19 4h-3.5l-1-1h-5l-1 1H5v2h14z"
}), "Delete");
const kI = j.forwardRef(({
    elementRef: e,
    children: t,
    open: n,
    onClose: r
  }, i) => {
    const s = uq(),
      o = j.useRef(n),
      [a, c] = j.useState(n),
      l = j.useCallback(() => {
        c(!1), o.current = !1, r == null || r()
      }, [r]);
    return j.useImperativeHandle(i, () => ({
      isOpen: () => o.current,
      open: () => {
        c(!0), o.current = !0
      },
      close: l
    }), [l]), C.jsx(uH, {
      container: s,
      ref: e,
      anchor: "bottom",
      open: a,
      onClose: l,
      ModalProps: DJ,
      PaperProps: NJ,
      BackdropProps: MJ,
      disableAutoFocus: !0,
      children: t
    })
  }),
  jXe = (e, t) => {
    switch (e) {
      case ot.Done:
        return {
          color: t.palette.success.main, alpha: .12, darken: 0
        };
      case ot.Failed:
        return {
          color: t.palette.error.main, alpha: .12, darken: 0
        };
      case ot.Done | ot.Partial:
      case ot.Done | ot.Refunded:
      case "warning":
        return {
          color: t.palette.warning.main, alpha: .48, darken: t.palette.mode === "light" ? .32 : 0
        };
      default:
        return {
          color: t.palette.primary.main, alpha: .12, darken: 0
        }
    }
  },
  P1 = me(Pe)(({
    theme: e
  }) => ({
    display: "grid",
    placeItems: "center",
    position: "relative"
  })),
  _I = me(Pe, {
    shouldForwardProp: e => e !== "status"
  })(({
    theme: e,
    status: t
  }) => {
    const {
      color: n,
      alpha: r,
      darken: i
    } = jXe(t, e);
    return {
      backgroundColor: Vt(n, r),
      borderRadius: "50%",
      width: 64,
      height: 64,
      display: "grid",
      position: "relative",
      placeItems: "center",
      "& > svg": {
        color: lu(n, i),
        width: 32,
        height: 32
      }
    }
  }),
  UXe = j.forwardRef(({
    onContinue: e,
    onCancel: t
  }, n) => {
    const [r, i] = j.useState(), s = j.useRef(null), o = j.useRef(), a = () => {
      var u;
      (u = n.current) == null || u.close(!0), e == null || e()
    }, c = j.useCallback(() => {
      var u;
      (u = n.current) == null || u.close(!1), t == null || t()
    }, [t, n]), l = j.useCallback(() => {
      var u;
      (u = n.current) == null || u.close(!1, !1), t == null || t()
    }, [t, n]);
    return j.useImperativeHandle(n, () => ({
      isOpen: () => {
        var u;
        return (u = s.current) == null ? void 0 : u.isOpen()
      },
      open: (u, f) => {
        var h;
        i(f), o.current = u, (h = s.current) == null || h.open()
      },
      close: (u = !1, f = !0) => {
        var h, g;
        (h = o.current) == null || h.call(o, u), f && ((g = s.current) == null || g.close())
      }
    }), []), C.jsx(kI, {
      ref: s,
      onClose: l,
      children: C.jsx(zXe, {
        data: r,
        onContinue: a,
        onCancel: c
      })
    })
  }),
  zXe = ({
    data: e,
    onCancel: t,
    onContinue: n
  }) => {
    const {
      t: r
    } = ft(), i = j.useRef();
    dq(i);
    const s = Dn((e == null ? void 0 : e.oldToAmount) || 1);
    return C.jsxs(Pe, {
      p: 3,
      ref: i,
      children: [C.jsxs(P1, {
        children: [C.jsx(_I, {
          status: "warning",
          mb: 1,
          children: C.jsx(Gm, {
            color: "warning"
          })
        }), C.jsx(Ue, {
          py: 1,
          fontSize: 18,
          fontWeight: 700,
          children: r("warning.title.rateChanged")
        })]
      }), C.jsx(Ue, {
        py: 1,
        children: r("warning.message.rateChanged")
      }), C.jsxs(Pe, {
        display: "flex",
        justifyContent: "space-between",
        mt: 1,
        children: [C.jsx(Ue, {
          children: r("main.quotedAmount")
        }), C.jsxs(Ue, {
          fontWeight: 600,
          children: [r("format.number", {
            value: Ei(e == null ? void 0 : e.oldToAmount, e == null ? void 0 : e.toToken.decimals, 5)
          }), " ", e == null ? void 0 : e.toToken.symbol]
        })]
      }), C.jsxs(Pe, {
        display: "flex",
        justifyContent: "space-between",
        mt: .25,
        children: [C.jsx(Ue, {
          children: r("main.currentAmount")
        }), C.jsxs(Ue, {
          fontWeight: 600,
          children: [r("format.number", {
            value: Ei(e == null ? void 0 : e.newToAmount, e == null ? void 0 : e.toToken.decimals, 5)
          }), " ", e == null ? void 0 : e.toToken.symbol]
        })]
      }), C.jsxs(Pe, {
        display: "flex",
        justifyContent: "space-between",
        mt: .25,
        children: [C.jsx(Ue, {
          children: r("main.rateChange")
        }), C.jsxs(Ue, {
          fontWeight: 600,
          children: [Dn((e == null ? void 0 : e.newToAmount) || 0).div(s.eq(0) ? Dn(1) : s).minus(1).mul(100).round(2, Dn.roundUp).toString(), "%"]
        })]
      }), C.jsxs(Pe, {
        display: "flex",
        mt: 3,
        children: [C.jsx(ur, {
          variant: "text",
          onClick: t,
          fullWidth: !0,
          children: r("button.cancel")
        }), C.jsx(Pe, {
          display: "flex",
          p: 1
        }), C.jsx(ur, {
          variant: "contained",
          onClick: n,
          fullWidth: !0,
          children: r("button.continue")
        })]
      })]
    })
  },
  gX = ({
    onClick: e,
    route: t,
    text: n,
    loading: r
  }) => {
    const {
      insufficientGas: i,
      isInitialLoading: s
    } = wq(t), {
      insufficientFromToken: o,
      isInitialLoading: a
    } = yq(t), c = o || !!(i != null && i.length);
    return C.jsx(KJ, {
      onClick: e,
      text: n,
      disabled: c,
      loading: a || s || r
    })
  },
  HXe = ({
    onClick: e,
    text: t,
    route: n,
    loading: r,
    disabled: i,
    insurableRouteId: s
  }) => {
    const o = gl(c => c.routes[s]),
      {
        isFetching: a
      } = Ih({
        insurableRoute: o == null ? void 0 : o.route
      });
    return C.jsx(gX, {
      onClick: e,
      text: t,
      route: n,
      disabled: i,
      loading: r || a,
      insurableRouteId: s
    })
  },
  VXe = ({
    status: e,
    route: t
  }) => {
    var G, L, b, T, R, N, O, U, q, W, M, Q, he;
    const {
      t: n
    } = ft(), {
      navigateBack: r,
      navigate: i
    } = Ud(), s = j.useRef(null), {
      getChainById: o
    } = vo(), {
      setValue: a
    } = Ls(), {
      subvariant: c,
      contractComponent: l,
      contractSecondaryComponent: u,
      contractCompactComponent: f
    } = Wt(), h = {
      ...((L = (G = t.steps.at(-1)) == null ? void 0 : G.execution) == null ? void 0 : L.toToken) ?? t.toToken,
      amount : ((T = (b = t.steps.at(-1)) == null ? void 0 : b.execution) == null ? void 0 : T.toAmount) ?? ((R = t.steps.at(-1)) == null ? void 0 : R.estimate.toAmount) ?? t.toAmount
    }, {
      token: g,
      refetch: y,
      refetchNewBalance: x,
      refetchAllBalances: k
    } = bq(h, t.toAddress), _ = () => {
      k(), a(Qe.FromAmount, ""), a(Qe.ToAmount, "")
    }, p = () => {
      _(), r()
    }, v = () => {
      _(), h.chainId !== t.toToken.chainId && h.address !== t.toToken.address && (a(Qe.FromAmount, Ei(h.amount, h.decimals), {
        shouldTouch: !0
      }), a(Qe.FromChain, h.chainId, {
        shouldTouch: !0
      }), a(Qe.FromToken, h.address, {
        shouldTouch: !0
      }), a(Qe.ToChain, t.toToken.chainId, {
        shouldTouch: !0
      }), a(Qe.ToToken, t.toToken.address, {
        shouldTouch: !0
      })), r()
    }, S = () => {
      var H;
      _(), (H = s.current) == null || H.close()
    }, I = () => {
      S(), i(Je.transactionDetails, {
        state: {
          routeId: t.id
        },
        replace: !0
      })
    }, A = t.fromChainId === t.toChainId ? "swap" : "bridge";
    let w, E, D, $ = p;
    switch (e) {
      case ot.Done: {
        w = n(c === "nft" ? "success.title.purchaseSuccessful" : `success.title.${A}Successful`), g && (E = n("success.message.exchangeSuccessful", {
          amount: Ei(g.amount),
          tokenSymbol: g.symbol,
          chainName: (N = o(g.chainId)) == null ? void 0 : N.name,
          walletAddress: pp(t.toAddress)
        })), $ = p;
        break
      }
      case ot.Done | ot.Partial: {
        w = n(`success.title.${A}PartiallySuccessful`), E = n("success.message.exchangePartiallySuccessful", {
          tool: (O = t.steps.at(-1)) == null ? void 0 : O.toolDetails.name,
          tokenSymbol: (U = t.steps.at(-1)) == null ? void 0 : U.action.toToken.symbol
        }), g && (D = n("success.message.exchangeSuccessful", {
          amount: Ei(g.amount),
          tokenSymbol: g.symbol,
          chainName: (q = o(g.chainId)) == null ? void 0 : q.name,
          walletAddress: pp(t.toAddress)
        })), $ = v;
        break
      }
      case ot.Done | ot.Refunded: {
        w = n("success.title.refundIssued"), E = n("success.message.exchangePartiallySuccessful", {
          tool: (W = t.steps.at(-1)) == null ? void 0 : W.toolDetails.name,
          tokenSymbol: (M = t.steps.at(-1)) == null ? void 0 : M.action.toToken.symbol
        }), g && (D = n("success.message.exchangeSuccessful", {
          amount: Ei(g.amount),
          tokenSymbol: g.symbol,
          chainName: (Q = o(g.chainId)) == null ? void 0 : Q.name,
          walletAddress: pp(t.toAddress)
        }));
        break
      }
      case ot.Failed: {
        const H = t.steps.find(Z => {
            var te;
            return ((te = Z.execution) == null ? void 0 : te.status) === "FAILED"
          }),
          ne = (he = H == null ? void 0 : H.execution) == null ? void 0 : he.process.find(Z => Z.status === "FAILED");
        if (!H || !ne) break;
        const X = Eq(n, o, H, ne);
        w = X.title, E = X.message, $ = S;
        break
      }
    }
    j.useEffect(() => {
      var ne, X;
      const H = ha(e, ot.Done);
      (H || ha(e, ot.Failed)) && !((ne = s.current) != null && ne.isOpen()) && (H && (x(), y()), (X = s.current) == null || X.open())
    }, [y, x, e]);
    const V = c === "nft" && ha(e, ot.Done);
    return C.jsx(kI, {
      ref: s,
      children: C.jsxs(Pe, {
        p: 3,
        children: [V ? null : C.jsx(P1, {
          children: C.jsxs(_I, {
            status: e,
            mb: 1,
            children: [e === ot.Idle ? C.jsx(yE, {
              color: "primary"
            }) : null, e === ot.Done ? C.jsx(CI, {
              color: "success"
            }) : null, ha(e, ot.Partial) || ha(e, ot.Refunded) ? C.jsx(Gm, {
              color: "warning"
            }) : null, ha(e, ot.Failed) ? C.jsx(gE, {
              color: "error"
            }) : null]
          })
        }), C.jsx(P1, {
          children: C.jsx(Ue, {
            py: 1,
            fontSize: 18,
            fontWeight: 700,
            children: w
          })
        }), V ? f || u || l : C.jsx(P1, {
          children: ha(e, ot.Done) ? C.jsx(om, {
            token: h,
            py: 1,
            disableDescription: !0
          }) : null
        }), V ? null : C.jsx(Ue, {
          py: 1,
          children: E
        }), D ? C.jsx(Ue, {
          py: 1,
          children: D
        }) : null, C.jsx(Pe, {
          mt: 2,
          children: C.jsxs(ur, {
            variant: "contained",
            fullWidth: !0,
            onClick: $,
            children: [e === ot.Idle ? n("button.ok") : null, ha(e, ot.Done) ? n("button.done") : null, e === ot.Failed ? n("button.seeDetails") : null]
          })
        }), ha(e, ot.Done) ? C.jsx(Pe, {
          mt: 2,
          children: C.jsx(ur, {
            variant: "text",
            onClick: I,
            fullWidth: !0,
            children: n("button.seeDetails")
          })
        }) : null]
      })
    })
  },
  yX = e => `${((Number(e.toAmountUSD||0)/(Number(e.fromAmountUSD||0)+Number(e.gasCostUSD||0))-1)*100).toFixed(2)}%`,
  WXe = j.forwardRef(({
    route: e,
    onContinue: t,
    onCancel: n
  }, r) => {
    const i = () => {
      var s;
      (s = r.current) == null || s.close(), n == null || n()
    };
    return C.jsx(kI, {
      ref: r,
      onClose: n,
      children: C.jsx(qXe, {
        route: e,
        onContinue: t,
        onCancel: i
      })
    })
  }),
  qXe = ({
    route: e,
    onCancel: t,
    onContinue: n
  }) => {
    const {
      t: r
    } = ft(), i = j.useRef();
    return dq(i), C.jsxs(Pe, {
      p: 3,
      ref: i,
      children: [C.jsxs(P1, {
        children: [C.jsx(_I, {
          status: "warning",
          mb: 1,
          children: C.jsx(Gm, {
            color: "warning"
          })
        }), C.jsx(Ue, {
          py: 1,
          fontSize: 18,
          fontWeight: 700,
          children: r("warning.title.highValueLoss")
        })]
      }), C.jsx(Ue, {
        py: 1,
        children: r("warning.message.highValueLoss")
      }), C.jsxs(Pe, {
        display: "flex",
        justifyContent: "space-between",
        mt: 1,
        children: [C.jsx(Ue, {
          children: r("main.sending")
        }), C.jsx(Ue, {
          fontWeight: 600,
          children: r("format.currency", {
            value: e.fromAmountUSD
          })
        })]
      }), C.jsxs(Pe, {
        display: "flex",
        justifyContent: "space-between",
        mt: .25,
        children: [C.jsx(Ue, {
          children: r("main.gasCost")
        }), C.jsx(Ue, {
          fontWeight: 600,
          children: r("format.currency", {
            value: e.gasCostUSD
          })
        })]
      }), C.jsxs(Pe, {
        display: "flex",
        justifyContent: "space-between",
        mt: .25,
        children: [C.jsx(Ue, {
          children: r("main.receiving")
        }), C.jsx(Ue, {
          fontWeight: 600,
          children: r("format.currency", {
            value: e.toAmountUSD
          })
        })]
      }), C.jsxs(Pe, {
        display: "flex",
        justifyContent: "space-between",
        mt: .25,
        children: [C.jsx(Ue, {
          children: r("main.valueLoss")
        }), C.jsx(Ue, {
          fontWeight: 600,
          children: yX(e)
        })]
      }), C.jsxs(Pe, {
        display: "flex",
        mt: 3,
        children: [C.jsx(ur, {
          variant: "text",
          onClick: t,
          fullWidth: !0,
          children: r("button.cancel")
        }), C.jsx(Pe, {
          display: "flex",
          p: 1
        }), C.jsx(ur, {
          variant: "contained",
          onClick: n,
          fullWidth: !0,
          children: r("button.continue")
        })]
      })]
    })
  },
  GXe = e => {
    if (!e) return !1;
    const t = Number(e.fromAmountUSD || 0),
      n = Number(e.toAmountUSD || 0),
      r = Number(e.gasCostUSD || 0);
    return !t && !n ? !1 : n / (t + r) < .9
  },
  KXe = me(yo)(({
    theme: e
  }) => ({
    padding: e.spacing(1, 3)
  })),
  QXe = () => {
    var T, R;
    const {
      t: e
    } = ft(), {
      setValue: t
    } = Ls(), n = Pm(), {
      navigateBack: r
    } = Ud(), {
      subvariant: i,
      insurance: s,
      contractComponent: o,
      contractSecondaryComponent: a
    } = Wt(), {
      state: c
    } = yu(), l = Om(), u = c == null ? void 0 : c.routeId, [f, h] = j.useState(u), g = j.useRef(null), y = j.useRef(null), x = (N, O) => {
      var U;
      (U = y.current) == null || U.open(N, O)
    }, {
      route: k,
      status: _,
      executeRoute: p,
      restartRoute: v,
      deleteRoute: S
    } = Sq({
      routeId: f,
      onAcceptExchangeRateUpdate: x
    });
    if (j.useEffect(() => {
        if (k && i !== "nft") {
          const N = k.fromChainId === k.toChainId ? "Swap" : "Bridge";
          return l.getState().setTitle(_ === ot.Idle ? e(`button.review${N}`) : e(`header.${N.toLowerCase()}`))
        }
      }, [l, k, _, i, e]), j.useEffect(() => {
        _ === ot.Idle && n.emit(Cs.ReviewTransactionPageEntered, k)
      }, []), !k) return null;
    const I = GXe(k),
      A = () => {
        var N, O;
        (N = g.current) != null && N.isOpen() && n.emit(Cs.RouteHighValueLoss, {
          fromAmountUsd: k.fromAmountUSD,
          gasCostUSD: k.gasCostUSD,
          toAmountUSD: k.toAmountUSD,
          valueLoss: yX(k)
        }), (O = g.current) == null || O.close(), p(), t(Qe.FromAmount, ""), i === "nft" && (t(Qe.FromToken, ""), t(Qe.ToToken, ""))
      },
      w = async () => {
        var N;
        _ === ot.Idle && (I && i !== "nft" ? (N = g.current) == null || N.open() : A()), _ === ot.Failed && v()
      }, E = () => {
        r(), S()
      }, D = () => {
        switch (_) {
          case ot.Idle:
            switch (i) {
              case "nft":
                return e("button.buyNow");
              case "refuel":
                return e("button.startBridging");
              default:
                const N = k.fromChainId === k.toChainId ? "Swapping" : "Bridging";
                return e(`button.start${N}`)
            }
            case ot.Failed:
              return e("button.tryAgain");
            default:
              return ""
        }
      }, $ = ((T = k.insurance) == null ? void 0 : T.state) === "INSURED", V = s && i !== "refuel" && _ === ot.Idle && ((R = k.insurance) == null ? void 0 : R.state) === "INSURABLE", G = $ || V, L = V ? HXe : gX, b = () => {
        var N, O;
        return ((O = (N = k.steps[0].execution) == null ? void 0 : N.process.filter(U => U.type !== "TOKEN_ALLOWANCE").find(U => U.txHash)) == null ? void 0 : O.txHash) ?? k.fromAddress
      };
    return C.jsxs(KXe, {
      children: [hX(k, i), i === "nft" ? C.jsx(F_, {
        mt: 2,
        children: a || o
      }) : null, G ? C.jsx(dX, {
        mt: 2,
        status: _,
        insurableRouteId: u,
        feeAmountUsd: k.insurance.feeAmountUsd,
        insuredAmount: Ei(k.toAmountMin, k.toToken.decimals),
        insuredTokenSymbol: k.toToken.symbol,
        insuranceCoverageId: b(),
        onChange: h
      }) : null, _ === ot.Idle || _ === ot.Failed ? C.jsxs(C.Fragment, {
        children: [C.jsx(FJ, {
          mt: 2,
          route: k
        }), C.jsxs(Pe, {
          mt: 2,
          display: "flex",
          children: [C.jsx(L, {
            text: D(),
            onClick: w,
            route: k,
            insurableRouteId: u
          }), _ === ot.Failed ? C.jsx(ro, {
            title: e("button.removeTransaction"),
            placement: "bottom-end",
            enterDelay: 400,
            arrow: !0,
            children: C.jsx(ur, {
              onClick: E,
              sx: {
                minWidth: 48,
                marginLeft: 1
              },
              children: C.jsx(mX, {})
            })
          }) : null]
        })]
      }) : null, _ ? C.jsx(VXe, {
        status: _,
        route: k
      }) : null, I && i !== "nft" ? C.jsx(WXe, {
        route: k,
        ref: g,
        onContinue: A
      }) : null, C.jsx(UXe, {
        ref: y
      })]
    })
  },
  YXe = () => ak([{
    path: "/",
    element: C.jsx(HYe, {})
  }, {
    path: Je.settings,
    element: C.jsx(uXe, {})
  }, {
    path: `${Je.settings}/${Je.bridges}`,
    element: C.jsx(eF, {
      type: "Bridges"
    })
  }, {
    path: `${Je.settings}/${Je.exchanges}`,
    element: C.jsx(eF, {
      type: "Exchanges"
    })
  }, {
    path: Je.fromToken,
    element: C.jsx(tF, {
      formType: "from"
    })
  }, {
    path: Je.toToken,
    element: C.jsx(tF, {
      formType: "to"
    })
  }, {
    path: Je.toTokenNative,
    element: C.jsx(z8, {
      formType: "to",
      selectNativeToken: !0
    })
  }, {
    path: `${Je.fromToken}?/${Je.fromChain}`,
    element: C.jsx(z8, {
      formType: "from"
    })
  }, {
    path: `${Je.toToken}?/${Je.toChain}`,
    element: C.jsx(z8, {
      formType: "to"
    })
  }, {
    path: Je.routes,
    element: C.jsx(WYe, {})
  }, {
    path: Je.activeTransactions,
    element: C.jsx(ZKe, {})
  }, {
    path: Je.transactionHistory,
    element: C.jsx($Xe, {})
  }, {
    path: `${Je.transactionHistory}?/${Je.routes}?/${Je.transactionExecution}?/${Je.transactionDetails}`,
    element: C.jsx(OXe, {})
  }, {
    path: `${Je.routes}?/${Je.transactionExecution}?/${Je.selectWallet}`,
    element: C.jsx(BJe, {})
  }, {
    path: `${Je.routes}?/${Je.activeTransactions}?/${Je.transactionExecution}`,
    element: C.jsx(QXe, {})
  }, {
    path: "*",
    element: C.jsx(EKe, {})
  }]),
  II = me(Ohe)(({
    theme: e
  }) => ({
    backgroundColor: "transparent",
    color: e.palette.text.primary,
    flexDirection: "row",
    alignItems: "center",
    position: "relative",
    minHeight: 40,
    padding: e.spacing(0, 3, 0, 3),
    ":first-of-type": {
      paddingTop: e.spacing(1.5),
      paddingBottom: e.spacing(.5)
    }
  })),
  JXe = me(Pe, {
    shouldForwardProp: e => e !== "sticky"
  })(({
    theme: e,
    sticky: t
  }) => ({
    backgroundColor: e.palette.background.default,
    backdropFilter: "blur(12px)",
    position: t ? "sticky" : "relative",
    top: 0,
    zIndex: 1200
  })),
  vX = me(ur)(({
    theme: e
  }) => ({
    color: e.palette.text.primary,
    backgroundColor: "transparent",
    padding: e.spacing(1, 1.5),
    maxHeight: 40,
    fontSize: "0.875rem",
    fontWeight: 600,
    borderRadius: e.shape.borderRadius * 2,
    "&:hover": {
      backgroundColor: e.palette.mode === "light" ? Vt(e.palette.common.black, .04) : Vt(e.palette.common.white, .08)
    },
    [`.${H0.endIcon} > *:nth-of-type(1)`]: {
      fontSize: "24px"
    },
    [`.${H0.startIcon} > *:nth-of-type(1)`]: {
      fontSize: "24px"
    }
  })),
  XXe = me(Pe)(({
    theme: e
  }) => ({
    width: "100%",
    display: "flex",
    justifyContent: "space-between",
    "& button:first-of-type": {
      marginLeft: e.spacing(-1)
    },
    "& button:last-of-type": {
      marginRight: e.spacing(-1.25)
    }
  }));
var PI = {},
  ZXe = Zt;
Object.defineProperty(PI, "__esModule", {
  value: !0
});
var bX = PI.default = void 0,
  eZe = ZXe(an()),
  tZe = C;
bX = PI.default = (0, eZe.default)((0, tZe.jsx)("path", {
  d: "M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20z"
}), "ArrowBack");
var RI = {},
  nZe = Zt;
Object.defineProperty(RI, "__esModule", {
  value: !0
});
var wX = RI.default = void 0,
  rZe = nZe(an()),
  oF = C;
wX = RI.default = (0, rZe.default)([(0, oF.jsx)("path", {
  d: "M19.5 3.5 18 2l-1.5 1.5L15 2l-1.5 1.5L12 2l-1.5 1.5L9 2 7.5 3.5 6 2v14H3v3c0 1.66 1.34 3 3 3h12c1.66 0 3-1.34 3-3V2zM19 19c0 .55-.45 1-1 1s-1-.45-1-1v-3H8V5h11z"
}, "0"), (0, oF.jsx)("path", {
  d: "M9 7h6v2H9zm7 0h2v2h-2zm-7 3h6v2H9zm7 0h2v2h-2z"
}, "1")], "ReceiptLong");
var OI = {},
  iZe = Zt;
Object.defineProperty(OI, "__esModule", {
  value: !0
});
var xX = OI.default = void 0,
  sZe = iZe(an()),
  oZe = C;
xX = OI.default = (0, sZe.default)((0, oZe.jsx)("path", {
  d: "M19.14 12.94c.04-.3.06-.61.06-.94 0-.32-.02-.64-.07-.94l2.03-1.58c.18-.14.23-.41.12-.61l-1.92-3.32c-.12-.22-.37-.29-.59-.22l-2.39.96c-.5-.38-1.03-.7-1.62-.94l-.36-2.54c-.04-.24-.24-.41-.48-.41h-3.84c-.24 0-.43.17-.47.41l-.36 2.54c-.59.24-1.13.57-1.62.94l-2.39-.96c-.22-.08-.47 0-.59.22L2.74 8.87c-.12.21-.08.47.12.61l2.03 1.58c-.05.3-.09.63-.09.94s.02.64.07.94l-2.03 1.58c-.18.14-.23.41-.12.61l1.92 3.32c.12.22.37.29.59.22l2.39-.96c.5.38 1.03.7 1.62.94l.36 2.54c.05.24.24.41.48.41h3.84c.24 0 .44-.17.47-.41l.36-2.54c.59-.24 1.13-.56 1.62-.94l2.39.96c.22.08.47 0 .59-.22l1.92-3.32c.12-.22.07-.47-.12-.61zM12 15.6c-1.98 0-3.6-1.62-3.6-3.6s1.62-3.6 3.6-3.6 3.6 1.62 3.6 3.6-1.62 3.6-3.6 3.6"
}), "Settings");
var DI = {},
  aZe = Zt;
Object.defineProperty(DI, "__esModule", {
  value: !0
});
var EX = DI.default = void 0,
  cZe = aZe(an()),
  lZe = C;
EX = DI.default = (0, cZe.default)((0, lZe.jsx)("path", {
  d: "M18.3 5.71a.9959.9959 0 0 0-1.41 0L12 10.59 7.11 5.7a.9959.9959 0 0 0-1.41 0c-.39.39-.39 1.02 0 1.41L10.59 12 5.7 16.89c-.39.39-.39 1.02 0 1.41.39.39 1.02.39 1.41 0L12 13.41l4.89 4.89c.39.39 1.02.39 1.41 0 .39-.39.39-1.02 0-1.41L13.41 12l4.89-4.89c.38-.38.38-1.02 0-1.4"
}), "CloseRounded");
const SX = e => {
    const {
      t
    } = ft(), {
      closeDrawer: n
    } = e3e();
    return C.jsx(ro, {
      title: t("button.close"),
      enterDelay: 400,
      arrow: !0,
      children: C.jsx(_s, {
        size: "medium",
        onClick: n,
        ...e,
        children: C.jsx(EX, {})
      })
    })
  },
  uZe = me(uwe)(({
    theme: e
  }) => ({
    backgroundColor: e.palette.mode === "dark" ? e.palette.background.paper : Vt(e.palette.common.black, .04),
    borderRadius: Math.max(e.shape.borderRadius, e.shape.borderRadiusSecondary),
    padding: e.spacing(.5),
    flex: 1,
    display: "flex",
    alignItems: "center",
    height: 56,
    [`.${up.flexContainer}`]: {
      alignItems: "center"
    },
    [`.${up.scroller}`]: {
      overflow: "initial !important"
    },
    [`.${up.indicator}`]: {
      position: "absolute",
      top: "50%",
      transform: "translateY(-50%)",
      height: 48,
      backgroundColor: e.palette.mode === "dark" ? e.palette.background.default : e.palette.common.white,
      borderRadius: e.shape.borderRadiusSecondary,
      boxShadow: `0px 2px 4px ${Vt(e.palette.common.black,.04)}`
    }
  })),
  aF = me(Bbe, {
    shouldForwardProp: e => e !== "isDarkMode"
  })(({
    theme: e
  }) => ({
    zIndex: 1,
    display: "flex",
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
    flexDirection: "row",
    textTransform: "none",
    height: 48,
    minHeight: 48,
    fontSize: "1rem",
    fontWeight: 700,
    color: e.palette.mode === "dark" ? e.palette.common.white : e.palette.common.black,
    textDecoration: "none",
    [`&.${Wl.selected}`]: {
      color: e.palette.mode === "dark" ? e.palette.common.white : e.palette.common.black,
      backgroundColor: "transparent"
    },
    [`.${Wl.iconWrapper}`]: {
      margin: e.spacing(0, 1, 0, 0)
    }
  })),
  dZe = () => {
    const {
      t: e
    } = ft(), [t, n] = Hk(s => [s.state, s.setState]), {
      setValue: r
    } = Ls(), i = (s, o) => {
      r(Qe.FromAmount, ""), r(Qe.FromToken, ""), r(Qe.ToToken, ""), n(o === 0 ? "swap" : "bridge")
    };
    return C.jsx(II, {
      elevation: 0,
      sx: {
        py: 1
      },
      children: C.jsxs(uZe, {
        value: t === "swap" ? 0 : 1,
        onChange: i,
        "aria-label": "tabs",
        indicatorColor: "primary",
        children: [C.jsx(aF, {
          label: e("header.swap"),
          disableRipple: !0
        }), C.jsx(aF, {
          label: e("header.bridge"),
          disableRipple: !0
        })]
      })
    })
  };
var NI = {},
  fZe = Zt;
Object.defineProperty(NI, "__esModule", {
  value: !0
});
var CX = NI.default = void 0,
  hZe = fZe(an()),
  pZe = C;
CX = NI.default = (0, hZe.default)((0, pZe.jsx)("path", {
  d: "M12 3c-.55 0-1 .45-1 1v8c0 .55.45 1 1 1s1-.45 1-1V4c0-.55-.45-1-1-1m5.14 2.86c-.39.39-.38 1-.01 1.39 1.13 1.2 1.83 2.8 1.87 4.57.09 3.83-3.08 7.13-6.91 7.17C8.18 19.05 5 15.9 5 12c0-1.84.71-3.51 1.87-4.76.37-.39.37-1-.01-1.38-.4-.4-1.05-.39-1.43.02C3.98 7.42 3.07 9.47 3 11.74c-.14 4.88 3.83 9.1 8.71 9.25 5.1.16 9.29-3.93 9.29-9 0-2.37-.92-4.51-2.42-6.11-.38-.41-1.04-.42-1.44-.02"
}), "PowerSettingsNewRounded");
const mZe = me(EH)(({
    theme: e
  }) => ({
    [`& .${tN.paper}`]: {
      borderRadius: e.shape.borderRadius,
      color: e.palette.text.primary,
      boxShadow: "0px 2px 4px rgb(0 0 0 / 8%), 0px 8px 16px rgb(0 0 0 / 8%)",
      padding: e.spacing(2),
      [`& .${tN.list}`]: {
        padding: 0
      },
      [`& .${A0.root}`]: {
        borderRadius: e.shape.borderRadiusSecondary,
        padding: e.spacing(1, 2, 1, 1),
        [`& .${xde.root}`]: {
          fontSize: 20,
          color: e.palette.text.primary,
          marginRight: e.spacing(1.5)
        }
      }
    }
  })),
  gZe = () => C.jsx(II, {
    elevation: 0,
    sx: {
      justifyContent: "flex-end"
    },
    children: C.jsx(AX, {})
  }),
  AX = () => {
    const {
      account: e
    } = Ri(), {
      variant: t,
      subvariant: n,
      hiddenUI: r
    } = Wt();
    return t === "drawer" ? C.jsxs(XXe, {
      children: [e.isActive ? C.jsx(lF, {}) : C.jsx(cF, {}), n !== "split" && !(r != null && r.includes(Ui.DrawerCloseButton)) ? C.jsx(SX, {}) : null]
    }) : e.isActive ? C.jsx(lF, {}) : C.jsx(cF, {})
  },
  cF = () => {
    const {
      t: e
    } = ft(), {
      pathname: t
    } = yu(), {
      walletManagement: n,
      subvariant: r,
      variant: i
    } = Wt(), {
      connect: s
    } = Ri(), o = Ba(), a = async () => {
      if (n) {
        await s();
        return
      }
      o(Je.selectWallet)
    };
    return C.jsx(vX, {
      endIcon: i !== "drawer" && r !== "split" ? C.jsx(T2, {}) : void 0,
      startIcon: i === "drawer" || r === "split" ? C.jsx(T2, {
        sx: {
          marginLeft: -.25
        }
      }) : void 0,
      onClick: t.includes(Je.selectWallet) ? void 0 : a,
      sx: {
        marginRight: r === "split" ? 0 : -1.25,
        marginLeft: r === "split" ? -1.25 : 0
      },
      children: e("button.connectWallet")
    })
  },
  lF = () => {
    const {
      t: e
    } = ft(), {
      subvariant: t
    } = Wt(), {
      account: n,
      disconnect: r
    } = Ri(), i = pp(n.address), {
      chain: s
    } = _m(n.chainId), [o, a] = j.useState(null), c = h => {
      a(h.currentTarget)
    }, l = () => {
      a(null)
    }, u = () => {
      r(), l()
    }, f = async () => {
      await navigator.clipboard.writeText(n.address ?? ""), l()
    };
    return C.jsxs(C.Fragment, {
      children: [C.jsx(vX, {
        endIcon: C.jsx(My, {}),
        startIcon: C.jsx(bl, {
          src: s == null ? void 0 : s.logoURI,
          alt: s == null ? void 0 : s.key,
          sx: {
            width: 24,
            height: 24
          },
          children: s == null ? void 0 : s.name[0]
        }),
        sx: {
          marginRight: t === "split" ? 0 : -1.25,
          marginLeft: t === "split" ? -1 : 0
        },
        onClick: c,
        children: i
      }), C.jsxs(mZe, {
        anchorEl: o,
        open: !!o,
        onClose: l,
        children: [C.jsxs(Vf, {
          onClick: f,
          children: [C.jsx(bI, {}), e("button.copyAddress")]
        }), C.jsxs(Vf, {
          component: "a",
          onClick: l,
          href: `${s==null?void 0:s.metamask.blockExplorerUrls[0]}address/${n.address}`,
          target: "_blank",
          children: [C.jsx(oI, {}), e("button.viewOnExplorer")]
        }), C.jsx(ur, {
          onClick: u,
          fullWidth: !0,
          startIcon: C.jsx(CX, {}),
          sx: {
            marginTop: 1
          },
          children: e("button.disconnect")
        })]
      })]
    })
  },
  yZe = () => {
    const {
      t: e
    } = ft(), {
      subvariant: t,
      hiddenUI: n,
      variant: r
    } = Wt(), {
      navigate: i,
      navigateBack: s
    } = Ud(), {
      account: o
    } = Ri(), {
      element: a,
      title: c
    } = GCe(k => k), {
      pathname: l
    } = yu(), u = l.endsWith("/") ? l.slice(0, -1) : l, f = u.substring(u.lastIndexOf("/") + 1), h = sCe.includes(f), g = t === "split" && !h, y = () => {
      switch (f) {
        case Je.selectWallet:
          return e("header.selectWallet");
        case Je.settings:
          return e("header.settings");
        case Je.bridges:
          return e("settings.enabledBridges");
        case Je.exchanges:
          return e("settings.enabledExchanges");
        case Je.transactionHistory:
          return e("header.transactionHistory");
        case Je.fromToken:
          return e(t === "nft" ? "header.payWith" : "header.from");
        case Je.toToken:
          return e("header.to");
        case Je.fromChain:
        case Je.toChain:
        case Je.toTokenNative:
          return e("header.selectChain");
        case Je.routes:
          return e("header.youGet");
        case Je.activeTransactions:
          return e("header.activeTransactions");
        case Je.transactionExecution:
          return e(t === "nft" ? "header.purchase" : "header.exchange");
        case Je.transactionDetails:
          return e(t === "nft" ? "header.purchaseDetails" : "header.transactionDetails");
        default:
          switch (t) {
            case "nft":
              return e("header.checkout");
            case "refuel":
              return e("header.gas");
            default:
              return e("header.exchange")
          }
      }
    }, x = r === "drawer" && t === "split" && !(n != null && n.includes(Ui.DrawerCloseButton));
    return C.jsxs(C.Fragment, {
      children: [C.jsxs(II, {
        elevation: 0,
        children: [aCe.includes(f) ? C.jsx(_s, {
          size: "medium",
          edge: "start",
          onClick: s,
          children: C.jsx(bX, {})
        }) : null, g ? C.jsx(Pe, {
          flex: 1,
          children: n != null && n.includes(Ui.WalletMenu) ? null : C.jsx(AX, {})
        }) : C.jsx(Ue, {
          fontSize: h ? 18 : 24,
          align: h ? "center" : "left",
          fontWeight: "700",
          flex: 1,
          noWrap: !0,
          children: c || y()
        }), C.jsxs(Nxe, {
          children: [C.jsx(iA, {
            path: Je.home,
            element: C.jsxs(Pe, {
              children: [o.isActive && !(n != null && n.includes(Ui.History)) ? C.jsx(ro, {
                title: e("header.transactionHistory"),
                enterDelay: 400,
                arrow: !0,
                children: C.jsx(_s, {
                  size: "medium",
                  edge: "start",
                  onClick: () => i(Je.transactionHistory),
                  children: C.jsx(wX, {})
                })
              }) : null, C.jsx(ro, {
                title: e("header.settings"),
                enterDelay: 400,
                arrow: !0,
                children: C.jsx(_s, {
                  size: "medium",
                  onClick: () => i(Je.settings),
                  sx: {
                    marginRight: x ? 0 : -1.25
                  },
                  children: C.jsx(xX, {})
                })
              }), x ? C.jsx(SX, {
                sx: {
                  marginRight: -1.25
                }
              }) : null]
            })
          }), C.jsx(iA, {
            path: "*",
            element: a || C.jsx(Pe, {
              width: 28,
              height: 40
            })
          })]
        })]
      }), g ? C.jsx(dZe, {}) : null]
    })
  },
  vZe = ({
    children: e
  }) => {
    const {
      pathname: t
    } = yu(), n = cy();
    return C.jsx(JXe, {
      id: dh(pc.Header, n),
      sticky: oCe.some(r => t.includes(r)),
      children: e
    })
  },
  bZe = () => {
    const {
      walletManagement: e,
      subvariant: t,
      hiddenUI: n
    } = Wt();
    return C.jsxs(vZe, {
      children: [!e && t !== "split" && !(n != null && n.includes(Ui.WalletMenu)) ? C.jsx(gZe, {}) : null, C.jsx(yZe, {})]
    })
  },
  wZe = () => (hCe(), null),
  xZe = me(K2)(({
    theme: e
  }) => ({
    display: "flex",
    alignItems: "center",
    border: "none",
    ":hover": {
      color: e.palette.primary.main
    }
  })),
  EZe = () => {
    const {
      hiddenUI: e
    } = Wt(), {
      pathname: t
    } = yu();
    return t.includes(Je.fromToken) || t.includes(Je.toToken) ? null : C.jsx(Pe, {
      px: 3,
      pt: 1,
      pb: e != null && e.includes(Ui.PoweredBy) ? 1 : 2,
      sx: {
        display: "flex",
        alignItems: "flex-end",
        justifyContent: "flex-end"
      },
      children: e != null && e.includes(Ui.PoweredBy) ? null : C.jsx(ro, {
        title: `v${$k}`,
        placement: "top",
        enterDelay: 1e3,
        arrow: !0,
        children: C.jsxs(xZe, {
          href: "https://li.fi",
          target: "_blank",
          underline: "none",
          color: "text.primary",
          children: [C.jsx(Ue, {
            color: "text.secondary",
            fontSize: 12,
            fontWeight: 500,
            px: .5,
            children: "Powered by"
          }), C.jsx(Ue, {
            color: "text.primary",
            fontSize: 12,
            fontWeight: 500,
            children: "LI.FI"
          })]
        })
      })
    })
  },
  SZe = j.forwardRef(({
    elementRef: e,
    open: t,
    onClose: n,
    integrator: r,
    ...i
  }, s) => {
    const o = j.useMemo(() => ({
      integrator: r,
      ...i,
      ...i.config
    }), [r, i]);
    return (o == null ? void 0 : o.variant) !== "drawer" ? C.jsx(TJ, {
      config: o,
      children: C.jsx(TX, {})
    }) : C.jsx(yKe, {
      ref: s,
      elementRef: e,
      integrator: r,
      config: o,
      open: t,
      onClose: n
    })
  }),
  TX = () => {
    const {
      elementId: e
    } = Wt(), t = hq();
    return C.jsxs(mYe, {
      id: dh(pc.AppExpandedContainer, e),
      children: [C.jsxs(vYe, {
        children: [C.jsx(bZe, {}), C.jsx(qJ, {
          disableGutters: !0,
          children: C.jsx(YXe, {})
        }), C.jsx(EZe, {}), C.jsx(wZe, {})]
      }), t ? C.jsx(CYe, {}) : null]
    })
  },
  CZe = SZe,
  AZe = () => C.jsxs("header", {
    children: [C.jsx("div", {
      className: "header-part",
      children: C.jsx("a", {
        href: "#",
        children: C.jsx("img", {
          className: "logo",
          src: "/logo.png",
          alt: "BasedChad"
        })
      })
    }), C.jsx("div", {
      className: "header-part third-links",
      children: C.jsxs("ul", {
        className: "icon-links",
        children: [
        C.jsx("li", {
          style: {
            rotate: "-7deg"
          },
          className: "no-bg header-icon reset-style-header-link",
          children: C.jsx("a", {
            target: "_blank",
            rel: "noopener",
            href: "https://t.me/chadonbase",
            children: C.jsx("img", {
              src: "/telegram.webp",
              alt: "Telegram"
            })
          })
        }), C.jsx("li", {
          style: {
            rotate: "2.5deg"
          },
          className: "no-bg header-icon reset-style-header-link",
          children: C.jsx("a", {
            target: "_blank",
            rel: "noopener",
            href: "https://twitter.com/chadsonbase",
            children: C.jsx("img", {
              src: "/x.webp",
              alt: "X"
            })
          })
        }),]
      })
    })]
  });

function TZe() {
  const [e, t] = j.useState(0), n = j.useMemo(() => ({
    toChain: 8453,
    toToken: "0x17931cfc3217261ce0fa21bb066633c463ed8634",
    integrator: "bridgy",
    containerStyle: {
      boxShadow: "0px 8px 32px rgba(0, 0, 0, 0.08)",
      borderRadius: "16px"
    },
    fee: .004,
    theme: {
      palette: {
        text: {
          primary: "#ffffff",
          secondary: "#ffffff"
        },
        primary: {
          main: "#2E6EFB",
          A200: "#FF0000"
        },
        background: {
          default: "#5087fd",
          paper: "#3270fb"
        },
        grey: {
          700: "#ffffff",
          800: "#545454"
        }
      },
      shape: {
        borderRadius: 15,
        borderRadiusSecondary: 15
      }
    },
    appearance: "dark",
    hiddenUI: ["appearance"]
  }), []);
  return j.useEffect(() => {
    var r;
    if (e == 1) {
      let i = document.querySelector(".debridge-widget-iframe");
      i || (r = window == null ? void 0 : window.deBridge) == null || r.widget({
        v: "1",
        element: "debridgeWidget",
        width: "392",
        height: "654",
        title: "",
        description: "",
        r: 6368,
        supportedChains: '{"inputChains":{"1":"all","10":"all","56":"all","137":"all","8453":"all","42161":"all","43114":"all","59144":"all","7565164":"all","245022934":"all"},"outputChains":{"1":"all","10":"all","56":"all","137":"all","8453":"all","42161":"all","43114":"all","59144":"all","7565164":"all","245022934":"all"}}',
        inputChain: 56,
        outputChain: 8453,
        inputCurrency: "",
        outputCurrency: "0x17931cfc3217261ce0fa21bb066633c463ed8634",
        address: "",
        showSwapTransfer: !0,
        amount: "",
        outputAmount: "",
        isAmountFromNotModifiable: !1,
        isAmountToNotModifiable: !1,
        lang: "en",
        mode: "deswap",
        isEnableCalldata: !1,
        styles: "eyJhcHBCYWNrZ3JvdW5kIjoiIzUwODdmZCIsImFwcEFjY2VudEJnIjoiIzMyNzBmYiIsImNoYXJ0QmciOiIjZmZmZmZmIiwiYmFkZ2UiOiIjZmJmYmZiIiwiYm9yZGVyUmFkaXVzIjoxMiwidG9vbHRpcEJnIjoiI2ZmZmZmZiIsImZvcm1Db250cm9sQmciOiIjMGExNGM1IiwiZHJvcGRvd25CZyI6IiNmZmZmZmYiLCJwcmltYXJ5IjoiIzJlNmVmYiIsImljb25Db2xvciI6IiNmZmZmZmYiLCJmb250RmFtaWx5IjoiIiwicHJpbWFyeUJ0bkJnIjoiIzJlNmVmYiIsInByaW1hcnlCdG5UZXh0IjoiI2ZmZmZmZiIsInNlY29uZGFyeUJ0bkJnIjoiIiwibGlnaHRCdG5CZyI6IiIsImxpZ2h0QnRuVGV4dCI6IiMzMjcwZmIifQ==",
        theme: "dark",
        isHideLogo: !0,
        logo: ""
      }), setTimeout(() => {
        i = document.querySelector(".debridge-widget-iframe"), i && (i.style.maxWidth = "100%")
      }, 2500)
    }
  }, [e]), C.jsx(C.Fragment, {
    children: C.jsxs("div", {
      className: "container",
      children: [C.jsx(AZe, {}), C.jsxs("div", {
        className: "center",
        children: [C.jsxs("div", {
          className: "switch",
          children: [C.jsx("button", {
            onClick: () => t(0),
            className: e == 0 ? "active" : "",
            children: "Jumper"
          }), C.jsx("button", {
            onClick: () => t(1),
            className: e == 1 ? "active" : "",
            children: "Debridge"
          })]
        }), C.jsxs("div", {
          className: "widget-wrapper",
          children: [e == 0 && C.jsx(CZe, {
            integrator: "bridgy",
            config: n
          }), e == 1 && C.jsx("div", {
            style: {
              maxWidth: "100%"
            },
            children: C.jsx("div", {
              id: "debridgeWidget"
            })
          })]
        })]
      }), C.jsx("div", {
        className: "chad-bottom",
        children: C.jsx("img", {
          src: "/media/chad-bottom.png",
          alt: ""
        })
      })]
    })
  })
}
V8.createRoot(document.getElementById("root")).render(C.jsx(Jt.StrictMode, {
  children: C.jsx(TZe, {})
}));
export {
  I7 as _
};